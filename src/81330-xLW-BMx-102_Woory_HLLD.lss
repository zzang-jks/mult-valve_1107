mlx16-gcc (Melexis Mlx16-GCC v3.1.115.11) 7.5.0
Copyright (C) 2017 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


81330-xLW-BMx-102_Woory_HLLD.elf:     file format elf32-mlx16-fx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .fw_vectors   000001e0  00005800  00005800  00000194  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .mlx4_cst_tables_ram 0000005e  00000e80  000059e0  00000374  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .mlx4_par_tables_ram 00000088  00000f00  00005a3e  000003d2  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .lin_ram_flash 00000012  00001000  00001000  00000194  2**0
                  ALLOC
  4 .data         00000048  00001012  00005ac6  0000045a  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          000001c6  0000105a  00005b0e  000004a2  2**1
                  ALLOC
  6 .flash_data   000029d4  00005b0e  00005b0e  000004a2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .flash_fill   00005302  000084e2  000084e2  00002e76  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  8 .fw_product_id 00000008  0000d7e4  0000d7e4  00008178  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .fw_app_version 00000004  0000d7ec  0000d7ec  00008180  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 10 .fw_pltf_version 00000004  0000d7f0  0000d7f0  00008184  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 11 .fw_prot_key  00000008  0000d7f4  0000d7f4  00008188  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 12 .flash_crc    00000004  0000d7fc  0000d7fc  00008190  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 13 .debug_frame  00001bcc  00000000  00000000  00008194  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_info   0005e12f  00000000  00000000  00009d60  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_abbrev 00004b61  00000000  00000000  00067e8f  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000450d  00000000  00000000  0006c9f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_aranges 00000a58  00000000  00000000  00070efd  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_line   00009721  00000000  00000000  00071955  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_str    0000e298  00000000  00000000  0007b076  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .comment      00000055  00000000  00000000  0008930e  2**0
                  CONTENTS, READONLY

Disassembly of section .fw_vectors:

00005800 <__fw_vectors>:
 * @return  void
 */
void l_ifc_wake_up_sl1 (void)
{
    (void)ml_WakeUp();
}
    5800:	54f0      	mov	UPr, #0
 */
void protection_Start(void)
{
    g_e8ShortOcc = C_ERR_SHORT_NO;
    diagnostic_Start();
}
    5802:	76da 33bb 	jmpf	0x6776 <_fw_start>
    5806:	a04f      	add	A, #79
    5808:	54f8      	mov	UPr, #8
    580a:	76da 1a05 	jmpf	0x340a <__fatal>
    580e:	0000      	nop
    5810:	54f8      	mov	UPr, #8
    5812:	76da 1a05 	jmpf	0x340a <__fatal>
    5816:	0000      	nop
    5818:	54f8      	mov	UPr, #8
    581a:	76da 1a05 	jmpf	0x340a <__fatal>
    581e:	0000      	nop
    5820:	54f8      	mov	UPr, #8
    5822:	76da 1a05 	jmpf	0x340a <__fatal>
    5826:	0100      	jmp	0x5a28 <.LASF1928+0xc>
    5828:	54f8      	mov	UPr, #8
    582a:	76da 1a05 	jmpf	0x340a <__fatal>
    582e:	0000      	nop
    5830:	54f0      	mov	UPr, #0
    5832:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    5836:	0000      	nop
    5838:	54f0      	mov	UPr, #0
    583a:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    583e:	0000      	nop
    5840:	54f0      	mov	UPr, #0
    5842:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    5846:	0000      	nop
    5848:	54f0      	mov	UPr, #0
    584a:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    584e:	0000      	nop
    5850:	54f0      	mov	UPr, #0
    5852:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    5856:	0000      	nop
    5858:	54f0      	mov	UPr, #0
    585a:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    585e:	0000      	nop
    5860:	54f0      	mov	UPr, #0
    5862:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    5866:	0000      	nop
    5868:	54f0      	mov	UPr, #0
    586a:	76da 318d 	jmpf	0x631a <__UV_VS_INT>
    586e:	0000      	nop
    5870:	54f0      	mov	UPr, #0
    5872:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    5876:	0000      	nop
    5878:	54f1      	mov	UPr, #1
    587a:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    587e:	0000      	nop
    5880:	54f1      	mov	UPr, #1
    5882:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    5886:	0000      	nop
    5888:	54f1      	mov	UPr, #1
    588a:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    588e:	0000      	nop
    5890:	54f1      	mov	UPr, #1
    5892:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    5896:	0000      	nop
    5898:	54f1      	mov	UPr, #1
    589a:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    589e:	0000      	nop
    58a0:	54f1      	mov	UPr, #1
    58a2:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    58a6:	0000      	nop
    58a8:	54f1      	mov	UPr, #1
    58aa:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    58ae:	0000      	nop
    58b0:	54f1      	mov	UPr, #1
    58b2:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    58b6:	0000      	nop
    58b8:	54f1      	mov	UPr, #1
    58ba:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    58be:	0000      	nop
    58c0:	54f1      	mov	UPr, #1
    58c2:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    58c6:	0000      	nop
    58c8:	54f1      	mov	UPr, #1
    58ca:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    58ce:	0000      	nop
    58d0:	54f5      	mov	UPr, #5
    58d2:	76da 3fb4 	jmpf	0x7f68 <__STIMER_INT>
    58d6:	0000      	nop
    58d8:	54f2      	mov	UPr, #2
    58da:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    58de:	0000      	nop
    58e0:	54f2      	mov	UPr, #2
    58e2:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    58e6:	0000      	nop
    58e8:	54f2      	mov	UPr, #2
    58ea:	76da 3b6d 	jmpf	0x76da <__CTIMER0_3_INT>
    58ee:	0000      	nop
    58f0:	54f2      	mov	UPr, #2
    58f2:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    58f6:	0000      	nop
    58f8:	54f2      	mov	UPr, #2
    58fa:	76da 3e43 	jmpf	0x7c86 <__CTIMER1_2_INT>
    58fe:	0000      	nop
    5900:	54f2      	mov	UPr, #2
    5902:	76da 3ea6 	jmpf	0x7d4c <__CTIMER1_3_INT>
    5906:	0000      	nop
    5908:	54f2      	mov	UPr, #2
    590a:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    590e:	0000      	nop
    5910:	54f2      	mov	UPr, #2
    5912:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    5916:	0000      	nop
    5918:	54f2      	mov	UPr, #2
    591a:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    591e:	0000      	nop
    5920:	54f2      	mov	UPr, #2
    5922:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    5926:	0000      	nop
    5928:	54f2      	mov	UPr, #2
    592a:	76da 3d6d 	jmpf	0x7ada <__PWM_MASTER1_END_INT>
    592e:	0000      	nop
    5930:	54f2      	mov	UPr, #2
    5932:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    5936:	0000      	nop
    5938:	54f2      	mov	UPr, #2
    593a:	76da 3d83 	jmpf	0x7b06 <__PWM_SLAVE2_CMP_INT>
    593e:	0000      	nop
    5940:	54f2      	mov	UPr, #2
    5942:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    5946:	0000      	nop
    5948:	54f2      	mov	UPr, #2
    594a:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    594e:	0000      	nop
    5950:	54f2      	mov	UPr, #2
    5952:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    5956:	0000      	nop
    5958:	54f3      	mov	UPr, #3
    595a:	76da 2fa4 	jmpf	0x5f48 <__ADC_SAR_INT>
    595e:	0000      	nop
    5960:	54f2      	mov	UPr, #2
    5962:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    5966:	0000      	nop
    5968:	54f2      	mov	UPr, #2
    596a:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    596e:	0000      	nop
    5970:	54f2      	mov	UPr, #2
    5972:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    5976:	0000      	nop
    5978:	54f4      	mov	UPr, #4
    597a:	76da 322f 	jmpf	0x645e <__COLIN_LIN_INT>
    597e:	0000      	nop
    5980:	54f2      	mov	UPr, #2
    5982:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    5986:	0000      	nop
    5988:	54f2      	mov	UPr, #2
    598a:	76da 3d85 	jmpf	0x7b0a <__DIAG_INT>
    598e:	0000      	nop
    5990:	54f2      	mov	UPr, #2
    5992:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    5996:	0000      	nop
    5998:	54f2      	mov	UPr, #2
    599a:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    599e:	0000      	nop
    59a0:	54f2      	mov	UPr, #2
    59a2:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    59a6:	0000      	nop
    59a8:	54f2      	mov	UPr, #2
    59aa:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    59ae:	0000      	nop
    59b0:	54f2      	mov	UPr, #2
    59b2:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    59b6:	0000      	nop
    59b8:	54f2      	mov	UPr, #2
    59ba:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    59be:	0000      	nop
    59c0:	54f2      	mov	UPr, #2
    59c2:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    59c6:	0000      	nop
    59c8:	54f2      	mov	UPr, #2
    59ca:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    59ce:	0000      	nop
    59d0:	54f2      	mov	UPr, #2
    59d2:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    59d6:	0000      	nop
    59d8:	54f6      	mov	UPr, #6
    59da:	76da 31c4 	jmpf	0x6388 <_Generic_INT>
    59de:	0000      	nop

Disassembly of section .mlx4_cst_tables_ram:

00000e80 <__mlx4_cst_tables_ram_start>:
 e80:	a55a      	or	A, dp:0x5a <.LLST24+0x8>
 e82:	5aa5      	mov	io:0x25 <.LASF1345+0x4>, Y
 e84:	0000      	nop
 e86:	0000      	nop
 e88:	0000      	nop
 e8a:	0000      	nop
 e8c:	0000      	nop
 e8e:	0000      	nop
 e90:	0000      	nop
 e92:	0000      	nop
 e94:	0000      	nop
 e96:	0000      	nop
 e98:	4104      	mov	dp:0x4 <_RST_CTRL+0x2>, AL
 e9a:	2000      	add	X, #0
 e9c:	0000      	nop
 e9e:	0000      	nop
 ea0:	01e0      	jmp	0x1262 <.LASF1629+0x11>
 ea2:	0003      	jmp	0xeaa <.LLST7+0xd>
 ea4:	0005      	jmp	0xeb0 <.Lframe0+0x4>
 ea6:	0000      	nop
 ea8:	4233      	mov	[S-52], AL
 eaa:	5f50      	mov	ep:0x50 <__data_size+0x8>, X
 eac:	7c6d      	lod	X, #109
 eae:	998a      	subc	AL, dp:0x8a <__mlx4_flash_table_size+0x2>
 eb0:	140e      	call	0x6ce <.LASF1465>
 eb2:	201a      	add	X, #26
 eb4:	2c26      	cmp	X, #38
 eb6:	3832      	subc	X, #50
 eb8:	0248      	jmp	0x134a <.LASF1622+0x2b>
 eba:	c852      	sub	AH, #82
 ebc:	6f03      	lod	YH, ep:0x3 <_RST_CTRL+0x1>
 ebe:	ff05      	xor	Y, ep:0x5 <_RST_CTRL+0x3>
 ec0:	0000      	nop
 ec2:	e0ac      	add	Y, #-84
 ec4:	0001      	jmp	0xec8 <.LASF922>
 ec6:	0200      	jmp	0x12c8 <.LLST14+0x14>
 ec8:	7da0      	lod	X, dp:0xa0 <.LASF1253>
 eca:	d70a      	and	AH, ep:0xa <_MUPET>
 ecc:	39e4      	subc	X, dp:0xe4 <.LLST20+0xb>
 ece:	934e      	adc	AL, ep:0x4e <__data_size+0x6>
 ed0:	d3e0      	adc	AH, ep:0xe0 <.LLST20+0x7>
 ed2:	a497      	or	A, #-105
 ed4:	2c1f      	cmp	X, #31
 ed6:	5b68      	mov	ep:0x68 <.LASF730+0x9>, Y
 ed8:	a81f      	sub	A, #31
 eda:	b47f      	and	A, #127
 edc:	00b2      	jmp	0x1042 <.LASF1417+0x1b>

Disassembly of section .mlx4_par_tables_ram:

00000f00 <_INDXtbl>:
 f00:	4040      	jmp	fp2:0x00
 f02:	4040      	jmp	fp2:0x00
 f04:	4040      	jmp	fp2:0x00
 f06:	4040      	jmp	fp2:0x00
 f08:	4040      	jmp	fp2:0x00
 f0a:	4040      	jmp	fp2:0x00
 f0c:	4040      	jmp	fp2:0x00
 f0e:	4040      	jmp	fp2:0x00
 f10:	4040      	jmp	fp2:0x00
 f12:	4040      	jmp	fp2:0x00
 f14:	4040      	jmp	fp2:0x00
 f16:	4040      	jmp	fp2:0x00
 f18:	4040      	jmp	fp2:0x00
 f1a:	4040      	jmp	fp2:0x00
 f1c:	4040      	jmp	fp2:0x00
 f1e:	4040      	jmp	fp2:0x00
 f20:	4040      	jmp	fp2:0x00
 f22:	4040      	jmp	fp2:0x00
 f24:	4040      	jmp	fp2:0x00
 f26:	4040      	jmp	fp2:0x00
 f28:	4040      	jmp	fp2:0x00
 f2a:	4040      	jmp	fp2:0x00
 f2c:	4040      	jmp	fp2:0x00
 f2e:	4040      	jmp	fp2:0x00
 f30:	4040      	jmp	fp2:0x00
 f32:	4040      	jmp	fp2:0x00
 f34:	4040      	jmp	fp2:0x00
 f36:	4040      	jmp	fp2:0x00
 f38:	4040      	jmp	fp2:0x00
 f3a:	4040      	jmp	fp2:0x00
 f3c:	1110      	call	0x115e <.LASF1664+0xa>
 f3e:	c0c0      	add	AH, #-64

00000f40 <_PARAMtbl>:
 f40:	2f09      	cmp	X, ep:0x9 <_FUNC_TEST+0x3>
 f42:	2f2f      	cmp	X, ep:0x2f <_IWD+0x3>
 f44:	2f2f      	cmp	X, ep:0x2f <_IWD+0x3>
 f46:	a0a0      	add	A, #-96
 f48:	a0a0      	add	A, #-96
 f4a:	a0a0      	add	A, #-96
 f4c:	a0a0      	add	A, #-96
 f4e:	a0a0      	add	A, #-96
 f50:	2707      	or	X, ep:0x7 <_FUNC_TEST+0x1>
 f52:	a0a0      	add	A, #-96
 f54:	a0a0      	add	A, #-96
 f56:	a0a0      	add	A, #-96
 f58:	a0a0      	add	A, #-96
 f5a:	a0a0      	add	A, #-96
 f5c:	a0a0      	add	A, #-96
 f5e:	a0a0      	add	A, #-96
 f60:	a0a0      	add	A, #-96
 f62:	a0a0      	add	A, #-96
 f64:	a0a0      	add	A, #-96
 f66:	a0a0      	add	A, #-96
 f68:	a0a0      	add	A, #-96
 f6a:	a0a0      	add	A, #-96
 f6c:	a0a0      	add	A, #-96
 f6e:	a0a0      	add	A, #-96
 f70:	a0a0      	add	A, #-96
 f72:	a0a0      	add	A, #-96
 f74:	a0a0      	add	A, #-96
 f76:	a0a0      	add	A, #-96
 f78:	a0a0      	add	A, #-96
 f7a:	a0a0      	add	A, #-96
 f7c:	a0a0      	add	A, #-96
 f7e:	a0a0      	add	A, #-96

00000f80 <_AUTOADDtbl>:
 f80:	2610      	or	X, [S-17]
 f82:	0626      	jmp	0xbd0 <.Lframe0+0xc>
 f84:	0000      	nop
 f86:	0000      	nop

Disassembly of section .flash_data:

00005b0e <.LC0>:
    5b0e:	ad01      	cmp	A, dp:0x1 <__bss_dp_size+0x1>
    5b10:	b473      	and	A, #115
    5b12:	76f5      	jmp	[Y+5]
    5b14:	ab37      	sub	A, ep:0x37 <_PORT_TEST_ADC+0x1>

00005b15 <_eeprom_defaults>:
    5b15:	01ab 73ad f5b4 3776 00ff 0000 0000 0000     ...s..v7........
    5b25:	b200                                             .

00005b26 <.L59>:
    5b26:	36b2      	and	X, io:0x32 <_STIMER+0x2>
    5b28:	36d4      	.word	0x36d4
    5b2a:	36ca      	and	X, [--PC]
    5b2c:	36de      	and	X, [X++]
    5b2e:	36e6      	and	X, Y
    5b30:	36eb      	and	X, ??
    5b32:	36c8      	and	X, [--??]

00005b34 <.L31>:
    5b34:	379a      	and	X, ep:0x9a <.LASF1085>
    5b36:	3791      	and	X, ep:0x91 <.LASF1440+0x5>
    5b38:	379a      	and	X, ep:0x9a <.LASF1085>
    5b3a:	37a7      	and	X, ep:0xa7 <.LASF1253+0x7>
    5b3c:	37a7      	and	X, ep:0xa7 <.LASF1253+0x7>
    5b3e:	37a7      	and	X, ep:0xa7 <.LASF1253+0x7>
    5b40:	37a7      	and	X, ep:0xa7 <.LASF1253+0x7>
    5b42:	37a7      	and	X, ep:0xa7 <.LASF1253+0x7>
    5b44:	379a      	and	X, ep:0x9a <.LASF1085>
    5b46:	37a7      	and	X, ep:0xa7 <.LASF1253+0x7>
    5b48:	37a7      	and	X, ep:0xa7 <.LASF1253+0x7>
    5b4a:	37a7      	and	X, ep:0xa7 <.LASF1253+0x7>
    5b4c:	3791      	and	X, ep:0x91 <.LASF1440+0x5>

00005b4e <___MotorsControl_flags_mask_3931>:
    5b4e:	0003 1000                                   ....

00005b52 <___MOTOR1_States_flags_mask_3795>:
    5b52:	0784 0080                                   ....

00005b56 <___MOTOR2_States_flags_mask_3823>:
    5b56:	3888 0100                                   .8..

00005b5a <___MOTOR3_States_flags_mask_3851>:
    5b5a:	c090 0201                                   ....

00005b5e <___MOTOR4_States_flags_mask_3879>:
    5b5e:	00a0 040e                                   ....

00005b62 <___MOTOR5_States_flags_mask_3907>:
    5b62:	00c0 0870                                   ..p.

00005b66 <_frameList>:
    5b66:	0000 5b7e 0000 5b88 0000 5b86 0000 5b84     ..~[...[...[...[
    5b76:	0000 5b82 0000 5b80                         ...[...[

00005b7e <_l_sl1_MotorsControl_frame>:
    5b7e:	38fd                                        .8

00005b80 <_l_sl1_MOTOR5_States_frame>:
    5b80:	37db                                        .7

00005b82 <_l_sl1_MOTOR4_States_frame>:
    5b82:	3815                                        .8

00005b84 <_l_sl1_MOTOR3_States_frame>:
    5b84:	384f                                        O8

00005b86 <_l_sl1_MOTOR2_States_frame>:
    5b86:	3889                                        .8

00005b88 <_l_sl1_MOTOR1_States_frame>:
    5b88:	38c3                                        .8

00005b8a <_ml_ProductID>:
    5b8a:	0123 0123 0001                              #.#...

00005b90 <_ml_InitialNAD>:
    5b90:	0001                                        ..

00005b92 <___divsi3>:
    5b92:	7c00      	lod	X, #0
    5b94:	4cc0      	mov	D, YA
    5b96:	1d82      	jnn	0x5b9c <a_positive>
    5b98:	4cd0      	neg	D
    5b9a:	7c01      	lod	X, #1

00005b9c <a_positive>:
    5b9c:	7205      	lod	A, [S-6]
    5b9e:	7a03      	lod	Y, [S-4]
    5ba0:	1d82      	jnn	0x5ba6 <b_positive>
    5ba2:	4cf0      	neg	YA
    5ba4:	3c01      	xor	X, #1

00005ba6 <b_positive>:
    5ba6:	5edf      	push	X
    5ba8:	7c00      	lod	X, #0
    5baa:	4ca3      	push	YA
    5bac:	4c80      	mov	YA, D
    5bae:	102a      	call	0x5c04 <___udivmodsi4>
    5bb0:	5c03      	dec	S, #4
    5bb2:	7ecf      	pop	X
    5bb4:	1901      	je	0x5bb8 <done>
    5bb6:	4cf0      	neg	YA

00005bb8 <done>:
    5bb8:	5401      	ret

00005bba <___modsi3>:
    5bba:	7c00      	lod	X, #0
    5bbc:	4cc0      	mov	D, YA
    5bbe:	1d82      	jnn	0x5bc4 <ma_positive>
    5bc0:	4cd0      	neg	D
    5bc2:	7c01      	lod	X, #1

00005bc4 <ma_positive>:
    5bc4:	7205      	lod	A, [S-6]
    5bc6:	7a03      	lod	Y, [S-4]
    5bc8:	1d81      	jnn	0x5bcc <mb_positive>
    5bca:	4cf0      	neg	YA

00005bcc <mb_positive>:
    5bcc:	5edf      	push	X
    5bce:	7c01      	lod	X, #1
    5bd0:	4ca3      	push	YA
    5bd2:	4c80      	mov	YA, D
    5bd4:	1017      	call	0x5c04 <___udivmodsi4>
    5bd6:	5c03      	dec	S, #4
    5bd8:	7ecf      	pop	X
    5bda:	1901      	je	0x5bde <mdone>
    5bdc:	4cf0      	neg	YA

00005bde <mdone>:
    5bde:	5401      	ret

00005be0 <__divU32_U32byU16>:
    5be0:	5edf      	push	X
    5be2:	4ca3      	push	YA
    5be4:	72e6      	lod	A, Y
    5be6:	7800      	lod	Y, #0
    5be8:	7e09      	lod	X, [S-10]
    5bea:	4c63      	divu	YA, X
    5bec:	4c63      	divu	YA, X
    5bee:	5201      	mov	[S-2], A
    5bf0:	7203      	lod	A, [S-4]
    5bf2:	4c63      	divu	YA, X
    5bf4:	4c63      	divu	YA, X
    5bf6:	7a01      	lod	Y, [S-2]
    5bf8:	7e05      	lod	X, [S-6]
    5bfa:	5407      	ret	#8

00005bfc <___udivsi3>:
    5bfc:	7c00      	lod	X, #0
    5bfe:	0002      	jmp	0x5c04 <___udivmodsi4>

00005c00 <___umodsi3>:
    5c00:	7c01      	lod	X, #1
    5c02:	0000      	nop

00005c04 <___udivmodsi4>:
    5c04:	5edf      	push	X
    5c06:	2c00      	cmp	X, #0
    5c08:	1d06      	jne	0x5c16 <chk1_skipped>
    5c0a:	7e05      	lod	X, [S-6]
    5c0c:	1d05      	jne	0x5c18 <chk1_passed>
    5c0e:	7e07      	lod	X, [S-8]
    5c10:	5e01      	mov	[S-2], X
    5c12:	17e6      	call	0x5be0 <__divU32_U32byU16>
    5c14:	5403      	ret	#4

00005c16 <chk1_skipped>:
    5c16:	7e05      	lod	X, [S-6]

00005c18 <chk1_passed>:
    5c18:	2607      	or	X, [S-8]
    5c1a:	1d03      	jne	0x5c22 <chk2_passed>
    5c1c:	4cfa ffff 	movs	YA, #65535
    5c20:	5403      	ret	#4

00005c22 <chk2_passed>:
    5c22:	4cc0      	mov	D, YA
    5c24:	7eef      	lod	X, S
    5c26:	2808      	sub	X, #8
    5c28:	4cea 0000 	movu	YA, #0
    5c2c:	54e0      	mov	Cx, #0

00005c2e <Loop>:
    5c2e:	48c0      	asl	D, #1
    5c30:	4402      	rlc	A
    5c32:	4406      	rlc	Y
    5c34:	1802      	jc	0x5c3a <L1_1>
    5c36:	4cb7      	cmp	YA, [X]
    5c38:	1803      	jc	0x5c40 <L1_2>

00005c3a <L1_1>:
    5c3a:	4c37      	sub	YA, [X]
    5c3c:	4c0a 0001 	addu	D, #1

00005c40 <L1_2>:
    5c40:	48c0      	asl	D, #1
    5c42:	4402      	rlc	A
    5c44:	4406      	rlc	Y
    5c46:	1802      	jc	0x5c4c <L2_1>
    5c48:	4cb7      	cmp	YA, [X]
    5c4a:	1803      	jc	0x5c52 <L2_2>

00005c4c <L2_1>:
    5c4c:	4c37      	sub	YA, [X]
    5c4e:	4c0a 0001 	addu	D, #1

00005c52 <L2_2>:
    5c52:	1fed      	djnz	Cx, 0x5c2e <Loop>

00005c54 <done>:
    5c54:	7ecf      	pop	X
    5c56:	1d01      	jne	0x5c5a <exit>
    5c58:	4c80      	mov	YA, D

00005c5a <exit>:
    5c5a:	5401      	ret
    5c5c:	5edf      	push	X
    5c5e:	4ca3      	push	YA
    5c60:	72e6      	lod	A, Y
    5c62:	7800      	lod	Y, #0
    5c64:	7e09      	lod	X, [S-10]
    5c66:	4c63      	divu	YA, X
    5c68:	4c63      	divu	YA, X
    5c6a:	5201      	mov	[S-2], A
    5c6c:	7203      	lod	A, [S-4]
    5c6e:	4c63      	divu	YA, X
    5c70:	4c63      	divu	YA, X
    5c72:	7a01      	lod	Y, [S-2]
    5c74:	7e05      	lod	X, [S-6]
    5c76:	5407      	ret	#8

00005c78 <_adc_DoSoftwareTrigger>:
 * @retval  false  otherwise.
 *
 * @remark  this function will also start the adc if it was not started yet.
 */
static bool adc_DoSoftwareTrigger(AdcPhaseState_t NextState)
{
    5c78:	5803      	inc	S, #4

00005c7a <.LCFI0>:
    5c7a:	5201      	mov	[S-2], A

00005c7c <.LM2>:
    bool Result = false;

    if (IO_GET(ADC_SAR, START) == 0u)
    5c7c:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>

00005c80 <.LVL2>:
    5c80:	9401      	and	AL, #1
    5c82:	1d0a      	jne	0x5c98 <.L2>

00005c84 <.LBB504>:
    return (IO_GET(ADC_SAR, STOP) == 0u);
}

STATIC INLINE void AdcClearAllErrors(void)
{
    IO_SET(ADC_SAR,
    5c84:	601f      	lod	AL, #31
    5c86:	42d8 016b 	mov	0x16b <_ADC_SAR+0x5>, AL

00005c8a <.LBB506>:
    }
}

STATIC INLINE void AdcResume(void)
{
    IO_HOST(ADC_SAR, RESUME) = (uint16_t)1u << IO_OFFSET(ADC_SAR, RESUME);
    5c8a:	7002      	lod	A, #2
    5c8c:	0ea7      	lod	C, ML.7
    5c8e:	52d8 016a 	mov	0x16a <_ADC_SAR+0x4>, A

00005c92 <.LBB508>:
           ADC_WIDTH, (uint16_t)ctrl.s.adcWidth);
}

STATIC INLINE void AdcStart(void)
{
    IO_HOST(ADC_SAR, START) = (uint16_t)1u << IO_OFFSET(ADC_SAR, START); /* START the ADC. */
    5c92:	7001      	lod	A, #1
    5c94:	52d8 0166 	mov	0x166 <_ADC_SAR>, A

00005c98 <.L2>:
    }
}

STATIC INLINE void DELAY(const uint16_t loops)
{
    delay_cycles(loops);
    5c98:	7028      	lod	A, #40
    5c9a:	82db 10f8 	callf	0x21f0 <_delay_cycles>

00005c9e <.LBB513>:
    IO_HOST(ADC_SAR, PAUSE) = (uint16_t)1u << IO_OFFSET(ADC_SAR, PAUSE);
}

STATIC INLINE void AdcSwTrigger(void)
{
    IO_SET(ADC_SAR, SW_TRIG, 1u);
    5c9e:	6004      	lod	AL, #4
    5ca0:	42d8 016a 	mov	0x16a <_ADC_SAR+0x4>, AL

00005ca4 <.L3>:

    DELAY_US(C_ADC_SETTLING_TIME);  /* setting time */

    AdcSwTrigger();  /* execute the software trigger */

    while (IO_GET(ADC_SAR, STOP) == 0u)
    5ca4:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>
    5ca8:	b402      	and	A, #2
    5caa:	1902      	je	0x5cb0 <.L5>

00005cac <.LM9>:
 *
 * @remark  this function will also start the adc if it was not started yet.
 */
static bool adc_DoSoftwareTrigger(AdcPhaseState_t NextState)
{
    bool Result = false;
    5cac:	7000      	lod	A, #0
    5cae:	5405      	ret	#6

00005cb0 <.L5>:

    AdcSwTrigger();  /* execute the software trigger */

    while (IO_GET(ADC_SAR, STOP) == 0u)
    {
        if (IO_GET(ADC_SAR, STATE) == NextState)
    5cb0:	7ed8 016a 	lod	X, 0x16a <_ADC_SAR+0x4>
    5cb4:	7aee      	lod	Y, X
    5cb6:	44c8      	rl	YL, #2
    5cb8:	f403      	and	Y, #3
    5cba:	ee01      	cmp	Y, [S-2]
    5cbc:	1906      	je	0x5cca <.L6>

00005cbe <.LM11>:
            /* the conversion is done, adc reached the requested state */
            Result = true;
            break;
        }

        if (IO_GET(ADC_SAR, ABORTED) != 0u)
    5cbe:	7ed8 016a 	lod	X, 0x16a <_ADC_SAR+0x4>
    5cc2:	36da 1000 	and	X, #4096
    5cc6:	196e      	je	0x5ca4 <.L3>

00005cc8 <.L4>:
            break;
        }
    }

    return (Result);
}
    5cc8:	5405      	ret	#6

00005cca <.L6>:
    while (IO_GET(ADC_SAR, STOP) == 0u)
    {
        if (IO_GET(ADC_SAR, STATE) == NextState)
        {
            /* the conversion is done, adc reached the requested state */
            Result = true;
    5cca:	7001      	lod	A, #1
    5ccc:	07fd      	jmp	0x5cc8 <.L4>

00005cce <_adc_Init>:
/**
 * Initialize the adc module
 */
void adc_Init(void)
{
    conv_high_voltage_init();
    5cce:	117c      	call	0x5fc8 <_conv_high_voltage_init>

00005cd0 <.LM16>:
    conv_low_voltage_init();
    5cd0:	11cb      	call	0x6068 <_conv_low_voltage_init>

00005cd2 <.LM17>:
    conv_motor_voltage_init();
    5cd2:	121a      	call	0x6108 <_conv_motor_voltage_init>

00005cd4 <.LM18>:
    conv_shunt_current_init();
    5cd4:	1286      	call	0x61e2 <_conv_shunt_current_init>

00005cd6 <.LBB515>:
}

STATIC INLINE void conv_update_shunt_current_offset(uint16_t value)
{
    extern calib_data_t calib_current;
    calib_current.simple.offset = value;
    5cd6:	7000      	lod	A, #0
    5cd8:	52d8 1124 	mov	0x1124 <_calib_current>, A

00005cdc <.LBE515>:
    conv_update_shunt_current_offset(0);

    /* enable VSM low-pass filter */
    IO_SET(PORT_MISC2_OUT, VSM_FILT_ON, 1u);
    5cdc:	72d8 01f4 	lod	A, 0x1f4 <_PORT_MISC2_OUT>
    5ce0:	c404      	or	AH, #4
    5ce2:	52d8 01f4 	mov	0x1f4 <_PORT_MISC2_OUT>, A

00005ce6 <.LBB517>:
    5ce6:	72da 2710 	lod	A, #10000
    5cea:	82db 10f8 	callf	0x21f0 <_delay_cycles>

00005cee <.LBE517>:
    /* wait for about 1.25ms to settle; measurements of the VSMF channel before the end of the delay are incorrect */
    DELAY_US(1250);

    /* enable current sense amplifier */
    IO_SET(PORT_DRV_OUT, ENABLE_CSA, 1u);
    5cee:	62d8 020e 	lod	AL, 0x20e <_PORT_DRV_OUT>
    5cf2:	8440      	or	AL, #64
    5cf4:	42d8 020e 	mov	0x20e <_PORT_DRV_OUT>, AL

00005cf8 <.LM23>:

    /* enable the adc module */
    IO_SET(PORT_ADC_CTRL, ADC_EN, 1u);
    5cf8:	62b4      	lod	AL, io:0x34 <_PORT_ADC_CTRL>
    5cfa:	8402      	or	AL, #2
    5cfc:	42b4      	mov	io:0x34 <_PORT_ADC_CTRL>, AL

00005cfe <.LBB520>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    5cfe:	7ee3      	lod	X, M

00005d00 <.LBB523>:
    return 1;
}

STATIC INLINE uint16_t mlx16_di_enter_system_mode(void)
{
    __asm__ __volatile__ (".word OPCODE_CALL_FP_ENTER_SYSTEM_MODE_PRIO_0");
    5d00:	503d      	call	fp1:0xE8

00005d02 <.LBE523>:

    /* enable adc interrupts */
    ENTER_SECTION(ATOMIC_SYSTEM_MODE);
    Itc_SetPrio(ADC_SAR, PRIO_ADC_SAR_INT);
    5d02:	62d8 008c 	lod	AL, 0x8c <.LASF1440>
    5d06:	94f3      	and	AL, #-13
    5d08:	8404      	or	AL, #4
    5d0a:	42d8 008c 	mov	0x8c <.LASF1440>, AL

00005d0e <.LM27>:
    Itc_Enable(ADC_SAR);
    5d0e:	62d8 0070 	lod	AL, 0x70 <.LASF730+0x11>
    5d12:	8420      	or	AL, #32
    5d14:	42d8 0070 	mov	0x70 <.LASF730+0x11>, AL

00005d18 <.LBB525>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    5d18:	5ee3      	mov	M, X

00005d1a <.LBE520>:
    EXIT_SECTION();
}
    5d1a:	5401      	ret

00005d1c <_adc_Start>:
 * This function initialize the adc module and clears/disables it's
 * corresponding interrupt.
 * @param[in]  bWait  true : wait for 1 conversion cycle to be finished.
 */
void adc_Start(bool bWait)
{
    5d1c:	7ee2      	lod	X, A

00005d1e <.LBB529>:
    return (IO_GET(ADC_SAR, STOP) == 0u);
}

STATIC INLINE void AdcClearAllErrors(void)
{
    IO_SET(ADC_SAR,
    5d1e:	601f      	lod	AL, #31

00005d20 <.LVL18>:
    5d20:	42d8 016b 	mov	0x16b <_ADC_SAR+0x5>, AL

00005d24 <.LBB531>:
    }
}

STATIC INLINE void AdcResume(void)
{
    IO_HOST(ADC_SAR, RESUME) = (uint16_t)1u << IO_OFFSET(ADC_SAR, RESUME);
    5d24:	7002      	lod	A, #2
    5d26:	0ea7      	lod	C, ML.7
    5d28:	52d8 016a 	mov	0x16a <_ADC_SAR+0x4>, A

00005d2c <.LBB533>:
}

STATIC INLINE void AdcInit(uint8_t AdcDiv, const void* SBase,
                           AdcControl_t ctrl)
{
    IO_SET(PORT_ADC_CTRL, ADC_EN, 1u);
    5d2c:	62b4      	lod	AL, io:0x34 <_PORT_ADC_CTRL>
    5d2e:	8402      	or	AL, #2
    5d30:	42b4      	mov	io:0x34 <_PORT_ADC_CTRL>, AL

00005d32 <.LM38>:
    IO_SET(ADC_SAR, STOP, 1u); /* STOP the ADC from any ADC mode. */
    5d32:	62d8 0166 	lod	AL, 0x166 <_ADC_SAR>
    5d36:	94fc      	and	AL, #-4
    5d38:	8402      	or	AL, #2
    5d3a:	42d8 0166 	mov	0x166 <_ADC_SAR>, AL

00005d3e <.LM39>:
    IO_SET(ADC_SAR, ADC_CLK_DIV, AdcDiv);
    5d3e:	6007      	lod	AL, #7
    5d40:	42d8 016c 	mov	0x16c <_ADC_SAR+0x6>, AL

00005d44 <.LM40>:
    IO_SET(ADC_SAR, SBASE_0, (uint16_t )SBase);
    5d44:	0ea7      	lod	C, ML.7
    5d46:	72da 1012 	lod	A, #4114
    5d4a:	52d8 0168 	mov	0x168 <_ADC_SAR+0x2>, A

00005d4e <.LM41>:
    IO_SET(ADC_SAR, START, 0u, /* Don't impact on Start-Stop */
    5d4e:	72da 0ac4 	lod	A, #2756
    5d52:	0ea7      	lod	C, ML.7
    5d54:	52d8 0166 	mov	0x166 <_ADC_SAR>, A

00005d58 <.LBB535>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    5d58:	7ae3      	lod	Y, M

00005d5a <.LBB538>:
    5d5a:	503d      	call	fp1:0xE8

00005d5c <.LBE538>:
    /* initialize adc unit */
    AdcInit(((FPLL / 4000u) - 1u), (void*)&sBase[0], adc_ctrl);

    /* start the adc sequence */
    ENTER_SECTION(ATOMIC_SYSTEM_MODE);
    Itc_Clear(ADC_SAR);
    5d5c:	6020      	lod	AL, #32
    5d5e:	42d8 0054 	mov	0x54 <.LLST24+0x2>, AL

00005d62 <.LBB540>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    5d62:	5ae3      	mov	M, Y

00005d64 <.LBB544>:
           ADC_WIDTH, (uint16_t)ctrl.s.adcWidth);
}

STATIC INLINE void AdcStart(void)
{
    IO_HOST(ADC_SAR, START) = (uint16_t)1u << IO_OFFSET(ADC_SAR, START); /* START the ADC. */
    5d64:	7001      	lod	A, #1
    5d66:	0ea7      	lod	C, ML.7
    5d68:	52d8 0166 	mov	0x166 <_ADC_SAR>, A

00005d6c <.LBE544>:
    EXIT_SECTION();
    AdcStart();
    if (bWait)
    5d6c:	2c00      	cmp	X, #0
    5d6e:	1904      	je	0x5d78 <.L10>

00005d70 <.L12>:
    {
        /* wait to fill buffers with valid data */
        while (Itc_IsPending(ADC_SAR) == 0u)
    5d70:	72d8 0054 	lod	A, 0x54 <.LLST24+0x2>
    5d74:	9420      	and	AL, #32
    5d76:	197c      	je	0x5d70 <.L12>

00005d78 <.L10>:
        {}
    }
}
    5d78:	5401      	ret

00005d7a <_adc_Stop>:
 * This function tries to stop the adc using the recommended method, it will
 * wait for some time to wait till the adc really stopped.
 */
void adc_Stop(void)
{
    if (IO_GET(ADC_SAR, STOP) != 1u)
    5d7a:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>
    5d7e:	9402      	and	AL, #2
    5d80:	1d1c      	jne	0x5dba <.L18>

00005d82 <.L39>:
    {
        /* Stop ADC */
        while (IO_GET(ADC_SAR, STOP) == 0u)
    5d82:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>
    5d86:	9402      	and	AL, #2
    5d88:	1d14      	jne	0x5db2 <.L22>

00005d8a <.LBB557>:
}

STATIC INLINE void AdcStop(void)
{
    IO_HOST(ADC_SAR, STOP) = (uint16_t)1u << IO_OFFSET(ADC_SAR, STOP); /* STOP the ADC. */
    5d8a:	7002      	lod	A, #2
    5d8c:	52d8 0166 	mov	0x166 <_ADC_SAR>, A
    5d90:	07f8      	jmp	0x5d82 <.L39>

00005d92 <.L23>:
           ADC_WIDTH, (uint16_t)ctrl.s.adcWidth);
}

STATIC INLINE void AdcStart(void)
{
    IO_HOST(ADC_SAR, START) = (uint16_t)1u << IO_OFFSET(ADC_SAR, START); /* START the ADC. */
    5d92:	7001      	lod	A, #1
    5d94:	52d8 0166 	mov	0x166 <_ADC_SAR>, A

00005d98 <.L40>:
        }

        while (IO_GET(ADC_SAR, STATE) != ADC_PHASE_IDLE)
        {
            /* Restart ADC ...*/
            while (IO_GET(ADC_SAR, START) == 0u)
    5d98:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>
    5d9c:	9401      	and	AL, #1
    5d9e:	1979      	je	0x5d92 <.L23>

00005da0 <.LBB561>:
        );
}

STATIC INLINE void builtin_mlx16_nop(void)
{
    __asm__ __volatile__ ("nop");
    5da0:	0000      	nop

00005da2 <.L41>:
            }

            NOP();

            /* ... and STOP it again */
            while (IO_GET(ADC_SAR, STOP) == 0u)
    5da2:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>
    5da6:	9402      	and	AL, #2
    5da8:	1d04      	jne	0x5db2 <.L22>

00005daa <.LBB563>:
}

STATIC INLINE void AdcStop(void)
{
    IO_HOST(ADC_SAR, STOP) = (uint16_t)1u << IO_OFFSET(ADC_SAR, STOP); /* STOP the ADC. */
    5daa:	7002      	lod	A, #2
    5dac:	52d8 0166 	mov	0x166 <_ADC_SAR>, A
    5db0:	07f8      	jmp	0x5da2 <.L41>

00005db2 <.L22>:
        while (IO_GET(ADC_SAR, STOP) == 0u)
        {
            AdcStop();
        }

        while (IO_GET(ADC_SAR, STATE) != ADC_PHASE_IDLE)
    5db2:	72d8 016a 	lod	A, 0x16a <_ADC_SAR+0x4>
    5db6:	94c0      	and	AL, #-64
    5db8:	1d6f      	jne	0x5d98 <.L40>

00005dba <.L18>:
            {
                AdcStop();
            }
        }
    }
}
    5dba:	5401      	ret

00005dbc <_adc_Shunt_OffsetCalib>:
 * calculations by the application.
 *
 * @remark  Driver must be enabled before calling this function!
 */
void adc_Shunt_OffsetCalib(void)
{
    5dbc:	581d      	inc	S, #30

00005dbe <.LCFI1>:
    volatile uint16_t ZCO[3];  /**< adc sample buffer (2 samples + 1 crc) */
    volatile AdcSData_t sBase_CurrOff[] =
    5dbe:	7eef      	lod	X, S
    5dc0:	20f0      	add	X, #-16
    5dc2:	7800      	lod	Y, #0
    5dc4:	72e6      	lod	A, Y
    5dc6:	52de      	mov	[X++], A
    5dc8:	52de      	mov	[X++], A
    5dca:	52de      	mov	[X++], A
    5dcc:	720f      	lod	A, [S-16]
    5dce:	5207      	mov	[S-8], A
    5dd0:	720d      	lod	A, [S-14]
    5dd2:	5205      	mov	[S-6], A
    5dd4:	720b      	lod	A, [S-12]
    5dd6:	5203      	mov	[S-4], A
    5dd8:	72ef      	lod	A, S
    5dda:	a0ea      	add	A, #-22
    5ddc:	5209      	mov	[S-10], A
    5dde:	7207      	lod	A, [S-8]
    5de0:	b483      	and	A, #-125
    5de2:	a440      	or	A, #64
    5de4:	b6da fc7f 	and	A, #64639
    5de8:	a6da 0180 	or	A, #384
    5dec:	5207      	mov	[S-8], A
    5dee:	7205      	lod	A, [S-6]
    5df0:	b483      	and	A, #-125
    5df2:	a440      	or	A, #64
    5df4:	b6da fc7f 	and	A, #64639
    5df8:	a6da 0180 	or	A, #384
    5dfc:	5205      	mov	[S-6], A
    5dfe:	7203      	lod	A, [S-4]
    5e00:	8403      	or	AL, #3
    5e02:	5203      	mov	[S-4], A
    5e04:	7209      	lod	A, [S-10]
    5e06:	521d      	mov	[S-30], A
    5e08:	7207      	lod	A, [S-8]
    5e0a:	521b      	mov	[S-28], A
    5e0c:	7205      	lod	A, [S-6]
    5e0e:	5219      	mov	[S-26], A
    5e10:	7203      	lod	A, [S-4]
    5e12:	5217      	mov	[S-24], A

00005e14 <.LBB565>:
}

STATIC INLINE void AdcInit(uint8_t AdcDiv, const void* SBase,
                           AdcControl_t ctrl)
{
    IO_SET(PORT_ADC_CTRL, ADC_EN, 1u);
    5e14:	62b4      	lod	AL, io:0x34 <_PORT_ADC_CTRL>
    5e16:	8402      	or	AL, #2
    5e18:	42b4      	mov	io:0x34 <_PORT_ADC_CTRL>, AL

00005e1a <.LM64>:
    IO_SET(ADC_SAR, STOP, 1u); /* STOP the ADC from any ADC mode. */
    5e1a:	62d8 0166 	lod	AL, 0x166 <_ADC_SAR>
    5e1e:	94fc      	and	AL, #-4
    5e20:	8402      	or	AL, #2
    5e22:	42d8 0166 	mov	0x166 <_ADC_SAR>, AL

00005e26 <.LM65>:
    IO_SET(ADC_SAR, ADC_CLK_DIV, AdcDiv);
    5e26:	6007      	lod	AL, #7
    5e28:	42d8 016c 	mov	0x16c <_ADC_SAR+0x6>, AL

00005e2c <.LM66>:
    IO_SET(ADC_SAR, SBASE_0, (uint16_t )SBase);
    5e2c:	72ef      	lod	A, S
    5e2e:	a0e2      	add	A, #-30

00005e30 <.LVL25>:
    5e30:	52d8 0168 	mov	0x168 <_ADC_SAR+0x2>, A

00005e34 <.LM67>:
    IO_SET(ADC_SAR, START, 0u, /* Don't impact on Start-Stop */
    5e34:	72da 08d8 	lod	A, #2264

00005e38 <.LVL26>:
    5e38:	52d8 0166 	mov	0x166 <_ADC_SAR>, A

00005e3c <.LBE565>:
                              .adcWidth = ADC_WDT_16Bit}};

    /* initialize adc unit */
    AdcInit(((FPLL / 4000u) - 1u), (void*)&sBase_CurrOff[0], adc_ctrl);

    (void)adc_DoSoftwareTrigger(ADC_PHASE_WAIT_TRIGGER);
    5e3c:	0ea7      	lod	C, ML.7
    5e3e:	7003      	lod	A, #3
    5e40:	5a01      	mov	[S-2], Y
    5e42:	171a      	call	0x5c78 <_adc_DoSoftwareTrigger>

00005e44 <.LM69>:
    (void)adc_DoSoftwareTrigger(ADC_PHASE_IDLE);
    5e44:	7a01      	lod	Y, [S-2]
    5e46:	72e6      	lod	A, Y
    5e48:	1717      	call	0x5c78 <_adc_DoSoftwareTrigger>

00005e4a <.LM70>:

    i16MotorCurrentZeroOffset = (ZCO[0] + ZCO[1] + 1) / 2;
    5e4a:	7215      	lod	A, [S-22]
    5e4c:	7e13      	lod	X, [S-20]
    5e4e:	a2ee      	add	A, X
    5e50:	a001      	add	A, #1
    5e52:	4432      	lsr	A
    5e54:	52d8 105c 	mov	0x105c <_i16MotorCurrentZeroOffset>, A

00005e58 <.LM71>:

    if ((diff < -10) || (diff > 10))
    {
        /* calibration data and measured data are diverging to much, there might be some electric error */
    }
}
    5e58:	541f      	ret	#32

00005e5a <_adc_CaptureOneChannel>:

uint16_t adc_CaptureOneChannel(AdcSignal_t channel)
{
    5e5a:	5827      	inc	S, #40

00005e5c <.LCFI2>:
    uint16_t retval;
    volatile uint16_t Temp[5];  /**< adc sample buffer (4 samples + 1 crc) */
    volatile AdcSData_t sBase_Temp[] =
    5e5c:	7eef      	lod	X, S
    5e5e:	20da      	add	X, #-38
    5e60:	7800      	lod	Y, #0
    5e62:	54e5      	mov	Cx, #5
    5e64:	5ade      	mov	[X++], Y
    5e66:	1ffe      	djnz	Cx, 0x5e64 <.LCFI2+0x8>

00005e68 <.LM74>:
    {
        {.u16 = (uint16_t)&Temp[0]},
    5e68:	7eef      	lod	X, S
    5e6a:	20f0      	add	X, #-16

00005e6c <.LM75>:

uint16_t adc_CaptureOneChannel(AdcSignal_t channel)
{
    uint16_t retval;
    volatile uint16_t Temp[5];  /**< adc sample buffer (4 samples + 1 crc) */
    volatile AdcSData_t sBase_Temp[] =
    5e6c:	5e27      	mov	[S-40], X
    5e6e:	b41f      	and	A, #31

00005e70 <.LVL32>:
    5e70:	44a2      	asl	A, #2
    5e72:	7e25      	lod	X, [S-38]
    5e74:	36da fc03 	and	X, #64515
    5e78:	26e2      	or	X, A
    5e7a:	26da 0180 	or	X, #384
    5e7e:	5e25      	mov	[S-38], X
    5e80:	7e23      	lod	X, [S-36]
    5e82:	36da fc03 	and	X, #64515
    5e86:	26e2      	or	X, A
    5e88:	26da 0180 	or	X, #384
    5e8c:	5e23      	mov	[S-36], X
    5e8e:	7e21      	lod	X, [S-34]
    5e90:	36da fc03 	and	X, #64515
    5e94:	26e2      	or	X, A
    5e96:	26da 0180 	or	X, #384
    5e9a:	5e21      	mov	[S-34], X
    5e9c:	7e1f      	lod	X, [S-32]
    5e9e:	36da fc03 	and	X, #64515
    5ea2:	a6ee      	or	A, X
    5ea4:	a6da 0180 	or	A, #384
    5ea8:	521f      	mov	[S-32], A
    5eaa:	7eef      	lod	X, S
    5eac:	20e2      	add	X, #-30
    5eae:	62f8      	lod	AL, [X]
    5eb0:	8403      	or	AL, #3
    5eb2:	42f8      	mov	[X], AL
    5eb4:	2002      	add	X, #2
    5eb6:	5e01      	mov	[S-2], X
    5eb8:	7aef      	lod	Y, S
    5eba:	e0d8      	add	Y, #-40
    5ebc:	5a05      	mov	[S-6], Y
    5ebe:	54e6      	mov	Cx, #6
    5ec0:	54c6      	movsw	[X++], [Y++]
    5ec2:	1ffe      	djnz	Cx, 0x5ec0 <.LASF2014+0x2>

00005ec4 <.LM76>:
          .adcDiv = ADC_DIV_DISABLED}},
        {{.adcEosSign = ADC_EOS_SIGN}},
    };

    /* configure the adc for sample measurements */
    adc_Stop();  /* properly stop the adc */
    5ec4:	175a      	call	0x5d7a <_adc_Stop>

00005ec6 <.LBB567>:
}

STATIC INLINE void AdcInit(uint8_t AdcDiv, const void* SBase,
                           AdcControl_t ctrl)
{
    IO_SET(PORT_ADC_CTRL, ADC_EN, 1u);
    5ec6:	62b4      	lod	AL, io:0x34 <_PORT_ADC_CTRL>
    5ec8:	8402      	or	AL, #2
    5eca:	42b4      	mov	io:0x34 <_PORT_ADC_CTRL>, AL

00005ecc <.LM78>:
    IO_SET(ADC_SAR, STOP, 1u); /* STOP the ADC from any ADC mode. */
    5ecc:	62d8 0166 	lod	AL, 0x166 <_ADC_SAR>
    5ed0:	94fc      	and	AL, #-4
    5ed2:	8402      	or	AL, #2
    5ed4:	42d8 0166 	mov	0x166 <_ADC_SAR>, AL

00005ed8 <.LM79>:
    IO_SET(ADC_SAR, ADC_CLK_DIV, AdcDiv);
    5ed8:	6007      	lod	AL, #7
    5eda:	42d8 016c 	mov	0x16c <_ADC_SAR+0x6>, AL

00005ede <.LM80>:
    IO_SET(ADC_SAR, SBASE_0, (uint16_t )SBase);
    5ede:	72ef      	lod	A, S
    5ee0:	a0e4      	add	A, #-28
    5ee2:	52d8 0168 	mov	0x168 <_ADC_SAR+0x2>, A

00005ee6 <.LM81>:
    IO_SET(ADC_SAR, START, 0u, /* Don't impact on Start-Stop */
    5ee6:	72da 08d8 	lod	A, #2264
    5eea:	52d8 0166 	mov	0x166 <_ADC_SAR>, A

00005eee <.LBE567>:
                              .adcWidth = ADC_WDT_16Bit}};

    /* initialize adc unit */
    AdcInit(((FPLL / 4000u) - 1u), (void*)&sBase_Temp[0], adc_ctrl);

    (void)adc_DoSoftwareTrigger(ADC_PHASE_WAIT_TRIGGER);
    5eee:	0ea7      	lod	C, ML.7
    5ef0:	7003      	lod	A, #3
    5ef2:	16c2      	call	0x5c78 <_adc_DoSoftwareTrigger>

00005ef4 <.LM83>:
    (void)adc_DoSoftwareTrigger(ADC_PHASE_WAIT_TRIGGER);
    5ef4:	7003      	lod	A, #3
    5ef6:	16c0      	call	0x5c78 <_adc_DoSoftwareTrigger>

00005ef8 <.LM84>:
    (void)adc_DoSoftwareTrigger(ADC_PHASE_WAIT_TRIGGER);
    5ef8:	7003      	lod	A, #3
    5efa:	16be      	call	0x5c78 <_adc_DoSoftwareTrigger>

00005efc <.LM85>:
    (void)adc_DoSoftwareTrigger(ADC_PHASE_IDLE);
    5efc:	7000      	lod	A, #0
    5efe:	16bc      	call	0x5c78 <_adc_DoSoftwareTrigger>

00005f00 <.LM86>:

    retval = (Temp[0] + Temp[1] + Temp[2] + Temp[3] + 2) / 4;
    5f00:	7e0f      	lod	X, [S-16]
    5f02:	7a0d      	lod	Y, [S-14]
    5f04:	720b      	lod	A, [S-12]
    5f06:	5201      	mov	[S-2], A
    5f08:	7209      	lod	A, [S-10]
    5f0a:	5205      	mov	[S-6], A
    5f0c:	22e6      	add	X, Y
    5f0e:	2002      	add	X, #2
    5f10:	7201      	lod	A, [S-2]
    5f12:	a2ee      	add	A, X
    5f14:	a205      	add	A, [S-6]
    5f16:	44b2      	lsr	A, #2

00005f18 <.LM87>:

    return retval;
}
    5f18:	5429      	ret	#42

00005f1a <_adc_ConvertToCurrent>:
int16_t adc_ConvertToCurrent(uint16_t u16AdcVal)
{
    int16_t current;

    /* the current sensor current in mA units */
    current = conv_shunt_current(u16AdcVal);		//Option-A
    5f1a:	0178      	jmp	0x620c <_conv_shunt_current>

00005f1c <_adc_ConvertToTchip>:
 * @param[in]  u16AdcVal  Raw adc measurement.
 * @return  the temperature in 1 degC.
 */
int16_t adc_ConvertToTchip(uint16_t u16AdcVal)
{
    return CalculateTemperature3pLinearize(u16AdcVal);
    5f1c:	76da 4101 	jmpf	0x8202 <_CalculateTemperature3pLinearize>

00005f20 <_adc_ConvertToVsmFiltered>:
 * @param[in]  u16AdcVal  Raw adc measurement.
 * @return  the filtered Vsm supply voltage in 10 mV.
 */
int16_t adc_ConvertToVsmFiltered(uint16_t u16AdcVal)
{
    return conv_motor_voltage_filtered_with_tcorrection(u16AdcVal, dBase[ADC_SAMPLE_TEMP]);
    5f20:	7ed8 10f8 	lod	X, 0x10f8 <.LASF909>
    5f24:	5edf      	push	X

00005f26 <.LCFI3>:
    5f26:	1137      	call	0x6196 <_conv_motor_voltage_filtered_with_tcorrection>

00005f28 <.LCFI4>:
}
    5f28:	5403      	ret	#4

00005f2a <_adc_ConvertToVsupply>:
 * @param[in]  u16AdcVal  Raw adc measurement.
 * @return  the supply voltage in 10 mV.
 */
int16_t adc_ConvertToVsupply(uint16_t u16AdcVal)
{
    return conv_high_voltage_with_tcorrection(u16AdcVal, dBase[ADC_SAMPLE_TEMP]);
    5f2a:	7ed8 10f8 	lod	X, 0x10f8 <.LASF909>
    5f2e:	5edf      	push	X

00005f30 <.LCFI5>:
    5f30:	1075      	call	0x601c <_conv_high_voltage_with_tcorrection>

00005f32 <.LCFI6>:
}
    5f32:	5403      	ret	#4

00005f34 <_adc_ConvertToVio>:
int16_t adc_ConvertToVio(uint16_t u16AdcVal)
{
#define C_IO_ADC_OFFSET 	0U

	u16AdcVal += C_IO_ADC_OFFSET;
    return (conv_low_voltage_with_tcorrection(u16AdcVal , dBase[ADC_SAMPLE_TEMP]) << 1U);		//original
    5f34:	7ed8 10f8 	lod	X, 0x10f8 <.LASF909>
    5f38:	5edf      	push	X

00005f3a <.LCFI7>:
    5f3a:	10c0      	call	0x60bc <_conv_low_voltage_with_tcorrection>

00005f3c <.LVL52>:
    5f3c:	4422      	asl	A

00005f3e <.LCFI8>:
//    return (conv_low_voltage(u16AdcVal) << 1U);		//Option-B
}
    5f3e:	5403      	ret	#4

00005f40 <_adc_ConvertToVoltage>:
 */
MATHLIB_INLINE_STATIC __inline__ uint32_t mulU32_U16byU16(uint16_t multiplicand, uint16_t multiplier)
{
    uint32_t result;

    __asm__ __volatile__ (
    5f40:	4822 09c4 	mulu	YA, A, #2500

00005f44 <.LBE569>:
 */
int16_t adc_ConvertToVoltage(uint16_t u16AdcVal)
{
    int16_t i16Volt;

    i16Volt = (int16_t)(mulU32_U16byU16(u16AdcVal, 2500u) / 1024u);
    5f44:	48a9      	lsr	YA, #10

00005f46 <.LM106>:

    return (i16Volt);
}
    5f46:	5401      	ret

00005f48 <__ADC_SAR_INT>:
/**
 * @brief ADC Interrupt Service Routine
 * In case no ADC_ISR action required, this ISR has 4us overhead
 */
__attribute__((interrupt)) void _ADC_SAR_INT(void)
{
    5f48:	5edf      	push	X

00005f4a <.LCFI9>:
    5f4a:	5adf      	push	Y

00005f4c <.LCFI10>:
    5f4c:	52df      	push	A

00005f4e <.LCFI11>:
    5f4e:	4c83      	push	D

00005f50 <.LCFI12>:
    if (p16AdcIrq != NULL)
    5f50:	72d8 105a 	lod	A, 0x105a <__data_end>
    5f54:	1903      	je	0x5f5c <.L51>

00005f56 <.LM109>:
    {
        p16AdcIrq();
    5f56:	0001      	jmp	0x5f5a <.L57>

00005f58 <.L56>:
    5f58:	76e2      	jmp	A

00005f5a <.L57>:
    5f5a:	17fe      	call	0x5f58 <.L56>

00005f5c <.L51>:
    if (p16AdcIrq2 != NULL)
    {
        p16AdcIrq2();
    }
    #endif
}
    5f5c:	4cc3      	pop	D

00005f5e <.LCFI13>:
    5f5e:	72cf      	pop	A

00005f60 <.LCFI14>:
    5f60:	7acf      	pop	Y

00005f62 <.LCFI15>:
    5f62:	7ecf      	pop	X

00005f64 <.LCFI16>:
    5f64:	72cb      	pop	M
    5f66:	5401      	ret

00005f68 <_conv_clock_error_init>:
int16_t clock_error_SClockHighCal;  /**< CPU clock gain for high temperature range */
int16_t clock_error_OClockCal;  /**< CPU clock offset */

void conv_clock_error_init(void)
{
    clock_error_OTempCal = EE_GET(OTEMPCAL);
    5f68:	72d8 09b4 	lod	A, 0x9b4 <.LASF2082+0xa>
    5f6c:	52d8 1104 	mov	0x1104 <_clock_error_OTempCal>, A

00005f70 <.LM3>:

    #if (FPLL == 32000) || (FPLL == 16000)
    clock_error_SClockLowCal = EE_GET(SCLOCK32LOWCAL);
    5f70:	72d8 09c4 	lod	A, 0x9c4 <.LASF935+0x8>
    5f74:	66e0      	lod	YL, AL
    5f76:	5ce6      	ssex	Y
    5f78:	5ad8 1108 	mov	0x1108 <_clock_error_SClockLowCal>, Y

00005f7c <.LM4>:
    clock_error_SClockHighCal = EE_GET(SCLOCK32HIGHCAL);
    5f7c:	62e4      	lod	AL, AH
    5f7e:	5ce2      	ssex	A
    5f80:	52d8 110a 	mov	0x110a <_clock_error_SClockHighCal>, A

00005f84 <.LM5>:
    clock_error_OClockCal = EE_GET(OCLOCK32CAL);
    5f84:	62d8 09c6 	lod	AL, 0x9c6 <.LASF935+0xa>
    5f88:	5ce2      	ssex	A
    5f8a:	52d8 1106 	mov	0x1106 <_clock_error_OClockCal>, A

00005f8e <.LM6>:
    #else
    clock_error_SClockLowCal = 0;
    clock_error_SClockHighCal = 0;
    clock_error_OClockCal = 0;
    #endif
}
    5f8e:	5401      	ret

00005f90 <_conv_clock_error_speed>:
int16_t conv_clock_error_speed(uint16_t raw_temperature)
{
    int16_t temp;
    int16_t gain;

    temp = (int16_t)raw_temperature - clock_error_OTempCal;
    5f90:	aad8 1104 	sub	A, 0x1104 <_clock_error_OTempCal>

00005f94 <.LM9>:

    if (temp > 0)
    5f94:	ac00      	cmp	A, #0
    5f96:	1b0f      	jsle	0x5fb6 <.L3>

00005f98 <.LM10>:
    {
        gain = clock_error_SClockLowCal;
    5f98:	7ed8 1108 	lod	X, 0x1108 <_clock_error_SClockLowCal>

00005f9c <.L4>:
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI32_I16byI16(int16_t multiplicand, int16_t multiplier)
{
    int32_t result;

    __asm__ __volatile__ (
    5f9c:	4833      	muls	YA, A, X

00005f9e <.LBE6>:
    else
    {
        gain = clock_error_SClockHighCal;
    }

    return clock_error_OClockCal + (int16_t)(mulI32_I16byI16(temp, gain) / 64);
    5f9e:	4cb2 0000 	cmp	YA, #0
    5fa2:	0000 
    5fa4:	1e84      	jsge	0x5fae <.L5>
    5fa6:	4cc0      	mov	D, YA
    5fa8:	4c0a 003f 	addu	D, #63
    5fac:	4c80      	mov	YA, D

00005fae <.L5>:
    5fae:	48b5      	asr	YA, #6
    5fb0:	a2d8 1106 	add	A, 0x1106 <_clock_error_OClockCal>

00005fb4 <.LM13>:
}
    5fb4:	5401      	ret

00005fb6 <.L3>:
    {
        gain = clock_error_SClockLowCal;
    }
    else
    {
        gain = clock_error_SClockHighCal;
    5fb6:	7ed8 110a 	lod	X, 0x110a <_clock_error_SClockHighCal>

00005fba <.LVL5>:
    5fba:	07f0      	jmp	0x5f9c <.L4>

00005fbc <_conv_clock_error_correct_period>:
    return clock_error_OClockCal + (int16_t)(mulI32_I16byI16(temp, gain) / 64);
}

uint16_t conv_clock_error_correct_period(uint16_t period, int16_t clock_error)
{
    int16_t temp = 2048 + clock_error;
    5fbc:	7e03      	lod	X, [S-4]
    5fbe:	22da 0800 	add	X, #2048

00005fc2 <.LBB8>:
 */
MATHLIB_INLINE_STATIC __inline__ uint32_t mulU32_U16byU16(uint16_t multiplicand, uint16_t multiplier)
{
    uint32_t result;

    __asm__ __volatile__ (
    5fc2:	4823      	mulu	YA, A, X

00005fc4 <.LBE8>:
    return (uint16_t)(mulU32_U16byU16(period, (uint16_t)temp) / 2048u);
    5fc4:	48aa      	lsr	YA, #11

00005fc6 <.LM19>:
}
    5fc6:	5401      	ret

00005fc8 <_conv_high_voltage_init>:
calib_data_t calib_hvi;

void conv_high_voltage_init(void)
{
#if defined(EE_O_HVI_GET)
    calib_hvi.simple.offset = EE_GET(O_HVI);
    5fc8:	72d8 09d4 	lod	A, 0x9d4 <.Ldebug_line0>
    5fcc:	62e4      	lod	AL, AH
    5fce:	5ce2      	ssex	A
    5fd0:	52d8 110c 	mov	0x110c <_calib_hvi>, A
    5fd4:	72d8 09d8 	lod	A, 0x9d8 <.Ldebug_line0+0x4>
    5fd8:	d400      	and	AH, #0

00005fda <.LM3>:
    calib_hvi.simple.gain = EE_GET(GAIN_HVI);
    5fda:	52d8 110e 	mov	0x110e <_calib_hvi+0x2>, A

00005fde <.LM4>:
    calib_hvi.gain_low_t = EE_GET(GAINLO_VSMF);
    5fde:	7ad8 09e2 	lod	Y, 0x9e2 <.Ldebug_abbrev0+0x7>
    5fe2:	46d8 1110 	mov	0x1110 <_calib_hvi+0x4>, YL

00005fe6 <.LM5>:
    calib_hvi.gain_high_t = EE_GET(GAINHI_VSMF);
    5fe6:	0ea7      	lod	C, ML.7
    5fe8:	4ed8 1111 	mov	0x1111 <_calib_hvi+0x5>, YH

00005fec <.LM6>:
    calib_hvi.simple.gain = EE_GET(VS_GAIN);
    calib_hvi.gain_low_t = 0;
    calib_hvi.gain_high_t = 0;
#endif

    if (calib_hvi.simple.gain == 0u)
    5fec:	ac00      	cmp	A, #0
    5fee:	1d04      	jne	0x5ff8 <.L1>

00005ff0 <.LM7>:
    {
        /* gain 0 is not allowed, use the default value */
        calib_hvi.simple.gain = 164u;               /* 2.5V * 21 * 100 * HVI_GAIN_DIV / 1023 */
    5ff0:	72da 00a4 	lod	A, #164
    5ff4:	52d8 110e 	mov	0x110e <_calib_hvi+0x2>, A

00005ff8 <.L1>:
    }
}
    5ff8:	5401      	ret

00005ffa <_conv_high_voltage>:
 * @return  updated measurement.
 */
STATIC INLINE int16_t apply_offset_gain(uint16_t u16ADC_Value, simple_calib_data_t * cal_data, uint8_t divider)
{
    int16_t measurement = (int16_t)u16ADC_Value;
    measurement -= cal_data->offset;
    5ffa:	aad8 110c 	sub	A, 0x110c <_calib_hvi>

00005ffe <.LBB24>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byU8(int16_t multiplicand, uint8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    5ffe:	7ed8 110e 	lod	X, 0x110e <_calib_hvi+0x2>
    6002:	36da 00ff 	and	X, #255

00006006 <.LM12>:

    __asm__ __volatile__ (
    6006:	4833      	muls	YA, A, X

00006008 <.LBE24>:
    measurement = (int16_t)(mulI24_I16byU8(measurement, cal_data->gain) / divider);
    6008:	4cb2 0000 	cmp	YA, #0
    600c:	0000 
    600e:	1e84      	jsge	0x6018 <.L4>
    6010:	4cc0      	mov	D, YA
    6012:	4c0a 001f 	addu	D, #31
    6016:	4c80      	mov	YA, D

00006018 <.L4>:
    6018:	48b4      	asr	YA, #5

0000601a <.LBE22>:

int16_t conv_high_voltage(uint16_t u16ADC_Value)
{
    /* cHVI = (mHVI - O_HVI_EE) * Gain_HVI_EE / 2^5 */
    return apply_offset_gain(u16ADC_Value, &calib_hvi.simple, HVI_GAIN_DIV);
}
    601a:	5401      	ret

0000601c <_conv_high_voltage_with_tcorrection>:

int16_t conv_high_voltage_with_tcorrection(uint16_t u16ADC_Value, uint16_t u16ADC_Temp)
{
    601c:	5805      	inc	S, #6

0000601e <.LCFI0>:
     * }else{
     *     tempGain = ((GainHi_VSMF_EE / 2^11) * mTempDiff)/2^7;
     * }
     * cHVIcorr = cHVI * (1 + tempGain)
     */
    return apply_temp_gain(conv_high_voltage(u16ADC_Value), u16ADC_Temp, &calib_hvi);
    601e:	17ed      	call	0x5ffa <_conv_high_voltage>

00006020 <.LVL5>:
    6020:	5205      	mov	[S-6], A

00006022 <.LBB26>:
 * @return  updated measurement.
 */
STATIC INLINE int16_t apply_temp_gain(uint16_t u16ADC_Value, uint16_t u16ADC_Temp, calib_data_t * cal_data)
{
    int16_t gain;
    int16_t temp_diff = (int16_t)(u16ADC_Temp - EE_GET(OTEMPCAL));
    6022:	7e09      	lod	X, [S-10]
    6024:	2ad8 09b4 	sub	X, 0x9b4 <.LASF2082+0xa>

00006028 <.LM18>:

    if (temp_diff > 0)
    6028:	2c00      	cmp	X, #0
    602a:	1b1b      	jsle	0x6062 <.L6>

0000602c <.LBB28>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byI8(int16_t multiplicand, int8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    602c:	66d8 1110 	lod	YL, 0x1110 <_calib_hvi+0x4>

00006030 <.L12>:
    6030:	5ce6      	ssex	Y

00006032 <.LM20>:

    __asm__ __volatile__ (
    6032:	72ee      	lod	A, X

00006034 <.LVL10>:
    6034:	4811      	muls	D, A, Y
    6036:	5880      	mov	[S-4], D

00006038 <.LBE30>:
    {
        gain = (int16_t)(mulI24_I16byI8(temp_diff, cal_data->gain_low_t) / 128);
    }
    else
    {
        gain = (int16_t)(mulI24_I16byI8(temp_diff, cal_data->gain_high_t) / 128);
    6038:	4caa 0000 	cmpu	D, #0
    603c:	1e83      	jsge	0x6044 <.L9>

0000603e <.LVL11>:
    603e:	4c0a 007f 	addu	D, #127
    6042:	5880      	mov	[S-4], D

00006044 <.L9>:
    6044:	58e0      	mov	YA, [S-4]

00006046 <.LVL12>:
    6046:	48b6      	asr	YA, #7

00006048 <.LBB33>:
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI32_I16byI16(int16_t multiplicand, int16_t multiplier)
{
    int32_t result;

    __asm__ __volatile__ (
    6048:	7e05      	lod	X, [S-6]

0000604a <.LVL14>:
    604a:	4833      	muls	YA, A, X

0000604c <.LBE33>:
    }

    return (u16ADC_Value + (mulI32_I16byI16(gain, u16ADC_Value) / 2048));
    604c:	4cb2 0000 	cmp	YA, #0
    6050:	0000 
    6052:	1e84      	jsge	0x605c <.L10>
    6054:	4cc0      	mov	D, YA
    6056:	4c0a 07ff 	addu	D, #2047
    605a:	4c80      	mov	YA, D

0000605c <.L10>:
    605c:	48ba      	asr	YA, #11
    605e:	a205      	add	A, [S-6]

00006060 <.LBE26>:
}
    6060:	5407      	ret	#8

00006062 <.L6>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byI8(int16_t multiplicand, int8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    6062:	66d8 1111 	lod	YL, 0x1111 <_calib_hvi+0x5>
    6066:	07e4      	jmp	0x6030 <.L12>

00006068 <_conv_low_voltage_init>:
calib_data_t calib_lvi;

void conv_low_voltage_init(void)
{
#if defined(EE_O_LVI_GET)
    calib_lvi.simple.offset = EE_GET(O_LVI);
    6068:	72d8 09d6 	lod	A, 0x9d6 <.Ldebug_line0+0x2>
    606c:	7ee2      	lod	X, A
    606e:	54e4      	mov	Cx, #4
    6070:	44fe      	asr	X, #2
    6072:	1ffe      	djnz	Cx, 0x6070 <.LASF1978+0x3>
    6074:	5ed8 1112 	mov	0x1112 <_calib_lvi>, X
    6078:	d400      	and	AH, #0

0000607a <.LM3>:
    calib_lvi.simple.gain = EE_GET(GAIN_LVI);
    607a:	52d8 1114 	mov	0x1114 <_calib_lvi+0x2>, A

0000607e <.LM4>:
    calib_lvi.gain_low_t = EE_GET(GAINLO_LVI);
    607e:	7ad8 09da 	lod	Y, 0x9da <.Ldebug_line0+0x6>
    6082:	46d8 1116 	mov	0x1116 <_calib_lvi+0x4>, YL

00006086 <.LM5>:
    calib_lvi.gain_high_t = EE_GET(GAINHI_LVI);
    6086:	0ea7      	lod	C, ML.7
    6088:	4ed8 1711 	mov	0x1117 <_calib_lvi+0x5>, YH

0000608c <.LM6>:
    calib_lvi.simple.gain = 213u;                   /* 2.5V * 1.36 * 1000 * LVI_GAIN_DIV / 1023 */
    calib_lvi.gain_low_t = 0;
    calib_lvi.gain_high_t = 0;
#endif

    if (calib_lvi.simple.gain == 0u)
    608c:	ac00      	cmp	A, #0
    608e:	1d04      	jne	0x6098 <.L1>

00006090 <.LM7>:
    {
        /* gain 0 is not allowed, use the default value */
        calib_lvi.simple.gain = 213u;               /* 2.5V * 1.36 * 1000 * LVI_GAIN_DIV / 1023 */
    6090:	72da 00d5 	lod	A, #213
    6094:	52d8 1114 	mov	0x1114 <_calib_lvi+0x2>, A

00006098 <.L1>:
    }
}
    6098:	5401      	ret

0000609a <_conv_low_voltage>:
 * @return  updated measurement.
 */
STATIC INLINE int16_t apply_offset_gain(uint16_t u16ADC_Value, simple_calib_data_t * cal_data, uint8_t divider)
{
    int16_t measurement = (int16_t)u16ADC_Value;
    measurement -= cal_data->offset;
    609a:	aad8 1112 	sub	A, 0x1112 <_calib_lvi>

0000609e <.LBB24>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byU8(int16_t multiplicand, uint8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    609e:	7ed8 1114 	lod	X, 0x1114 <_calib_lvi+0x2>
    60a2:	36da 00ff 	and	X, #255

000060a6 <.LM12>:

    __asm__ __volatile__ (
    60a6:	4833      	muls	YA, A, X

000060a8 <.LBE24>:
    measurement = (int16_t)(mulI24_I16byU8(measurement, cal_data->gain) / divider);
    60a8:	4cb2 0000 	cmp	YA, #0
    60ac:	0000 
    60ae:	1e84      	jsge	0x60b8 <.L5>
    60b0:	4cc0      	mov	D, YA
    60b2:	4c0a 003f 	addu	D, #63
    60b6:	4c80      	mov	YA, D

000060b8 <.L5>:
    60b8:	48b5      	asr	YA, #6

000060ba <.LBE22>:

int16_t conv_low_voltage(uint16_t u16ADC_Value)
{
    /* cLVI = (mLVI - O_LVI_EE) * Gain_LVI_EE / 2^6 */
    return apply_offset_gain(u16ADC_Value, &calib_lvi.simple, LVI_GAIN_DIV);
}
    60ba:	5401      	ret

000060bc <_conv_low_voltage_with_tcorrection>:

int16_t conv_low_voltage_with_tcorrection(uint16_t u16ADC_Value, uint16_t u16ADC_Temp)
{
    60bc:	5805      	inc	S, #6

000060be <.LCFI0>:
     * }else{
     *     tempGain = ((GainHi_LVI_EE / 2^11) * mTempDiff)/2^7;
     * }
     * cLVIcorr = cLVI * (1 + tempGain)
     */
    return apply_temp_gain(conv_low_voltage(u16ADC_Value), u16ADC_Temp, &calib_lvi);
    60be:	17ed      	call	0x609a <_conv_low_voltage>

000060c0 <.LVL5>:
    60c0:	5205      	mov	[S-6], A

000060c2 <.LBB26>:
 * @return  updated measurement.
 */
STATIC INLINE int16_t apply_temp_gain(uint16_t u16ADC_Value, uint16_t u16ADC_Temp, calib_data_t * cal_data)
{
    int16_t gain;
    int16_t temp_diff = (int16_t)(u16ADC_Temp - EE_GET(OTEMPCAL));
    60c2:	7e09      	lod	X, [S-10]
    60c4:	2ad8 09b4 	sub	X, 0x9b4 <.LASF2082+0xa>

000060c8 <.LM18>:

    if (temp_diff > 0)
    60c8:	2c00      	cmp	X, #0
    60ca:	1b1b      	jsle	0x6102 <.L7>

000060cc <.LBB28>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byI8(int16_t multiplicand, int8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    60cc:	66d8 1116 	lod	YL, 0x1116 <_calib_lvi+0x4>

000060d0 <.L13>:
    60d0:	5ce6      	ssex	Y

000060d2 <.LM20>:

    __asm__ __volatile__ (
    60d2:	72ee      	lod	A, X

000060d4 <.LVL10>:
    60d4:	4811      	muls	D, A, Y
    60d6:	5880      	mov	[S-4], D

000060d8 <.LBE30>:
    {
        gain = (int16_t)(mulI24_I16byI8(temp_diff, cal_data->gain_low_t) / 128);
    }
    else
    {
        gain = (int16_t)(mulI24_I16byI8(temp_diff, cal_data->gain_high_t) / 128);
    60d8:	4caa 0000 	cmpu	D, #0
    60dc:	1e83      	jsge	0x60e4 <.L10>

000060de <.LVL11>:
    60de:	4c0a 007f 	addu	D, #127
    60e2:	5880      	mov	[S-4], D

000060e4 <.L10>:
    60e4:	58e0      	mov	YA, [S-4]

000060e6 <.LVL12>:
    60e6:	48b6      	asr	YA, #7

000060e8 <.LBB33>:
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI32_I16byI16(int16_t multiplicand, int16_t multiplier)
{
    int32_t result;

    __asm__ __volatile__ (
    60e8:	7e05      	lod	X, [S-6]

000060ea <.LVL14>:
    60ea:	4833      	muls	YA, A, X

000060ec <.LBE33>:
    }

    return (u16ADC_Value + (mulI32_I16byI16(gain, u16ADC_Value) / 2048));
    60ec:	4cb2 0000 	cmp	YA, #0
    60f0:	0000 
    60f2:	1e84      	jsge	0x60fc <.L11>
    60f4:	4cc0      	mov	D, YA
    60f6:	4c0a 07ff 	addu	D, #2047
    60fa:	4c80      	mov	YA, D

000060fc <.L11>:
    60fc:	48ba      	asr	YA, #11
    60fe:	a205      	add	A, [S-6]

00006100 <.LBE26>:
}
    6100:	5407      	ret	#8

00006102 <.L7>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byI8(int16_t multiplicand, int8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    6102:	66d8 1117 	lod	YL, 0x1117 <_calib_lvi+0x5>
    6106:	07e4      	jmp	0x60d0 <.L13>

00006108 <_conv_motor_voltage_init>:
calib_data_t calib_vsm;
/** VSM filtered calibration data */
calib_data_t calib_vsmf;

void conv_motor_voltage_init(void)
{
    6108:	5805      	inc	S, #6

0000610a <.LCFI0>:
#if defined(EE_O_HVI_GET)
    calib_vsm.simple.offset = EE_GET(O_HVI);
    610a:	72d8 09d4 	lod	A, 0x9d4 <.Ldebug_line0>
    610e:	7ae2      	lod	Y, A
    6110:	66ec      	lod	YL, YH
    6112:	5ce6      	ssex	Y
    6114:	5a03      	mov	[S-4], Y
    6116:	5ad8 111e 	mov	0x111e <_calib_vsm>, Y
    611a:	d400      	and	AH, #0

0000611c <.LM3>:
    calib_vsm.simple.gain = EE_GET(GAIN_VSMF);
    611c:	52d8 1120 	mov	0x1120 <_calib_vsm+0x2>, A

00006120 <.LM4>:
    calib_vsm.gain_low_t = EE_GET(GAINLO_VSMF);
    6120:	66d8 09e2 	lod	YL, 0x9e2 <.Ldebug_abbrev0+0x7>
    6124:	5ce6      	ssex	Y
    6126:	5a05      	mov	[S-6], Y
    6128:	46d8 1122 	mov	0x1122 <_calib_vsm+0x4>, YL

0000612c <.LM5>:
    calib_vsm.gain_high_t = EE_GET(GAINHI_VSMF);
    612c:	7ad8 09e2 	lod	Y, 0x9e2 <.Ldebug_abbrev0+0x7>
    6130:	66ec      	lod	YL, YH
    6132:	5ce6      	ssex	Y
    6134:	5a01      	mov	[S-2], Y
    6136:	46d8 1123 	mov	0x1123 <_calib_vsm+0x5>, YL

0000613a <.LM6>:
    calib_vsm.simple.gain = EE_GET(VSM_GAIN);
    calib_vsm.gain_low_t = 0;
    calib_vsm.gain_high_t = 0;
#endif

    if (calib_vsm.simple.gain == 0u)
    613a:	ac00      	cmp	A, #0
    613c:	1d04      	jne	0x6146 <.L2>

0000613e <.LM7>:
    {
        /* gain 0 is not allowed, use the default value */
        calib_vsm.simple.gain = 164u;               /* 2.5V * 21 * 100 * HVI_GAIN_DIV / 1023 */
    613e:	7eda 00a4 	lod	X, #164
    6142:	5ed8 1120 	mov	0x1120 <_calib_vsm+0x2>, X

00006146 <.L2>:
    }

#if defined(EE_O_HVI_GET)
    calib_vsmf.simple.offset = EE_GET(O_HVI) + EE_GET(O_VSMF);
    6146:	7ed8 09d8 	lod	X, 0x9d8 <.Ldebug_line0+0x4>
    614a:	54e4      	mov	Cx, #4
    614c:	44fe      	asr	X, #2
    614e:	1ffe      	djnz	Cx, 0x614c <.L2+0x6>
    6150:	2203      	add	X, [S-4]
    6152:	5ed8 1118 	mov	0x1118 <_calib_vsmf>, X

00006156 <.LM9>:
    calib_vsmf.simple.gain = EE_GET(GAIN_VSMF);
    6156:	52d8 111a 	mov	0x111a <_calib_vsmf+0x2>, A

0000615a <.LM10>:
    calib_vsmf.gain_low_t = EE_GET(GAINLO_VSMF);
    615a:	6605      	lod	YL, [S-6]
    615c:	46d8 111c 	mov	0x111c <_calib_vsmf+0x4>, YL

00006160 <.LM11>:
    calib_vsmf.gain_high_t = EE_GET(GAINHI_VSMF);
    6160:	6601      	lod	YL, [S-2]
    6162:	46d8 111d 	mov	0x111d <_calib_vsmf+0x5>, YL

00006166 <.LM12>:
    calib_vsmf.simple.gain = EE_GET(VSM_FILT_GAIN);
    calib_vsmf.gain_low_t = 0;
    calib_vsmf.gain_high_t = 0;
#endif

    if (calib_vsmf.simple.gain == 0u)
    6166:	ac00      	cmp	A, #0
    6168:	1d04      	jne	0x6172 <.L1>

0000616a <.LM13>:
    {
        /* gain 0 is not allowed, use the default value */
        calib_vsmf.simple.gain = 164u;              /* 2.5V * 21 * 100 * HVI_GAIN_DIV / 1023 */
    616a:	72da 00a4 	lod	A, #164
    616e:	52d8 111a 	mov	0x111a <_calib_vsmf+0x2>, A

00006172 <.L1>:
    }
}
    6172:	5407      	ret	#8

00006174 <_conv_motor_voltage_filtered>:
 * @return  updated measurement.
 */
STATIC INLINE int16_t apply_offset_gain(uint16_t u16ADC_Value, simple_calib_data_t * cal_data, uint8_t divider)
{
    int16_t measurement = (int16_t)u16ADC_Value;
    measurement -= cal_data->offset;
    6174:	aad8 1118 	sub	A, 0x1118 <_calib_vsmf>

00006178 <.LBB54>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byU8(int16_t multiplicand, uint8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    6178:	7ed8 111a 	lod	X, 0x111a <_calib_vsmf+0x2>
    617c:	36da 00ff 	and	X, #255

00006180 <.LM35>:

    __asm__ __volatile__ (
    6180:	4833      	muls	YA, A, X

00006182 <.LBE54>:
    measurement = (int16_t)(mulI24_I16byU8(measurement, cal_data->gain) / divider);
    6182:	4cb2 0000 	cmp	YA, #0
    6186:	0000 
    6188:	1e84      	jsge	0x6192 <.L16>
    618a:	4cc0      	mov	D, YA
    618c:	4c0a 001f 	addu	D, #31
    6190:	4c80      	mov	YA, D

00006192 <.L16>:
    6192:	48b4      	asr	YA, #5

00006194 <.LBE52>:

int16_t conv_motor_voltage_filtered(uint16_t u16ADC_Value)
{
    /* cVSMF = (mVSMF - O_HVI_EE - O_VSMF_EE) * Gain_VSMF_EE / 2^5 */
    return apply_offset_gain(u16ADC_Value, &calib_vsmf.simple, HVI_GAIN_DIV);
}
    6194:	5401      	ret

00006196 <_conv_motor_voltage_filtered_with_tcorrection>:

    return u16ADC_Value;
}

int16_t conv_motor_voltage_filtered_with_tcorrection(uint16_t u16ADC_Value, uint16_t u16ADC_Temp)
{
    6196:	5805      	inc	S, #6

00006198 <.LCFI2>:
     * }else{
     *     tempGain = ((GainHi_VSMF_EE / 2^11) * mTempDiff)/2^7;
     * }
     * cVSMFcorr = cVSMF * (1 + tempGain)
     */
    return apply_temp_gain(conv_motor_voltage_filtered(u16ADC_Value), u16ADC_Temp, &calib_vsmf);
    6198:	17ed      	call	0x6174 <_conv_motor_voltage_filtered>

0000619a <.LVL26>:
    619a:	5205      	mov	[S-6], A

0000619c <.LBB58>:
 * @return  updated measurement.
 */
STATIC INLINE int16_t apply_temp_gain(uint16_t u16ADC_Value, uint16_t u16ADC_Temp, calib_data_t * cal_data)
{
    int16_t gain;
    int16_t temp_diff = (int16_t)(u16ADC_Temp - EE_GET(OTEMPCAL));
    619c:	7e09      	lod	X, [S-10]
    619e:	2ad8 09b4 	sub	X, 0x9b4 <.LASF2082+0xa>

000061a2 <.LM46>:

    if (temp_diff > 0)
    61a2:	2c00      	cmp	X, #0
    61a4:	1b1b      	jsle	0x61dc <.L19>

000061a6 <.LBB60>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byI8(int16_t multiplicand, int8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    61a6:	66d8 111c 	lod	YL, 0x111c <_calib_vsmf+0x4>

000061aa <.L25>:
    61aa:	5ce6      	ssex	Y

000061ac <.LM48>:

    __asm__ __volatile__ (
    61ac:	72ee      	lod	A, X

000061ae <.LVL31>:
    61ae:	4811      	muls	D, A, Y
    61b0:	5880      	mov	[S-4], D

000061b2 <.LBE62>:
    {
        gain = (int16_t)(mulI24_I16byI8(temp_diff, cal_data->gain_low_t) / 128);
    }
    else
    {
        gain = (int16_t)(mulI24_I16byI8(temp_diff, cal_data->gain_high_t) / 128);
    61b2:	4caa 0000 	cmpu	D, #0
    61b6:	1e83      	jsge	0x61be <.L22>

000061b8 <.LVL32>:
    61b8:	4c0a 007f 	addu	D, #127
    61bc:	5880      	mov	[S-4], D

000061be <.L22>:
    61be:	58e0      	mov	YA, [S-4]

000061c0 <.LVL33>:
    61c0:	48b6      	asr	YA, #7

000061c2 <.LBB65>:
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI32_I16byI16(int16_t multiplicand, int16_t multiplier)
{
    int32_t result;

    __asm__ __volatile__ (
    61c2:	7e05      	lod	X, [S-6]

000061c4 <.LVL35>:
    61c4:	4833      	muls	YA, A, X

000061c6 <.LBE65>:
    }

    return (u16ADC_Value + (mulI32_I16byI16(gain, u16ADC_Value) / 2048));
    61c6:	4cb2 0000 	cmp	YA, #0
    61ca:	0000 
    61cc:	1e84      	jsge	0x61d6 <.L23>
    61ce:	4cc0      	mov	D, YA
    61d0:	4c0a 07ff 	addu	D, #2047
    61d4:	4c80      	mov	YA, D

000061d6 <.L23>:
    61d6:	48ba      	asr	YA, #11
    61d8:	a205      	add	A, [S-6]

000061da <.LBE58>:
}
    61da:	5407      	ret	#8

000061dc <.L19>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byI8(int16_t multiplicand, int8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    61dc:	66d8 111d 	lod	YL, 0x111d <_calib_vsmf+0x5>
    61e0:	07e4      	jmp	0x61aa <.L25>

000061e2 <_conv_shunt_current_init>:
calib_data_t calib_current;

void conv_shunt_current_init(void)
{
#if defined(EE_O_CURR_GET)
    calib_current.simple.offset = EE_GET(O_CURR) + 512;
    61e2:	72d8 09dc 	lod	A, 0x9dc <.Ldebug_abbrev0+0x1>
    61e6:	7ee2      	lod	X, A
    61e8:	54e4      	mov	Cx, #4
    61ea:	44fe      	asr	X, #2
    61ec:	1ffe      	djnz	Cx, 0x61ea <.LASF1880+0x5>
    61ee:	22da 0200 	add	X, #512
    61f2:	5ed8 1124 	mov	0x1124 <_calib_current>, X

000061f6 <.LM3>:
    calib_current.simple.gain = EE_GET(GAIN_CURR);
    61f6:	d400      	and	AH, #0
    61f8:	52d8 1126 	mov	0x1126 <_calib_current+0x2>, A

000061fc <.LM4>:
    calib_current.gain_low_t = EE_GET(GAINLO_CURR);
    61fc:	72d8 09e0 	lod	A, 0x9e0 <.Ldebug_abbrev0+0x5>
    6200:	42d8 1128 	mov	0x1128 <_calib_current+0x4>, AL

00006204 <.LM5>:
    calib_current.gain_high_t = EE_GET(GAINHI_CURR);
    6204:	0ea7      	lod	C, ML.7
    6206:	4ad8 2911 	mov	0x1129 <_calib_current+0x5>, AH

0000620a <.LM6>:
    calib_current.simple.offset = EE_GET(CURR_OFFS) + 512;
    calib_current.simple.gain = EE_GET(CURR_GAIN);
    calib_current.gain_low_t = 0;
    calib_current.gain_high_t = 0;
#endif
}
    620a:	5401      	ret

0000620c <_conv_shunt_current>:
 * @return  updated measurement.
 */
STATIC INLINE int16_t apply_offset_gain(uint16_t u16ADC_Value, simple_calib_data_t * cal_data, uint8_t divider)
{
    int16_t measurement = (int16_t)u16ADC_Value;
    measurement -= cal_data->offset;
    620c:	aad8 1124 	sub	A, 0x1124 <_calib_current>

00006210 <.LBB16>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byU8(int16_t multiplicand, uint8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    6210:	7ed8 1126 	lod	X, 0x1126 <_calib_current+0x2>
    6214:	36da 00ff 	and	X, #255

00006218 <.LM10>:

    __asm__ __volatile__ (
    6218:	4833      	muls	YA, A, X

0000621a <.LBE16>:
    measurement = (int16_t)(mulI24_I16byU8(measurement, cal_data->gain) / divider);
    621a:	4cb2 0000 	cmp	YA, #0
    621e:	0000 
    6220:	1e84      	jsge	0x622a <.L4>
    6222:	4cc0      	mov	D, YA
    6224:	4c0a 003f 	addu	D, #63
    6228:	4c80      	mov	YA, D

0000622a <.L4>:
    622a:	48b5      	asr	YA, #6

0000622c <.LBE14>:
{
    /* MLX81330: cCur = (mCur - (O_Curr_EE + 512)) * Gain_Curr_EE / 2^6
     * MLX81332: cCur = (mCur - (O_Curr_EE + 512)) * Gain_Curr_EE / 2^5
     */
    return apply_offset_gain(u16ADC_Value, &calib_current.simple, CURR_GAIN_DIV);
}
    622c:	5401      	ret

0000622e <_diagnostic_Init>:
void diagnostic_Init(void)
{
    /* Disable hardware protection for over-temperature, under-voltage
     * Hardware protection is enabled in case of OC, VDS(LS), VDS(HS), OV_VS, OVT
     */
    IO_SET(PORT_DRV1_PROT, DIS_UV_VDDA, 1u, DIS_UV_VDDAF, 1u, DIS_UV_VS, 1u);
    622e:	72d8 0218 	lod	A, 0x218 <_PORT_DRV1_PROT>
    6232:	a6da 02a0 	or	A, #672
    6236:	52d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, A

0000623a <.LM5>:

    /*
     * Connect the phase to GND in case of VDS(HS),
     */
    IO_SET(PORT_DRV1_PROT,
    623a:	0ea7      	lod	C, ML.7
    623c:	72d8 0218 	lod	A, 0x218 <_PORT_DRV1_PROT>
    6240:	b6da abfa 	and	A, #44026
    6244:	c404      	or	AH, #4
    6246:	52d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, A

0000624a <.LM6>:
           0,  /* high */
           OC_PM,
           PROTECTION_MODE_TRISTATE);

    /* Set/enable UV & OV debounce circuitry */
    IO_SET(PORT_SUPP_CFG, UV_VS_FILT_SEL, 1u);  /* 0 : 1-2us filtering, 1 : 100-110us filtering */
    624a:	62d8 01e4 	lod	AL, 0x1e4 <_PORT_SUPP_CFG>
    624e:	8408      	or	AL, #8
    6250:	42d8 01e4 	mov	0x1e4 <_PORT_SUPP_CFG>, AL

00006254 <.LM7>:
    IO_SET(PORT_SUPP_CFG, OV_VS_FILT_SEL, 0u);  /* 0 : 1-2us filtering, 1 : 100-110us filtering */
    6254:	62d8 01e4 	lod	AL, 0x1e4 <_PORT_SUPP_CFG>
    6258:	94ef      	and	AL, #-17
    625a:	42d8 01e4 	mov	0x1e4 <_PORT_SUPP_CFG>, AL

0000625e <.LM8>:

    /* Under/Over voltage detection levels */
    IO_SET(PORT_MISC_OUT, PRUV_VS, vsuv6V);
    625e:	72d8 01f2 	lod	A, 0x1f2 <_PORT_MISC_OUT>
    6262:	b6da fe3f 	and	A, #65087
    6266:	8480      	or	AL, #-128
    6268:	52d8 01f2 	mov	0x1f2 <_PORT_MISC_OUT>, A

0000626c <.LM9>:
    IO_SET(PORT_MISC_OUT, PROV_VS, vsov22V);
    626c:	72d8 01f2 	lod	A, 0x1f2 <_PORT_MISC_OUT>
    6270:	d4f9      	and	AH, #-7
    6272:	52d8 01f2 	mov	0x1f2 <_PORT_MISC_OUT>, A

00006276 <.LM10>:
			STEP2_INC , 1U) ; 	/* STEP_INC = 1 */
    IO_SET (PORT_SSCM2_CONF , SSCM2_EN , 1u ) ; /* Enable the spread spectrum modulation */
#endif
    // VDDA output voltage level
    // Default : 3.3V output
    IO_SET(PORT_MISC_OUT, SWITCH_VDDA_TO_5V, 1u);            /* 5V output*/
    6276:	62d8 01f2 	lod	AL, 0x1f2 <_PORT_MISC_OUT>
    627a:	8420      	or	AL, #32
    627c:	42d8 01f2 	mov	0x1f2 <_PORT_MISC_OUT>, AL

00006280 <.LM11>:

    /* Enable UV-VS interrupt */
    Itc_Enable(UV_VS);
    6280:	62d8 006c 	lod	AL, 0x6c <.LASF730+0xd>
    6284:	8480      	or	AL, #-128
    6286:	42d8 006c 	mov	0x6c <.LASF730+0xd>, AL

0000628a <.LM12>:

    g_bDiagnosticInitialized = true;
    628a:	6001      	lod	AL, #1
    628c:	42d8 105e 	mov	0x105e <_g_bDiagnosticInitialized>, AL

00006290 <.LM13>:
}
    6290:	5401      	ret

00006292 <_diagnostic_IsUVPending>:
 */
bool diagnostic_IsUVPending(void)
{
    bool bRetVal;

    bRetVal = IO_GET(PORT_SUPP_IN, UV_VS_IT) ? true : false;
    6292:	72d8 01e0 	lod	A, 0x1e0 <_PORT_SUPP_IN>
    6296:	b404      	and	A, #4
    6298:	5cae      	sne	X

0000629a <.LM36>:

    /* Re-enable interrupt when voltage is above threshold */
    if (!bRetVal)
    629a:	ac00      	cmp	A, #0
    629c:	1d08      	jne	0x62ae <.L6>

0000629e <.LBB85>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    629e:	7ae3      	lod	Y, M

000062a0 <.LBB88>:
    62a0:	503d      	call	fp1:0xE8

000062a2 <.LBE88>:
    {
        ENTER_SECTION(ATOMIC_SYSTEM_MODE);
        Itc_Enable(UV_VS);
    62a2:	62d8 006c 	lod	AL, 0x6c <.LASF730+0xd>
    62a6:	8480      	or	AL, #-128
    62a8:	42d8 006c 	mov	0x6c <.LASF730+0xd>, AL

000062ac <.LBB90>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    62ac:	5ae3      	mov	M, Y

000062ae <.L6>:
        EXIT_SECTION();
    }

    return bRetVal;
}
    62ae:	72ee      	lod	A, X
    62b0:	5401      	ret

000062b2 <_diagnostic_IsOVPending>:
 */
bool diagnostic_IsOVPending(void)
{
    bool bRetVal;

    bRetVal = IO_GET(PORT_DIAG_IN, OV_VS_MEM) ? true : false;
    62b2:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>
    62b6:	b402      	and	A, #2
    62b8:	5cae      	sne	X

000062ba <.LM44>:

    if (bRetVal)
    62ba:	ac00      	cmp	A, #0
    62bc:	190a      	je	0x62d2 <.L8>

000062be <.LM45>:
    {
        IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 1u);  /* clear MEM flag */
    62be:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    62c2:	8408      	or	AL, #8
    62c4:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

000062c8 <.LM46>:
        IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 0u);  /* re-enable hardware protection */
    62c8:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    62cc:	94f7      	and	AL, #-9
    62ce:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

000062d2 <.L8>:
    }

    return bRetVal;
}
    62d2:	72ee      	lod	A, X
    62d4:	5401      	ret

000062d6 <_diagnostic_IsOVTPending>:
 */
bool diagnostic_IsOVTPending(void)
{
    bool bRetVal;

    bRetVal = IO_GET(PORT_DIAG_IN, OVT_MEM) ? true : false;
    62d6:	7ed8 021e 	lod	X, 0x21e <_PORT_DIAG_IN>

000062da <.LM50>:

    if (bRetVal)
    62da:	3401      	and	X, #1
    62dc:	190a      	je	0x62f2 <.L13>

000062de <.LM51>:
    {
        IO_SET(PORT_DRV1_PROT, DIS_OVT, 1u);  /* clear MEM flag */
    62de:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    62e2:	8402      	or	AL, #2
    62e4:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

000062e8 <.LM52>:
        IO_SET(PORT_DRV1_PROT, DIS_OVT, 0u);  /* re-enable hardware protection */
    62e8:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    62ec:	94fd      	and	AL, #-3
    62ee:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

000062f2 <.L13>:
    }

    return bRetVal;
}
    62f2:	72ee      	lod	A, X
    62f4:	5401      	ret

000062f6 <_diagnostic_IsOVCPending>:
 */
bool diagnostic_IsOVCPending(void)
{
    bool bRetVal;

    bRetVal = IO_GET(PORT_DIAG_IN, OVC_MEM) ? true : false;
    62f6:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>

000062fa <.LM56>:

    return bRetVal;
    62fa:	9420      	and	AL, #32
    62fc:	5ca2      	sne	A

000062fe <.LM57>:
}
    62fe:	5401      	ret

00006300 <_diagnostic_IsVDSPending>:
 */
bool diagnostic_IsVDSPending(void)
{
    bool bRetVal;

    bRetVal = (IO_GET(PORT_DIAG_IN, OV_HS_VDS_MEM) || IO_GET(PORT_DIAG_IN, OV_LS_VDS_MEM)) ? true : false;
    6300:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>
    6304:	b6da 03c0 	and	A, #960
    6308:	1d06      	jne	0x6316 <.L20>

0000630a <.LM60>:
    630a:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>
    630e:	b6da 3c00 	and	A, #15360
    6312:	5ca2      	sne	A
    6314:	5401      	ret

00006316 <.L20>:
    6316:	7001      	lod	A, #1

00006318 <.LM62>:

    return bRetVal;
}
    6318:	5401      	ret

0000631a <__UV_VS_INT>:

/**
 * Under voltage interrupt
 */
INTERRUPT void _UV_VS_INT(void)
{
    631a:	5edf      	push	X

0000631c <.LCFI0>:
    631c:	5adf      	push	Y

0000631e <.LCFI1>:
    631e:	52df      	push	A

00006320 <.LCFI2>:
    6320:	4c83      	push	D

00006322 <.LCFI3>:
    /* Disable the interrupt, otherwise the interrupt will be called continuously */
    Itc_Disable(UV_VS);
    6322:	62d8 006c 	lod	AL, 0x6c <.LASF730+0xd>
    6326:	947f      	and	AL, #127
    6328:	42d8 006c 	mov	0x6c <.LASF730+0xd>, AL

0000632c <.LM65>:

    /* Call application callback (save data to EEPROM, log error, etc) */
    EVENT_UnderVoltage();
    632c:	82db 3b69 	callf	0x76d2 <_EVENT_UnderVoltage>

00006330 <.LM66>:
}
    6330:	4cc3      	pop	D

00006332 <.LCFI4>:
    6332:	72cf      	pop	A

00006334 <.LCFI5>:
    6334:	7acf      	pop	Y

00006336 <.LCFI6>:
    6336:	7ecf      	pop	X

00006338 <.LCFI7>:
    6338:	72cb      	pop	M
    633a:	5401      	ret

0000633c <_eeprom_Init>:

/**
 * Module initialization
 */
bool eeprom_Init(void)
{
    633c:	5801      	inc	S, #2

0000633e <.LCFI0>:
    bool retval = true;

    unirom_Init();
    633e:	82db 4008 	callf	0x8010 <_unirom_Init>

00006342 <.LM3>:

    if (!unirom_LoadUserConfig())
    6342:	82db 4009 	callf	0x8012 <_unirom_LoadUserConfig>
    6346:	7ae2      	lod	Y, A
    6348:	1d06      	jne	0x6356 <.L2>

0000634a <.LM4>:
    {
        (void)unirom_ResetUserConfig(&eeprom_defaults);
    634a:	72da 5b15 	lod	A, #23317
    634e:	5a01      	mov	[S-2], Y
    6350:	82db 4090 	callf	0x8120 <_unirom_ResetUserConfig>
    6354:	7a01      	lod	Y, [S-2]

00006356 <.L2>:

        retval = false;
    }

    return retval;
}
    6356:	72e6      	lod	A, Y
    6358:	5403      	ret	#4

0000635a <_eeprom_ReadLINconfig>:
 * @param[in]  length  the number of configuration words to read
 * @retval  true  valid configuration found in eeprom.
 * @retval  false  otherwise.
 */
bool eeprom_ReadLINconfig(uint8_t * config, uint8_t length)
{
    635a:	6603      	lod	YL, [S-4]
    635c:	5cf6      	usex	Y

0000635e <.LM7>:
    bool retval = false;

    retval = unirom_ReadPage(0u, config, length);
    635e:	5adf      	push	Y

00006360 <.LCFI1>:
    6360:	52df      	push	A

00006362 <.LCFI2>:
    6362:	7000      	lod	A, #0

00006364 <.LVL7>:
    6364:	82db 40da 	callf	0x81b4 <_unirom_ReadPage>

00006368 <.LCFI3>:

    return retval;
}
    6368:	5405      	ret	#6

0000636a <_eeprom_StoreLINconfig>:
 * @param[in]  length  the number of configuration words to store
 * @retval  true  the configuration is correctly stored
 * @retval  false  otherwise
 */
bool eeprom_StoreLINconfig(uint8_t * config, uint8_t length)
{
    636a:	6603      	lod	YL, [S-4]
    636c:	5cf6      	usex	Y

0000636e <.LM11>:
    bool retval = false;

    if (length <= 7)
    636e:	ec07      	cmp	Y, #7
    6370:	1e09      	jug	0x6384 <.L6>

00006372 <.LM12>:
    {
        (void)unirom_WritePage(0u, config, length);
    6372:	5adf      	push	Y

00006374 <.LCFI4>:
    6374:	52df      	push	A

00006376 <.LCFI5>:
    6376:	7000      	lod	A, #0

00006378 <.LVL11>:
    6378:	82db 40a0 	callf	0x8140 <_unirom_WritePage>

0000637c <.LM13>:

        (void)unirom_StoreUserConfig();
    637c:	82db 404f 	callf	0x809e <_unirom_StoreUserConfig>

00006380 <.LM14>:

        retval = true;
    6380:	7001      	lod	A, #1

00006382 <.LCFI6>:
    6382:	5405      	ret	#6

00006384 <.L6>:
 * @retval  true  the configuration is correctly stored
 * @retval  false  otherwise
 */
bool eeprom_StoreLINconfig(uint8_t * config, uint8_t length)
{
    bool retval = false;
    6384:	7000      	lod	A, #0

00006386 <.LM16>:

        retval = true;
    }

    return retval;
}
    6386:	5401      	ret

00006388 <_Generic_INT>:
}

#ifndef HAS_SW_EXPLICIT_FAIL_INFO
/* Generic interrupt handler */
WEAK_INTERRUPT void Generic_INT(void)
{
    6388:	5edf      	push	X

0000638a <.LCFI0>:
    638a:	5adf      	push	Y

0000638c <.LCFI1>:
    638c:	52df      	push	A

0000638e <.LCFI2>:
    638e:	4c83      	push	D

00006390 <.LBB8>:
}

STATIC INLINE void ErrH_FatalInformed(ErrH_Identifier information)
{
    UNUSED(information);
    _fatal();
    6390:	82db 1a05 	callf	0x340a <__fatal>

00006394 <_fw_mls_ErrorDetected>:

    plinEventTable->ldt_ErrorDetected = fw_mls_ErrorDetected;
}

void fw_mls_ErrorDetected(ml_LinError_t error)
{
    6394:	5803      	inc	S, #4

00006396 <.LCFI0>:
    6396:	5203      	mov	[S-4], A

00006398 <.LBB76>:
    for (uint8_t cnt = 0; cnt < ld_ErrorDetectedMultipleHandler.eventsCount; cnt++) {
    6398:	62d8 11cf 	lod	AL, 0x11cf <.LASF908+0x2>

0000639c <.LVL2>:
    639c:	1915      	je	0x63c8 <.L1>
    639e:	7000      	lod	A, #0
    63a0:	5201      	mov	[S-2], A

000063a2 <.L3>:
        ld_ErrorDetectedMultipleHandler.eventHandlerBuffer[cnt](error);
    63a2:	7201      	lod	A, [S-2]
    63a4:	4422      	asl	A
    63a6:	7ed8 11cc 	lod	X, 0x11cc <_ld_ErrorDetectedMultipleHandler>
    63aa:	22e2      	add	X, A
    63ac:	7203      	lod	A, [S-4]
    63ae:	7af8      	lod	Y, [X]
    63b0:	0001      	jmp	0x63b4 <.L9>

000063b2 <.L8>:
    63b2:	76e6      	jmp	Y

000063b4 <.L9>:
    63b4:	17fe      	call	0x63b2 <.L8>

000063b6 <.LM4>:
    plinEventTable->ldt_ErrorDetected = fw_mls_ErrorDetected;
}

void fw_mls_ErrorDetected(ml_LinError_t error)
{
    for (uint8_t cnt = 0; cnt < ld_ErrorDetectedMultipleHandler.eventsCount; cnt++) {
    63b6:	6201      	lod	AL, [S-2]
    63b8:	8001      	add	AL, #1
    63ba:	66e0      	lod	YL, AL

000063bc <.LVL5>:
    63bc:	5cf2      	usex	A

000063be <.LVL6>:
    63be:	5201      	mov	[S-2], A
    63c0:	62d8 11cf 	lod	AL, 0x11cf <.LASF908+0x2>
    63c4:	8ee8      	cmp	AL, YL
    63c6:	1e6d      	jug	0x63a2 <.L3>

000063c8 <.L1>:
        ld_ErrorDetectedMultipleHandler.eventHandlerBuffer[cnt](error);
    }
}
    63c8:	5405      	ret	#6

000063ca <_fw_mls_Init>:
#include "io.h"

/** Set the MLX4 clock divider on top of MLX16 clock */
STATIC INLINE void mls_SetMlx4ClockDivider(void)
{
    IO_SET(COLIN, SPEED, (uint16_t)LIN_CLK_DIV);
    63ca:	62d8 01bc 	lod	AL, 0x1bc <.LLST12>
    63ce:	94f8      	and	AL, #-8
    63d0:	42d8 01bc 	mov	0x1bc <.LLST12>, AL

000063d4 <.LBE77>:

void fw_mls_Init(void)
{
    mls_SetMlx4ClockDivider();
#if ML_HAS_LIN_EVENT_TABLE_IN_RAM == 0
    ml_InitLinEventTable(&fwlinEventTable);
    63d4:	72da 1078 	lod	A, #4216
    63d8:	82db 1fa7 	callf	0x3f4e <_ml_InitLinEventTable>

000063dc <.LM9>:
#endif /* ML_HAS_LIN_EVENT_TABLE_IN_RAM == 0 */

    /* Initialize LIN TL */
    ld_RequestMultipleHandler.eventHandlerBuffer = ld_RequestMHBuffer;
    63dc:	72da 1072 	lod	A, #4210
    63e0:	0ea7      	lod	C, ML.7
    63e2:	52d8 11c4 	mov	0x11c4 <_ld_RequestMultipleHandler>, A

000063e6 <.LM10>:
    ld_RequestMultipleHandler.eventsMaxLength = MLS_TL_MAX_NUMBER_OF_SUBSCRIBERS;
    63e6:	7003      	lod	A, #3
    63e8:	52d8 11c6 	mov	0x11c6 <.LLST8>, A

000063ec <.LM11>:
    ld_RequestMultipleHandler.eventsCount = 0u;
    ld_ResponseTransmittedMultipleHandler.eventHandlerBuffer = ld_ResponseTransmittedMHBuffer;
    63ec:	0ea7      	lod	C, ML.7
    63ee:	7eda 106c 	lod	X, #4204
    63f2:	5ed8 11c0 	mov	0x11c0 <_ld_ResponseTransmittedMultipleHandler>, X

000063f6 <.LM12>:
    ld_ResponseTransmittedMultipleHandler.eventsMaxLength = MLS_TL_MAX_NUMBER_OF_SUBSCRIBERS;
    63f6:	52d8 11c2 	mov	0x11c2 <_ld_ResponseTransmittedMultipleHandler+0x2>, A

000063fa <.LM13>:
    ld_ResponseTransmittedMultipleHandler.eventsCount = 0u;
    ld_FunctionalRequestMultipleHandler.eventHandlerBuffer = ld_FunctionalRequestMHBuffer;
    63fa:	0ea7      	lod	C, ML.7
    63fc:	7eda 1066 	lod	X, #4198
    6400:	5ed8 11c8 	mov	0x11c8 <_ld_FunctionalRequestMultipleHandler>, X

00006404 <.LM14>:
    ld_FunctionalRequestMultipleHandler.eventsMaxLength = MLS_TL_MAX_NUMBER_OF_SUBSCRIBERS;
    6404:	52d8 11ca 	mov	0x11ca <_ld_FunctionalRequestMultipleHandler+0x2>, A

00006408 <.LM15>:
    ld_FunctionalRequestMultipleHandler.eventsCount = 0u;
    ld_ErrorDetectedMultipleHandler.eventHandlerBuffer = ld_ErrorDetectedMHBuffer;
    6408:	0ea7      	lod	C, ML.7
    640a:	7eda 1060 	lod	X, #4192
    640e:	5ed8 11cc 	mov	0x11cc <_ld_ErrorDetectedMultipleHandler>, X

00006412 <.LM16>:
    ld_ErrorDetectedMultipleHandler.eventsMaxLength = MLS_TL_MAX_NUMBER_OF_SUBSCRIBERS;
    6412:	52d8 11ce 	mov	0x11ce <.LASF908+0x1>, A

00006416 <.LM17>:
    ld_ErrorDetectedMultipleHandler.eventsCount = 0u;

    Itc_Clear(COLIN_LIN);
    6416:	0ea7      	lod	C, ML.7
    6418:	6002      	lod	AL, #2
    641a:	42d8 0055 	mov	0x55 <.LLST24+0x3>, AL

0000641e <.LM18>:
    Itc_SetPrio(COLIN_LIN, MLS_IRQ_PRIO);
    641e:	62d8 008d 	lod	AL, 0x8d <.LASF1440+0x1>
    6422:	94f3      	and	AL, #-13
    6424:	8408      	or	AL, #8
    6426:	42d8 008d 	mov	0x8d <.LASF1440+0x1>, AL

0000642a <.LM19>:
    Itc_Enable(COLIN_LIN);
    642a:	62d8 0071 	lod	AL, 0x71 <.LASF730+0x12>
    642e:	8402      	or	AL, #2
    6430:	42d8 0071 	mov	0x71 <.LASF730+0x12>, AL

00006434 <.LM20>:
}
    6434:	5401      	ret

00006436 <_fw_mls_TransportLayerInit>:

void fw_mls_TransportLayerInit(void)
{
    ldt_Init(&ldt_TL_data,
    6436:	54ca 11c8 	pushw	#4552

0000643a <.LCFI1>:
    643a:	54ca 11c0 	pushw	#4544

0000643e <.LCFI2>:
    643e:	54ca 11c4 	pushw	#4548

00006442 <.LCFI3>:
    6442:	0ea7      	lod	C, ML.7
    6444:	54ca 0000 	pushw	#0

00006448 <.LCFI4>:
    6448:	72da 112a 	lod	A, #4394
    644c:	82db 1e93 	callf	0x3d26 <_ldt_Init>

00006450 <.LM23>:

#if FW_LIN_TL_FUNCTIONAL_NAD_FIX == 1
    (void)ldt_SubscribeMultipleHandler(plinEventTable->ldt_ResponseTransmitted, fw_mls_ldt_CustomResponseTransmitted);
#endif

    plinEventTable->ldt_ErrorDetected = fw_mls_ErrorDetected;
    6450:	7ed8 1002 	lod	X, 0x1002 <_plinEventTable>
    6454:	2016      	add	X, #22
    6456:	72da 31ca 	lod	A, #12746
    645a:	52f8      	mov	[X], A

0000645c <.LCFI5>:
}
    645c:	5409      	ret	#10

0000645e <__COLIN_LIN_INT>:
#endif /* FW_LIN_TL_FUNCTIONAL_NAD_FIX */

/** LIN interrupt handler
 */
__attribute__((interrupt)) void _COLIN_LIN_INT(void)
{
    645e:	5edf      	push	X

00006460 <.LCFI6>:
    6460:	5adf      	push	Y

00006462 <.LCFI7>:
    6462:	52df      	push	A

00006464 <.LCFI8>:
    6464:	4c83      	push	D

00006466 <.LCFI9>:
    ml_LinInterruptHandler();
    6466:	82db 1fbe 	callf	0x3f7c <_ml_LinInterruptHandler>

0000646a <.LM27>:
}
    646a:	4cc3      	pop	D

0000646c <.LCFI10>:
    646c:	72cf      	pop	A

0000646e <.LCFI11>:
    646e:	7acf      	pop	Y

00006470 <.LCFI12>:
    6470:	7ecf      	pop	X

00006472 <.LCFI13>:
    6472:	72cb      	pop	M
    6474:	5401      	ret

00006476 <_fw_lepm_ResponseTransmitted>:
STATIC bool fw_lepm_ResponseTransmitted(LINDiagTransfer_t* transfer)
{
    (void)transfer;

#if HAS_PPM_EPM == 1
    if (lepmFlag == true) {
    6476:	62d8 1096 	lod	AL, 0x1096 <_lepmFlag>

0000647a <.LVL1>:
    647a:	1904      	je	0x6484 <.L2>

0000647c <.LM3>:
        MLX16_RESET_SIGNED((uint16_t)C_CHIP_STATE_PPM_CMD_EPM);
    647c:	72da b065 	lod	A, #45157
    6480:	82db 1468 	callf	0x28d0 <_MLX16_RESET_SIGNED>

00006484 <.L2>:
    6484:	62d8 1097 	lod	AL, 0x1097 <_isAwaitingResponseTransmitted>
    6488:	5cf2      	usex	A

0000648a <.LM4>:
        return true;
    } else {
        /* The event is intended for the next LIN TL subscribers */
        return false;
    }
}
    648a:	5401      	ret

0000648c <_fw_lepm_Init>:
}

void fw_lepm_Init(void)
{
    /* LIN TL */
    (void)ldt_SubscribeMultipleHandler(&ld_RequestMultipleHandler, fw_lepm_Request);
    648c:	54ca 3256 	pushw	#12886

00006490 <.LCFI0>:
    6490:	72da 11c4 	lod	A, #4548
    6494:	82db 1ee8 	callf	0x3dd0 <_ldt_SubscribeMultipleHandler>

00006498 <.LM7>:
    (void)ldt_SubscribeMultipleHandler(&ld_ResponseTransmittedMultipleHandler, fw_lepm_ResponseTransmitted);
    6498:	54ca 323b 	pushw	#12859

0000649c <.LCFI1>:
    649c:	72da 11c0 	lod	A, #4544
    64a0:	82db 1ee8 	callf	0x3dd0 <_ldt_SubscribeMultipleHandler>

000064a4 <.LM8>:

    /* LIN EPM specific */
#if HAS_PPM_EPM == 1
    lepmFlag = false;
    64a4:	6000      	lod	AL, #0
    64a6:	42d8 1096 	mov	0x1096 <_lepmFlag>, AL

000064aa <.LCFI2>:
#endif
}
    64aa:	5405      	ret	#6

000064ac <_fw_lepm_Request>:
    /* Always allow enter programming mode by default */
    return true;
}

STATIC bool fw_lepm_Request(LINDiagTransfer_t* transfer)
{
    64ac:	5807      	inc	S, #8

000064ae <.LCFI3>:
    64ae:	5205      	mov	[S-6], A

000064b0 <.LM13>:
     *   returns PLTF_VERSION + TYPE
     *
     * - Read by ID=LE_MLX_PATCH_ID, LE_MLX_SUPPLIER_ID, LE_MLX_FUNCTION_ID_GET_CHIP_VERSION (no broadcasts supported);
     *   returns patch identification
     */
    if (transfer->request.reqSId == LE_READ_BY_ID_SID) {
    64b0:	7ae2      	lod	Y, A
    64b2:	62f0      	lod	AL, [Y]

000064b4 <.LVL7>:
    64b4:	8cb2      	cmp	AL, #-78
    64b6:	1902      	je	0x64bc <.L6>

000064b8 <.L25>:
    return true;
}

STATIC bool fw_lepm_Request(LINDiagTransfer_t* transfer)
{
    bool isAnswerExpected = false;
    64b8:	7000      	lod	A, #0
    64ba:	0055      	jmp	0x6566 <.L7>

000064bc <.L6>:
     *
     * - Read by ID=LE_MLX_PATCH_ID, LE_MLX_SUPPLIER_ID, LE_MLX_FUNCTION_ID_GET_CHIP_VERSION (no broadcasts supported);
     *   returns patch identification
     */
    if (transfer->request.reqSId == LE_READ_BY_ID_SID) {
        if (transfer->request.dataLen <= LE_MIN_RBI_DATA_LEN) {
    64bc:	7e05      	lod	X, [S-6]
    64be:	72fa      	lod	A, [X+2]
    64c0:	ac05      	cmp	A, #5
    64c2:	1e7a      	jug	0x64b8 <.L25>

000064c4 <.LBB20>:

            fw_lepm_ReadByIdProdIdReq_t* pProdIdReq = (fw_lepm_ReadByIdProdIdReq_t*)transfer->request.data;

            if ((pProdIdReq->supp_id == LE_MLX_SUPPLIER_ID)) {
    64c4:	7aee      	lod	Y, X

000064c6 <.LVL11>:
    64c6:	e005      	add	Y, #5
    64c8:	7ee6      	lod	X, Y
    64ca:	66f8      	lod	YL, [X]
    64cc:	6ef9      	lod	YH, [X+1]
    64ce:	ec13      	cmp	Y, #19
    64d0:	1d73      	jne	0x64b8 <.L25>

000064d2 <.LM17>:
                switch (pProdIdReq->id) {
    64d2:	7a05      	lod	Y, [S-6]
    64d4:	62f4      	lod	AL, [Y+4]
    64d6:	8c34      	cmp	AL, #52
    64d8:	1d01      	jne	0x64dc <.LM17+0xa>
    64da:	0048      	jmp	0x656c <.L9>
    64dc:	66e0      	lod	YL, AL
    64de:	5cf6      	usex	Y
    64e0:	ec35      	cmp	Y, #53
    64e2:	1d01      	jne	0x64e6 <.LASF779+0x8>
    64e4:	005a      	jmp	0x659a <.L10>
    64e6:	ec33      	cmp	Y, #51
    64e8:	1d67      	jne	0x64b8 <.L25>

000064ea <.LM18>:
                    case LE_MLX_SPECIAL_ID:
                        if ((pProdIdReq->func_id == LE_MLX_FUNCTION_ID_GET_CHIP_VERSION)
    64ea:	7a05      	lod	Y, [S-6]
    64ec:	e007      	add	Y, #7
    64ee:	62f0      	lod	AL, [Y]
    64f0:	6af1      	lod	AH, [Y+1]
    64f2:	94bf      	and	AL, #-65
    64f4:	aeda cabc 	cmp	A, #51900
    64f8:	1d17      	jne	0x6528 <.L12>

000064fa <.LBB21>:
}

STATIC void fw_lepm_PrepareProdResponse(LINDiagTransfer_t* transfer)
{
    /* Use Response SID */
    transfer->response.respSId = LE_READ_BY_ID_RSID;
    64fa:	72da 00f2 	lod	A, #242
    64fe:	7e05      	lod	X, [S-6]
    6500:	42f8      	mov	[X], AL

00006502 <.LM20>:
    transfer->response.dataLen = 5u;
    6502:	7005      	lod	A, #5
    6504:	52fa      	mov	[X+2], A

00006506 <.LM21>:

    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_ProdIdRes_t* pDeviceVerRev = (fw_lepm_ProdIdRes_t*)transfer->response.data;
    pDeviceVerRev->prod_id_low = (uint16_t)PRODUCT_VERSION_32;
    6506:	72d8 0a36 	lod	A, 0xa36 <.LASF1477+0x1>
    650a:	6400      	lod	YL, #0
    650c:	42fc      	mov	[X+4], AL
    650e:	4afd      	mov	[X+5], AH

00006510 <.LM22>:
    pDeviceVerRev->prod_id_high = (uint16_t)(PRODUCT_VERSION_32 >> 16);
    6510:	72ee      	lod	A, X
    6512:	a006      	add	A, #6
    6514:	7ee2      	lod	X, A
    6516:	46f8      	mov	[X], YL

00006518 <.LVL15>:
    6518:	46f9      	mov	[X+1], YL

0000651a <.LM23>:
    pDeviceVerRev->reserved = 0xFFu; /* it's reserved */
    651a:	7e05      	lod	X, [S-6]
    651c:	2008      	add	X, #8
    651e:	72da 00ff 	lod	A, #255

00006522 <.L27>:
    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_PltfRevRes_t* pPltfRevResp = (fw_lepm_PltfRevRes_t*)transfer->response.data;
    pPltfRevResp->major = RELEASE_MAJOR;
    pPltfRevResp->minor = RELEASE_MINOR;
    pPltfRevResp->patch = RELEASE_REVISION;
    pPltfRevResp->build = 0x00u;
    6522:	42f8      	mov	[X], AL

00006524 <.L26>:
                    case LE_MLX_PATCH_ID:
                        if ((pProdIdReq->func_id == LE_MLX_FUNCTION_ID_GET_CHIP_VERSION)
                            || (pProdIdReq->func_id ==
                                fw_lepm_GetFuncIdAllModes(LE_MLX_FUNCTION_ID_GET_CHIP_VERSION))) {
                            fw_lepm_PreparePatchRevResponse(transfer);
                            isAnswerExpected = true;
    6524:	7001      	lod	A, #1
    6526:	001f      	jmp	0x6566 <.L7>

00006528 <.L12>:
                                fw_lepm_GetFuncIdAllModes(LE_MLX_FUNCTION_ID_GET_CHIP_VERSION))) {
                            /* Prepare response with product identifiers */
                            fw_lepm_PrepareProdResponse(transfer);
                            isAnswerExpected = true;
#if HAS_PPM_EPM == 1
                        } else if ((pProdIdReq->func_id == LE_MLX_FUNCTION_ID_ENTER_PPM_MODE)
    6528:	aeda cabd 	cmp	A, #51901
    652c:	1d45      	jne	0x64b8 <.L25>

0000652e <.LM27>:
                                   || (pProdIdReq->func_id ==
                                       fw_lepm_GetFuncIdAllModes(LE_MLX_FUNCTION_ID_ENTER_PPM_MODE))) {
                            if (fw_lepm_ApplicationStop()) {
    652e:	11ee      	call	0x690c <_fw_lepm_ApplicationStop>
    6530:	ac00      	cmp	A, #0
    6532:	1942      	je	0x64b8 <.L25>

00006534 <.LM28>:
                                /* Set PPM mode flag */
                                lepmFlag = true;
    6534:	6401      	lod	YL, #1
    6536:	46d8 1096 	mov	0x1096 <_lepmFlag>, YL

0000653a <.LBB26>:
}

STATIC void fw_lepm_PrepareProdResponse(LINDiagTransfer_t* transfer)
{
    /* Use Response SID */
    transfer->response.respSId = LE_READ_BY_ID_RSID;
    653a:	7ada 00f2 	lod	Y, #242
    653e:	7e05      	lod	X, [S-6]
    6540:	46f8      	mov	[X], YL

00006542 <.LM30>:
    transfer->response.dataLen = 5u;
    6542:	7805      	lod	Y, #5
    6544:	5afa      	mov	[X+2], Y

00006546 <.LM31>:

    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_ProdIdRes_t* pDeviceVerRev = (fw_lepm_ProdIdRes_t*)transfer->response.data;
    pDeviceVerRev->prod_id_low = (uint16_t)PRODUCT_VERSION_32;
    6546:	7ad8 0a36 	lod	Y, 0xa36 <.LASF1477+0x1>
    654a:	46fc      	mov	[X+4], YL
    654c:	4efd      	mov	[X+5], YH

0000654e <.LM32>:
    pDeviceVerRev->prod_id_high = (uint16_t)(PRODUCT_VERSION_32 >> 16);
    654e:	7aee      	lod	Y, X
    6550:	e006      	add	Y, #6
    6552:	5a03      	mov	[S-4], Y
    6554:	6400      	lod	YL, #0
    6556:	7e03      	lod	X, [S-4]
    6558:	46f8      	mov	[X], YL

0000655a <.LVL21>:
    655a:	7e03      	lod	X, [S-4]
    655c:	46f9      	mov	[X+1], YL

0000655e <.LM33>:
    pDeviceVerRev->reserved = 0xFFu; /* it's reserved */
    655e:	7e05      	lod	X, [S-6]
    6560:	2008      	add	X, #8
    6562:	64ff      	lod	YL, #-1
    6564:	46f8      	mov	[X], YL

00006566 <.L7>:
        /* ignore other diagnostic messages */
    }

    /* If MLS device ID response is prepared then it's true;
     * in the case of new application specific request after - it's false */
    isAwaitingResponseTransmitted = isAnswerExpected;
    6566:	42d8 1097 	mov	0x1097 <_isAwaitingResponseTransmitted>, AL

0000656a <.LM35>:
    return isAnswerExpected;
}
    656a:	5409      	ret	#10

0000656c <.L9>:
                            /* ignore unknown Function ID value */
                        }
                        break;

                    case LE_MLX_PLTF_ID:
                        if ((pProdIdReq->func_id == LE_MLX_FUNCTION_ID_GET_CHIP_VERSION)
    656c:	7a05      	lod	Y, [S-6]
    656e:	e007      	add	Y, #7
    6570:	62f0      	lod	AL, [Y]
    6572:	6af1      	lod	AH, [Y+1]
    6574:	94bf      	and	AL, #-65
    6576:	aeda cabc 	cmp	A, #51900
    657a:	1901      	je	0x657e <.LM37>
    657c:	079d      	jmp	0x64b8 <.L25>

0000657e <.LM37>:
}

STATIC void fw_lepm_PreparePltfRevResponse(LINDiagTransfer_t* transfer)
{
    /* Use Response SID */
    transfer->response.respSId = LE_READ_BY_ID_RSID;
    657e:	72da 00f2 	lod	A, #242
    6582:	7a05      	lod	Y, [S-6]
    6584:	42f0      	mov	[Y], AL

00006586 <.LM38>:
    transfer->response.dataLen = LE_PLTF_REV_RES_DATA_LENGTH;
    6586:	7005      	lod	A, #5
    6588:	52f2      	mov	[Y+2], A
    658a:	7ada 0101 	lod	Y, #257
    658e:	7e05      	lod	X, [S-6]
    6590:	5afc      	mov	[X+4], Y

00006592 <.LM39>:

    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_PltfRevRes_t* pPltfRevResp = (fw_lepm_PltfRevRes_t*)transfer->response.data;
    pPltfRevResp->major = RELEASE_MAJOR;
    pPltfRevResp->minor = RELEASE_MINOR;
    6592:	7804      	lod	Y, #4
    6594:	5afe      	mov	[X+6], Y

00006596 <.LM40>:
    pPltfRevResp->patch = RELEASE_REVISION;
    pPltfRevResp->build = 0x00u;
    6596:	2008      	add	X, #8
    6598:	07c4      	jmp	0x6522 <.L27>

0000659a <.L10>:
                            /* ignore unknown Function ID value */
                        }
                        break;

                    case LE_MLX_PATCH_ID:
                        if ((pProdIdReq->func_id == LE_MLX_FUNCTION_ID_GET_CHIP_VERSION)
    659a:	7a05      	lod	Y, [S-6]
    659c:	e007      	add	Y, #7
    659e:	62f0      	lod	AL, [Y]
    65a0:	6af1      	lod	AH, [Y+1]
    65a2:	94bf      	and	AL, #-65
    65a4:	aeda cabc 	cmp	A, #51900
    65a8:	1901      	je	0x65ac <.LBB29>
    65aa:	0786      	jmp	0x64b8 <.L25>

000065ac <.LBB29>:
}

STATIC void fw_lepm_PreparePatchRevResponse(LINDiagTransfer_t* transfer)
{
    /* Use Response SID */
    transfer->response.respSId = LE_READ_BY_ID_RSID;
    65ac:	72da 00f2 	lod	A, #242
    65b0:	7a05      	lod	Y, [S-6]
    65b2:	42f0      	mov	[Y], AL

000065b4 <.LM43>:
    transfer->response.dataLen = LE_PATCH_REV_RES_DATA_LENGTH;
    65b4:	7002      	lod	A, #2
    65b6:	52f2      	mov	[Y+2], A

000065b8 <.LM44>:

    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_PatchRevRes_t* pPatchRevResp = (fw_lepm_PatchRevRes_t*)transfer->response.data;

    /* Return patch identifier only when patch is enabled by ROM */
    if (((IO_GET(MLX16, DBG_CONTROL0) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
    65b8:	72d8 0042 	lod	A, 0x42 <.LLST2+0x3>
    65bc:	d43f      	and	AH, #63
    65be:	aeda 0410 	cmp	A, #1040
    65c2:	190c      	je	0x65dc <.L13>

000065c4 <.LM45>:
        ((IO_GET(MLX16, DBG_CONTROL1) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
    65c4:	72d8 0046 	lod	A, 0x46 <.LLST2+0x7>
    65c8:	d43f      	and	AH, #63

000065ca <.LM46>:

    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_PatchRevRes_t* pPatchRevResp = (fw_lepm_PatchRevRes_t*)transfer->response.data;

    /* Return patch identifier only when patch is enabled by ROM */
    if (((IO_GET(MLX16, DBG_CONTROL0) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
    65ca:	aeda 0410 	cmp	A, #1040
    65ce:	1906      	je	0x65dc <.L13>

000065d0 <.LM47>:
        ((IO_GET(MLX16, DBG_CONTROL1) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
        ((IO_GET(MLX16, DBG_CONTROL2) & 0x3FFFu) == PATCH_CTRL_ENABLE)) {
    65d0:	72d8 004a 	lod	A, 0x4a <__data_size+0x2>
    65d4:	d43f      	and	AH, #63

000065d6 <.LM48>:
    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_PatchRevRes_t* pPatchRevResp = (fw_lepm_PatchRevRes_t*)transfer->response.data;

    /* Return patch identifier only when patch is enabled by ROM */
    if (((IO_GET(MLX16, DBG_CONTROL0) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
        ((IO_GET(MLX16, DBG_CONTROL1) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
    65d6:	aeda 0410 	cmp	A, #1040
    65da:	1d07      	jne	0x65ea <.L14>

000065dc <.L13>:
        ((IO_GET(MLX16, DBG_CONTROL2) & 0x3FFFu) == PATCH_CTRL_ENABLE)) {
        pPatchRevResp->identifier = EE_HOST(PATCH_CRC);
    65dc:	7300      	lod	A, ep:0x0 <__bss_dp_size>
    65de:	7e05      	lod	X, [S-6]
    65e0:	42fc      	mov	[X+4], AL
    65e2:	6000      	lod	AL, #0
    65e4:	72e4      	swap	A
    65e6:	42fd      	mov	[X+5], AL
    65e8:	079d      	jmp	0x6524 <.L26>

000065ea <.L14>:
    } else {
        pPatchRevResp->identifier = 0xFFFFu;
    65ea:	7e05      	lod	X, [S-6]
    65ec:	2004      	add	X, #4
    65ee:	60ff      	lod	AL, #-1
    65f0:	42f8      	mov	[X], AL

000065f2 <.LVL32>:
    65f2:	42f9      	mov	[X+1], AL
    65f4:	0797      	jmp	0x6524 <.L26>

000065f6 <_fw_low_level_init>:
    builtin_mlx16_set_priority(7);  /* system mode, the lowest priority: 7 */
}

void fw_low_level_init(void)
{
    if (nvram_CalcCRC((uint16_t*)EE_APP_TRIM_AREA_START, EE_APP_TRIM_AREA_SIZE >> 1) == NVRAM_CORRECT_CRC) {
    65f6:	54ca 0028 	pushw	#40

000065fa <.LCFI0>:
    65fa:	72da 09b0 	lod	A, #2480
    65fe:	82db 1540 	callf	0x2a80 <_nvram_CalcCRC>
    6602:	5c01      	dec	S, #2

00006604 <.LCFI1>:
    6604:	aeda 00ff 	cmp	A, #255
    6608:	1901      	je	0x660c <.LM3>
    660a:	004f      	jmp	0x66aa <.L2>

0000660c <.LM3>:
        /* load trimming data to io registers */
        IO_SET(TRIM1_DRV,
    660c:	72d8 0208 	lod	A, 0x208 <_TRIM1_DRV>
    6610:	b6da f000 	and	A, #61440
    6614:	7ed8 09ec 	lod	X, 0x9ec <.LLST3>
    6618:	3403      	and	X, #3
    661a:	a6ee      	or	A, X
    661c:	7ed8 09ec 	lod	X, 0x9ec <.LLST3>
    6620:	36da 0ffc 	and	X, #4092
    6624:	a6ee      	or	A, X
    6626:	52d8 0208 	mov	0x208 <_TRIM1_DRV>, A

0000662a <.LM4>:
               TRIM_DRVSUP, EE_GET(TRIM_DRVSUP),            /* trim output level of driver supply */
               PRE_TRIM_DRVMOD_CPCLK, EE_GET(TRIM_CPCLK));  /* trim frequency of driver clock */
        IO_SET(TRIM2_DRV,
    662a:	72d8 020a 	lod	A, 0x20a <_TRIM2_DRV>
    662e:	b6da fe00 	and	A, #65024
    6632:	0ea7      	lod	C, ML.7
    6634:	7ed8 09ee 	lod	X, 0x9ee <.LLST3+0x2>
    6638:	340f      	and	X, #15
    663a:	a6ee      	or	A, X
    663c:	7ed8 09ee 	lod	X, 0x9ee <.LLST3+0x2>
    6640:	36da 01f0 	and	X, #496
    6644:	a6ee      	or	A, X
    6646:	52d8 020a 	mov	0x20a <_TRIM2_DRV>, A

0000664a <.LM5>:
               TRIM_SLWRT, EE_GET(TRIM_SLWRT),              /* trim slewrate / slope of drivers */
               TRIM_CSA_GAIN, EE_GET(TRIM_CSA_GAIN));       /* trim gain of current sense amplifier */
        IO_SET(TRIM3_DRV,
    664a:	62d8 09f1 	lod	AL, 0x9f1 <.LLST3+0x5>
    664e:	42d8 020c 	mov	0x20c <_TRIM3_DRV>, AL

00006652 <.LM6>:
               TRIM_CSA_CL, EE_GET(TRIM_CSA_CL_LOW));       /* trim over-current limit of current sense amplifier */
        IO_SET(TRIM_MISC,
    6652:	0ea7      	lod	C, ML.7
    6654:	72d8 0206 	lod	A, 0x206 <_TRIM_MISC>
    6658:	b6da c000 	and	A, #49152
    665c:	7ed8 09f2 	lod	X, 0x9f2 <.LLST3+0x6>
    6660:	0ea7      	lod	C, ML.7
    6662:	36da 0fc0 	and	X, #4032
    6666:	a6ee      	or	A, X
    6668:	7ed8 09f2 	lod	X, 0x9f2 <.LLST3+0x6>
    666c:	36da 3000 	and	X, #12288
    6670:	a6ee      	or	A, X
    6672:	7ad8 09d0 	lod	Y, 0x9d0 <.LASF1512+0x7>
    6676:	7ae8      	swap	Y
    6678:	f43f      	and	Y, #63
    667a:	a6e6      	or	A, Y
    667c:	52d8 0206 	mov	0x206 <_TRIM_MISC>, A

00006680 <.LM7>:
               TRIM_OTD, EE_GET(TRIM_OTD),                  /* trim over temperature detection */
               TRIM_SDAFILT_IO, EE_GET(TRIM_SDAFILT_IO),    /* trim i2c sda filter/delay time */
               TRIM_LCD_LINAA, EE_GET(LINAA_TRIM_LCD_205)); /* trim linaa current */
        IO_SET(PORT_LINAA2,
    6680:	62d8 0204 	lod	AL, 0x204 <_PORT_LINAA2>
    6684:	94f8      	and	AL, #-8
    6686:	7ad8 09d0 	lod	Y, 0x9d0 <.LASF1512+0x7>
    668a:	44c6      	rl	Y, #2
    668c:	f403      	and	Y, #3
    668e:	86e8      	or	AL, YL
    6690:	42d8 0204 	mov	0x204 <_PORT_LINAA2>, AL

00006694 <.LM8>:
               LCD_SEL_LINAA, EE_GET(LINAA_LCD_SEL_205));   /* select adjustment of linaa current */
        IO_SET(PORT_LINAA1,
    6694:	7ed8 0202 	lod	X, 0x202 <_PORT_LINAA1>
    6698:	72d8 09d2 	lod	A, 0x9d2 <.LASF1512+0x9>
    669c:	6000      	lod	AL, #0
    669e:	72e4      	swap	A
    66a0:	36da fe00 	and	X, #65024
    66a4:	a6ee      	or	A, X
    66a6:	52d8 0202 	mov	0x202 <_PORT_LINAA1>, A

000066aa <.L2>:
               LINAA_DIV, EE_GET(LINAA_DIV));               /* linaa amplifier common-mode rejection adjustment */
    } else {
        /* load default values */
    }

    IO_SET(PORT_SUPP_CFG,
    66aa:	605f      	lod	AL, #95
    66ac:	42d8 01e4 	mov	0x1e4 <_PORT_SUPP_CFG>, AL

000066b0 <.LM10>:
           UV_VS_FILT_SEL, 1u,                      /* 100-110us filtering for VS under voltage */
           OV_VS_FILT_SEL, 1u,                      /* 100-110us filtering for VS over voltage */
           OVC_FILT_SEL, 0u,                        /* 1-2us filtering for over current */
           OVT_FILT_SEL, 1u);                       /* 100-110us filtering for over temperature */

    IO_SET(PORT_MISC_OUT, SEL_TEMP, 8u);            /* temperature channel selection */
    66b0:	72d8 01f2 	lod	A, 0x1f2 <_PORT_MISC_OUT>
    66b4:	d40f      	and	AH, #15
    66b6:	c480      	or	AH, #-128
    66b8:	52d8 01f2 	mov	0x1f2 <_PORT_MISC_OUT>, A

000066bc <.LM11>:

    IO_SET(PORT_MISC2_OUT, ENABLE_OTD, 1u);         /* enable over-temperature detector */
    66bc:	72d8 01f4 	lod	A, 0x1f4 <_PORT_MISC2_OUT>
    66c0:	c402      	or	AH, #2
    66c2:	52d8 01f4 	mov	0x1f4 <_PORT_MISC2_OUT>, A

000066c6 <.LM12>:

    IO_SET(PORT_DRV1_PROT, OC_PM, 1u);              /* switch drivers to tri-state in case of over-current */
    66c6:	72d8 0218 	lod	A, 0x218 <_PORT_DRV1_PROT>
    66ca:	c404      	or	AH, #4
    66cc:	52d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, A

000066d0 <.LM13>:
}
    66d0:	5401      	ret

000066d2 <_fw_premain>:
 * Function Definitions
 * --------------------------------------------- */

void fw_premain(void)
{
    fw_low_level_init();            /* optionally call more low level initialization */
    66d2:	1791      	call	0x65f6 <_fw_low_level_init>

000066d4 <.LM16>:

    fw_ram_section_init();          /* RAM initialization */
    66d4:	100b      	call	0x66ec <_fw_ram_section_init>

000066d6 <.LM17>:
#if defined (HAS_PATCH_COLIN)
    patch_colin_Init();
#endif /* HAS_PATCH_COLIN */

#if defined (HAS_MLS_API)
    fw_mls_Init();                  /* MLX LIN Slave initialization */
    66d6:	1679      	call	0x63ca <_fw_mls_Init>

000066d8 <.LM18>:
#endif /* HAS_MLS_API */

#if defined (HAS_STD_LIN_API) || defined (HAS_MLS_DEVICE_ID) || defined (HAS_MLS_LOADER)
    fw_mls_TransportLayerInit();
    66d8:	16ae      	call	0x6436 <_fw_mls_TransportLayerInit>

000066da <.LM19>:
#endif /* HAS_STD_LIN_API || HAS_MLS_DEVICE_ID || defined (HAS_MLS_LOADER) */

#if defined (HAS_MLS_DEVICE_ID)
    fw_lepm_Init();                 /* MLX LIN device ID initialization */
    66da:	16d8      	call	0x648c <_fw_lepm_Init>

000066dc <.LBB6>:
    ac_sel = 0u;
#elif FPLL == 28000
    tmp.u = EE_MS_TRIM7_VALUE;
    ac_sel = 0u;
#elif FPLL == 32000
    tmp.u = EE_MS_TRIM8_VALUE;
    66dc:	72d8 0a12 	lod	A, 0xa12 <.LLST0>

000066e0 <.LM21>:
    ac_sel = 0u;
#else
    #warning "Clock Speed not valid, use 32MHz"
#endif

    SetSystemSpeed(tmp, ac_sel);
    66e0:	54ca 0000 	pushw	#0

000066e4 <.LCFI2>:
    66e4:	82db 4124 	callf	0x8248 <_SetSystemSpeed>

000066e8 <.LBB8>:
        );
}

STATIC INLINE void builtin_mlx16_set_priority(uint8_t level)
{
    __asm__ __volatile__ (
    66e8:	54f7      	mov	UPr, #7

000066ea <.LBE8>:
    mls_loader_Init();
#endif /* HAS_MLS_LOADER */

    set_Clock_Speed();              /* set clock speed */
    builtin_mlx16_set_priority(7);  /* system mode, the lowest priority: 7 */
}
    66ea:	5403      	ret	#4

000066ec <_fw_ram_section_init>:
#if !defined(RAM_APPLICATION)
    uint16_t* r;
#endif /* !RAM_APPLICATION */

    /* clear .bss and .dp.bss sections */
    for (w = &_bss_dp_start; w < &_bss_dp_end; ) {
    66ec:	7ada 1012 	lod	Y, #4114
    66f0:	eeda 1012 	cmp	Y, #4114
    66f4:	1c08      	jnc	0x6706 <.L2>
    66f6:	7eda 1012 	lod	X, #4114
    66fa:	2ae6      	sub	X, Y
    66fc:	1904      	je	0x6706 <.L2>
    66fe:	443e      	lsr	X
    6700:	7000      	lod	A, #0
    6702:	52d6      	mov	[Y++], A

00006704 <L0>:
    6704:	1bfe      	djnz	X, 0x6702 <.LASF690+0x9>

00006706 <.L2>:
        *w++ = 0;
    }

    for (w = &_bss_start; w < &_bss_end; ) {
    6706:	7ada 105a 	lod	Y, #4186
    670a:	eeda 1220 	cmp	Y, #4640
    670e:	1c08      	jnc	0x6720 <.L4>
    6710:	7eda 1220 	lod	X, #4640
    6714:	2ae6      	sub	X, Y
    6716:	1904      	je	0x6720 <.L4>
    6718:	443e      	lsr	X
    671a:	7000      	lod	A, #0
    671c:	52d6      	mov	[Y++], A

0000671e <L0>:
    671e:	1bfe      	djnz	X, 0x671c <.LASF994+0x7>

00006720 <.L4>:

#if !defined(RAM_APPLICATION)   /* skip ROM-to-RAM loading for RAM application */
    /* initialize .data and .dp.data sections */
    r = &_data_load_start;      /* copy data from rom */

    for (w = &_data_dp_start; w < &_data_dp_end; ) {
    6720:	7ada 1012 	lod	Y, #4114
    6724:	7eda 5ac6 	lod	X, #23238

00006728 <.L26>:
    6728:	eeda 1012 	cmp	Y, #4114
    672c:	1c03      	jnc	0x6734 <.L6>
    672e:	0ea7      	lod	C, ML.7
    6730:	54ce      	movsw	[Y++], [X++]
    6732:	07fa      	jmp	0x6728 <.L26>

00006734 <.L6>:
        *w++ = *r++;
    }

    for (w = &_data_start; w < &_data_end; ) {
    6734:	7ada 1012 	lod	Y, #4114

00006738 <.L25>:
    6738:	eeda 105a 	cmp	Y, #4186
    673c:	1c03      	jnc	0x6744 <.L8>
    673e:	0ea7      	lod	C, ML.7
    6740:	54ce      	movsw	[Y++], [X++]
    6742:	07fa      	jmp	0x6738 <.L25>

00006744 <.L8>:
    }
#endif /* !RAM_APPLICATION */

#if defined (HAS_MLS_API)
    r = &_mlx4_cst_tables_ram_load_start;
    for (w = &_mlx4_cst_tables_ram_start; w < &_mlx4_cst_tables_ram_end; ) {
    6744:	7eda 0e80 	lod	X, #3712
    6748:	2eda 0ede 	cmp	X, #3806
    674c:	1c07      	jnc	0x675c <.L10>
    674e:	7ada 59e0 	lod	Y, #23008

00006752 <.L11>:
    6752:	0ea7      	lod	C, ML.7
    6754:	54c6      	movsw	[X++], [Y++]
    6756:	2eda 0ede 	cmp	X, #3806
    675a:	187b      	jc	0x6752 <.L11>

0000675c <.L10>:
        *w++ = *r++;
    }

    r = &_mlx4_flash_table_load_start;
    for (w = &_mlx4_flash_table_start; w < &_mlx4_flash_table_end; ) {
    675c:	7eda 0f00 	lod	X, #3840
    6760:	2eda 0f88 	cmp	X, #3976
    6764:	1c07      	jnc	0x6774 <.L1>
    6766:	7ada 5a3e 	lod	Y, #23102

0000676a <.L13>:
    676a:	0ea7      	lod	C, ML.7
    676c:	54c6      	movsw	[X++], [Y++]
    676e:	2eda 0f88 	cmp	X, #3976
    6772:	187b      	jc	0x676a <.L13>

00006774 <.L1>:
        *w++ = *r++;
    }
#endif /* HAS_MLS_API */
}
    6774:	5401      	ret

00006776 <_fw_start>:
#include "sys_tools.h"
#endif

STATIC INLINE void Sys_SetStack(const uint16_t* const stackptr)
{
    __asm__ __volatile__ (
    6776:	72da 1220 	lod	A, #4640
    677a:	52ef      	mov	S, A

0000677c <.LBB118>:
    return (stack_pointer);
}

STATIC INLINE void SYS_clearCpuStatus (void)
{
    __asm__ __volatile__ (
    677c:	7000      	lod	A, #0
    677e:	52e3      	mov	M, A

00006780 <.LBE118>:
                             * initialized during execution of the reset vector
                             * (see JMPVECTOR macro)
                             */

    /* set priorities to lowest level */
    IO_SET(MLX16, ITC_PRIO0, 0xFFFFu);
    6780:	70ff      	lod	A, #-1
    6782:	52d8 0088 	mov	0x88 <__mlx4_flash_table_size>, A

00006786 <.LM5>:
    IO_SET(MLX16, ITC_PRIO1, 0xFFFFu);
    6786:	0ea7      	lod	C, ML.7
    6788:	52d8 008a 	mov	0x8a <__mlx4_flash_table_size+0x2>, A

0000678c <.LM6>:
    IO_SET(MLX16, ITC_PRIO2, 0xFFFFu);
    678c:	52d8 008c 	mov	0x8c <.LASF1440>, A

00006790 <.LM7>:
    IO_SET(MLX16, ITC_PRIO3, 0xFFFFu);
    6790:	52d8 008e 	mov	0x8e <.LASF1440+0x2>, A

00006794 <.LM8>:
    IO_SET(MLX16, ITC_PRIO4, 0xFFFFu);
    6794:	0ea7      	lod	C, ML.7
    6796:	60ff      	lod	AL, #-1
    6798:	42d8 0090 	mov	0x90 <.LASF1440+0x4>, AL

0000679c <.LBB120>:
STATIC INLINE void MotorDriverUVWTSelectSource(DrvCtrlSelect_t drvctrl_u,
                                               DrvCtrlSelect_t drvctrl_v,
                                               DrvCtrlSelect_t drvctrl_w,
                                               DrvCtrlSelect_t drvctrl_t)
{
    IO_SET(PORT_DRV_CTRL,
    679c:	72da eeee 	lod	A, #61166
    67a0:	0ea7      	lod	C, ML.7
    67a2:	52d8 0216 	mov	0x216 <_PORT_DRV_CTRL>, A

000067a6 <.LBE120>:

    /* all phases in tri-state explicitly */
    MotorDriverUVWTSelectSource(DRV_CTRL_TRISTATE, DRV_CTRL_TRISTATE, DRV_CTRL_TRISTATE, DRV_CTRL_TRISTATE);

    fw_premain();           /* Don't make this functions static to be sure its local variable will not apear before the SP assignment */
    67a6:	1795      	call	0x66d2 <_fw_premain>

000067a8 <.LM11>:

    __asm__ ("JMP _main\n\t" ::); /* jump to the main function */
    67a8:	76da 3918 	jmpf	0x7230 <_main>

000067ac <.LM12>:
}
    67ac:	5401      	ret

000067ae <_ld_AppDiagRequest>:
    {
        transfer->response.respSId = transfer->request.reqSId + 0x40;
    }

    return retVal;
}
    67ae:	7000      	lod	A, #0

000067b0 <.LVL1>:
    67b0:	5401      	ret

000067b2 <_lin22_Init>:
 *
 * This function initialize the lin module and it will assign
 * the default frame ids to the different messages.
 */
void lin22_Init(void)
{
    67b2:	5809      	inc	S, #10

000067b4 <.LCFI0>:
    (void)l_sys_init();
    67b4:	1315      	call	0x6de0 <_l_sys_init>

000067b6 <.LM7>:
    (void)l_ifc_init_sl1();
    67b6:	133d      	call	0x6e32 <_l_ifc_init_sl1>

000067b8 <.LM8>:

    uint8_t lin_cfg_len = SL_NUMBER_OF_DYNAMIC_MESSAGES + 1u;
    uint8_t lin_config[1 + SL_NUMBER_OF_DYNAMIC_MESSAGES] = SL_NODE_CONFIGURATION_INITIALIZER;
    67b8:	7eef      	lod	X, S
    67ba:	20f6      	add	X, #-10
    67bc:	7ada 5b0e 	lod	Y, #23310
    67c0:	54e7      	mov	Cx, #7
    67c2:	54c4      	movsb	[X++], [Y++]
    67c4:	1ffe      	djnz	Cx, 0x67c2 <.LASF1056+0x4>

000067c6 <.LM9>:

#if (SL_HAS_SAVE_CONFIGURATION_SERVICE == 1)
    (void)eeprom_ReadLINconfig(lin_config, lin_cfg_len);
    67c6:	54ca 0007 	pushw	#7

000067ca <.LCFI1>:
    67ca:	7aef      	lod	Y, S
    67cc:	e0f4      	add	Y, #-12
    67ce:	72e6      	lod	A, Y
    67d0:	5a03      	mov	[S-4], Y
    67d2:	15c3      	call	0x635a <_eeprom_ReadLINconfig>

000067d4 <.LM10>:
    (void)ld_set_configuration(ifcSlave_1, lin_config, lin_cfg_len);
    67d4:	54ca 0007 	pushw	#7

000067d8 <.LCFI2>:
    67d8:	7a05      	lod	Y, [S-6]
    67da:	5adf      	push	Y

000067dc <.LCFI3>:
    67dc:	7001      	lod	A, #1
    67de:	115d      	call	0x6a9a <_ld_set_configuration>

000067e0 <.LM11>:

    ml_ConfiguredNAD = lin_config[0];
#endif /* (SL_HAS_SAVE_CONFIGURATION_SERVICE == 1) */

#if (SL_HAS_UNKNOWN_DIAG_CALLOUT == 1)
    (void)ldt_SubscribeMultipleHandler(plinEventTable->ldt_Request, ld_AppDiagRequest);
    67e0:	7ed8 1002 	lod	X, 0x1002 <_plinEventTable>
    67e4:	201a      	add	X, #26
    67e6:	54ca 33d7 	pushw	#13271

000067ea <.LCFI4>:
    67ea:	72f8      	lod	A, [X]
    67ec:	82db 1ee8 	callf	0x3dd0 <_ldt_SubscribeMultipleHandler>

000067f0 <.LM12>:
#endif /* (SL_HAS_UNKNOWN_DIAG_CALLOUT == 1) */

    /* register a timer for SL_LD_N_AS_TIMEOUT timeout */
    swtimer_register(SWTIMER_LINAS, (SL_LD_N_AS_TIMEOUT / TO_N_AS_TIMEOUT_TICKS), REPETITIVE);
    67f0:	54ca 0001 	pushw	#1

000067f4 <.LCFI5>:
    67f4:	54ca 000a 	pushw	#10

000067f8 <.LCFI6>:
    67f8:	7001      	lod	A, #1
    67fa:	82db 3f62 	callf	0x7ec4 <_swtimer_register>

000067fe <.LM13>:
    swtimer_start(SWTIMER_LINAS);
    67fe:	7001      	lod	A, #1
    6800:	82db 3f78 	callf	0x7ef0 <_swtimer_start>

00006804 <.LM14>:

    /* register a timer for SL_LD_N_CR_TIMEOUT timeout */
    swtimer_register(SWTIMER_LINCR, (SL_LD_N_CR_TIMEOUT / TO_N_CR_TIMEOUT_TICKS), REPETITIVE);
    6804:	54ca 0001 	pushw	#1

00006808 <.LCFI7>:
    6808:	54ca 000a 	pushw	#10

0000680c <.LCFI8>:
    680c:	0ea7      	lod	C, ML.7
    680e:	7002      	lod	A, #2
    6810:	82db 3f62 	callf	0x7ec4 <_swtimer_register>

00006814 <.LM15>:
    swtimer_start(SWTIMER_LINCR);
    6814:	7002      	lod	A, #2
    6816:	82db 3f78 	callf	0x7ef0 <_swtimer_start>

0000681a <.LM16>:

    /* register a timer for COLIN check timeout */
    swtimer_register(SWTIMER_CHECKCOLIN, COLIN_CHECK_TIMEOUT, REPETITIVE);
    681a:	54ca 0001 	pushw	#1

0000681e <.LCFI9>:
    681e:	54ca 012c 	pushw	#300

00006822 <.LCFI10>:
    6822:	0ea7      	lod	C, ML.7
    6824:	7000      	lod	A, #0
    6826:	82db 3f62 	callf	0x7ec4 <_swtimer_register>

0000682a <.LM17>:
    swtimer_start(SWTIMER_CHECKCOLIN);
    682a:	7000      	lod	A, #0
    682c:	82db 3f78 	callf	0x7ef0 <_swtimer_start>

00006830 <.LM18>:
    #if DEBUG_DB_B2 == 1
    adc_RegisterIRQ2(B2_exit);
    #endif
    #endif

    bLinActive = true;
    6830:	6001      	lod	AL, #1
    6832:	42d8 1099 	mov	0x1099 <_bLinActive>, AL

00006836 <.LCFI11>:
}
    6836:	541f      	ret	#32

00006838 <_lin22_CheckColin>:
    }
}

/** Check the status of the COLIN module and handle accordingly */
void lin22_CheckColin(void)
{
    6838:	5801      	inc	S, #2

0000683a <.LBB373>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    683a:	7ae3      	lod	Y, M

0000683c <.LBB376>:

#include "builtin_mlx16_common.h"

STATIC INLINE void builtin_mlx16_disable_interrupts(void)
{
    __asm__ __volatile__ (
    683c:	08b2      	clrb	MH.2
    683e:	08b1      	clrb	MH.1
    6840:	08b0      	clrb	MH.0

00006842 <.LBE376>:
    static uint8_t u8ColinErrorState = 0u;
    ml_LinState_t ColinState;

    ENTER_SECTION(ATOMIC_KEEP_MODE);
    ColinState = ml_GetState(ML_CLR_LIN_BUS_ACTIVITY);
    6842:	7008      	lod	A, #8
    6844:	5a01      	mov	[S-2], Y
    6846:	82db 11a3 	callf	0x2346 <_ml_GetState>

0000684a <.LBB379>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    684a:	7a01      	lod	Y, [S-2]
    684c:	5ae3      	mov	M, Y

0000684e <.LBE373>:
    EXIT_SECTION();

    if (ColinState != ml_stINVALID)
    684e:	acff      	cmp	A, #-1
    6850:	1912      	je	0x6876 <.L6>

00006852 <.LM37>:
    {
        /* COLIN is responding */
        if (COLIN_LINstatus.event_overflow != 0u)
    6852:	62d8 0e2f 	lod	AL, 0xe2f <.LASF1454+0x8>

00006856 <.LVL21>:
    6856:	9408      	and	AL, #8
    6858:	1919      	je	0x688c <.L5>

0000685a <.LBB383>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    685a:	7ae3      	lod	Y, M

0000685c <.LBB386>:

#include "builtin_mlx16_common.h"

STATIC INLINE void builtin_mlx16_disable_interrupts(void)
{
    __asm__ __volatile__ (
    685c:	08b2      	clrb	MH.2
    685e:	08b1      	clrb	MH.1
    6860:	08b0      	clrb	MH.0

00006862 <.LBE386>:
        {
            /* command overflow was detected */
            ENTER_SECTION(ATOMIC_KEEP_MODE);
            (void)ml_GetState(ML_CLR_LIN_CMD_OVERFLOW);
    6862:	7001      	lod	A, #1
    6864:	5a01      	mov	[S-2], Y
    6866:	82db 11a3 	callf	0x2346 <_ml_GetState>

0000686a <.LBB389>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    686a:	7a01      	lod	Y, [S-2]
    686c:	5ae3      	mov	M, Y

0000686e <.LBE383>:
            EXIT_SECTION();

            /* do handshake MLX16 <> COLIN */
            ml_SetSLVCMD(0x42u);
    686e:	7042      	lod	A, #66
    6870:	82db 11e7 	callf	0x23ce <_ml_SetSLVCMD>
    6874:	5403      	ret	#4

00006876 <.L6>:
        }
    }
    else
    {
        /* COLIN response time-out */
        u8ColinErrorState++;
    6876:	62d8 1098 	lod	AL, 0x1098 <___u8ColinErrorState_7000>

0000687a <.LVL27>:
    687a:	8001      	add	AL, #1
    687c:	42d8 1098 	mov	0x1098 <___u8ColinErrorState_7000>, AL

00006880 <.LM44>:

        if (u8ColinErrorState >= 4u)
    6880:	8c03      	cmp	AL, #3
    6882:	1a04      	jule	0x688c <.L5>

00006884 <.LBB393>:
    return 1;
}

STATIC INLINE uint16_t mlx16_enter_system_mode_keep_prio(void)
{
    __asm__ __volatile__ (".word OPCODE_CALL_FP_ENTER_SYSTEM_MODE_KEEP_PRIO");
    6884:	503c      	call	fp1:0xE0

00006886 <.LBE396>:
}

STATIC INLINE NO_RETURN void Sys_ResetCpu (void)
{
    (void) mlx16_enter_system_mode_keep_prio();
    IO_SET(RST_CTRL, SOFT_RESET, 1u);    /* Reset happens immediately after writing SOFT_RESET bit */
    6886:	6283      	lod	AL, io:0x3 <_RST_CTRL+0x1>
    6888:	8420      	or	AL, #32
    688a:	4283      	mov	io:0x3 <_RST_CTRL+0x1>, AL

0000688c <.L5>:
        {
            /* COLIN has not been responding to often, lets reset the module */
            Sys_ResetCpu();
        }
    }
}
    688c:	5403      	ret	#4

0000688e <_lin22_BackgroundHandler>:
 *
 * This function should be called from the main loop. It will check if the
 * lin module needs attention and if so will execute the specific handling.
 */
void lin22_BackgroundHandler(void)
{
    688e:	5809      	inc	S, #10

00006890 <.LCFI14>:
#if (SL_HAS_SAVE_CONFIGURATION_SERVICE == 1)
    l_s_IfcStatus_t status;
    status.word = l_ifc_read_status_sl1();
    6890:	12da      	call	0x6e46 <_l_ifc_read_status_sl1>

00006892 <.LM50>:

    if (status.mapped.SaveConfig != 0)
    6892:	9440      	and	AL, #64
    6894:	1912      	je	0x68ba <.L13>

00006896 <.LBB398>:
    {
        uint8_t lin_cfg_len = SL_NUMBER_OF_DYNAMIC_MESSAGES + 1u;
    6896:	6007      	lod	AL, #7

00006898 <.LVL29>:
    6898:	4202      	mov	[S-3], AL

0000689a <.LM52>:
        uint8_t lin_config[1 + SL_NUMBER_OF_DYNAMIC_MESSAGES];

        (void)ld_read_configuration(ifcSlave_1, lin_config, &lin_cfg_len);
    689a:	72ef      	lod	A, S
    689c:	a0fd      	add	A, #-3
    689e:	52df      	push	A

000068a0 <.LCFI15>:
    68a0:	7aef      	lod	Y, S
    68a2:	e0f4      	add	Y, #-12
    68a4:	5adf      	push	Y

000068a6 <.LCFI16>:
    68a6:	7001      	lod	A, #1
    68a8:	5a05      	mov	[S-6], Y
    68aa:	10d0      	call	0x6a4c <_ld_read_configuration>

000068ac <.LM53>:

        (void)eeprom_StoreLINconfig(lin_config, lin_cfg_len);
    68ac:	6206      	lod	AL, [S-7]
    68ae:	5cf2      	usex	A
    68b0:	52df      	push	A

000068b2 <.LCFI17>:
    68b2:	7a07      	lod	Y, [S-8]
    68b4:	72e6      	lod	A, Y
    68b6:	1559      	call	0x636a <_eeprom_StoreLINconfig>

000068b8 <.LBE398>:
    68b8:	5c05      	dec	S, #6

000068ba <.L13>:
        /* nothing to be done */
    }
#endif /* (SL_HAS_SAVE_CONFIGURATION_SERVICE == 1) */

    /* Check LIN AS-timeout */
    if (swtimer_isTriggered(SWTIMER_LINAS))
    68ba:	7001      	lod	A, #1
    68bc:	82db 3f99 	callf	0x7f32 <_swtimer_isTriggered>
    68c0:	ac00      	cmp	A, #0
    68c2:	1906      	je	0x68d0 <.L14>

000068c4 <.LM55>:
    {
        ldt_Tick(100u / TO_N_AS_TIMEOUT_TICKS, 0u);
    68c4:	54ca 0000 	pushw	#0

000068c8 <.LCFI19>:
    68c8:	7001      	lod	A, #1
    68ca:	82db 41db 	callf	0x83b6 <_ldt_Tick>
    68ce:	5c01      	dec	S, #2

000068d0 <.L14>:
    }

    /* Check LIN CR-timeout */
    if (swtimer_isTriggered(SWTIMER_LINCR))
    68d0:	7002      	lod	A, #2
    68d2:	82db 3f99 	callf	0x7f32 <_swtimer_isTriggered>
    68d6:	ac00      	cmp	A, #0
    68d8:	1906      	je	0x68e6 <.L15>

000068da <.LM57>:
    {
        ldt_Tick(0u, 100u / TO_N_CR_TIMEOUT_TICKS);
    68da:	54ca 0001 	pushw	#1

000068de <.LCFI21>:
    68de:	7000      	lod	A, #0
    68e0:	82db 41db 	callf	0x83b6 <_ldt_Tick>
    68e4:	5c01      	dec	S, #2

000068e6 <.L15>:
    }

    if (swtimer_isTriggered(SWTIMER_CHECKCOLIN))
    68e6:	7000      	lod	A, #0
    68e8:	82db 3f99 	callf	0x7f32 <_swtimer_isTriggered>
    68ec:	ac00      	cmp	A, #0
    68ee:	1901      	je	0x68f2 <.L12>

000068f0 <.LM59>:
    {
        /* check COLIN state */
        lin22_CheckColin();
    68f0:	17a3      	call	0x6838 <_lin22_CheckColin>

000068f2 <.L12>:
    }
}
    68f2:	540b      	ret	#12

000068f4 <_ld_serial_number_callout>:
 * This function is called by the lin driver on receipt of a
 * read by id 0x00 request.
 * @param[out]  data  pointer to the data to be filled
 */
void ld_serial_number_callout(l_u8 data[4])
{
    68f4:	7ee2      	lod	X, A

000068f6 <.LM62>:
    data[0] = (l_u8)(EE_CHIP_ID_0);                 /* LSB */
    68f6:	7ada 0a30 	lod	Y, #2608
    68fa:	0ea7      	lod	C, ML.7
    68fc:	54c4      	movsb	[X++], [Y++]

000068fe <.LM63>:
    data[1] = (l_u8)(EE_CHIP_ID_0 >> 8);
    68fe:	54c4      	movsb	[X++], [Y++]

00006900 <.LM64>:
    data[2] = (l_u8)(EE_CHIP_ID_1);
    6900:	7ada 0a32 	lod	Y, #2610
    6904:	0ea7      	lod	C, ML.7
    6906:	54c4      	movsb	[X++], [Y++]

00006908 <.LM65>:
    data[3] = (l_u8)(EE_CHIP_ID_1 >> 8);            /* MSB */
    6908:	54c4      	movsb	[X++], [Y++]

0000690a <.LM66>:
}
    690a:	5401      	ret

0000690c <_fw_lepm_ApplicationStop>:
 * @retval  true   command has been handled successful;
 * @retval  false  command has not been handled successful;
 */
bool fw_lepm_ApplicationStop(void)
{
    adc_Stop();
    690c:	82db 2ebd 	callf	0x5d7a <_adc_Stop>

00006910 <.LM69>:
    pwm_Disable();
    6910:	82db 3d41 	callf	0x7a82 <_pwm_Disable>

00006914 <.LM70>:
    swtimer_deinit();
    6914:	82db 3f49 	callf	0x7e92 <_swtimer_deinit>

00006918 <.LM71>:
    return (true);  /* return that the application has stopped */
}
    6918:	7001      	lod	A, #1
    691a:	5401      	ret

0000691c <_ld_read_by_id_callout>:
 * - LD_NEGATIVE_RESPONSE   - the slave node will respond with a negative response;
 * - LD_POSTIVE_RESPONSE    - the slave node will setup a positive response;
 * - LD_NO_RESPONSE         - the slave node will not answer.
 */
l_u8 ld_read_by_id_callout(l_ifc_handle iii, l_u8 id, l_u8* pci, l_u8* data)
{
    691c:	5811      	inc	S, #18

0000691e <.LCFI23>:
    l_u8 u8Return;
    (void)iii;

    switch (id)
    691e:	6215      	lod	AL, [S-22]

00006920 <.LVL46>:
    6920:	8c2b      	cmp	AL, #43
    6922:	191e      	je	0x6960 <.L43>
    6924:	5cf2      	usex	A
    6926:	ac2c      	cmp	A, #44
    6928:	1927      	je	0x6978 <.L44>
    692a:	ac21      	cmp	A, #33
    692c:	1d3a      	jne	0x69a2 <.L47>

0000692e <.LBB413>:
    {
        case 0x21u:
        {
            uint8_t lin_cfg_len = SL_NUMBER_OF_DYNAMIC_MESSAGES + 1u;
            uint8_t lin_config[1 + SL_NUMBER_OF_DYNAMIC_MESSAGES] = SL_NODE_CONFIGURATION_INITIALIZER;
    692e:	7eef      	lod	X, S
    6930:	20ee      	add	X, #-18
    6932:	7ada 5b0e 	lod	Y, #23310
    6936:	54e7      	mov	Cx, #7
    6938:	54c4      	movsb	[X++], [Y++]
    693a:	1ffe      	djnz	Cx, 0x6938 <.LASF1000+0x5>

0000693c <.LM94>:

            /* Verify NAD */
#if (SL_HAS_SAVE_CONFIGURATION_SERVICE == 1)
            (void)eeprom_ReadLINconfig(lin_config, lin_cfg_len);
    693c:	54ca 0007 	pushw	#7

00006940 <.LCFI24>:
    6940:	7aef      	lod	Y, S
    6942:	e0ec      	add	Y, #-20
    6944:	72e6      	lod	A, Y
    6946:	5a07      	mov	[S-8], Y
    6948:	1508      	call	0x635a <_eeprom_ReadLINconfig>

0000694a <.LM95>:
#endif
            *pci = 8u;  /* 7-bytes of data + 1 */
    694a:	7e19      	lod	X, [S-26]
    694c:	6008      	lod	AL, #8
    694e:	42f8      	mov	[X], AL
    6950:	7e1b      	lod	X, [S-28]
    6952:	7a07      	lod	Y, [S-8]
    6954:	54e7      	mov	Cx, #7
    6956:	54c4      	movsb	[X++], [Y++]
    6958:	1ffe      	djnz	Cx, 0x6956 <.LASF678+0x4>
    695a:	5c01      	dec	S, #2

0000695c <.L48>:
            *pci = 5u;                              /* 4-bytes of data + 1-byte of pci */
            data[0] = (uint8_t)LIBRARIES_VERSION_MAJOR;
            data[1] = (uint8_t)LIBRARIES_VERSION_MINOR;
            data[2] = (uint8_t)LIBRARIES_VERSION_REVISION;
            data[3] = (uint8_t)LIBRARIES_VERSION_CUSTOMER_BUILD;
            u8Return = LD_POSITIVE_RESPONSE;
    695c:	7007      	lod	A, #7

0000695e <.LM97>:
            break;
    695e:	5413      	ret	#20

00006960 <.L43>:
 * - LD_NEGATIVE_RESPONSE   - the slave node will respond with a negative response;
 * - LD_POSTIVE_RESPONSE    - the slave node will setup a positive response;
 * - LD_NO_RESPONSE         - the slave node will not answer.
 */
l_u8 ld_read_by_id_callout(l_ifc_handle iii, l_u8 id, l_u8* pci, l_u8* data)
{
    6960:	7e17      	lod	X, [S-24]

00006962 <.LM99>:
            break;
        }

        case 0x2Bu:
        {
            *pci = 5u;                              /* 4-bytes of data + 1-byte of pci */
    6962:	6005      	lod	AL, #5
    6964:	42f8      	mov	[X], AL

00006966 <.LM100>:
 * - LD_NEGATIVE_RESPONSE   - the slave node will respond with a negative response;
 * - LD_POSTIVE_RESPONSE    - the slave node will setup a positive response;
 * - LD_NO_RESPONSE         - the slave node will not answer.
 */
l_u8 ld_read_by_id_callout(l_ifc_handle iii, l_u8 id, l_u8* pci, l_u8* data)
{
    6966:	7e19      	lod	X, [S-26]

00006968 <.LM101>:
        }

        case 0x2Bu:
        {
            *pci = 5u;                              /* 4-bytes of data + 1-byte of pci */
            data[0] = (uint8_t)LIBRARIES_VERSION_MAJOR;
    6968:	6002      	lod	AL, #2
    696a:	42f8      	mov	[X], AL

0000696c <.LM102>:
            data[1] = (uint8_t)LIBRARIES_VERSION_MINOR;
    696c:	600b      	lod	AL, #11
    696e:	42f9      	mov	[X+1], AL

00006970 <.LM103>:
            data[2] = (uint8_t)LIBRARIES_VERSION_REVISION;
    6970:	6000      	lod	AL, #0
    6972:	42fa      	mov	[X+2], AL

00006974 <.LM104>:
            data[3] = (uint8_t)LIBRARIES_VERSION_CUSTOMER_BUILD;
    6974:	42fb      	mov	[X+3], AL
    6976:	07f2      	jmp	0x695c <.L48>

00006978 <.L44>:
            break;
        }

        case 0x2Cu:
        {
            uint32_t version = VERSION_getFwAppVersion();
    6978:	82db 41a6 	callf	0x834c <_VERSION_getFwAppVersion>
    697c:	58a0      	mov	[S-4], YA

0000697e <.LM106>:
            *pci = 5u;  /* 4-bytes of data + 1-byte of pci */
    697e:	7e17      	lod	X, [S-24]
    6980:	6405      	lod	YL, #5
    6982:	46f8      	mov	[X], YL

00006984 <.LM107>:
            data[0] = (uint8_t)(version >> 24);
    6984:	58e0      	mov	YA, [S-4]
    6986:	48af      	lsr	YA, #16
    6988:	48a7      	lsr	YA, #8

0000698a <.LVL55>:
    698a:	58a3      	mov	[S-10], YA
    698c:	7e19      	lod	X, [S-26]
    698e:	42f8      	mov	[X], AL

00006990 <.LM108>:
            data[1] = (uint8_t)(version >> 16);
    6990:	6601      	lod	YL, [S-2]
    6992:	46f9      	mov	[X+1], YL

00006994 <.LM109>:
            data[2] = (uint8_t)(version >> 8);
    6994:	58e0      	mov	YA, [S-4]
    6996:	48a7      	lsr	YA, #8
    6998:	58a3      	mov	[S-10], YA
    699a:	42fa      	mov	[X+2], AL

0000699c <.LM110>:
            data[3] = (uint8_t)(version >> 0);
    699c:	6603      	lod	YL, [S-4]
    699e:	46fb      	mov	[X+3], YL
    69a0:	07dd      	jmp	0x695c <.L48>

000069a2 <.L47>:
            u8Return = LD_POSITIVE_RESPONSE;
            break;
        }

        default:
            u8Return = LD_NEGATIVE_RESPONSE;
    69a2:	7002      	lod	A, #2

000069a4 <.LM112>:
            break;
    }

    return (u8Return);
}
    69a4:	5413      	ret	#20

000069a6 <_l_ifc_sleep_entered_callout>:
    //        EVENT_GotoSleep();
    //        lin22_GotoSleep();  /* switch to sleep mode */
#endif
            break;
    }
}
    69a6:	5401      	ret

000069a8 <_l_mls_Init>:
    const l_u8 l_s_ver = ML_VER_DEFAULT;
#endif /* ML_MLX4_VERSION >= 412 */

    /* Start and initialize the LIN Module
     * Note: MLX LIN API shall be initialized first with proper settings and only TL then */
    if (ml_Init(SL_LIN_AUTOBAUDRATE_MODE, SL_LIN_BAUDRATE, l_s_ver, MLX4_FPLL) == ML_SUCCESS) {
    69a8:	54ca 7d00 	pushw	#32000

000069ac <.LCFI0>:
    69ac:	54ca 0009 	pushw	#9

000069b0 <.LCFI1>:
    69b0:	54ca 4b00 	pushw	#19200

000069b4 <.LCFI2>:
    69b4:	0ea7      	lod	C, ML.7
    69b6:	7001      	lod	A, #1
    69b8:	82db 4240 	callf	0x8480 <_ml_Init>
    69bc:	5c05      	dec	S, #6

000069be <.LCFI3>:
    69be:	ac00      	cmp	A, #0
    69c0:	1d3a      	jne	0x6a36 <.L1>

000069c2 <.LBB10>:
 * @return void
 */
static void l_mls_InitEventTable(void)
{
    /* General events processing */
    plinEventTable->mlu_LinSleepMode = l_LinSleepMode;
    69c2:	7ad8 1002 	lod	Y, 0x1002 <_plinEventTable>
    69c6:	7ee6      	lod	X, Y
    69c8:	200a      	add	X, #10
    69ca:	72da 3741 	lod	A, #14145
    69ce:	52f8      	mov	[X], A

000069d0 <.LM4>:
    plinEventTable->mlu_AutoAddressingStep = l_AutoAddressingStep;
    69d0:	2002      	add	X, #2
    69d2:	72da 37c4 	lod	A, #14276
    69d6:	52f8      	mov	[X], A

000069d8 <.LM5>:

    /* Non-diagnostic frames are processed always by std. LIN API when it's initialized
     * The std. LIN API uses event from LIN transport layer */
    plinEventTable->ldt_NonDiagMessageReceived = l_MessageReceived;
    69d8:	2002      	add	X, #2
    69da:	72da 374e 	lod	A, #14158
    69de:	52f8      	mov	[X], A

000069e0 <.LM6>:
    plinEventTable->ldt_NonDiagDataRequest = l_DataRequest;
    69e0:	2004      	add	X, #4
    69e2:	72da 376d 	lod	A, #14189
    69e6:	52f8      	mov	[X], A

000069e8 <.LM7>:
    plinEventTable->ldt_NonDiagDataTransmitted = l_DataTransmitted;
    69e8:	20fe      	add	X, #-2
    69ea:	72da 37a8 	lod	A, #14248
    69ee:	52f8      	mov	[X], A

000069f0 <.LM8>:

    /* Subscribe to errors reporting */
    uint8_t* idx = &ld_ErrorDetectedMultipleHandler.eventsCount;
    if (*idx < ld_ErrorDetectedMultipleHandler.eventsMaxLength) {
    69f0:	62d8 11cf 	lod	AL, 0x11cf <.LASF908+0x2>
    69f4:	5cf2      	usex	A
    69f6:	7ee2      	lod	X, A
    69f8:	62d8 11ce 	lod	AL, 0x11ce <.LASF908+0x1>
    69fc:	8ed8 11cf 	cmp	AL, 0x11cf <.LASF908+0x2>
    6a00:	1a0c      	jule	0x6a1a <.L3>

00006a02 <.LM9>:
        ld_ErrorDetectedMultipleHandler.eventHandlerBuffer[*idx] = l_ErrorDetected;
    6a02:	442e      	asl	X
    6a04:	72d8 11cc 	lod	A, 0x11cc <_ld_ErrorDetectedMultipleHandler>
    6a08:	22e2      	add	X, A
    6a0a:	72da 3789 	lod	A, #14217
    6a0e:	52f8      	mov	[X], A

00006a10 <.LM10>:
        *idx = *idx + 1;
    6a10:	62d8 11cf 	lod	AL, 0x11cf <.LASF908+0x2>
    6a14:	8001      	add	AL, #1
    6a16:	42d8 11cf 	mov	0x11cf <.LASF908+0x2>, AL

00006a1a <.L3>:
    }

#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
    /* Diagnostic frames: node configuration / identification */
    (void)ldt_SubscribeMultipleHandler(plinEventTable->ldt_Request, ld_DiagRequest);
    6a1a:	7ee6      	lod	X, Y
    6a1c:	201a      	add	X, #26
    6a1e:	54ca 35d9 	pushw	#13785

00006a22 <.LCFI4>:
    6a22:	72f8      	lod	A, [X]
    6a24:	82db 1ee8 	callf	0x3dd0 <_ldt_SubscribeMultipleHandler>

00006a28 <.LM12>:
    plinEventTable->ldt_GetLINNAD = ld_GetLINNAD;
    6a28:	7ed8 1002 	lod	X, 0x1002 <_plinEventTable>
    6a2c:	2014      	add	X, #20
    6a2e:	72da 35b0 	lod	A, #13744
    6a32:	52f8      	mov	[X], A
    6a34:	5c01      	dec	S, #2

00006a36 <.L1>:
     * Note: MLX LIN API shall be initialized first with proper settings and only TL then */
    if (ml_Init(SL_LIN_AUTOBAUDRATE_MODE, SL_LIN_BAUDRATE, l_s_ver, MLX4_FPLL) == ML_SUCCESS) {
        /* Initialize MLX LIN API event table */
        l_mls_InitEventTable();
    }
}
    6a36:	5401      	ret

00006a38 <_l_sys_irq_disable>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    6a38:	72e3      	lod	A, M

00006a3a <.LBE12>:
l_irqmask l_sys_irq_disable(void)
{
    l_u16 mreg_saved = builtin_mlx16_get_status();

    /* Keep User-bit unchanged */
    builtin_mlx16_set_status((mreg_saved & ~((l_u16)7u << 8)) |
    6a3a:	7ee2      	lod	X, A
    6a3c:	36da f8ff 	and	X, #63743
    6a40:	26da 0400 	or	X, #1024

00006a44 <.LBB14>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    6a44:	5ee3      	mov	M, X

00006a46 <.LBE14>:
                             (((l_u16)LINAPI_RESOURCES_BLOCKING_PRIORITY & 7u) << 8));
    return mreg_saved;
}
    6a46:	5401      	ret

00006a48 <_l_sys_irq_restore>:
    6a48:	52e3      	mov	M, A

00006a4a <.LBE16>:
 * @return void
 */
void l_sys_irq_restore(l_irqmask previous)
{
    builtin_mlx16_set_status(previous);
}
    6a4a:	5401      	ret

00006a4c <_ld_read_configuration>:
 * @return  Status:
 * - LD_READ_OK             - if the service was successful;
 * - LD_LENGTH_TOO_SHORT    - if the configuration size is greater than the length.
 */
l_u8 ld_read_configuration (l_ifc_handle iii, l_u8* const data, l_u8* const length)
{
    6a4c:	5805      	inc	S, #6

00006a4e <.LBB8>:
    /* Flash version - ignore */
    (void) iii;

    ENTER_STD_LIN_API_ATOMIC_SECTION();
    6a4e:	17f4      	call	0x6a38 <_l_sys_irq_disable>

00006a50 <.LVL1>:
    6a50:	5205      	mov	[S-6], A

00006a52 <.LBE8>:
 * @return  Status:
 * - LD_READ_OK             - if the service was successful;
 * - LD_LENGTH_TOO_SHORT    - if the configuration size is greater than the length.
 */
l_u8 ld_read_configuration (l_ifc_handle iii, l_u8* const data, l_u8* const length)
{
    6a52:	7e0b      	lod	X, [S-12]

00006a54 <.LM4>:
    ENTER_STD_LIN_API_ATOMIC_SECTION();

    uint_fast8_t i;     /* iterator */
    l_u8 retVal;

    if (*length < (SL_NUMBER_OF_DYNAMIC_MESSAGES + 1U)) {
    6a54:	62f8      	lod	AL, [X]

00006a56 <.LVL3>:
    6a56:	8c06      	cmp	AL, #6
    6a58:	1e09      	jug	0x6a6c <.L2>

00006a5a <.LM5>:
        /* returns proper length to the application */
        *length = SL_NUMBER_OF_DYNAMIC_MESSAGES + 1U;
    6a5a:	6007      	lod	AL, #7
    6a5c:	42f8      	mov	[X], AL

00006a5e <.LM6>:
        retVal = (l_u8)LD_LENGTH_TOO_SHORT;
    6a5e:	7801      	lod	Y, #1

00006a60 <.L3>:
 *
 */

STATIC INLINE void l_sys_irq_restore_pointer (const l_irqmask *p)
{
    l_sys_irq_restore(*p);
    6a60:	7205      	lod	A, [S-6]
    6a62:	5a01      	mov	[S-2], Y
    6a64:	17f1      	call	0x6a48 <_l_sys_irq_restore>

00006a66 <.LBE9>:
        *length = SL_NUMBER_OF_DYNAMIC_MESSAGES + 1U;
        retVal = (l_u8)LD_READ_OK;
    }
    return retVal;
    EXIT_STD_LIN_API_ATOMIC_SECTION();
}
    6a66:	7a01      	lod	Y, [S-2]
    6a68:	72e6      	lod	A, Y
    6a6a:	5407      	ret	#8

00006a6c <.L2>:
 * @return  Status:
 * - LD_READ_OK             - if the service was successful;
 * - LD_LENGTH_TOO_SHORT    - if the configuration size is greater than the length.
 */
l_u8 ld_read_configuration (l_ifc_handle iii, l_u8* const data, l_u8* const length)
{
    6a6c:	7e09      	lod	X, [S-10]

00006a6e <.LM10>:
        /* returns proper length to the application */
        *length = SL_NUMBER_OF_DYNAMIC_MESSAGES + 1U;
        retVal = (l_u8)LD_LENGTH_TOO_SHORT;
    } else {
#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
        data[0] = ml_ConfiguredNAD;
    6a6e:	62d8 1024 	lod	AL, 0x1024 <_ml_ConfiguredNAD>
    6a72:	42f8      	mov	[X], AL

00006a74 <.LM11>:
#else
        data[0] = 0;
#endif /* SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012 */

        /* other data filled in by assignFrameIdRange */
        for (i = 0U; i < SL_NUMBER_OF_DYNAMIC_MESSAGES; i++) {
    6a74:	7c00      	lod	X, #0
    6a76:	7006      	lod	A, #6

00006a78 <.L4>:
            data[i+1U] = node_configuration[i];
    6a78:	7aee      	lod	Y, X
    6a7a:	e001      	add	Y, #1
    6a7c:	5a03      	mov	[S-4], Y
    6a7e:	22da 11d8 	add	X, #4568

00006a82 <.LVL10>:
    6a82:	7a09      	lod	Y, [S-10]
    6a84:	e203      	add	Y, [S-4]
    6a86:	0ea7      	lod	C, ML.7
    6a88:	54cc      	movsb	[Y++], [X++]

00006a8a <.LVL11>:
    6a8a:	7e03      	lod	X, [S-4]

00006a8c <.LM13>:
#else
        data[0] = 0;
#endif /* SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012 */

        /* other data filled in by assignFrameIdRange */
        for (i = 0U; i < SL_NUMBER_OF_DYNAMIC_MESSAGES; i++) {
    6a8c:	a0ff      	add	A, #-1
    6a8e:	1d74      	jne	0x6a78 <.L4>

00006a90 <.LM14>:
            data[i+1U] = node_configuration[i];
        }

        /* returns actual length to the application */
        *length = SL_NUMBER_OF_DYNAMIC_MESSAGES + 1U;
    6a90:	7e0b      	lod	X, [S-12]
    6a92:	6007      	lod	AL, #7
    6a94:	42f8      	mov	[X], AL

00006a96 <.LM15>:
        retVal = (l_u8)LD_READ_OK;
    6a96:	7800      	lod	Y, #0
    6a98:	07e3      	jmp	0x6a60 <.L3>

00006a9a <_ld_set_configuration>:
 * - LD_LENGTH_NOT_CORRECT  - if the required size of the configuration is not equal to the given length;
 * - LD_DATA_ERROR          - the set of configuration could not be made.
 * @note This function shall NOT be used in other interrupts which can interrupt LIN ISR.
 */
l_u8 ld_set_configuration (l_ifc_handle iii, const l_u8* const data, l_u16 length)
{
    6a9a:	5809      	inc	S, #10

00006a9c <.LBB18>:
    /* Flash version - ignore */
    (void) iii;

    ENTER_STD_LIN_API_ATOMIC_SECTION();
    6a9c:	17cd      	call	0x6a38 <_l_sys_irq_disable>

00006a9e <.LVL14>:
    6a9e:	5209      	mov	[S-10], A

00006aa0 <.LBE18>:
 * - LD_LENGTH_NOT_CORRECT  - if the required size of the configuration is not equal to the given length;
 * - LD_DATA_ERROR          - the set of configuration could not be made.
 * @note This function shall NOT be used in other interrupts which can interrupt LIN ISR.
 */
l_u8 ld_set_configuration (l_ifc_handle iii, const l_u8* const data, l_u16 length)
{
    6aa0:	7e0d      	lod	X, [S-14]

00006aa2 <.LVL16>:
    6aa2:	720f      	lod	A, [S-16]

00006aa4 <.LBB19>:
 */
static l_u8 ld_set_configuration_helper (const l_u8* const data, l_u16 length)
{
    uint_fast8_t i; /* iterator */

    if ((SL_NUMBER_OF_DYNAMIC_MESSAGES + 1U) != length) {
    6aa4:	ac07      	cmp	A, #7
    6aa6:	1901      	je	0x6aaa <.LASF1864+0x2>
    6aa8:	0050      	jmp	0x6b4a <.L14>
    6aaa:	7aee      	lod	Y, X
    6aac:	e001      	add	Y, #1
    6aae:	5a07      	mov	[S-8], Y
    6ab0:	7800      	lod	Y, #0

00006ab2 <.L12>:
    }
    /* else: length is Ok, continue processing .. */


    for (i = 0U; i < SL_NUMBER_OF_DYNAMIC_MESSAGES; i++) {
        if (data[i+1U] == 0U) { /* unassign this message index */
    6ab2:	7e07      	lod	X, [S-8]
    6ab4:	62de      	lod	AL, [X++]
    6ab6:	5e07      	mov	[S-8], X
    6ab8:	4203      	mov	[S-4], AL
    6aba:	5cf2      	usex	A
    6abc:	7ee2      	lod	X, A
    6abe:	6203      	lod	AL, [S-4]
    6ac0:	1d32      	jne	0x6b26 <.L8>

00006ac2 <.LM21>:
            (void)ml_Disconnect();
    6ac2:	5a05      	mov	[S-6], Y
    6ac4:	82db 11c0 	callf	0x2380 <_ml_Disconnect>

00006ac8 <.LM22>:
            if (ml_DisableMessage((ml_MessageID_t)i) != ML_SUCCESS) {
    6ac8:	7a05      	lod	Y, [S-6]
    6aca:	62e8      	lod	AL, YL
    6acc:	5cf2      	usex	A
    6ace:	82db 1145 	callf	0x228a <_ml_DisableMessage>

00006ad2 <.L24>:
    6ad2:	7a05      	lod	Y, [S-6]
    6ad4:	ac00      	cmp	A, #0
    6ad6:	1909      	je	0x6aea <.L9>

00006ad8 <.LM23>:
                (void)ml_Connect();
    6ad8:	82db 11be 	callf	0x237c <_ml_Connect>

00006adc <.LM24>:
                return (l_u8)LD_DATA_ERROR;
    6adc:	7802      	lod	Y, #2

00006ade <.L7>:
    6ade:	7209      	lod	A, [S-10]
    6ae0:	5a05      	mov	[S-6], Y
    6ae2:	17b2      	call	0x6a48 <_l_sys_irq_restore>

00006ae4 <.LBE22>:

    ENTER_STD_LIN_API_ATOMIC_SECTION();
    l_u8 retVal = ld_set_configuration_helper (data, length);
    return retVal;
    EXIT_STD_LIN_API_ATOMIC_SECTION();
}
    6ae4:	7a05      	lod	Y, [S-6]
    6ae6:	72e6      	lod	A, Y
    6ae8:	540b      	ret	#12

00006aea <.L9>:
                (void)ml_Connect();
                return (l_u8)LD_DATA_ERROR;
            } else {
                /* it's successful: do nothing */
            }
            (void)ml_Connect();
    6aea:	5a05      	mov	[S-6], Y
    6aec:	82db 11be 	callf	0x237c <_ml_Connect>
    6af0:	7a05      	lod	Y, [S-6]

00006af2 <.L10>:
        return (l_u8)LD_LENGTH_NOT_CORRECT;
    }
    /* else: length is Ok, continue processing .. */


    for (i = 0U; i < SL_NUMBER_OF_DYNAMIC_MESSAGES; i++) {
    6af2:	e001      	add	Y, #1

00006af4 <.LVL26>:
    6af4:	ec06      	cmp	Y, #6
    6af6:	1d5d      	jne	0x6ab2 <.L12>

00006af8 <.LM29>:
            /* no other special id, continue processing .. */
        }
    }

    /* if no return occurred, new configuration can be stored, otherwise the previous one remains */
    for (i = 0U; i < SL_NUMBER_OF_DYNAMIC_MESSAGES; i++) {
    6af8:	7000      	lod	A, #0
    6afa:	5a01      	mov	[S-2], Y

00006afc <.L13>:
        node_configuration[i] = data[i+1U];
    6afc:	7ae2      	lod	Y, A
    6afe:	e001      	add	Y, #1
    6b00:	5a07      	mov	[S-8], Y
    6b02:	7e0d      	lod	X, [S-14]
    6b04:	22e6      	add	X, Y
    6b06:	a2da 11d8 	add	A, #4568

00006b0a <.LVL28>:
    6b0a:	7ae2      	lod	Y, A
    6b0c:	0ea7      	lod	C, ML.7
    6b0e:	54cc      	movsb	[Y++], [X++]

00006b10 <.LVL29>:
    6b10:	7207      	lod	A, [S-8]

00006b12 <.LM31>:
            /* no other special id, continue processing .. */
        }
    }

    /* if no return occurred, new configuration can be stored, otherwise the previous one remains */
    for (i = 0U; i < SL_NUMBER_OF_DYNAMIC_MESSAGES; i++) {
    6b12:	7e01      	lod	X, [S-2]
    6b14:	20ff      	add	X, #-1
    6b16:	5e01      	mov	[S-2], X
    6b18:	1d71      	jne	0x6afc <.L13>

00006b1a <.LM32>:
        /* else: don't store PID */
#endif /* !SL_vSAE_J2602_2012 && SL_EN_EVENT_TRIGGERED_FRAMES */
    }

#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
    ml_ConfiguredNAD = data[0];
    6b1a:	7e0d      	lod	X, [S-14]
    6b1c:	62f8      	lod	AL, [X]
    6b1e:	42d8 1024 	mov	0x1024 <_ml_ConfiguredNAD>, AL

00006b22 <.LM33>:
#endif /* SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012 */

    return (l_u8)LD_SET_OK;
    6b22:	7800      	lod	Y, #0
    6b24:	07dc      	jmp	0x6ade <.L7>

00006b26 <.L8>:
                return (l_u8)LD_DATA_ERROR;
            } else {
                /* it's successful: do nothing */
            }
            (void)ml_Connect();
        } else if (data[i+1U] != 0xFFU) {   /* 0xFF is "don't care" value */
    6b26:	2eda 00ff 	cmp	X, #255
    6b2a:	1963      	je	0x6af2 <.L10>

00006b2c <.LM35>:
            (void)ml_Disconnect();
    6b2c:	5a05      	mov	[S-6], Y
    6b2e:	82db 11c0 	callf	0x2380 <_ml_Disconnect>

00006b32 <.LM36>:
            if (ml_AssignFrameToMessageID((ml_MessageID_t)i, data[i+1U]) != ML_SUCCESS) {
    6b32:	7e07      	lod	X, [S-8]
    6b34:	20ff      	add	X, #-1
    6b36:	62f8      	lod	AL, [X]
    6b38:	5cf2      	usex	A
    6b3a:	52df      	push	A

00006b3c <.LCFI2>:
    6b3c:	7a07      	lod	Y, [S-8]
    6b3e:	62e8      	lod	AL, YL
    6b40:	5cf2      	usex	A
    6b42:	82db 1142 	callf	0x2284 <_ml_AssignFrameToMessageID>
    6b46:	5c01      	dec	S, #2

00006b48 <.LCFI3>:
    6b48:	07c4      	jmp	0x6ad2 <.L24>

00006b4a <.L14>:
static l_u8 ld_set_configuration_helper (const l_u8* const data, l_u16 length)
{
    uint_fast8_t i; /* iterator */

    if ((SL_NUMBER_OF_DYNAMIC_MESSAGES + 1U) != length) {
        return (l_u8)LD_LENGTH_NOT_CORRECT;
    6b4a:	7801      	lod	Y, #1
    6b4c:	07c8      	jmp	0x6ade <.L7>

00006b4e <_ld_DiagInit>:
/** (Re)initialize the configuration/identification layer
 * @return  void
 */
void ld_DiagInit (void)
{
    pendingSlaveResponse = respNoResponse;
    6b4e:	7000      	lod	A, #0
    6b50:	52d8 109c 	mov	0x109c <_pendingSlaveResponse>, A

00006b54 <.LM44>:
    ml_ConfiguredNAD = ml_InitialNAD;
    6b54:	62d8 5b90 	lod	AL, 0x5b90 <_ml_InitialNAD>
    6b58:	0ea7      	lod	C, ML.7
    6b5a:	42d8 1024 	mov	0x1024 <_ml_ConfiguredNAD>, AL

00006b5e <.LM45>:
}
    6b5e:	5401      	ret

00006b60 <_ld_GetLINNAD>:
 * @return Current NAD.
 */
l_u8 ld_GetLINNAD (l_u8 NAD)
{
    (void)NAD; /* There is no interest to track other than current NADs on the bus */
    l_u8 retVal = ml_ConfiguredNAD;
    6b60:	66d8 1024 	lod	YL, 0x1024 <_ml_ConfiguredNAD>
    6b64:	5cf6      	usex	Y

00006b66 <.LM51>:
#if SL_EN_ASSIGN_NAD_SERVICE
    /* Assign NAD request */
    if (ML_SLAVE_FRAME_DATA_BUFFER[2] == 0xB0u) {
    6b66:	62d8 1006 	lod	AL, 0x1006 <_ml_Data+0x2>

00006b6a <.LVL39>:
    6b6a:	8cb0      	cmp	AL, #-80
    6b6c:	1d03      	jne	0x6b74 <.L30>

00006b6e <.LM52>:
        retVal = ml_InitialNAD;
    6b6e:	66d8 5b90 	lod	YL, 0x5b90 <_ml_InitialNAD>
    6b72:	5cf6      	usex	Y

00006b74 <.L30>:
    }
#endif /* SL_EN_ASSIGN_NAD_SERVICE */
    return retVal;
}
    6b74:	72e6      	lod	A, Y
    6b76:	5401      	ret

00006b78 <_isSupplierIdValid>:
    l_u16 supplierID;
    l_u16 cur_supplierID;
    ml_Status_t status;

    /* supplierID word could be on odd address, so get LSB, MSB separately */
    supplierID = ((l_u16)data[1] << 8 ) | data[0];
    6b78:	7ee2      	lod	X, A
    6b7a:	62f8      	lod	AL, [X]
    6b7c:	6af9      	lod	AH, [X+1]

00006b7e <.LM56>:
    cur_supplierID = (l_u16)ml_ProductID[0]
    6b7e:	66d8 5b8a 	lod	YL, 0x5b8a <_ml_ProductID>
    6b82:	6ed8 5b8b 	lod	YH, 0x5b8b <_ml_ProductID+0x1>

00006b86 <.LM57>:
                     | (((l_u16)ml_ProductID[1]) << 8);

    if (   (supplierID == cur_supplierID)
    6b86:	aee6      	cmp	A, Y
    6b88:	1904      	je	0x6b92 <.L33>

00006b8a <.LM58>:
           || (supplierID == 0x7FFFU /* wildcard */)) {
        status = ML_SUCCESS;
    6b8a:	aeda 7fff 	cmp	A, #32767
    6b8e:	5ca2      	sne	A
    6b90:	5401      	ret

00006b92 <.L33>:
    6b92:	7000      	lod	A, #0

00006b94 <.LM59>:
    } else {
        status = ML_FAILURE;
    }

    return status;
}
    6b94:	5401      	ret

00006b96 <_isFunctionIdValid>:
    l_u16 functionID;
    l_u16 cur_functionID;
    ml_Status_t status;

    /* functionID word could be on odd address, so get LSB, MSB separately */
    functionID = ((l_u16)data[1] << 8) | data[0];
    6b96:	7ee2      	lod	X, A
    6b98:	62f8      	lod	AL, [X]
    6b9a:	6af9      	lod	AH, [X+1]

00006b9c <.LM62>:
    cur_functionID = ((l_u16)ml_ProductID[2])
    6b9c:	66d8 5b8c 	lod	YL, 0x5b8c <_ml_ProductID+0x2>
    6ba0:	6ed8 5b8d 	lod	YH, 0x5b8d <_ml_ProductID+0x3>

00006ba4 <.LM63>:
                     | (((l_u16)ml_ProductID[3]) << 8);

    if (   (functionID == cur_functionID)
    6ba4:	aee6      	cmp	A, Y
    6ba6:	1903      	je	0x6bae <.L36>

00006ba8 <.LM64>:
           || (functionID == 0xFFFFU /* wildcard */)) {
        status = ML_SUCCESS;
    6ba8:	acff      	cmp	A, #-1
    6baa:	5ca2      	sne	A
    6bac:	5401      	ret

00006bae <.L36>:
    6bae:	7000      	lod	A, #0

00006bb0 <.LM65>:
    } else {
        status = ML_FAILURE;
    }

    return status;
}
    6bb0:	5401      	ret

00006bb2 <_ld_DiagRequest>:
 * @return Status:
 * - true  There is data to send;
 * - false There is nothing to send (no response).
 */
bool ld_DiagRequest(LINDiagTransfer_t *transfer)
{
    6bb2:	5809      	inc	S, #10

00006bb4 <.LCFI4>:
    6bb4:	7ae2      	lod	Y, A

00006bb6 <.LM67>:
    pDiagTransfer = transfer;
    6bb6:	52d8 109a 	mov	0x109a <_pDiagTransfer>, A

00006bba <.LM68>:

    /* A new MRF received,
     * so reset pending response
     */
    pendingSlaveResponse = respNoResponse;
    6bba:	7000      	lod	A, #0

00006bbc <.LVL48>:
    6bbc:	52d8 109c 	mov	0x109c <_pendingSlaveResponse>, A

00006bc0 <.LM69>:

    switch (pDiagTransfer->request.reqSId) {
    6bc0:	62f0      	lod	AL, [Y]
    6bc2:	4205      	mov	[S-6], AL
    6bc4:	6205      	lod	AL, [S-6]
    6bc6:	8cb2      	cmp	AL, #-78
    6bc8:	1d01      	jne	0x6bcc <.Ldebug_info0+0x2>
    6bca:	0061      	jmp	0x6c8e <.L39>
    6bcc:	5cf2      	usex	A
    6bce:	aeda 00b2 	cmp	A, #178
    6bd2:	1e11      	jug	0x6bf6 <.L40>
    6bd4:	aeda 00b0 	cmp	A, #176
    6bd8:	1d01      	jne	0x6bdc <.L38>
    6bda:	0040      	jmp	0x6c5c <.L41>

00006bdc <.L38>:
 * - false There is nothing to send (no response).
 */
static bool ld_DiagResponse (void)
{
    bool retVal = true;
    SlaveResponse_t thisPendingSlaveResponse = pendingSlaveResponse;
    6bdc:	7ed8 109c 	lod	X, 0x109c <_pendingSlaveResponse>

00006be0 <.LM71>:

    /* reset pending response after processing */
    /* speculative next state/response, overwrite if otherwise */
    pendingSlaveResponse = respNoResponse;
    6be0:	7000      	lod	A, #0
    6be2:	52d8 109c 	mov	0x109c <_pendingSlaveResponse>, A

00006be6 <.LM72>:

    switch (thisPendingSlaveResponse) {
    6be6:	20ff      	add	X, #-1

00006be8 <.LVL51>:
    6be8:	2c06      	cmp	X, #6
    6bea:	1a01      	jule	0x6bee <.LASF1061+0x2>
    6bec:	00d2      	jmp	0x6d92 <.L65>
    6bee:	442e      	asl	X
    6bf0:	22da 5b26 	add	X, #23334
    6bf4:	76f8      	jmp	[X]

00006bf6 <.L40>:
    /* A new MRF received,
     * so reset pending response
     */
    pendingSlaveResponse = respNoResponse;

    switch (pDiagTransfer->request.reqSId) {
    6bf6:	aeda 00b6 	cmp	A, #182
    6bfa:	1d01      	jne	0x6bfe <.LASF1008+0x3>
    6bfc:	0086      	jmp	0x6d0a <.L42>
    6bfe:	aeda 00b7 	cmp	A, #183
    6c02:	1d6c      	jne	0x6bdc <.L38>

00006c04 <.LBB43>:
 * @return: Requested response or respNoResponse.
 */
static SlaveResponse_t assignFrameIdRange (void)
{
    /* wrong PCI */
    if (pDiagTransfer->request.dataLen != 0x05U) { /* if (PCI-1) is not correct .. */
    6c04:	72f2      	lod	A, [Y+2]
    6c06:	ac05      	cmp	A, #5
    6c08:	1d27      	jne	0x6c58 <.L49>

00006c0a <.LM75>:
        return respNoResponse;
    }

    /* invalid start index */
    if (pDiagTransfer->request.data[0] >= SL_NUMBER_OF_DYNAMIC_MESSAGES) {
    6c0a:	62f4      	lod	AL, [Y+4]
    6c0c:	4207      	mov	[S-8], AL
    6c0e:	8c05      	cmp	AL, #5
    6c10:	1e23      	jug	0x6c58 <.L49>

00006c12 <.LBB45>:
    } else {
        l_u8 *pid;
        l_u8 index;
        l_u8 i;

        index = pDiagTransfer->request.data[0] + 3u; /* index of the last frame in the range */
    6c12:	8003      	add	AL, #3
    6c14:	5cf2      	usex	A
    6c16:	5205      	mov	[S-6], A

00006c18 <.LM77>:
        pid = &pDiagTransfer->request.data[4]; /* PID of the last frame in the range */
    6c18:	e008      	add	Y, #8

00006c1a <.LVL55>:
    6c1a:	6207      	lod	AL, [S-8]

00006c1c <.LVL56>:
    6c1c:	80ff      	add	AL, #-1
    6c1e:	5cf2      	usex	A
    6c20:	5207      	mov	[S-8], A

00006c22 <.L56>:

        for (i = 0U; i < 4U; i++) {
            if (*pid != 0xFFU) {                                /* if id is NOT 0xFF .. */
    6c22:	62f0      	lod	AL, [Y]
    6c24:	8cff      	cmp	AL, #-1
    6c26:	1d01      	jne	0x6c2a <.LM79>
    6c28:	0082      	jmp	0x6d2e <.L50>

00006c2a <.LM79>:
                if (index >= SL_NUMBER_OF_DYNAMIC_MESSAGES) {   /* if wrong index for valid pid .. */
    6c2a:	7205      	lod	A, [S-6]
    6c2c:	ac05      	cmp	A, #5
    6c2e:	1e14      	jug	0x6c58 <.L49>

00006c30 <.LM80>:
                    return respNoResponse;
                } else {                                          /* proper index */
                    (void)ml_Disconnect();
    6c30:	5a03      	mov	[S-4], Y
    6c32:	82db 11c0 	callf	0x2380 <_ml_Disconnect>

00006c36 <.LM81>:
                    if (*pid == 0x00U) {                        /* unassign */
    6c36:	7a03      	lod	Y, [S-4]
    6c38:	62f0      	lod	AL, [Y]
    6c3a:	4201      	mov	[S-2], AL
    6c3c:	5cf2      	usex	A
    6c3e:	7ee2      	lod	X, A
    6c40:	6201      	lod	AL, [S-2]
    6c42:	1901      	je	0x6c46 <.LM82>
    6c44:	007e      	jmp	0x6d42 <.L51>

00006c46 <.LM82>:
                        if (ml_DisableMessage(index) != ML_SUCCESS) {
    6c46:	7205      	lod	A, [S-6]
    6c48:	82db 1145 	callf	0x228a <_ml_DisableMessage>
    6c4c:	7a03      	lod	Y, [S-4]
    6c4e:	ac00      	cmp	A, #0
    6c50:	1d01      	jne	0x6c54 <.L55>
    6c52:	0065      	jmp	0x6d1e <.L52>

00006c54 <.L55>:
                            (void)ml_Connect();
    6c54:	82db 11be 	callf	0x237c <_ml_Connect>

00006c58 <.L49>:
 */
static SlaveResponse_t assignFrameIdRange (void)
{
    /* wrong PCI */
    if (pDiagTransfer->request.dataLen != 0x05U) { /* if (PCI-1) is not correct .. */
        return respNoResponse;
    6c58:	7000      	lod	A, #0
    6c5a:	0016      	jmp	0x6c88 <.L53>

00006c5c <.L41>:
 *
 * @return: Requested response or respNoResponse
 */
static SlaveResponse_t assignNAD (void)
{
    if (pDiagTransfer->request.dataLen != 0x05u) {
    6c5c:	72f2      	lod	A, [Y+2]
    6c5e:	ac05      	cmp	A, #5
    6c60:	1d7b      	jne	0x6c58 <.L49>

00006c62 <.LM86>:
        return respNoResponse;
    }
    /* else: (PCI-1) is valid, continue processing .. */

    /* Validate SupplierID [3..4] and FunctionID [5..6] */
    if ( (isSupplierIdValid(&pDiagTransfer->request.data[0]) == ML_SUCCESS) &&
    6c62:	72e6      	lod	A, Y
    6c64:	a004      	add	A, #4
    6c66:	5a03      	mov	[S-4], Y
    6c68:	1787      	call	0x6b78 <_isSupplierIdValid>

00006c6a <.LVL63>:
    6c6a:	5205      	mov	[S-6], A
    6c6c:	7a03      	lod	Y, [S-4]
    6c6e:	ac00      	cmp	A, #0
    6c70:	1d73      	jne	0x6c58 <.L49>

00006c72 <.LM87>:
         (isFunctionIdValid(&pDiagTransfer->request.data[2]) == ML_SUCCESS) ) {
    6c72:	72e6      	lod	A, Y
    6c74:	a006      	add	A, #6
    6c76:	178f      	call	0x6b96 <_isFunctionIdValid>

00006c78 <.LM88>:
        return respNoResponse;
    }
    /* else: (PCI-1) is valid, continue processing .. */

    /* Validate SupplierID [3..4] and FunctionID [5..6] */
    if ( (isSupplierIdValid(&pDiagTransfer->request.data[0]) == ML_SUCCESS) &&
    6c78:	7a03      	lod	Y, [S-4]
    6c7a:	ac00      	cmp	A, #0
    6c7c:	1d6d      	jne	0x6c58 <.L49>

00006c7e <.LM89>:
         (isFunctionIdValid(&pDiagTransfer->request.data[2]) == ML_SUCCESS) ) {
        ml_ConfiguredNAD = pDiagTransfer->request.data[4];   /* new NAD */
    6c7e:	e008      	add	Y, #8
    6c80:	62f0      	lod	AL, [Y]
    6c82:	42d8 1024 	mov	0x1024 <_ml_ConfiguredNAD>, AL

00006c86 <.LM90>:
        return respPositiveAssignNAD;
    6c86:	7004      	lod	A, #4

00006c88 <.L53>:
            break; /* !case 0xB6 */
#endif /* SL_vLIN_2_1_plus || SL_vISO17987_2016 */

#if SL_vLIN_2_1_plus || SL_vISO17987_2016
        case 0xB7: /* Assign Frame ID range */
            pendingSlaveResponse = assignFrameIdRange();
    6c88:	52d8 109c 	mov	0x109c <_pendingSlaveResponse>, A

00006c8c <.LM92>:
            break; /* !case 0xB7 */
    6c8c:	07a7      	jmp	0x6bdc <.L38>

00006c8e <.L39>:
 */
static SlaveResponse_t readByIdentifier (void)
{
    SlaveResponse_t retVal;

    if (pDiagTransfer->request.dataLen != 0x05u) {
    6c8e:	72f2      	lod	A, [Y+2]
    6c90:	ac05      	cmp	A, #5
    6c92:	1901      	je	0x6c96 <.LM94>
    6c94:	0034      	jmp	0x6cfe <.L70>

00006c96 <.LM94>:
        retVal = respNoResponse;
    } else {
        /* else: (PCI-1) is valid, continue processing .. */

        /* Validate SupplierID [4..5] and FunctionID [6..7] */
        if ( (isSupplierIdValid(&pDiagTransfer->request.data[1]) == ML_SUCCESS) &&
    6c96:	72e6      	lod	A, Y
    6c98:	a005      	add	A, #5
    6c9a:	5a03      	mov	[S-4], Y
    6c9c:	176d      	call	0x6b78 <_isSupplierIdValid>

00006c9e <.LVL66>:
    6c9e:	5205      	mov	[S-6], A
    6ca0:	7a03      	lod	Y, [S-4]
    6ca2:	ac00      	cmp	A, #0
    6ca4:	1d2c      	jne	0x6cfe <.L70>

00006ca6 <.LM95>:
             (isFunctionIdValid(&pDiagTransfer->request.data[3]) == ML_SUCCESS) ) {
    6ca6:	72e6      	lod	A, Y
    6ca8:	a007      	add	A, #7
    6caa:	1775      	call	0x6b96 <_isFunctionIdValid>

00006cac <.LM96>:
        retVal = respNoResponse;
    } else {
        /* else: (PCI-1) is valid, continue processing .. */

        /* Validate SupplierID [4..5] and FunctionID [6..7] */
        if ( (isSupplierIdValid(&pDiagTransfer->request.data[1]) == ML_SUCCESS) &&
    6cac:	7a03      	lod	Y, [S-4]
    6cae:	ac00      	cmp	A, #0
    6cb0:	1d26      	jne	0x6cfe <.L70>

00006cb2 <.LM97>:
             (isFunctionIdValid(&pDiagTransfer->request.data[3]) == ML_SUCCESS) ) {

            /* if supplier/function IDs are valid .. */

            switch (pDiagTransfer->request.data[0]) {    /* check IDs ..  */
    6cb2:	62f4      	lod	AL, [Y+4]
    6cb4:	4205      	mov	[S-6], AL
    6cb6:	6205      	lod	AL, [S-6]
    6cb8:	1924      	je	0x6d02 <.L72>
    6cba:	5cf2      	usex	A
    6cbc:	7ee2      	lod	X, A
    6cbe:	ac01      	cmp	A, #1
    6cc0:	1d04      	jne	0x6cca <.L80>

00006cc2 <.LM98>:
                    retVal = respLinProductID;
                    break;

#if SL_EN_SERIAL_NUMBER_CALLOUT
                case 0x01:                      /* ID: Serial number (optional) */
                    retVal = respSerialNumber;
    6cc2:	7803      	lod	Y, #3

00006cc4 <.L45>:
            break;
#endif /* SL_vLIN_2_0 || (SL_vSAE_J2602_2012 && SL_EN_ASSIGN_FRAME_ID_SERVICE) */

#if SL_vLIN_2_x || SL_vISO17987_2016 || (SL_vSAE_J2602_2012 && SL_EN_READ_BY_ID_SERVICE)
        case 0xB2: /* Read by Identifier request */
            pendingSlaveResponse = readByIdentifier();
    6cc4:	5ad8 109c 	mov	0x109c <_pendingSlaveResponse>, Y

00006cc8 <.LM100>:
            break;
    6cc8:	0789      	jmp	0x6bdc <.L38>

00006cca <.L80>:
                    break;
#endif /* SL_vISO17987_2016 && SL_EN_NCF_LDF_VERSION */

                default:
#if SL_EN_READ_BY_ID_CALLOUT
                    if ( (pDiagTransfer->request.data[0] > 31u ) && (pDiagTransfer->request.data[0] < 64u) ) {
    6cca:	6205      	lod	AL, [S-6]
    6ccc:	80e0      	add	AL, #-32
    6cce:	8c1f      	cmp	AL, #31
    6cd0:	1e1a      	jug	0x6d06 <.L73>

00006cd2 <.LBB52>:
                        l_u8 pci = 6; /* Default value */
    6cd2:	6006      	lod	AL, #6
    6cd4:	4209      	mov	[S-10], AL

00006cd6 <.LM103>:
                        l_u8 response = ld_read_by_id_callout (dummy,
                                                               pDiagTransfer->request.data[0],
                                                               (l_u8*)&pci,
                                                               pDiagTransfer->response.data);
    6cd6:	e004      	add	Y, #4

00006cd8 <.LM104>:

                default:
#if SL_EN_READ_BY_ID_CALLOUT
                    if ( (pDiagTransfer->request.data[0] > 31u ) && (pDiagTransfer->request.data[0] < 64u) ) {
                        l_u8 pci = 6; /* Default value */
                        l_u8 response = ld_read_by_id_callout (dummy,
    6cd8:	5adf      	push	Y

00006cda <.LCFI5>:
    6cda:	72ef      	lod	A, S
    6cdc:	a0f4      	add	A, #-12
    6cde:	52df      	push	A

00006ce0 <.LCFI6>:
    6ce0:	5edf      	push	X

00006ce2 <.LCFI7>:
    6ce2:	72d8 11d0 	lod	A, 0x11d0 <_dummy>
    6ce6:	161a      	call	0x691c <_ld_read_by_id_callout>
    6ce8:	7ae2      	lod	Y, A

00006cea <.LM105>:
                                                               pDiagTransfer->request.data[0],
                                                               (l_u8*)&pci,
                                                               pDiagTransfer->response.data);
                        pDiagTransfer->response.dataLen = (l_u16)pci - 1u; /* Convert PCI to data length */
    6cea:	7ed8 109a 	lod	X, 0x109a <_pDiagTransfer>
    6cee:	620f      	lod	AL, [S-16]

00006cf0 <.LVL70>:
    6cf0:	5cf2      	usex	A
    6cf2:	a0ff      	add	A, #-1
    6cf4:	52fa      	mov	[X+2], A

00006cf6 <.LM106>:
                        pDiagTransfer->response.respSId = RSID(SID_ReadById);
    6cf6:	60f2      	lod	AL, #-14
    6cf8:	42f8      	mov	[X], AL

00006cfa <.LVL71>:
    6cfa:	5c05      	dec	S, #6

00006cfc <.LCFI8>:
    6cfc:	07e3      	jmp	0x6cc4 <.L45>

00006cfe <.L70>:
{
    SlaveResponse_t retVal;

    if (pDiagTransfer->request.dataLen != 0x05u) {
        /* if (PCI-1) is not valid .. */
        retVal = respNoResponse;
    6cfe:	7800      	lod	Y, #0
    6d00:	07e1      	jmp	0x6cc4 <.L45>

00006d02 <.L72>:

            /* if supplier/function IDs are valid .. */

            switch (pDiagTransfer->request.data[0]) {    /* check IDs ..  */
                case 0x00:                      /* ID: LIN Product Identification */
                    retVal = respLinProductID;
    6d02:	7801      	lod	Y, #1
    6d04:	07df      	jmp	0x6cc4 <.L45>

00006d06 <.L73>:
                        retVal = (SlaveResponse_t)response;
                        break;
                    }
                    /* else : wrong ID */
#endif /* SL_EN_READ_BY_ID_CALLOUT */
                    retVal = respNegativeResponse;
    6d06:	7802      	lod	Y, #2
    6d08:	07dd      	jmp	0x6cc4 <.L45>

00006d0a <.L42>:
/** Process Save Configuration frame.
 * @return  void
 */
static SlaveResponse_t saveConfiguration (void)
{
    if (pDiagTransfer->request.dataLen != 0u) {
    6d0a:	72f2      	lod	A, [Y+2]
    6d0c:	1901      	je	0x6d10 <.LM111>
    6d0e:	07a4      	jmp	0x6c58 <.L49>

00006d10 <.LM111>:
        /* if (PCI-1) is not correct .. */
        return respNoResponse;
    }
    /* else: (PCI-1) is correct, continue processing .. */

    s_ifcStatus.mapped.SaveConfig = true;
    6d10:	7eda 11d2 	lod	X, #4562
    6d14:	62f8      	lod	AL, [X]
    6d16:	8440      	or	AL, #64
    6d18:	42f8      	mov	[X], AL

00006d1a <.LM112>:

    return respPositiveSaveConfig;
    6d1a:	7006      	lod	A, #6
    6d1c:	07b5      	jmp	0x6c88 <.L53>

00006d1e <.L52>:
                        }
                        /* else save unassignment to node_configuration */

#if ((SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE) || ((SL_vLIN_2_0 || SL_vSAE_J2602_2012) && \
                        SL_EN_SAVE_CONFIG_FUNC)
                        node_configuration[index] = 0x00U;
    6d1e:	7e05      	lod	X, [S-6]
    6d20:	22da 11d8 	add	X, #4568
    6d24:	42f8      	mov	[X], AL

00006d26 <.L54>:
                        }
                        /* else: don't store PID */
#endif /* !SL_vSAE_J2602_2012 && SL_EN_EVENT_TRIGGERED_FRAMES */
                    } /* assign */

                    (void)ml_Connect();
    6d26:	5a03      	mov	[S-4], Y
    6d28:	82db 11be 	callf	0x237c <_ml_Connect>
    6d2c:	7a03      	lod	Y, [S-4]

00006d2e <.L50>:
                } /* proper index */
            } else {   /* id is 0xFF .. */
                       /* .. skip PID from processing */
            }

            --pid;          /*lint !e960 : deviation MISRA 2004:17.4 pointer decrement */
    6d2e:	e0ff      	add	Y, #-1

00006d30 <.LM116>:
            --index;        /* get previous index */
    6d30:	6205      	lod	AL, [S-6]
    6d32:	80ff      	add	AL, #-1
    6d34:	5cf2      	usex	A
    6d36:	5205      	mov	[S-6], A

00006d38 <.LM117>:
        l_u8 i;

        index = pDiagTransfer->request.data[0] + 3u; /* index of the last frame in the range */
        pid = &pDiagTransfer->request.data[4]; /* PID of the last frame in the range */

        for (i = 0U; i < 4U; i++) {
    6d38:	ae07      	cmp	A, [S-8]
    6d3a:	1901      	je	0x6d3e <.LM118>
    6d3c:	0772      	jmp	0x6c22 <.L56>

00006d3e <.LM118>:

            --pid;          /*lint !e960 : deviation MISRA 2004:17.4 pointer decrement */
            --index;        /* get previous index */
        } /* for 4 pids */

        return respPositiveAssignFidRange;
    6d3e:	7005      	lod	A, #5

00006d40 <.LVL79>:
    6d40:	07a3      	jmp	0x6c88 <.L53>

00006d42 <.L51>:
#if ((SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE) || ((SL_vLIN_2_0 || SL_vSAE_J2602_2012) && \
                        SL_EN_SAVE_CONFIG_FUNC)
                        node_configuration[index] = 0x00U;
#endif /* ((SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE) || ((SL_vLIN_2_0 || SL_vSAE_J2602_2012) && SL_EN_SAVE_CONFIG_FUNC) */
                    } else {                                      /* assign */
                        if (ml_AssignFrameToMessageID(index,*pid) != ML_SUCCESS) {
    6d42:	5edf      	push	X

00006d44 <.LCFI9>:
    6d44:	7207      	lod	A, [S-8]
    6d46:	5a05      	mov	[S-6], Y
    6d48:	82db 1142 	callf	0x2284 <_ml_AssignFrameToMessageID>
    6d4c:	5c01      	dec	S, #2

00006d4e <.LCFI10>:
    6d4e:	7a03      	lod	Y, [S-4]
    6d50:	ac00      	cmp	A, #0
    6d52:	1901      	je	0x6d56 <.LM120>
    6d54:	077f      	jmp	0x6c54 <.L55>

00006d56 <.LM120>:
                        /* else: assignment was OK, continue processing */

#if ((SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE) || ((SL_vLIN_2_0 || SL_vSAE_J2602_2012) && \
                        SL_EN_SAVE_CONFIG_FUNC)
                        /* save assignment to node_configuration */
                        node_configuration[index] = *pid;
    6d56:	7e05      	lod	X, [S-6]
    6d58:	22da 11d8 	add	X, #4568
    6d5c:	0ea7      	lod	C, ML.7
    6d5e:	54c4      	movsb	[X++], [Y++]

00006d60 <.LVL84>:
    6d60:	e0ff      	add	Y, #-1
    6d62:	07e1      	jmp	0x6d26 <.L54>

00006d64 <.L58>:
            retVal = false;
            break;

#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_EN_READ_BY_ID_SERVICE
        case respLinProductID:
            pDiagTransfer->response.respSId = RSID(SID_ReadById);
    6d64:	7ed8 109a 	lod	X, 0x109a <_pDiagTransfer>
    6d68:	60f2      	lod	AL, #-14
    6d6a:	42f8      	mov	[X], AL

00006d6c <.LM122>:
            pDiagTransfer->response.dataLen = 5u; /* Only data bytes length */
    6d6c:	7005      	lod	A, #5
    6d6e:	52fa      	mov	[X+2], A

00006d70 <.LM123>:
            pDiagTransfer->response.data[0] = ml_ProductID[0];
    6d70:	62d8 5b8a 	lod	AL, 0x5b8a <_ml_ProductID>
    6d74:	42fc      	mov	[X+4], AL

00006d76 <.LM124>:
            pDiagTransfer->response.data[1] = ml_ProductID[1];
    6d76:	62d8 5b8b 	lod	AL, 0x5b8b <_ml_ProductID+0x1>
    6d7a:	42fd      	mov	[X+5], AL

00006d7c <.LM125>:
            pDiagTransfer->response.data[2] = ml_ProductID[2];
    6d7c:	62d8 5b8c 	lod	AL, 0x5b8c <_ml_ProductID+0x2>
    6d80:	42fe      	mov	[X+6], AL

00006d82 <.LM126>:
            pDiagTransfer->response.data[3] = ml_ProductID[3];
    6d82:	62d8 5b8d 	lod	AL, 0x5b8d <_ml_ProductID+0x3>
    6d86:	42ff      	mov	[X+7], AL

00006d88 <.LM127>:
            pDiagTransfer->response.data[4] = ml_ProductID[4];
    6d88:	2008      	add	X, #8
    6d8a:	62d8 5b8e 	lod	AL, 0x5b8e <_ml_ProductID+0x4>
    6d8e:	42f8      	mov	[X], AL

00006d90 <.L75>:
 * - true  There is data to send;
 * - false There is nothing to send (no response).
 */
static bool ld_DiagResponse (void)
{
    bool retVal = true;
    6d90:	7001      	lod	A, #1

00006d92 <.L65>:
            break;
    }

    /* Prepare the response */
    return ld_DiagResponse();
}
    6d92:	540b      	ret	#12

00006d94 <.L61>:
            pDiagTransfer->response.data[4] = ml_ProductID[4];
            break;

#if SL_EN_SERIAL_NUMBER_CALLOUT
        case respSerialNumber:
            pDiagTransfer->response.respSId = RSID(SID_ReadById);
    6d94:	7ed8 109a 	lod	X, 0x109a <_pDiagTransfer>
    6d98:	60f2      	lod	AL, #-14
    6d9a:	42f8      	mov	[X], AL

00006d9c <.LM131>:
            pDiagTransfer->response.dataLen = 4u; /* Only data bytes length */
    6d9c:	7004      	lod	A, #4
    6d9e:	52fa      	mov	[X+2], A

00006da0 <.LM132>:
            ld_serial_number_callout(&pDiagTransfer->response.data[0]); /* Insert Serial Number into data bytes 3..6 */
    6da0:	72ee      	lod	A, X
    6da2:	a004      	add	A, #4
    6da4:	15a7      	call	0x68f4 <_ld_serial_number_callout>
    6da6:	07f4      	jmp	0x6d90 <.L75>

00006da8 <.L60>:
            pDiagTransfer->response.data[4] = 0x00u; /* reserved */
            break;
#endif /* SL_vISO17987_2016 && SL_EN_NCF_LDF_VERSION */

        case respNegativeResponse:
            pDiagTransfer->response.respSId = RSID_NegativeResponse;
    6da8:	7ed8 109a 	lod	X, 0x109a <_pDiagTransfer>
    6dac:	607f      	lod	AL, #127
    6dae:	42f8      	mov	[X], AL

00006db0 <.LM134>:
            pDiagTransfer->response.dataLen = 2u; /* Only data bytes length */
    6db0:	7002      	lod	A, #2
    6db2:	52fa      	mov	[X+2], A
    6db4:	72da 12b2 	lod	A, #4786
    6db8:	52fc      	mov	[X+4], A
    6dba:	07ea      	jmp	0x6d90 <.L75>

00006dbc <.L62>:
            break;
#endif /* SL_vLIN_2_x || SL_vISO17987_2016 || SL_EN_READ_BY_ID_SERVICE */

#if SL_EN_ASSIGN_NAD_SERVICE
        case respPositiveAssignNAD:
            pDiagTransfer->response.respSId = RSID(SID_AssignNad);
    6dbc:	7ed8 109a 	lod	X, 0x109a <_pDiagTransfer>
    6dc0:	72da 00f0 	lod	A, #240

00006dc4 <.L81>:
            break;
#endif /* SL_vLIN_2_1_plus || SL_vISO17987_2016 */

#if (SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE
        case respPositiveSaveConfig:
            pDiagTransfer->response.respSId = RSID(SID_SaveConfiguration);
    6dc4:	42f8      	mov	[X], AL

00006dc6 <.LM137>:
            pDiagTransfer->response.dataLen = 0u; /* Only data bytes length */
    6dc6:	7000      	lod	A, #0
    6dc8:	52fa      	mov	[X+2], A
    6dca:	07e2      	jmp	0x6d90 <.L75>

00006dcc <.L63>:
            break;
#endif /* SL_vSAE_J2602_2012 */

#if SL_vLIN_2_1_plus || SL_vISO17987_2016
        case respPositiveAssignFidRange:
            pDiagTransfer->response.respSId = RSID(SID_AssignFrameIdRange);
    6dcc:	7ed8 109a 	lod	X, 0x109a <_pDiagTransfer>
    6dd0:	72da 00f7 	lod	A, #247
    6dd4:	07f7      	jmp	0x6dc4 <.L81>

00006dd6 <.L64>:
            break;
#endif /* SL_vLIN_2_1_plus || SL_vISO17987_2016 */

#if (SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE
        case respPositiveSaveConfig:
            pDiagTransfer->response.respSId = RSID(SID_SaveConfiguration);
    6dd6:	7ed8 109a 	lod	X, 0x109a <_pDiagTransfer>
    6dda:	72da 00f6 	lod	A, #246
    6dde:	07f2      	jmp	0x6dc4 <.L81>

00006de0 <_l_sys_init>:
 * - 1 - fail.
 */
l_bool l_sys_init(void)
{
    return (l_bool)0u;
}
    6de0:	7000      	lod	A, #0
    6de2:	5401      	ret

00006de4 <_l_SetFlagsMask>:
 * @param[out]  dest    destination pointer
 * @param[in]   mask    used flags mask
 * @param[in]   size    area size
 */
void l_SetFlagsMask(volatile l_u8 *dest, const l_u8 *mask, const l_u8 size)
{
    6de4:	5805      	inc	S, #6

00006de6 <.LCFI0>:
    6de6:	5201      	mov	[S-2], A
    6de8:	620b      	lod	AL, [S-12]

00006dea <.LVL1>:
    6dea:	5cf2      	usex	A
    6dec:	5203      	mov	[S-4], A

00006dee <.LBB6>:
    ENTER_STD_LIN_API_ATOMIC_SECTION();
    6dee:	1624      	call	0x6a38 <_l_sys_irq_disable>
    6df0:	5205      	mov	[S-6], A

00006df2 <.LBB7>:
    for (l_u8 cnt = 0u; cnt < size; cnt++) {
    6df2:	7203      	lod	A, [S-4]

00006df4 <.LVL4>:
    6df4:	190a      	je	0x6e0a <.L3>
    6df6:	7e09      	lod	X, [S-10]
    6df8:	7a01      	lod	Y, [S-2]

00006dfa <.L4>:
        dest[cnt] |= mask[cnt];
    6dfa:	62f0      	lod	AL, [Y]
    6dfc:	86de      	or	AL, [X++]
    6dfe:	42d6      	mov	[Y++], AL

00006e00 <.LM7>:
 * @param[in]   size    area size
 */
void l_SetFlagsMask(volatile l_u8 *dest, const l_u8 *mask, const l_u8 size)
{
    ENTER_STD_LIN_API_ATOMIC_SECTION();
    for (l_u8 cnt = 0u; cnt < size; cnt++) {
    6e00:	62e8      	lod	AL, YL
    6e02:	8a01      	sub	AL, [S-2]
    6e04:	5cf2      	usex	A
    6e06:	ae03      	cmp	A, [S-4]
    6e08:	1878      	jc	0x6dfa <.L4>

00006e0a <.L3>:
    6e0a:	7205      	lod	A, [S-6]
    6e0c:	161d      	call	0x6a48 <_l_sys_irq_restore>

00006e0e <.LBE6>:
        dest[cnt] |= mask[cnt];
    }
    EXIT_STD_LIN_API_ATOMIC_SECTION();
}
    6e0e:	5407      	ret	#8

00006e10 <_l_ifcUpdateOverrun>:
    6e10:	7eda 11d2 	lod	X, #4562
    6e14:	66f8      	lod	YL, [X]
    6e16:	62e8      	lod	AL, YL
    6e18:	9404      	and	AL, #4
    6e1a:	1d0a      	jne	0x6e30 <.L1>

00006e1c <.LM3>:
    6e1c:	62d8 109e 	lod	AL, 0x109e <_s_ifcOverrunFramesCount>
    6e20:	8001      	add	AL, #1
    6e22:	42d8 109e 	mov	0x109e <_s_ifcOverrunFramesCount>, AL

00006e26 <.LM4>:
    6e26:	8c01      	cmp	AL, #1
    6e28:	1a03      	jule	0x6e30 <.L1>

00006e2a <.LM5>:
    6e2a:	62e8      	lod	AL, YL
    6e2c:	8404      	or	AL, #4
    6e2e:	42f8      	mov	[X], AL

00006e30 <.L1>:
    6e30:	5401      	ret

00006e32 <_l_ifc_init_sl1>:
    6e32:	15ba      	call	0x69a8 <_l_mls_Init>

00006e34 <.LM9>:
    6e34:	6000      	lod	AL, #0
    6e36:	42d8 109e 	mov	0x109e <_s_ifcOverrunFramesCount>, AL

00006e3a <.LM10>:
    6e3a:	1689      	call	0x6b4e <_ld_DiagInit>

00006e3c <.LM11>:
    6e3c:	82db 11be 	callf	0x237c <_ml_Connect>
    6e40:	ac00      	cmp	A, #0
    6e42:	5ca2      	sne	A

00006e44 <.LM12>:
    6e44:	5401      	ret

00006e46 <_l_ifc_read_status_sl1>:
    6e46:	5803      	inc	S, #4

00006e48 <.LBB17>:
    6e48:	15f7      	call	0x6a38 <_l_sys_irq_disable>
    6e4a:	5203      	mov	[S-4], A

00006e4c <.LM15>:
    6e4c:	7008      	lod	A, #8

00006e4e <.LVL5>:
    6e4e:	82db 11a3 	callf	0x2346 <_ml_GetState>

00006e52 <.LM16>:
    6e52:	62d8 1010 	lod	AL, 0x1010 <.LASF1833+0x7>
    6e56:	9401      	and	AL, #1
    6e58:	1905      	je	0x6e64 <.L7>

00006e5a <.LM17>:
    6e5a:	7eda 11d2 	lod	X, #4562
    6e5e:	62f8      	lod	AL, [X]
    6e60:	8410      	or	AL, #16
    6e62:	42f8      	mov	[X], AL

00006e64 <.L7>:
    6e64:	7ad8 11d2 	lod	Y, 0x11d2 <_s_ifcStatus>

00006e68 <.LM19>:
    6e68:	6000      	lod	AL, #0
    6e6a:	42d8 109e 	mov	0x109e <_s_ifcOverrunFramesCount>, AL

00006e6e <.LM20>:
    6e6e:	0ea7      	lod	C, ML.7
    6e70:	7000      	lod	A, #0
    6e72:	52d8 11d2 	mov	0x11d2 <_s_ifcStatus>, A

00006e76 <.LBB18>:
    6e76:	7203      	lod	A, [S-4]
    6e78:	5a01      	mov	[S-2], Y
    6e7a:	15e6      	call	0x6a48 <_l_sys_irq_restore>

00006e7c <.LBE17>:
    6e7c:	7a01      	lod	Y, [S-2]
    6e7e:	72e6      	lod	A, Y
    6e80:	5405      	ret	#6

00006e82 <_l_LinSleepMode>:
/** LIN Slave driver entered a sleep mode.
 * @param[in]   Reason    Reason of entering sleep mode.
 * @return void
 */
void l_LinSleepMode(ml_SleepReason_t Reason)
{
    6e82:	7ee2      	lod	X, A

00006e84 <.LM29>:

#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
    if (Reason == ml_reasonMaster) {
    6e84:	ac01      	cmp	A, #1
    6e86:	1d08      	jne	0x6e98 <.L14>

00006e88 <.LM30>:
        s_ifcStatus.mapped.GoToSleep = true;
    6e88:	7ada 11d2 	lod	Y, #4562

00006e8c <.LM31>:
        /*
         * MLX4 FW handles Goto Sleep frame (0x3C, 0x00 ...) automatically
         * and does not report it via l_MessageReceived event.
         * Hence write Protected ID 0x3C explicitly.
         */
        s_ifcStatus.mapped.PID = 0x3C;
    6e8c:	603c      	lod	AL, #60

00006e8e <.LVL14>:
    6e8e:	42d8 11d3 	mov	0x11d3 <_s_ifcStatus+0x1>, AL

00006e92 <.LM32>:
        s_ifcStatus.mapped.SuccessfulTrans = true;
    6e92:	62f0      	lod	AL, [Y]
    6e94:	840a      	or	AL, #10
    6e96:	42f0      	mov	[Y], AL

00006e98 <.L14>:
    }
    /* else: other reasons of sleep don't required special care */
#endif /* SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012 */

    l_ifc_sleep_entered_callout(Reason);    /* notify application on the sleep reason */
    6e98:	72ee      	lod	A, X
    6e9a:	0585      	jmp	0x69a6 <_l_ifc_sleep_entered_callout>

00006e9c <_l_MessageReceived>:
 * @note The Signals write and Flags update are done atomically.
 * Thus the Signals / Flags API functions are allowed to be used in other interrupts
 * with higher priority then LIN ISR.
 */
void l_MessageReceived(ml_MessageID_t MessageIndex)
{
    6e9c:	5801      	inc	S, #2

00006e9e <.LCFI1>:
    6e9e:	7ae2      	lod	Y, A

00006ea0 <.LM36>:
#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
    /*
     * Successful transfer is set if a frame has been
     * transmitted/received without an error
     */
    s_ifcStatus.mapped.SuccessfulTrans = true;
    6ea0:	7eda 11d2 	lod	X, #4562
    6ea4:	62f8      	lod	AL, [X]

00006ea6 <.LVL17>:
    6ea6:	8402      	or	AL, #2
    6ea8:	42f8      	mov	[X], AL

00006eaa <.LM37>:
    s_ifcStatus.mapped.PID = ml_GetProtectedID();
    6eaa:	5a01      	mov	[S-2], Y
    6eac:	82db 4211 	callf	0x8422 <_ml_GetProtectedID>
    6eb0:	42d8 11d3 	mov	0x11d3 <_s_ifcStatus+0x1>, AL

00006eb4 <.LM38>:
#endif /* SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012 */


        if (MessageIndex < SL_NUMBER_OF_DYNAMIC_MESSAGES) {
    6eb4:	7a01      	lod	Y, [S-2]
    6eb6:	ec05      	cmp	Y, #5
    6eb8:	1e0f      	jug	0x6ed8 <.L15>

00006eba <.LBB20>:

        }
#else /*SUPPORT_MULTI_SLAVE*/

		/* Get Frame Handler */
		const l_s_UnconditionalFrame_t *uncondFrame = currentFrame->Frame;
    6eba:	44a6      	asl	Y, #2
    6ebc:	e2da 5b68 	add	Y, #23400

00006ec0 <.LM40>:
		l_s_FrameHandler_t ProcessFrame = uncondFrame->FrameHandler;
    6ec0:	7ef0      	lod	X, [Y]
    6ec2:	7af8      	lod	Y, [X]

00006ec4 <.LM41>:

		/* Actions on the frame */
		(void)ProcessFrame(sfa_UpdateSignals); /* Use new signals values */
    6ec4:	7000      	lod	A, #0
    6ec6:	5a01      	mov	[S-2], Y
    6ec8:	0001      	jmp	0x6ecc <.L18>

00006eca <.L17>:
    6eca:	76e6      	jmp	Y

00006ecc <.L18>:
    6ecc:	17fe      	call	0x6eca <.L17>

00006ece <.LM42>:
		(void)ProcessFrame(sfa_SetFlags);   /* Mark corresponding signal's flags as received */
    6ece:	7003      	lod	A, #3
    6ed0:	7a01      	lod	Y, [S-2]
    6ed2:	0001      	jmp	0x6ed6 <.L20>

00006ed4 <.L19>:
    6ed4:	76e6      	jmp	Y

00006ed6 <.L20>:
    6ed6:	17fe      	call	0x6ed4 <.L19>

00006ed8 <.L15>:
#endif /* SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012 */
#endif /*SUPPORT_MULTI_SLAVE*/
    } else {
        /* Unexpected frame -> ignore */
    }
}
    6ed8:	5403      	ret	#4

00006eda <_l_DataRequest>:
/** Header of the relevant non-diagnostic slave-to-master frame has been received.
 * @param[in]    MessageIndex    Message index of the current Frame
 * @return  void
 */
void l_DataRequest (ml_MessageID_t MessageIndex)
{
    6eda:	5801      	inc	S, #2

00006edc <.LCFI2>:
    if (MessageIndex < SL_NUMBER_OF_DYNAMIC_MESSAGES) {
    6edc:	ac05      	cmp	A, #5
    6ede:	1e16      	jug	0x6f0c <.L22>

00006ee0 <.LBB21>:
        /* Non-diagnostic message */
        /* Get the frame by message index */
        const l_s_Frame_t *currentFrame = (const l_s_Frame_t*)&frameList[MessageIndex];

        /* Unconditional frame */
        if (currentFrame->FrameType == sft_UnconditionalFrame) {
    6ee0:	44a2      	asl	A, #2

00006ee2 <.LVL27>:
    6ee2:	7ee2      	lod	X, A
    6ee4:	22da 5b66 	add	X, #23398
    6ee8:	72f8      	lod	A, [X]
    6eea:	1d10      	jne	0x6f0c <.L22>

00006eec <.LBB22>:
            /* Get Frame Handler */
            const l_s_UnconditionalFrame_t *uncondFrame = currentFrame->Frame;
            const l_s_FrameHandler_t ProcessFrame = uncondFrame->FrameHandler;
    6eec:	7efa      	lod	X, [X+2]
    6eee:	7af8      	lod	Y, [X]

00006ef0 <.LM48>:


#else	/*SUPPORT_MULTI_SLAVE*/

        /* Actions on the frame */
        (void)ProcessFrame(sfa_FillBuffer);          /* Fill the data buffer */
    6ef0:	7001      	lod	A, #1
    6ef2:	5a01      	mov	[S-2], Y
    6ef4:	0001      	jmp	0x6ef8 <.L25>

00006ef6 <.L24>:
    6ef6:	76e6      	jmp	Y

00006ef8 <.L25>:
    6ef8:	17fe      	call	0x6ef6 <.L24>

00006efa <.LM49>:
        (void)ProcessFrame(sfa_SetFlags);            /* Consider Signals as sent */
    6efa:	7003      	lod	A, #3
    6efc:	7a01      	lod	Y, [S-2]
    6efe:	0001      	jmp	0x6f02 <.L27>

00006f00 <.L26>:
    6f00:	76e6      	jmp	Y

00006f02 <.L27>:
    6f02:	17fe      	call	0x6f00 <.L26>

00006f04 <.LM50>:

#if SL_vSAE_J2602_2012
        l_u8 api_info = mlu_SAE_SetStatusApiInfo(MessageIndex); /* call User Application */
        (void)ml_SAE_DataReady(api_info);            /* Notify driver */
#else
        (void)ml_DataReady(ML_END_OF_TX_ENABLED);    /* Notify driver */
    6f04:	7001      	lod	A, #1
    6f06:	82db 1137 	callf	0x226e <_ml_DataReady>

00006f0a <.LBE22>:
    6f0a:	5403      	ret	#4

00006f0c <.L22>:
            }
        }
#endif /* !SL_vSAE_J2602_2012 && SL_EN_EVENT_TRIGGERED_FRAMES */
        /* Unexpected frame type -> ignore */
        else {
            (void)ml_DiscardFrame();
    6f0c:	82db 116a 	callf	0x22d4 <_ml_DiscardFrame>

00006f10 <.LBE21>:
    }
    /* Unexpected message index -> ignore */
    else {
        (void)ml_DiscardFrame();
    }
}
    6f10:	5403      	ret	#4

00006f12 <_l_ErrorDetected>:
            /* There is no J2602 only specific action for other errors */
            break;
    }
#endif /* SL_vSAE_J2602_2012 */

    switch (Error) {
    6f12:	a0fc      	add	A, #-4

00006f14 <.LVL35>:
    6f14:	ac0c      	cmp	A, #12
    6f16:	1e1b      	jug	0x6f4e <.L28>
    6f18:	4422      	asl	A
    6f1a:	7ee2      	lod	X, A
    6f1c:	22da 5b34 	add	X, #23348
    6f20:	76f8      	jmp	[X]

00006f22 <.L32>:
L_FLAGS(l_sl1_flags.mapped, s_LIN_MOTOR1_State, signal, LIN_MOTOR1_State)
L_FLAGS(l_sl1_flags.mapped, s_LIN_MOTOR2_State, signal, LIN_MOTOR2_State)
L_FLAGS(l_sl1_flags.mapped, s_LIN_MOTOR3_State, signal, LIN_MOTOR3_State)
L_FLAGS(l_sl1_flags.mapped, s_LIN_MOTOR4_State, signal, LIN_MOTOR4_State)
L_FLAGS(l_sl1_flags.mapped, s_LIN_MOTOR5_State, signal, LIN_MOTOR5_State)
L_FLAGS(l_sl1_flags.mapped, s_LIN_Error, signal, LIN_Error)
    6f22:	158a      	call	0x6a38 <_l_sys_irq_disable>
    6f24:	7ae2      	lod	Y, A

00006f26 <.LVL38>:
    6f26:	7eda 11d4 	lod	X, #4564
    6f2a:	62f8      	lod	AL, [X]

00006f2c <.LVL39>:
    6f2c:	947f      	and	AL, #127
    6f2e:	42f8      	mov	[X], AL
    6f30:	72e6      	lod	A, Y
    6f32:	158a      	call	0x6a48 <_l_sys_irq_restore>

00006f34 <.L33>:
L_SIGNAL(l_u8, LIN_MOTOR1_State)
L_SIGNAL(l_u8, LIN_MOTOR2_State)
L_SIGNAL(l_u8, LIN_MOTOR3_State)
L_SIGNAL(l_u8, LIN_MOTOR4_State)
L_SIGNAL(l_u8, LIN_MOTOR5_State)
L_SIGNAL(l_bool, LIN_Error)
    6f34:	6001      	lod	AL, #1
    6f36:	42d8 102d 	mov	0x102d <.LASF1417+0x6>, AL

00006f3a <.LBE31>:
             */
            l_flg_clr_response_error();

            l_bool_wr_response_error(true);
#endif /* !SL_vSAE_J2602_2012 */
            s_ifcStatus.mapped.ErrorInResponse = true;
    6f3a:	7eda 11d2 	lod	X, #4562
    6f3e:	62f8      	lod	AL, [X]
    6f40:	8401      	or	AL, #1
    6f42:	42f8      	mov	[X], AL

00006f44 <.LM58>:
            s_ifcStatus.mapped.PID = ml_GetProtectedID();
    6f44:	82db 4211 	callf	0x8422 <_ml_GetProtectedID>
    6f48:	42d8 11d3 	mov	0x11d3 <_s_ifcStatus+0x1>, AL

00006f4c <.LM59>:
#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
            l_ifcUpdateOverrun();
    6f4c:	1761      	call	0x6e10 <_l_ifcUpdateOverrun>

00006f4e <.L28>:
    }

#if !SL_vSAE_J2602_2012 && SL_EN_EVENT_TRIGGERED_FRAMES
    isNonUnconditional = snuft_False;
#endif /* !SL_vSAE_J2602_2012 && SL_EN_EVENT_TRIGGERED_FRAMES */
}
    6f4e:	5401      	ret

00006f50 <_l_DataTransmitted>:

/** Frame has been successfully transmitted.
 * @return  void
 */
void l_DataTransmitted(ml_MessageID_t MessageIndex)
{
    6f50:	5801      	inc	S, #2

00006f52 <.LCFI3>:
#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
    /*
     * Successful transfer is set if a frame has been
     * transmitted/received without an error
     */
    s_ifcStatus.mapped.SuccessfulTrans = true;
    6f52:	7eda 11d2 	lod	X, #4562
    6f56:	62f8      	lod	AL, [X]

00006f58 <.LVL45>:
    6f58:	8402      	or	AL, #2
    6f5a:	42f8      	mov	[X], AL

00006f5c <.LM63>:
    s_ifcStatus.mapped.PID = ml_GetProtectedID();
    6f5c:	82db 4211 	callf	0x8422 <_ml_GetProtectedID>
    6f60:	42d8 11d3 	mov	0x11d3 <_s_ifcStatus+0x1>, AL

00006f64 <.LM64>:
    l_ifcUpdateOverrun();
    6f64:	1755      	call	0x6e10 <_l_ifcUpdateOverrun>

00006f66 <.LBB39>:
L_FLAGS(l_sl1_flags.mapped, s_LIN_MOTOR1_State, signal, LIN_MOTOR1_State)
L_FLAGS(l_sl1_flags.mapped, s_LIN_MOTOR2_State, signal, LIN_MOTOR2_State)
L_FLAGS(l_sl1_flags.mapped, s_LIN_MOTOR3_State, signal, LIN_MOTOR3_State)
L_FLAGS(l_sl1_flags.mapped, s_LIN_MOTOR4_State, signal, LIN_MOTOR4_State)
L_FLAGS(l_sl1_flags.mapped, s_LIN_MOTOR5_State, signal, LIN_MOTOR5_State)
L_FLAGS(l_sl1_flags.mapped, s_LIN_Error, signal, LIN_Error)
    6f66:	7ada 11d4 	lod	Y, #4564

00006f6a <.LBE39>:
    6f6a:	62f0      	lod	AL, [Y]
    6f6c:	1d8c      	jnn	0x6f86 <.L34>

00006f6e <.LBB41>:
    6f6e:	5a01      	mov	[S-2], Y
    6f70:	1563      	call	0x6a38 <_l_sys_irq_disable>
    6f72:	7ee2      	lod	X, A

00006f74 <.LVL49>:
    6f74:	7a01      	lod	Y, [S-2]
    6f76:	62f0      	lod	AL, [Y]

00006f78 <.LVL50>:
    6f78:	947f      	and	AL, #127
    6f7a:	42f0      	mov	[Y], AL
    6f7c:	72ee      	lod	A, X
    6f7e:	1564      	call	0x6a48 <_l_sys_irq_restore>

00006f80 <.LBB43>:
L_SIGNAL(l_u8, LIN_MOTOR1_State)
L_SIGNAL(l_u8, LIN_MOTOR2_State)
L_SIGNAL(l_u8, LIN_MOTOR3_State)
L_SIGNAL(l_u8, LIN_MOTOR4_State)
L_SIGNAL(l_u8, LIN_MOTOR5_State)
L_SIGNAL(l_bool, LIN_Error)
    6f80:	6000      	lod	AL, #0
    6f82:	42d8 102d 	mov	0x102d <.LASF1417+0x6>, AL

00006f86 <.L34>:
    }

    /* Notify user application about end of transmission */
    mlu_SAE_DataTransmitted();
#endif /* SL_vSAE_J2602_2012 */
}
    6f86:	5403      	ret	#4

00006f88 <_l_AutoAddressingStep>:
 * @return  void
 */
__attribute__((weak)) void l_AutoAddressingStep(l_u8 StepNumber)
{
    (void)StepNumber;   /* unused parameter */
}
    6f88:	5401      	ret

00006f8a <_l_FillBufferSlave>:
/** Fill the data buffer from source
 * @param[in]   src     pointer to source
 * @param[in]   size    area size
 */
void l_FillBufferSlave(l_u8 *src, l_u8 size)
{
    6f8a:	5805      	inc	S, #6

00006f8c <.LCFI4>:
    6f8c:	5205      	mov	[S-6], A

00006f8e <.LBB45>:
    for (l_u8 cnt = 0; cnt < size; cnt++) {
    6f8e:	6209      	lod	AL, [S-10]

00006f90 <.LVL56>:
    6f90:	1911      	je	0x6fb4 <.L40>
    6f92:	5cf2      	usex	A
    6f94:	5203      	mov	[S-4], A
    6f96:	7000      	lod	A, #0

00006f98 <.L42>:
        ((l_u8*)ML_SLAVE_FRAME_DATA_BUFFER)[cnt] = src[cnt];
    6f98:	7e05      	lod	X, [S-6]
    6f9a:	22e2      	add	X, A
    6f9c:	7ae2      	lod	Y, A
    6f9e:	e2da 1004 	add	Y, #4100
    6fa2:	0ea7      	lod	C, ML.7
    6fa4:	54cc      	movsb	[Y++], [X++]

00006fa6 <.LVL58>:
    6fa6:	a001      	add	A, #1

00006fa8 <.LM73>:
 * @param[in]   src     pointer to source
 * @param[in]   size    area size
 */
void l_FillBufferSlave(l_u8 *src, l_u8 size)
{
    for (l_u8 cnt = 0; cnt < size; cnt++) {
    6fa8:	66e0      	lod	YL, AL
    6faa:	5cf6      	usex	Y
    6fac:	5a01      	mov	[S-2], Y
    6fae:	7a03      	lod	Y, [S-4]
    6fb0:	ee01      	cmp	Y, [S-2]
    6fb2:	1e72      	jug	0x6f98 <.L42>

00006fb4 <.L40>:
        ((l_u8*)ML_SLAVE_FRAME_DATA_BUFFER)[cnt] = src[cnt];
    }
}
    6fb4:	5407      	ret	#8

00006fb6 <_l_sl1_MOTOR5_States_handler>:
    l_u16 sig_LIN_MOTOR5_Reserve3  : 16;
} l_sl1_MOTOR5_States_data_t;
ASSERT(sizeof(l_sl1_MOTOR5_States_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_MOTOR5_States_handler (l_s_FrameAction_t frameAction)
{
    6fb6:	580d      	inc	S, #14

00006fb8 <.LCFI0>:
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    static const l_sl1_flags_t MOTOR5_States_flags_mask = {{0xc0, 0x0, 0x70, 0x8}};

    switch (frameAction) {
    6fb8:	ac01      	cmp	A, #1
    6fba:	190c      	je	0x6fd4 <.L3>
    6fbc:	1802      	jc	0x6fc2 <.L4>
    6fbe:	ac03      	cmp	A, #3
    6fc0:	1d32      	jne	0x7026 <.L9>

00006fc2 <.L4>:
            break;
        }
        case sfa_UpdateSignals:     /* For M2S frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&MOTOR5_States_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
    6fc2:	54ca 0004 	pushw	#4

00006fc6 <.LCFI1>:
    6fc6:	54ca 5b62 	pushw	#23394

00006fca <.LCFI2>:
    6fca:	72da 11d4 	lod	A, #4564

00006fce <.LVL2>:
    6fce:	170a      	call	0x6de4 <_l_SetFlagsMask>

00006fd0 <.LM4>:
            break;
    6fd0:	5c03      	dec	S, #4

00006fd2 <.LCFI3>:
    6fd2:	0027      	jmp	0x7022 <.L10>

00006fd4 <.L3>:

    switch (frameAction) {
        case sfa_FillBuffer:    /* For S2M frames */
        {
            /* Freeze the volatile Signal values */
            l_u8 sig_LIN_MOTOR5_State = l_signals.LIN_MOTOR5_State;
    6fd4:	66d8 102c 	lod	YL, 0x102c <.LASF1417+0x5>

00006fd8 <.LM6>:
            l_bool sig_LIN_Error = l_signals.LIN_Error;
    6fd8:	62d8 102d 	lod	AL, 0x102d <.LASF1417+0x6>

00006fdc <.LM7>:
            l_u16 sig_LIN_MOTOR5_Reserve1 = l_signals.LIN_MOTOR5_Reserve1;
    6fdc:	7ed8 1046 	lod	X, 0x1046 <.LASF1417+0x1f>
    6fe0:	5e01      	mov	[S-2], X

00006fe2 <.LM8>:
            l_u16 sig_LIN_MOTOR5_Reserve2 = l_signals.LIN_MOTOR5_Reserve2;
    6fe2:	7ed8 1048 	lod	X, 0x1048 <.LASF1417+0x21>

00006fe6 <.LVL8>:
    6fe6:	5e03      	mov	[S-4], X

00006fe8 <.LM9>:
            l_u16 sig_LIN_MOTOR5_Reserve3 = l_signals.LIN_MOTOR5_Reserve3;
    6fe8:	7ed8 104a 	lod	X, 0x104a <.LASF1417+0x23>

00006fec <.LVL10>:
    6fec:	5e05      	mov	[S-6], X

00006fee <.LM10>:

            l_sl1_MOTOR5_States_data_t MOTOR5_States_data = {
    6fee:	460d      	mov	[S-14], YL
    6ff0:	b401      	and	A, #1

00006ff2 <.LVL12>:
    6ff2:	6800      	lod	AH, #0
    6ff4:	72e4      	swap	A
    6ff6:	7ae2      	lod	Y, A

00006ff8 <.LVL13>:
    6ff8:	720d      	lod	A, [S-14]
    6ffa:	d4fe      	and	AH, #-2
    6ffc:	a6e6      	or	A, Y
    6ffe:	520d      	mov	[S-14], A

00007000 <.LVL14>:
    7000:	7aef      	lod	Y, S
    7002:	e0f3      	add	Y, #-13
    7004:	62f0      	lod	AL, [Y]
    7006:	84fe      	or	AL, #-2
    7008:	42f0      	mov	[Y], AL
    700a:	7e01      	lod	X, [S-2]

0000700c <.LVL15>:
    700c:	5e0b      	mov	[S-12], X
    700e:	7e03      	lod	X, [S-4]
    7010:	5e09      	mov	[S-10], X
    7012:	7e05      	lod	X, [S-6]
    7014:	5e07      	mov	[S-8], X

00007016 <.LM11>:
                0x7f,
                sig_LIN_MOTOR5_Reserve1,
                sig_LIN_MOTOR5_Reserve2,
                sig_LIN_MOTOR5_Reserve3
            };
            l_FillBufferSlave((l_u8*)&MOTOR5_States_data, (l_u8)sizeof(l_sl1_MOTOR5_States_data_t));
    7016:	54ca 0008 	pushw	#8

0000701a <.LCFI4>:
    701a:	72ef      	lod	A, S
    701c:	a0f0      	add	A, #-16
    701e:	17b5      	call	0x6f8a <_l_FillBufferSlave>

00007020 <.LVL17>:
    7020:	5c01      	dec	S, #2

00007022 <.L10>:
} l_sl1_MOTOR5_States_data_t;
ASSERT(sizeof(l_sl1_MOTOR5_States_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_MOTOR5_States_handler (l_s_FrameAction_t frameAction)
{
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    7022:	7000      	lod	A, #0

00007024 <.LM13>:
        }
        case sfa_UpdateSignals:     /* For M2S frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&MOTOR5_States_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
            break;
    7024:	540f      	ret	#16

00007026 <.L9>:
        }
        case sfa_CheckFlags:    /* Only for frames associated with an Event-triggered frame */
        default:
            retVal = sfhs_Fail;
    7026:	7001      	lod	A, #1

00007028 <.LM15>:
            break;
    }
    return retVal;
}
    7028:	540f      	ret	#16

0000702a <_l_sl1_MOTOR4_States_handler>:
    l_u16 sig_LIN_MOTOR4_Reserve3  : 16;
} l_sl1_MOTOR4_States_data_t;
ASSERT(sizeof(l_sl1_MOTOR4_States_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_MOTOR4_States_handler (l_s_FrameAction_t frameAction)
{
    702a:	580d      	inc	S, #14

0000702c <.LCFI6>:
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    static const l_sl1_flags_t MOTOR4_States_flags_mask = {{0xa0, 0x0, 0xe, 0x4}};

    switch (frameAction) {
    702c:	ac01      	cmp	A, #1
    702e:	190c      	je	0x7048 <.L13>
    7030:	1802      	jc	0x7036 <.L14>
    7032:	ac03      	cmp	A, #3
    7034:	1d32      	jne	0x709a <.L19>

00007036 <.L14>:
            break;
        }
        case sfa_UpdateSignals:     /* For M2S frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&MOTOR4_States_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
    7036:	54ca 0004 	pushw	#4

0000703a <.LCFI7>:
    703a:	54ca 5b5e 	pushw	#23390

0000703e <.LCFI8>:
    703e:	72da 11d4 	lod	A, #4564

00007042 <.LVL22>:
    7042:	16d0      	call	0x6de4 <_l_SetFlagsMask>

00007044 <.LM19>:
            break;
    7044:	5c03      	dec	S, #4

00007046 <.LCFI9>:
    7046:	0027      	jmp	0x7096 <.L20>

00007048 <.L13>:

    switch (frameAction) {
        case sfa_FillBuffer:    /* For S2M frames */
        {
            /* Freeze the volatile Signal values */
            l_u8 sig_LIN_MOTOR4_State = l_signals.LIN_MOTOR4_State;
    7048:	66d8 102b 	lod	YL, 0x102b <.LASF1417+0x4>

0000704c <.LM21>:
            l_bool sig_LIN_Error = l_signals.LIN_Error;
    704c:	62d8 102d 	lod	AL, 0x102d <.LASF1417+0x6>

00007050 <.LM22>:
            l_u16 sig_LIN_MOTOR4_Reserve1 = l_signals.LIN_MOTOR4_Reserve1;
    7050:	7ed8 1040 	lod	X, 0x1040 <.LASF1417+0x19>
    7054:	5e01      	mov	[S-2], X

00007056 <.LM23>:
            l_u16 sig_LIN_MOTOR4_Reserve2 = l_signals.LIN_MOTOR4_Reserve2;
    7056:	7ed8 1042 	lod	X, 0x1042 <.LASF1417+0x1b>

0000705a <.LVL28>:
    705a:	5e03      	mov	[S-4], X

0000705c <.LM24>:
            l_u16 sig_LIN_MOTOR4_Reserve3 = l_signals.LIN_MOTOR4_Reserve3;
    705c:	7ed8 1044 	lod	X, 0x1044 <.LASF1417+0x1d>

00007060 <.LVL30>:
    7060:	5e05      	mov	[S-6], X

00007062 <.LM25>:

            l_sl1_MOTOR4_States_data_t MOTOR4_States_data = {
    7062:	460d      	mov	[S-14], YL
    7064:	b401      	and	A, #1

00007066 <.LVL32>:
    7066:	6800      	lod	AH, #0
    7068:	72e4      	swap	A
    706a:	7ae2      	lod	Y, A

0000706c <.LVL33>:
    706c:	720d      	lod	A, [S-14]
    706e:	d4fe      	and	AH, #-2
    7070:	a6e6      	or	A, Y
    7072:	520d      	mov	[S-14], A

00007074 <.LVL34>:
    7074:	7aef      	lod	Y, S
    7076:	e0f3      	add	Y, #-13
    7078:	62f0      	lod	AL, [Y]
    707a:	84fe      	or	AL, #-2
    707c:	42f0      	mov	[Y], AL
    707e:	7e01      	lod	X, [S-2]

00007080 <.LVL35>:
    7080:	5e0b      	mov	[S-12], X
    7082:	7e03      	lod	X, [S-4]
    7084:	5e09      	mov	[S-10], X
    7086:	7e05      	lod	X, [S-6]
    7088:	5e07      	mov	[S-8], X

0000708a <.LM26>:
                0x7f,
                sig_LIN_MOTOR4_Reserve1,
                sig_LIN_MOTOR4_Reserve2,
                sig_LIN_MOTOR4_Reserve3
            };
            l_FillBufferSlave((l_u8*)&MOTOR4_States_data, (l_u8)sizeof(l_sl1_MOTOR4_States_data_t));
    708a:	54ca 0008 	pushw	#8

0000708e <.LCFI10>:
    708e:	72ef      	lod	A, S
    7090:	a0f0      	add	A, #-16
    7092:	177b      	call	0x6f8a <_l_FillBufferSlave>

00007094 <.LVL37>:
    7094:	5c01      	dec	S, #2

00007096 <.L20>:
} l_sl1_MOTOR4_States_data_t;
ASSERT(sizeof(l_sl1_MOTOR4_States_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_MOTOR4_States_handler (l_s_FrameAction_t frameAction)
{
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    7096:	7000      	lod	A, #0

00007098 <.LM28>:
        }
        case sfa_UpdateSignals:     /* For M2S frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&MOTOR4_States_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
            break;
    7098:	540f      	ret	#16

0000709a <.L19>:
        }
        case sfa_CheckFlags:    /* Only for frames associated with an Event-triggered frame */
        default:
            retVal = sfhs_Fail;
    709a:	7001      	lod	A, #1

0000709c <.LM30>:
            break;
    }
    return retVal;
}
    709c:	540f      	ret	#16

0000709e <_l_sl1_MOTOR3_States_handler>:
    l_u16 sig_LIN_MOTOR3_Reserve3  : 16;
} l_sl1_MOTOR3_States_data_t;
ASSERT(sizeof(l_sl1_MOTOR3_States_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_MOTOR3_States_handler (l_s_FrameAction_t frameAction)
{
    709e:	580d      	inc	S, #14

000070a0 <.LCFI12>:
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    static const l_sl1_flags_t MOTOR3_States_flags_mask = {{0x90, 0xc0, 0x1, 0x2}};

    switch (frameAction) {
    70a0:	ac01      	cmp	A, #1
    70a2:	190c      	je	0x70bc <.L23>
    70a4:	1802      	jc	0x70aa <.L24>
    70a6:	ac03      	cmp	A, #3
    70a8:	1d32      	jne	0x710e <.L29>

000070aa <.L24>:
            break;
        }
        case sfa_UpdateSignals:     /* For M2S frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&MOTOR3_States_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
    70aa:	54ca 0004 	pushw	#4

000070ae <.LCFI13>:
    70ae:	54ca 5b5a 	pushw	#23386

000070b2 <.LCFI14>:
    70b2:	72da 11d4 	lod	A, #4564

000070b6 <.LVL42>:
    70b6:	1696      	call	0x6de4 <_l_SetFlagsMask>

000070b8 <.LM34>:
            break;
    70b8:	5c03      	dec	S, #4

000070ba <.LCFI15>:
    70ba:	0027      	jmp	0x710a <.L30>

000070bc <.L23>:

    switch (frameAction) {
        case sfa_FillBuffer:    /* For S2M frames */
        {
            /* Freeze the volatile Signal values */
            l_u8 sig_LIN_MOTOR3_State = l_signals.LIN_MOTOR3_State;
    70bc:	66d8 102a 	lod	YL, 0x102a <.LASF1417+0x3>

000070c0 <.LM36>:
            l_bool sig_LIN_Error = l_signals.LIN_Error;
    70c0:	62d8 102d 	lod	AL, 0x102d <.LASF1417+0x6>

000070c4 <.LM37>:
            l_u16 sig_LIN_MOTOR3_Reserve1 = l_signals.LIN_MOTOR3_Reserve1;
    70c4:	7ed8 103a 	lod	X, 0x103a <.LASF1417+0x13>
    70c8:	5e01      	mov	[S-2], X

000070ca <.LM38>:
            l_u16 sig_LIN_MOTOR3_Reserve2 = l_signals.LIN_MOTOR3_Reserve2;
    70ca:	7ed8 103c 	lod	X, 0x103c <.LASF1417+0x15>

000070ce <.LVL48>:
    70ce:	5e03      	mov	[S-4], X

000070d0 <.LM39>:
            l_u16 sig_LIN_MOTOR3_Reserve3 = l_signals.LIN_MOTOR3_Reserve3;
    70d0:	7ed8 103e 	lod	X, 0x103e <.LASF1417+0x17>

000070d4 <.LVL50>:
    70d4:	5e05      	mov	[S-6], X

000070d6 <.LM40>:

            l_sl1_MOTOR3_States_data_t MOTOR3_States_data = {
    70d6:	460d      	mov	[S-14], YL
    70d8:	b401      	and	A, #1

000070da <.LVL52>:
    70da:	6800      	lod	AH, #0
    70dc:	72e4      	swap	A
    70de:	7ae2      	lod	Y, A

000070e0 <.LVL53>:
    70e0:	720d      	lod	A, [S-14]
    70e2:	d4fe      	and	AH, #-2
    70e4:	a6e6      	or	A, Y
    70e6:	520d      	mov	[S-14], A

000070e8 <.LVL54>:
    70e8:	7aef      	lod	Y, S
    70ea:	e0f3      	add	Y, #-13
    70ec:	62f0      	lod	AL, [Y]
    70ee:	84fe      	or	AL, #-2
    70f0:	42f0      	mov	[Y], AL
    70f2:	7e01      	lod	X, [S-2]

000070f4 <.LVL55>:
    70f4:	5e0b      	mov	[S-12], X
    70f6:	7e03      	lod	X, [S-4]
    70f8:	5e09      	mov	[S-10], X
    70fa:	7e05      	lod	X, [S-6]
    70fc:	5e07      	mov	[S-8], X

000070fe <.LM41>:
                0x7f,
                sig_LIN_MOTOR3_Reserve1,
                sig_LIN_MOTOR3_Reserve2,
                sig_LIN_MOTOR3_Reserve3
            };
            l_FillBufferSlave((l_u8*)&MOTOR3_States_data, (l_u8)sizeof(l_sl1_MOTOR3_States_data_t));
    70fe:	54ca 0008 	pushw	#8

00007102 <.LCFI16>:
    7102:	72ef      	lod	A, S
    7104:	a0f0      	add	A, #-16
    7106:	1741      	call	0x6f8a <_l_FillBufferSlave>

00007108 <.LVL57>:
    7108:	5c01      	dec	S, #2

0000710a <.L30>:
} l_sl1_MOTOR3_States_data_t;
ASSERT(sizeof(l_sl1_MOTOR3_States_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_MOTOR3_States_handler (l_s_FrameAction_t frameAction)
{
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    710a:	7000      	lod	A, #0

0000710c <.LM43>:
        }
        case sfa_UpdateSignals:     /* For M2S frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&MOTOR3_States_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
            break;
    710c:	540f      	ret	#16

0000710e <.L29>:
        }
        case sfa_CheckFlags:    /* Only for frames associated with an Event-triggered frame */
        default:
            retVal = sfhs_Fail;
    710e:	7001      	lod	A, #1

00007110 <.LM45>:
            break;
    }
    return retVal;
}
    7110:	540f      	ret	#16

00007112 <_l_sl1_MOTOR2_States_handler>:
    l_u16 sig_LIN_MOTOR2_Reserve3  : 16;
} l_sl1_MOTOR2_States_data_t;
ASSERT(sizeof(l_sl1_MOTOR2_States_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_MOTOR2_States_handler (l_s_FrameAction_t frameAction)
{
    7112:	580d      	inc	S, #14

00007114 <.LCFI18>:
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    static const l_sl1_flags_t MOTOR2_States_flags_mask = {{0x88, 0x38, 0x0, 0x1}};

    switch (frameAction) {
    7114:	ac01      	cmp	A, #1
    7116:	190c      	je	0x7130 <.L33>
    7118:	1802      	jc	0x711e <.L34>
    711a:	ac03      	cmp	A, #3
    711c:	1d32      	jne	0x7182 <.L39>

0000711e <.L34>:
            break;
        }
        case sfa_UpdateSignals:     /* For M2S frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&MOTOR2_States_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
    711e:	54ca 0004 	pushw	#4

00007122 <.LCFI19>:
    7122:	54ca 5b56 	pushw	#23382

00007126 <.LCFI20>:
    7126:	72da 11d4 	lod	A, #4564

0000712a <.LVL62>:
    712a:	165c      	call	0x6de4 <_l_SetFlagsMask>

0000712c <.LM49>:
            break;
    712c:	5c03      	dec	S, #4

0000712e <.LCFI21>:
    712e:	0027      	jmp	0x717e <.L40>

00007130 <.L33>:

    switch (frameAction) {
        case sfa_FillBuffer:    /* For S2M frames */
        {
            /* Freeze the volatile Signal values */
            l_u8 sig_LIN_MOTOR2_State = l_signals.LIN_MOTOR2_State;
    7130:	66d8 1029 	lod	YL, 0x1029 <.LASF1417+0x2>

00007134 <.LM51>:
            l_bool sig_LIN_Error = l_signals.LIN_Error;
    7134:	62d8 102d 	lod	AL, 0x102d <.LASF1417+0x6>

00007138 <.LM52>:
            l_u16 sig_LIN_MOTOR2_Reserve1 = l_signals.LIN_MOTOR2_Reserve1;
    7138:	7ed8 1034 	lod	X, 0x1034 <.LASF1417+0xd>
    713c:	5e01      	mov	[S-2], X

0000713e <.LM53>:
            l_u16 sig_LIN_MOTOR2_Reserve2 = l_signals.LIN_MOTOR2_Reserve2;
    713e:	7ed8 1036 	lod	X, 0x1036 <.LASF1417+0xf>

00007142 <.LVL68>:
    7142:	5e03      	mov	[S-4], X

00007144 <.LM54>:
            l_u16 sig_LIN_MOTOR2_Reserve3 = l_signals.LIN_MOTOR2_Reserve3;
    7144:	7ed8 1038 	lod	X, 0x1038 <.LASF1417+0x11>

00007148 <.LVL70>:
    7148:	5e05      	mov	[S-6], X

0000714a <.LM55>:

            l_sl1_MOTOR2_States_data_t MOTOR2_States_data = {
    714a:	460d      	mov	[S-14], YL
    714c:	b401      	and	A, #1

0000714e <.LVL72>:
    714e:	6800      	lod	AH, #0
    7150:	72e4      	swap	A
    7152:	7ae2      	lod	Y, A

00007154 <.LVL73>:
    7154:	720d      	lod	A, [S-14]
    7156:	d4fe      	and	AH, #-2
    7158:	a6e6      	or	A, Y
    715a:	520d      	mov	[S-14], A

0000715c <.LVL74>:
    715c:	7aef      	lod	Y, S
    715e:	e0f3      	add	Y, #-13
    7160:	62f0      	lod	AL, [Y]
    7162:	84fe      	or	AL, #-2
    7164:	42f0      	mov	[Y], AL
    7166:	7e01      	lod	X, [S-2]

00007168 <.LVL75>:
    7168:	5e0b      	mov	[S-12], X
    716a:	7e03      	lod	X, [S-4]
    716c:	5e09      	mov	[S-10], X
    716e:	7e05      	lod	X, [S-6]
    7170:	5e07      	mov	[S-8], X

00007172 <.LM56>:
                0x7f,
                sig_LIN_MOTOR2_Reserve1,
                sig_LIN_MOTOR2_Reserve2,
                sig_LIN_MOTOR2_Reserve3
            };
            l_FillBufferSlave((l_u8*)&MOTOR2_States_data, (l_u8)sizeof(l_sl1_MOTOR2_States_data_t));
    7172:	54ca 0008 	pushw	#8

00007176 <.LCFI22>:
    7176:	72ef      	lod	A, S
    7178:	a0f0      	add	A, #-16
    717a:	1707      	call	0x6f8a <_l_FillBufferSlave>

0000717c <.LVL77>:
    717c:	5c01      	dec	S, #2

0000717e <.L40>:
} l_sl1_MOTOR2_States_data_t;
ASSERT(sizeof(l_sl1_MOTOR2_States_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_MOTOR2_States_handler (l_s_FrameAction_t frameAction)
{
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    717e:	7000      	lod	A, #0

00007180 <.LM58>:
        }
        case sfa_UpdateSignals:     /* For M2S frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&MOTOR2_States_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
            break;
    7180:	540f      	ret	#16

00007182 <.L39>:
        }
        case sfa_CheckFlags:    /* Only for frames associated with an Event-triggered frame */
        default:
            retVal = sfhs_Fail;
    7182:	7001      	lod	A, #1

00007184 <.LM60>:
            break;
    }
    return retVal;
}
    7184:	540f      	ret	#16

00007186 <_l_sl1_MOTOR1_States_handler>:
    l_u16 sig_LIN_MOTOR1_Reserve3  : 16;
} l_sl1_MOTOR1_States_data_t;
ASSERT(sizeof(l_sl1_MOTOR1_States_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_MOTOR1_States_handler (l_s_FrameAction_t frameAction)
{
    7186:	580d      	inc	S, #14

00007188 <.LCFI24>:
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    static const l_sl1_flags_t MOTOR1_States_flags_mask = {{0x84, 0x7, 0x80, 0x0}};

    switch (frameAction) {
    7188:	ac01      	cmp	A, #1
    718a:	190c      	je	0x71a4 <.L43>
    718c:	1802      	jc	0x7192 <.L44>
    718e:	ac03      	cmp	A, #3
    7190:	1d32      	jne	0x71f6 <.L49>

00007192 <.L44>:
            break;
        }
        case sfa_UpdateSignals:     /* For M2S frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&MOTOR1_States_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
    7192:	54ca 0004 	pushw	#4

00007196 <.LCFI25>:
    7196:	54ca 5b52 	pushw	#23378

0000719a <.LCFI26>:
    719a:	72da 11d4 	lod	A, #4564

0000719e <.LVL82>:
    719e:	1622      	call	0x6de4 <_l_SetFlagsMask>

000071a0 <.LM64>:
            break;
    71a0:	5c03      	dec	S, #4

000071a2 <.LCFI27>:
    71a2:	0027      	jmp	0x71f2 <.L50>

000071a4 <.L43>:

    switch (frameAction) {
        case sfa_FillBuffer:    /* For S2M frames */
        {
            /* Freeze the volatile Signal values */
            l_u8 sig_LIN_MOTOR1_State = l_signals.LIN_MOTOR1_State;
    71a4:	66d8 1028 	lod	YL, 0x1028 <.LASF1417+0x1>

000071a8 <.LM66>:
            l_bool sig_LIN_Error = l_signals.LIN_Error;
    71a8:	62d8 102d 	lod	AL, 0x102d <.LASF1417+0x6>

000071ac <.LM67>:
            l_u16 sig_LIN_MOTOR1_Reserve1 = l_signals.LIN_MOTOR1_Reserve1;
    71ac:	7ed8 102e 	lod	X, 0x102e <.LASF1417+0x7>
    71b0:	5e01      	mov	[S-2], X

000071b2 <.LM68>:
            l_u16 sig_LIN_MOTOR1_Reserve2 = l_signals.LIN_MOTOR1_Reserve2;
    71b2:	7ed8 1030 	lod	X, 0x1030 <.LASF1417+0x9>

000071b6 <.LVL88>:
    71b6:	5e03      	mov	[S-4], X

000071b8 <.LM69>:
            l_u16 sig_LIN_MOTOR1_Reserve3 = l_signals.LIN_MOTOR1_Reserve3;
    71b8:	7ed8 1032 	lod	X, 0x1032 <.LASF1417+0xb>

000071bc <.LVL90>:
    71bc:	5e05      	mov	[S-6], X

000071be <.LM70>:

            l_sl1_MOTOR1_States_data_t MOTOR1_States_data = {
    71be:	460d      	mov	[S-14], YL
    71c0:	b401      	and	A, #1

000071c2 <.LVL92>:
    71c2:	6800      	lod	AH, #0
    71c4:	72e4      	swap	A
    71c6:	7ae2      	lod	Y, A

000071c8 <.LVL93>:
    71c8:	720d      	lod	A, [S-14]
    71ca:	d4fe      	and	AH, #-2
    71cc:	a6e6      	or	A, Y
    71ce:	520d      	mov	[S-14], A

000071d0 <.LVL94>:
    71d0:	7aef      	lod	Y, S
    71d2:	e0f3      	add	Y, #-13
    71d4:	62f0      	lod	AL, [Y]
    71d6:	84fe      	or	AL, #-2
    71d8:	42f0      	mov	[Y], AL
    71da:	7e01      	lod	X, [S-2]

000071dc <.LVL95>:
    71dc:	5e0b      	mov	[S-12], X
    71de:	7e03      	lod	X, [S-4]
    71e0:	5e09      	mov	[S-10], X
    71e2:	7e05      	lod	X, [S-6]
    71e4:	5e07      	mov	[S-8], X

000071e6 <.LM71>:
                0x7f,
                sig_LIN_MOTOR1_Reserve1,
                sig_LIN_MOTOR1_Reserve2,
                sig_LIN_MOTOR1_Reserve3
            };
            l_FillBufferSlave((l_u8*)&MOTOR1_States_data, (l_u8)sizeof(l_sl1_MOTOR1_States_data_t));
    71e6:	54ca 0008 	pushw	#8

000071ea <.LCFI28>:
    71ea:	72ef      	lod	A, S
    71ec:	a0f0      	add	A, #-16
    71ee:	16cd      	call	0x6f8a <_l_FillBufferSlave>

000071f0 <.LVL97>:
    71f0:	5c01      	dec	S, #2

000071f2 <.L50>:
} l_sl1_MOTOR1_States_data_t;
ASSERT(sizeof(l_sl1_MOTOR1_States_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_MOTOR1_States_handler (l_s_FrameAction_t frameAction)
{
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    71f2:	7000      	lod	A, #0

000071f4 <.LM73>:
        }
        case sfa_UpdateSignals:     /* For M2S frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&MOTOR1_States_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
            break;
    71f4:	540f      	ret	#16

000071f6 <.L49>:
        }
        case sfa_CheckFlags:    /* Only for frames associated with an Event-triggered frame */
        default:
            retVal = sfhs_Fail;
    71f6:	7001      	lod	A, #1

000071f8 <.LM75>:
            break;
    }
    return retVal;
}
    71f8:	540f      	ret	#16

000071fa <_l_sl1_MotorsControl_handler>:
static l_s_FrameHandlerStatus_t l_sl1_MotorsControl_handler (l_s_FrameAction_t frameAction)
{
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    static const l_sl1_flags_t MotorsControl_flags_mask = {{0x3, 0x0, 0x0, 0x10}};

    switch (frameAction) {
    71fa:	ac01      	cmp	A, #1
    71fc:	1903      	je	0x7204 <.L53>
    71fe:	180b      	jc	0x7216 <.L54>
    7200:	ac03      	cmp	A, #3
    7202:	1d14      	jne	0x722c <.L62>

00007204 <.L53>:
            break;
        }
        case sfa_FillBuffer:    /* For S2M frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&MotorsControl_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
    7204:	54ca 0004 	pushw	#4

00007208 <.LCFI30>:
    7208:	54ca 5b4e 	pushw	#23374

0000720c <.LCFI31>:
    720c:	72da 11d4 	lod	A, #4564

00007210 <.LVL101>:
    7210:	15e9      	call	0x6de4 <_l_SetFlagsMask>

00007212 <.LM79>:
            break;
    7212:	5c03      	dec	S, #4

00007214 <.LCFI32>:
    7214:	0009      	jmp	0x7228 <.L63>

00007216 <.L54>:

    switch (frameAction) {
        case sfa_UpdateSignals:    /* For M2S frames */
        {
            l_sl1_MotorsControl_data_t MLXCOMP_354_WA *MotorsControl_data = (l_sl1_MotorsControl_data_t*)ML_SLAVE_FRAME_DATA_BUFFER;
            l_signals.LIN_SlaveFlag = MotorsControl_data->sig_LIN_SlaveFlag;
    7216:	62d8 1004 	lod	AL, 0x1004 <_ml_Data>

0000721a <.LVL104>:
    721a:	42d8 1026 	mov	0x1026 <_l_signals>, AL

0000721e <.LM81>:
            l_signals.LIN_Target_Angle = MotorsControl_data->sig_LIN_Target_Angle;
    721e:	62d8 1005 	lod	AL, 0x1005 <_ml_Data+0x1>
    7222:	0ea7      	lod	C, ML.7
    7224:	42d8 1027 	mov	0x1027 <.LASF1417>, AL

00007228 <.L63>:
} l_sl1_MotorsControl_data_t;
ASSERT(sizeof(l_sl1_MotorsControl_data_t) == 2);

static l_s_FrameHandlerStatus_t l_sl1_MotorsControl_handler (l_s_FrameAction_t frameAction)
{
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    7228:	7000      	lod	A, #0

0000722a <.LM83>:
        }
        case sfa_FillBuffer:    /* For S2M frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&MotorsControl_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
            break;
    722a:	5401      	ret

0000722c <.L62>:
        }
        case sfa_CheckFlags:    /* Only for frames associated with an Event-triggered frame */
        default:
            retVal = sfhs_Fail;
    722c:	7001      	lod	A, #1

0000722e <.LM85>:
            break;
    }
    return retVal;
}
    722e:	5401      	ret

00007230 <_main>:
 *   Stop
 * \enduml
 * @return 0
 */
int main(void)
{
    7230:	5809      	inc	S, #10

00007232 <.LBB372>:

/** WDG_disableIwdIt disables the intelligent watchdog timer interrupt */
STATIC INLINE void WDG_disableIwdIt(void)
{
    /* disable IWD interrupt */
    IO_SET(MLX16, IWD_ATT_ITC, 0u);
    7232:	62d8 006c 	lod	AL, 0x6c <.LASF730+0xd>
    7236:	94f7      	and	AL, #-9
    7238:	42d8 006c 	mov	0x6c <.LASF730+0xd>, AL

0000723c <.LBB374>:
/**
 * Log reset source
 */
static void log_reset_source(void)
{
    if (IO_GET(PORT_MISC_IN, LOCAL_WU) != 0u)
    723c:	72d8 01e2 	lod	A, 0x1e2 <_PORT_MISC_IN>
    7240:	d440      	and	AH, #64
    7242:	1d05      	jne	0x724e <.L2>

00007244 <.LM4>:
    {

    }
    else if (IO_GET(PORT_MISC_IN, LIN_WU) != 0u)
    7244:	72d8 01e2 	lod	A, 0x1e2 <_PORT_MISC_IN>
    7248:	d408      	and	AH, #8
    724a:	1d01      	jne	0x724e <.L2>

0000724c <.LM5>:
    {

    }
    else if (IO_GET(RST_CTRL, AWD_WBOOT) != 0u)
    724c:	7282      	lod	A, io:0x2 <_RST_CTRL>

0000724e <.L2>:
    WDG_disableIwdIt();

    /* Log reset source */
    log_reset_source();

    softio_configureOutput(1);
    724e:	7001      	lod	A, #1
    7250:	82db 41d7 	callf	0x83ae <_softio_configureOutput>

00007254 <.LM7>:
    softio_configureOutput(2);
    7254:	7002      	lod	A, #2
    7256:	82db 41d7 	callf	0x83ae <_softio_configureOutput>

0000725a <.LM8>:

    /* Initialize the timeout timer module */
    swtimer_init();
    725a:	82db 3f25 	callf	0x7e4a <_swtimer_init>

0000725e <.LM9>:

    /* Initialize the eeprom handler */
    eeprom_Init();
    725e:	82db 319e 	callf	0x633c <_eeprom_Init>

00007262 <.LM10>:

    /* initialize the pwm module */
    pwm_Init();
    7262:	12df      	call	0x7822 <_pwm_Init>

00007264 <.LM11>:

    /* Initialize the lin handler */
    lin22_Init();
    7264:	82db 33d9 	callf	0x67b2 <_lin22_Init>

00007268 <.LM12>:

    /* diag & prot */
    protection_Init();
    7268:	123a      	call	0x76de <_protection_Init>

0000726a <.LM13>:
	
    /* Initialize the adc driver */
    adc_Init();
    726a:	82db 2e67 	callf	0x5cce <_adc_Init>

0000726e <.LM14>:
    g_u16VBGD = (uint16_t)adc_ConvertToVoltage(adc_CaptureOneChannel(ADC_SIG_VBG_D));
    726e:	7004      	lod	A, #4
    7270:	82db 2f2d 	callf	0x5e5a <_adc_CaptureOneChannel>
    7274:	82db 2fa0 	callf	0x5f40 <_adc_ConvertToVoltage>
    7278:	7ee2      	lod	X, A
    727a:	52d8 1052 	mov	0x1052 <_g_u16VBGD>, A

0000727e <.LM15>:
    if (!g_bElectricDefect && (g_u16VBGD < (1150 - 200) || g_u16VBGD > (1220 + 200)))
    727e:	62d8 10bb 	lod	AL, 0x10bb <_g_bElectricDefect>
    7282:	1d08      	jne	0x7294 <.L3>

00007284 <.LM16>:
    7284:	22da fc4a 	add	X, #64586
    7288:	2eda 01d6 	cmp	X, #470
    728c:	1a03      	jule	0x7294 <.L3>

0000728e <.LM17>:
    {
        g_bElectricDefect = true;
    728e:	6001      	lod	AL, #1
    7290:	42d8 10bb 	mov	0x10bb <_g_bElectricDefect>, AL

00007294 <.L3>:
    }
    adc_Shunt_OffsetCalib();
    7294:	82db 2ede 	callf	0x5dbc <_adc_Shunt_OffsetCalib>

00007298 <.LM19>:
    adc_Start(true);  /* pwm must be initialized before you can use the do start and wait for loop */
    7298:	7001      	lod	A, #1
    729a:	82db 2e8e 	callf	0x5d1c <_adc_Start>

0000729e <.LBB376>:
 * @returns  raw Vsm adc sample.
 */
static INLINE uint16_t adc_GetRawVsm(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_VSM];
    729e:	7ada 10f6 	lod	Y, #4342
    72a2:	72f0      	lod	A, [Y]

000072a4 <.LBE376>:

    l_u32MotorSupplyVoltageFilter = adc_GetRawVsm() * 4u;
    72a4:	44a2      	asl	A, #2
    72a6:	4cc8      	movu	D, A
    72a8:	7eda 10b6 	lod	X, #4278
    72ac:	4c87      	mov	[X], D

000072ae <.LBB378>:
 * @returns  raw Vs adc sample.
 */
static INLINE uint16_t adc_GetRawVs(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_VS];
    72ae:	72d8 10fa 	lod	A, 0x10fa <.LASF909+0x2>

000072b2 <.LBE378>:
    l_u32SupplyVoltageFilter = adc_GetRawVs() * 4u;
    72b2:	44a2      	asl	A, #2
    72b4:	4cc8      	movu	D, A
    72b6:	7eda 10b2 	lod	X, #4274
    72ba:	4c87      	mov	[X], D

000072bc <.LBB380>:
 * @returns  raw temperature adc sample.
 */
static INLINE uint16_t adc_GetRawTemperature(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_TEMP];
    72bc:	72d8 10f8 	lod	A, 0x10f8 <.LASF909>

000072c0 <.LBE380>:
    l_u32ChipTemperatureFilter = adc_GetRawTemperature() * 4u;
    72c0:	44a2      	asl	A, #2
    72c2:	4cc8      	movu	D, A
    72c4:	7eda 10ae 	lod	X, #4270
    72c8:	4c87      	mov	[X], D

000072ca <.LM26>:

    /* Start application */
    IO_SET(PORT_IO_ENABLE, IO_DISREC, 0x04);	// IO Disconnect receiver IO3 -> ADC
    72ca:	72d8 023a 	lod	A, 0x23a <_PORT_IO_ENABLE>
    72ce:	d4f0      	and	AH, #-16
    72d0:	c404      	or	AH, #4
    72d2:	52d8 023a 	mov	0x23a <_PORT_IO_ENABLE>, A

000072d6 <.LM27>:

	//250414 - PWM Dual Capture by lin-in pin.
    pwm_communication_Init();
    72d6:	5a09      	mov	[S-10], Y
    72d8:	82db 3f1c 	callf	0x7e38 <_pwm_communication_Init>

000072dc <.LM28>:
    pwm_communication_Start();
    72dc:	82db 3f1d 	callf	0x7e3a <_pwm_communication_Start>

000072e0 <.LBB382>:
        );
}

STATIC INLINE void builtin_mlx16_enter_user_mode(void)
{
    __asm__ __volatile__ ("setb MH.3" ::: "M", "memory");
    72e0:	0ab3      	setb	MH.3

000072e2 <.LBE382>:

    builtin_mlx16_enter_user_mode();

    swtimer_register(SWTIMER_TASK_1ms, 1 * PI_TICKS_PER_MILLISECOND, REPETITIVE);
    72e2:	54ca 0001 	pushw	#1

000072e6 <.LCFI1>:
    72e6:	54ca 0001 	pushw	#1

000072ea <.LCFI2>:
    72ea:	7005      	lod	A, #5
    72ec:	82db 3f62 	callf	0x7ec4 <_swtimer_register>

000072f0 <.LM31>:
    swtimer_register(SWTIMER_TASK_3ms, 3 * PI_TICKS_PER_MILLISECOND, REPETITIVE);
    72f0:	54ca 0001 	pushw	#1

000072f4 <.LCFI3>:
    72f4:	54ca 0003 	pushw	#3

000072f8 <.LCFI4>:
    72f8:	7006      	lod	A, #6
    72fa:	82db 3f62 	callf	0x7ec4 <_swtimer_register>

000072fe <.LM32>:
    swtimer_register(SWTIMER_TASK_5ms, 5 * PI_TICKS_PER_MILLISECOND, REPETITIVE);
    72fe:	54ca 0001 	pushw	#1

00007302 <.LCFI5>:
    7302:	54ca 0005 	pushw	#5

00007306 <.LCFI6>:
    7306:	7007      	lod	A, #7
    7308:	82db 3f62 	callf	0x7ec4 <_swtimer_register>

0000730c <.LM33>:

    swtimer_start(SWTIMER_TASK_1ms);
    730c:	7005      	lod	A, #5
    730e:	82db 3f78 	callf	0x7ef0 <_swtimer_start>

00007312 <.LM34>:
    swtimer_start(SWTIMER_TASK_3ms);
    7312:	7006      	lod	A, #6
    7314:	82db 3f78 	callf	0x7ef0 <_swtimer_start>

00007318 <.LM35>:
    swtimer_start(SWTIMER_TASK_5ms);
    7318:	7007      	lod	A, #7
    731a:	82db 3f78 	callf	0x7ef0 <_swtimer_start>
    731e:	5c0b      	dec	S, #12

00007320 <.L24>:
#endif
	return result;
}
static __attribute__((always_inline)) inline uint16_t IO_AWD__WIN_OPEN_GET (void) {
	register uint16_t result;
	asm volatile (
    7320:	0f7f      	lod	C, io:0x0f.7

00007322 <.LBE386>:
}

/** WDG_conditionalAwdRefresh acknowledges the AWD timer if its window is opened */
STATIC INLINE void WDG_conditionalAwdRefresh(void)
{
    if (IO_GET(AWD, WIN_OPEN) != 0u) {
    7322:	1c01      	jnc	0x7326 <.L4>

00007324 <.LM38>:
        IO_SET(AWD, ACK, 1u);
    7324:	0b76      	setb	io:0x0e.6

00007326 <.L4>:
 * @returns  raw Vsm adc sample.
 */
static INLINE uint16_t adc_GetRawVsm(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_VSM];
    7326:	7ada 10f6 	lod	Y, #4342
    732a:	72f0      	lod	A, [Y]

0000732c <.LBB390>:
#ifndef FILTER_LPF_INLINE_IMPL_H
    #define FILTER_LPF_INLINE_IMPL_H

STATIC INLINE uint16_t filter_lpfU16(uint16_t in, uint32_t* reg, uint8_t k)
{
    *reg = *reg - ((*reg + (1 << (k - 1))) >> k) + (uint32_t)in;
    732c:	7eda 10b6 	lod	X, #4278
    7330:	4cf2      	usex	YA
    7332:	4cc7      	mov	D, [X]
    7334:	4c00      	add	D, YA
    7336:	5882      	mov	[S-8], D
    7338:	4cc7      	mov	D, [X]
    733a:	4c0a 0002 	addu	D, #2
    733e:	4c80      	mov	YA, D
    7340:	48a1      	lsr	YA, #2
    7342:	58a0      	mov	[S-4], YA
    7344:	58e2      	mov	YA, [S-8]
    7346:	aa03      	sub	A, [S-4]
    7348:	fa01      	subc	Y, [S-2]
    734a:	58a2      	mov	[S-8], YA
    734c:	4ca7      	mov	[X], YA

0000734e <.LM41>:
    return (uint16_t)((*reg + (1 << (k - 1))) >> k);
    734e:	4cc0      	mov	D, YA
    7350:	4c0a 0002 	addu	D, #2
    7354:	4c80      	mov	YA, D
    7356:	48a1      	lsr	YA, #2

00007358 <.LBE390>:
    /* Application loop */
    while (1u)
    {
    	WDG_conditionalAwdRefresh();  /* Restart watchdog */

        g_u16MotorSupplyVoltage =  adc_ConvertToVsmFiltered(filter_lpfU16(adc_GetRawVsm(), &l_u32MotorSupplyVoltageFilter, 2));
    7358:	82db 2f90 	callf	0x5f20 <_adc_ConvertToVsmFiltered>
    735c:	52d8 1058 	mov	0x1058 <_g_u16MotorSupplyVoltage>, A

00007360 <.LBB392>:
 * @returns  raw Vs adc sample.
 */
static INLINE uint16_t adc_GetRawVs(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_VS];
    7360:	72d8 10fa 	lod	A, 0x10fa <.LASF909+0x2>

00007364 <.LBB394>:
#ifndef FILTER_LPF_INLINE_IMPL_H
    #define FILTER_LPF_INLINE_IMPL_H

STATIC INLINE uint16_t filter_lpfU16(uint16_t in, uint32_t* reg, uint8_t k)
{
    *reg = *reg - ((*reg + (1 << (k - 1))) >> k) + (uint32_t)in;
    7364:	7eda 10b2 	lod	X, #4274
    7368:	4cf2      	usex	YA
    736a:	4cc7      	mov	D, [X]
    736c:	4c00      	add	D, YA
    736e:	5882      	mov	[S-8], D
    7370:	4cc7      	mov	D, [X]
    7372:	4c0a 0002 	addu	D, #2
    7376:	4c80      	mov	YA, D
    7378:	48a1      	lsr	YA, #2
    737a:	58a0      	mov	[S-4], YA
    737c:	58e2      	mov	YA, [S-8]
    737e:	aa03      	sub	A, [S-4]
    7380:	fa01      	subc	Y, [S-2]
    7382:	58a2      	mov	[S-8], YA
    7384:	4ca7      	mov	[X], YA

00007386 <.LM45>:
    return (uint16_t)((*reg + (1 << (k - 1))) >> k);
    7386:	4cc0      	mov	D, YA
    7388:	4c0a 0002 	addu	D, #2
    738c:	4c80      	mov	YA, D
    738e:	48a1      	lsr	YA, #2

00007390 <.LBE394>:
        g_u16SupplyVoltage = adc_ConvertToVsupply(filter_lpfU16(adc_GetRawVs(), &l_u32SupplyVoltageFilter, 2));
    7390:	82db 2f95 	callf	0x5f2a <_adc_ConvertToVsupply>
    7394:	52d8 1054 	mov	0x1054 <_g_u16SupplyVoltage>, A

00007398 <.LBB396>:
 * @returns  raw temperature adc sample.
 */
static INLINE uint16_t adc_GetRawTemperature(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_TEMP];
    7398:	72d8 10f8 	lod	A, 0x10f8 <.LASF909>

0000739c <.LBB398>:
#ifndef FILTER_LPF_INLINE_IMPL_H
    #define FILTER_LPF_INLINE_IMPL_H

STATIC INLINE uint16_t filter_lpfU16(uint16_t in, uint32_t* reg, uint8_t k)
{
    *reg = *reg - ((*reg + (1 << (k - 1))) >> k) + (uint32_t)in;
    739c:	7eda 10ae 	lod	X, #4270
    73a0:	4cf2      	usex	YA
    73a2:	4cc7      	mov	D, [X]
    73a4:	4c00      	add	D, YA
    73a6:	5882      	mov	[S-8], D
    73a8:	4cc7      	mov	D, [X]
    73aa:	4c0a 0002 	addu	D, #2
    73ae:	4c80      	mov	YA, D
    73b0:	48a1      	lsr	YA, #2
    73b2:	58a0      	mov	[S-4], YA
    73b4:	58e2      	mov	YA, [S-8]
    73b6:	aa03      	sub	A, [S-4]
    73b8:	fa01      	subc	Y, [S-2]
    73ba:	58a2      	mov	[S-8], YA
    73bc:	4ca7      	mov	[X], YA

000073be <.LM49>:
    return (uint16_t)((*reg + (1 << (k - 1))) >> k);
    73be:	4cc0      	mov	D, YA
    73c0:	4c0a 0002 	addu	D, #2
    73c4:	4c80      	mov	YA, D
    73c6:	48a1      	lsr	YA, #2

000073c8 <.LBE398>:
        g_i16ChipTemperature = adc_ConvertToTchip(filter_lpfU16(adc_GetRawTemperature(), &l_u32ChipTemperatureFilter, 2));
    73c8:	82db 2f8e 	callf	0x5f1c <_adc_ConvertToTchip>
    73cc:	52d8 1056 	mov	0x1056 <_g_i16ChipTemperature>, A

000073d0 <.LBB400>:
static INLINE uint16_t adc_GetRawCurrent(void)
{
    extern volatile uint16_t dBase[];
    extern int16_t i16MotorCurrentZeroOffset;

    return (dBase[ADC_SAMPLE_CURR] - i16MotorCurrentZeroOffset);
    73d0:	72d8 1100 	lod	A, 0x1100 <.LASF909+0x8>
    73d4:	aad8 105c 	sub	A, 0x105c <_i16MotorCurrentZeroOffset>

000073d8 <.LBE400>:
        g_i16ShuntCurrent = (int16_t)adc_ConvertToCurrent(adc_GetRawCurrent());
    73d8:	82db 2f8d 	callf	0x5f1a <_adc_ConvertToCurrent>
    73dc:	52d8 10ac 	mov	0x10ac <_g_i16ShuntCurrent>, A

000073e0 <.LBB402>:
 * @returns  raw VDDA voltage sample.
 */
static INLINE uint16_t adc_GetRawVdda(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_VDDA];
    73e0:	72d8 10fc 	lod	A, 0x10fc <.LASF909+0x4>

000073e4 <.LBB404>:
 */
MATHLIB_INLINE_STATIC __inline__ uint32_t mulU32_U16byU16(uint16_t multiplicand, uint16_t multiplier)
{
    uint32_t result;

    __asm__ __volatile__ (
    73e4:	4822 1388 	mulu	YA, A, #5000

000073e8 <.LBE404>:
        g_u16VDDA = (uint16_t)(mulU32_U16byU16(adc_GetRawVdda(), 5000u) / 1024u);
    73e8:	48a9      	lsr	YA, #10
    73ea:	52d8 11e2 	mov	0x11e2 <_g_u16VDDA>, A

000073ee <.LBB406>:
 * @returns  raw IO voltage sample.
 */
static INLINE uint16_t adc_GetRawIO3(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_IO3];
    73ee:	72d8 10fe 	lod	A, 0x10fe <.LASF909+0x6>

000073f2 <.LBE406>:
        g_u16PositionSensor = (adc_ConvertToVio(adc_GetRawIO3())-24);
    73f2:	82db 2f9a 	callf	0x5f34 <_adc_ConvertToVio>
    73f6:	a0e8      	add	A, #-24
    73f8:	52d8 10aa 	mov	0x10aa <_g_u16PositionSensor>, A

000073fc <.LM58>:

        protection_CheckShort();
    73fc:	1188      	call	0x770e <_protection_CheckShort>

000073fe <.LM59>:
        protection_CheckSupplyMotorVoltage(g_u16MotorSupplyVoltage);
    73fe:	72d8 1058 	lod	A, 0x1058 <_g_u16MotorSupplyVoltage>
    7402:	1199      	call	0x7736 <_protection_CheckSupplyMotorVoltage>

00007404 <.LM60>:
        protection_CheckChipTemperature(g_i16ChipTemperature);
    7404:	72d8 1056 	lod	A, 0x1056 <_g_i16ChipTemperature>
    7408:	11e3      	call	0x77d0 <_protection_CheckChipTemperature>

0000740a <.LM61>:

        if (g_bUnderVoltageDetected)  /* log UV_VS interrupt detection */
    740a:	0ea7      	lod	C, ML.7
    740c:	62d8 10ba 	lod	AL, 0x10ba <_g_bUnderVoltageDetected>
    7410:	1903      	je	0x7418 <.L5>

00007412 <.LM62>:
        {
            g_bUnderVoltageDetected = false;
    7412:	6000      	lod	AL, #0
    7414:	42d8 10ba 	mov	0x10ba <_g_bUnderVoltageDetected>, AL

00007418 <.L5>:

        }

        if(swtimer_isTriggered(SWTIMER_TASK_1ms) != 0)
    7418:	7005      	lod	A, #5
    741a:	82db 3f99 	callf	0x7f32 <_swtimer_isTriggered>

0000741e <.LM64>:
        {
        	// 1ms task
        }
        if(swtimer_isTriggered(SWTIMER_TASK_3ms) != 0)
    741e:	7006      	lod	A, #6
    7420:	82db 3f99 	callf	0x7f32 <_swtimer_isTriggered>

00007424 <.LM65>:
        {
        	// 3ms task
        }
        if(swtimer_isTriggered(SWTIMER_TASK_5ms) != 0)
    7424:	7007      	lod	A, #7
    7426:	82db 3f99 	callf	0x7f32 <_swtimer_isTriggered>

0000742a <.LBB408>:
static void background_Handler(void)
{
    static int16_t i16ChipTemperature = 35;
    uint8_t nad;
    /* Calibrate stimer over temperature */
    if (abs(g_i16ChipTemperature - i16ChipTemperature) > 10)
    742a:	72d8 1056 	lod	A, 0x1056 <_g_i16ChipTemperature>
    742e:	aad8 104c 	sub	A, 0x104c <___i16ChipTemperature_7994>
    7432:	1d81      	jnn	0x7436 <.L55>
    7434:	5cc2      	neg	A

00007436 <.L55>:
    7436:	ac0a      	cmp	A, #10
    7438:	1b08      	jsle	0x744a <.L6>

0000743a <.LBB410>:
 * @returns  raw temperature adc sample.
 */
static INLINE uint16_t adc_GetRawTemperature(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_TEMP];
    743a:	72d8 10f8 	lod	A, 0x10f8 <.LASF909>

0000743e <.LBE410>:
    {
        swtimer_calibrate(adc_GetRawTemperature());
    743e:	82db 3f55 	callf	0x7eaa <_swtimer_calibrate>

00007442 <.LM69>:
        i16ChipTemperature = g_i16ChipTemperature;
    7442:	72d8 1056 	lod	A, 0x1056 <_g_i16ChipTemperature>
    7446:	52d8 104c 	mov	0x104c <___i16ChipTemperature_7994>, A

0000744a <.L6>:
L_FLAGS(l_sl1_flags.mapped, f_MOTOR1_States, frame, MOTOR1_States)
L_FLAGS(l_sl1_flags.mapped, f_MOTOR2_States, frame, MOTOR2_States)
L_FLAGS(l_sl1_flags.mapped, f_MOTOR3_States, frame, MOTOR3_States)
L_FLAGS(l_sl1_flags.mapped, f_MOTOR4_States, frame, MOTOR4_States)
L_FLAGS(l_sl1_flags.mapped, f_MOTOR5_States, frame, MOTOR5_States)
L_FLAGS(l_sl1_flags.mapped, f_MotorsControl, frame, MotorsControl)
    744a:	62d8 11d7 	lod	AL, 0x11d7 <_l_sl1_flags+0x3>

0000744e <.LBE412>:
    }

	/* MotorControl_Frame handling */
	if (l_flg_tst_f_MotorsControl() != 0u)
    744e:	9410      	and	AL, #16
    7450:	1926      	je	0x749e <.L7>

00007452 <.LBB414>:
    7452:	82db 351c 	callf	0x6a38 <_l_sys_irq_disable>
    7456:	7ee2      	lod	X, A

00007458 <.LVL41>:
    7458:	62d8 11d7 	lod	AL, 0x11d7 <_l_sl1_flags+0x3>

0000745c <.LVL42>:
    745c:	94ef      	and	AL, #-17
    745e:	42d8 11d7 	mov	0x11d7 <_l_sl1_flags+0x3>, AL
    7462:	72ee      	lod	A, X
    7464:	82db 3524 	callf	0x6a48 <_l_sys_irq_restore>

00007468 <.LBB416>:

/*
 * Define API functions using templates
 */

L_SIGNAL(l_u8, LIN_SlaveFlag)
    7468:	66d8 1026 	lod	YL, 0x1026 <_l_signals>

0000746c <.LBE416>:
	{
		l_flg_clr_f_MotorsControl();

        nad = l_u8_rd_LIN_SlaveFlag();

        if((nad == ml_ConfiguredNAD ) || (nad == 0x7Fu))
    746c:	62e8      	lod	AL, YL
    746e:	5cf2      	usex	A
    7470:	7ee2      	lod	X, A
    7472:	62d8 1024 	lod	AL, 0x1024 <_ml_ConfiguredNAD>
    7476:	8ee8      	cmp	AL, YL
    7478:	1902      	je	0x747e <.L8>
    747a:	2c7f      	cmp	X, #127
    747c:	1d0d      	jne	0x7498 <.L9>

0000747e <.L8>:
L_SIGNAL(l_u8, LIN_Target_Angle)
    747e:	62d8 1027 	lod	AL, 0x1027 <.LASF1417>
    7482:	5cf2      	usex	A

00007484 <.LBE418>:
        {

            u16_LIN_Target_Angle = (uint16_t)l_u8_rd_LIN_Target_Angle();
    7484:	52d8 1050 	mov	0x1050 <_u16_LIN_Target_Angle>, A

00007488 <.LM77>:

            if(u16_LIN_Old_Target!=u16_LIN_Target_Angle)	//  LIN Target  LIN Target 
    7488:	aed8 11ea 	cmp	A, 0x11ea <_u16_LIN_Old_Target>
    748c:	1905      	je	0x7498 <.L9>

0000748e <.LM78>:
            {
            	g_Rotate_Done = 0;	// LIN_Target   clear
    748e:	6400      	lod	YL, #0
    7490:	46d8 10a3 	mov	0x10a3 <_g_Rotate_Done>, YL

00007494 <.LM79>:
            	u16_LIN_Old_Target=u16_LIN_Target_Angle;	//  LIN Target   .
    7494:	52d8 11ea 	mov	0x11ea <_u16_LIN_Old_Target>, A

00007498 <.L9>:
            }
        }

        g_LIN_PWM_Receive = true;
    7498:	6001      	lod	AL, #1
    749a:	42d8 10a2 	mov	0x10a2 <_g_LIN_PWM_Receive>, AL

0000749e <.L7>:
L_FLAGS(l_sl1_flags.mapped, s_LIN_MOTOR4_Reserve3, signal, LIN_MOTOR4_Reserve3)
L_FLAGS(l_sl1_flags.mapped, s_LIN_MOTOR5_Reserve1, signal, LIN_MOTOR5_Reserve1)
L_FLAGS(l_sl1_flags.mapped, s_LIN_MOTOR5_Reserve2, signal, LIN_MOTOR5_Reserve2)
L_FLAGS(l_sl1_flags.mapped, s_LIN_MOTOR5_Reserve3, signal, LIN_MOTOR5_Reserve3)

L_FLAGS(l_sl1_flags.mapped, f_MOTOR1_States, frame, MOTOR1_States)
    749e:	62d8 11d6 	lod	AL, 0x11d6 <_l_sl1_flags+0x2>
    74a2:	1d9d      	jnn	0x74de <.L11>

000074a4 <.LBB422>:
    74a4:	82db 351c 	callf	0x6a38 <_l_sys_irq_disable>
    74a8:	7ee2      	lod	X, A

000074aa <.LVL45>:
    74aa:	62d8 11d6 	lod	AL, 0x11d6 <_l_sl1_flags+0x2>

000074ae <.LVL46>:
    74ae:	947f      	and	AL, #127
    74b0:	42d8 11d6 	mov	0x11d6 <_l_sl1_flags+0x2>, AL
    74b4:	72ee      	lod	A, X
    74b6:	82db 3524 	callf	0x6a48 <_l_sys_irq_restore>

000074ba <.LBB424>:
 * Define API functions using templates
 */

L_SIGNAL(l_u8, LIN_SlaveFlag)
L_SIGNAL(l_u8, LIN_Target_Angle)
L_SIGNAL(l_u8, LIN_MOTOR1_State)
    74ba:	62d8 1024 	lod	AL, 0x1024 <_ml_ConfiguredNAD>
    74be:	42d8 1028 	mov	0x1028 <.LASF1417+0x1>, AL

000074c2 <.LBB426>:
L_SIGNAL(l_u8, LIN_MOTOR2_State)
L_SIGNAL(l_u8, LIN_MOTOR3_State)
L_SIGNAL(l_u8, LIN_MOTOR4_State)
L_SIGNAL(l_u8, LIN_MOTOR5_State)
L_SIGNAL(l_bool, LIN_Error)
L_SIGNAL(l_u16, LIN_MOTOR1_Reserve1)
    74c2:	72d8 10a8 	lod	A, 0x10a8 <_u16_CONV_Target_Angle>
    74c6:	0ea7      	lod	C, ML.7
    74c8:	52d8 102e 	mov	0x102e <.LASF1417+0x7>, A

000074cc <.LBB428>:
L_SIGNAL(l_u16, LIN_MOTOR1_Reserve2)
    74cc:	72d8 10aa 	lod	A, 0x10aa <_g_u16PositionSensor>
    74d0:	52d8 1030 	mov	0x1030 <.LASF1417+0x9>, A

000074d4 <.LBB430>:
L_SIGNAL(l_u16, LIN_MOTOR1_Reserve3)
    74d4:	0ea7      	lod	C, ML.7
    74d6:	72d8 11e2 	lod	A, 0x11e2 <_g_u16VDDA>
    74da:	52d8 1032 	mov	0x1032 <.LASF1417+0xb>, A

000074de <.L11>:
L_FLAGS(l_sl1_flags.mapped, s_LIN_MOTOR5_Reserve1, signal, LIN_MOTOR5_Reserve1)
L_FLAGS(l_sl1_flags.mapped, s_LIN_MOTOR5_Reserve2, signal, LIN_MOTOR5_Reserve2)
L_FLAGS(l_sl1_flags.mapped, s_LIN_MOTOR5_Reserve3, signal, LIN_MOTOR5_Reserve3)

L_FLAGS(l_sl1_flags.mapped, f_MOTOR1_States, frame, MOTOR1_States)
L_FLAGS(l_sl1_flags.mapped, f_MOTOR2_States, frame, MOTOR2_States)
    74de:	62d8 11d7 	lod	AL, 0x11d7 <_l_sl1_flags+0x3>

000074e2 <.LBE432>:


	}

	/* MOTOR2_States_Frame handling */
	if (l_flg_tst_f_MOTOR2_States() != 0u)		//update here..
    74e2:	9401      	and	AL, #1
    74e4:	191d      	je	0x7520 <.L12>

000074e6 <.LBB434>:
    74e6:	82db 351c 	callf	0x6a38 <_l_sys_irq_disable>
    74ea:	7ee2      	lod	X, A

000074ec <.LVL53>:
    74ec:	62d8 11d7 	lod	AL, 0x11d7 <_l_sl1_flags+0x3>

000074f0 <.LVL54>:
    74f0:	94fe      	and	AL, #-2
    74f2:	42d8 11d7 	mov	0x11d7 <_l_sl1_flags+0x3>, AL
    74f6:	72ee      	lod	A, X
    74f8:	82db 3524 	callf	0x6a48 <_l_sys_irq_restore>

000074fc <.LBB436>:
 */

L_SIGNAL(l_u8, LIN_SlaveFlag)
L_SIGNAL(l_u8, LIN_Target_Angle)
L_SIGNAL(l_u8, LIN_MOTOR1_State)
L_SIGNAL(l_u8, LIN_MOTOR2_State)
    74fc:	62d8 1024 	lod	AL, 0x1024 <_ml_ConfiguredNAD>
    7500:	42d8 1029 	mov	0x1029 <.LASF1417+0x2>, AL

00007504 <.LBB438>:
L_SIGNAL(l_u8, LIN_MOTOR5_State)
L_SIGNAL(l_bool, LIN_Error)
L_SIGNAL(l_u16, LIN_MOTOR1_Reserve1)
L_SIGNAL(l_u16, LIN_MOTOR1_Reserve2)
L_SIGNAL(l_u16, LIN_MOTOR1_Reserve3)
L_SIGNAL(l_u16, LIN_MOTOR2_Reserve1)
    7504:	72d8 10a8 	lod	A, 0x10a8 <_u16_CONV_Target_Angle>
    7508:	0ea7      	lod	C, ML.7
    750a:	52d8 1034 	mov	0x1034 <.LASF1417+0xd>, A

0000750e <.LBB440>:
L_SIGNAL(l_u16, LIN_MOTOR2_Reserve2)
    750e:	72d8 10aa 	lod	A, 0x10aa <_g_u16PositionSensor>
    7512:	52d8 1036 	mov	0x1036 <.LASF1417+0xf>, A

00007516 <.LBB442>:
L_SIGNAL(l_u16, LIN_MOTOR2_Reserve3)
    7516:	0ea7      	lod	C, ML.7
    7518:	72d8 11e2 	lod	A, 0x11e2 <_g_u16VDDA>
    751c:	52d8 1038 	mov	0x1038 <.LASF1417+0x11>, A

00007520 <.L12>:
L_FLAGS(l_sl1_flags.mapped, s_LIN_MOTOR5_Reserve2, signal, LIN_MOTOR5_Reserve2)
L_FLAGS(l_sl1_flags.mapped, s_LIN_MOTOR5_Reserve3, signal, LIN_MOTOR5_Reserve3)

L_FLAGS(l_sl1_flags.mapped, f_MOTOR1_States, frame, MOTOR1_States)
L_FLAGS(l_sl1_flags.mapped, f_MOTOR2_States, frame, MOTOR2_States)
L_FLAGS(l_sl1_flags.mapped, f_MOTOR3_States, frame, MOTOR3_States)
    7520:	62d8 11d7 	lod	AL, 0x11d7 <_l_sl1_flags+0x3>

00007524 <.LBE444>:
		l_u16_wr_LIN_MOTOR2_Reserve2(g_u16PositionSensor);
		l_u16_wr_LIN_MOTOR2_Reserve3(g_u16VDDA);//(g_u16VDDA);
	}

	/* MOTOR3_States_Frame handling */
	if (l_flg_tst_f_MOTOR3_States() != 0u)
    7524:	9402      	and	AL, #2
    7526:	191d      	je	0x7562 <.L13>

00007528 <.LBB446>:
    7528:	82db 351c 	callf	0x6a38 <_l_sys_irq_disable>
    752c:	7ee2      	lod	X, A

0000752e <.LVL61>:
    752e:	62d8 11d7 	lod	AL, 0x11d7 <_l_sl1_flags+0x3>

00007532 <.LVL62>:
    7532:	94fd      	and	AL, #-3
    7534:	42d8 11d7 	mov	0x11d7 <_l_sl1_flags+0x3>, AL
    7538:	72ee      	lod	A, X
    753a:	82db 3524 	callf	0x6a48 <_l_sys_irq_restore>

0000753e <.LBB448>:

L_SIGNAL(l_u8, LIN_SlaveFlag)
L_SIGNAL(l_u8, LIN_Target_Angle)
L_SIGNAL(l_u8, LIN_MOTOR1_State)
L_SIGNAL(l_u8, LIN_MOTOR2_State)
L_SIGNAL(l_u8, LIN_MOTOR3_State)
    753e:	62d8 1024 	lod	AL, 0x1024 <_ml_ConfiguredNAD>
    7542:	42d8 102a 	mov	0x102a <.LASF1417+0x3>, AL

00007546 <.LBB450>:
L_SIGNAL(l_u16, LIN_MOTOR1_Reserve2)
L_SIGNAL(l_u16, LIN_MOTOR1_Reserve3)
L_SIGNAL(l_u16, LIN_MOTOR2_Reserve1)
L_SIGNAL(l_u16, LIN_MOTOR2_Reserve2)
L_SIGNAL(l_u16, LIN_MOTOR2_Reserve3)
L_SIGNAL(l_u16, LIN_MOTOR3_Reserve1)
    7546:	72d8 10a8 	lod	A, 0x10a8 <_u16_CONV_Target_Angle>
    754a:	0ea7      	lod	C, ML.7
    754c:	52d8 103a 	mov	0x103a <.LASF1417+0x13>, A

00007550 <.LBB452>:
L_SIGNAL(l_u16, LIN_MOTOR3_Reserve2)
    7550:	72d8 10aa 	lod	A, 0x10aa <_g_u16PositionSensor>
    7554:	52d8 103c 	mov	0x103c <.LASF1417+0x15>, A

00007558 <.LBB454>:
L_SIGNAL(l_u16, LIN_MOTOR3_Reserve3)
    7558:	0ea7      	lod	C, ML.7
    755a:	72d8 11e2 	lod	A, 0x11e2 <_g_u16VDDA>
    755e:	52d8 103e 	mov	0x103e <.LASF1417+0x17>, A

00007562 <.L13>:
L_FLAGS(l_sl1_flags.mapped, s_LIN_MOTOR5_Reserve3, signal, LIN_MOTOR5_Reserve3)

L_FLAGS(l_sl1_flags.mapped, f_MOTOR1_States, frame, MOTOR1_States)
L_FLAGS(l_sl1_flags.mapped, f_MOTOR2_States, frame, MOTOR2_States)
L_FLAGS(l_sl1_flags.mapped, f_MOTOR3_States, frame, MOTOR3_States)
L_FLAGS(l_sl1_flags.mapped, f_MOTOR4_States, frame, MOTOR4_States)
    7562:	62d8 11d7 	lod	AL, 0x11d7 <_l_sl1_flags+0x3>

00007566 <.LBE456>:
		l_u16_wr_LIN_MOTOR3_Reserve2(g_u16PositionSensor);
		l_u16_wr_LIN_MOTOR3_Reserve3(g_u16VDDA);
	}

	/* MOTOR4_States_Frame handling */
	if (l_flg_tst_f_MOTOR4_States() != 0u)
    7566:	9404      	and	AL, #4
    7568:	191d      	je	0x75a4 <.L14>

0000756a <.LBB458>:
    756a:	82db 351c 	callf	0x6a38 <_l_sys_irq_disable>
    756e:	7ee2      	lod	X, A

00007570 <.LVL69>:
    7570:	62d8 11d7 	lod	AL, 0x11d7 <_l_sl1_flags+0x3>

00007574 <.LVL70>:
    7574:	94fb      	and	AL, #-5
    7576:	42d8 11d7 	mov	0x11d7 <_l_sl1_flags+0x3>, AL
    757a:	72ee      	lod	A, X
    757c:	82db 3524 	callf	0x6a48 <_l_sys_irq_restore>

00007580 <.LBB460>:
L_SIGNAL(l_u8, LIN_SlaveFlag)
L_SIGNAL(l_u8, LIN_Target_Angle)
L_SIGNAL(l_u8, LIN_MOTOR1_State)
L_SIGNAL(l_u8, LIN_MOTOR2_State)
L_SIGNAL(l_u8, LIN_MOTOR3_State)
L_SIGNAL(l_u8, LIN_MOTOR4_State)
    7580:	62d8 1024 	lod	AL, 0x1024 <_ml_ConfiguredNAD>
    7584:	42d8 102b 	mov	0x102b <.LASF1417+0x4>, AL

00007588 <.LBB462>:
L_SIGNAL(l_u16, LIN_MOTOR2_Reserve2)
L_SIGNAL(l_u16, LIN_MOTOR2_Reserve3)
L_SIGNAL(l_u16, LIN_MOTOR3_Reserve1)
L_SIGNAL(l_u16, LIN_MOTOR3_Reserve2)
L_SIGNAL(l_u16, LIN_MOTOR3_Reserve3)
L_SIGNAL(l_u16, LIN_MOTOR4_Reserve1)
    7588:	72d8 10a8 	lod	A, 0x10a8 <_u16_CONV_Target_Angle>
    758c:	0ea7      	lod	C, ML.7
    758e:	52d8 1040 	mov	0x1040 <.LASF1417+0x19>, A

00007592 <.LBB464>:
L_SIGNAL(l_u16, LIN_MOTOR4_Reserve2)
    7592:	72d8 10aa 	lod	A, 0x10aa <_g_u16PositionSensor>
    7596:	52d8 1042 	mov	0x1042 <.LASF1417+0x1b>, A

0000759a <.LBE464>:

		l_u8_wr_LIN_MOTOR4_State(ml_ConfiguredNAD);
		//l_u16_wr_LIN_MOTOR4_Reserve(g_u16debug_15++);
		l_u16_wr_LIN_MOTOR4_Reserve1(u16_CONV_Target_Angle);
		l_u16_wr_LIN_MOTOR4_Reserve2(g_u16PositionSensor);
		l_u16_wr_LIN_MOTOR4_Reserve3(pwm_capture_GetFrequency);//(g_u16VDDA);
    759a:	0ea7      	lod	C, ML.7
    759c:	72da 3e3d 	lod	A, #15933

000075a0 <.LBB466>:
L_SIGNAL(l_u16, LIN_MOTOR4_Reserve3)
    75a0:	52d8 1044 	mov	0x1044 <.LASF1417+0x1d>, A

000075a4 <.L14>:

L_FLAGS(l_sl1_flags.mapped, f_MOTOR1_States, frame, MOTOR1_States)
L_FLAGS(l_sl1_flags.mapped, f_MOTOR2_States, frame, MOTOR2_States)
L_FLAGS(l_sl1_flags.mapped, f_MOTOR3_States, frame, MOTOR3_States)
L_FLAGS(l_sl1_flags.mapped, f_MOTOR4_States, frame, MOTOR4_States)
L_FLAGS(l_sl1_flags.mapped, f_MOTOR5_States, frame, MOTOR5_States)
    75a4:	62d8 11d7 	lod	AL, 0x11d7 <_l_sl1_flags+0x3>

000075a8 <.LBE468>:
	}

	/* MOTOR5_States_Frame handling */
	if (l_flg_tst_f_MOTOR5_States() != 0u)
    75a8:	9408      	and	AL, #8
    75aa:	191d      	je	0x75e6 <.L15>

000075ac <.LBB470>:
    75ac:	82db 351c 	callf	0x6a38 <_l_sys_irq_disable>
    75b0:	7ee2      	lod	X, A

000075b2 <.LVL78>:
    75b2:	62d8 11d7 	lod	AL, 0x11d7 <_l_sl1_flags+0x3>

000075b6 <.LVL79>:
    75b6:	94f7      	and	AL, #-9
    75b8:	42d8 11d7 	mov	0x11d7 <_l_sl1_flags+0x3>, AL
    75bc:	72ee      	lod	A, X
    75be:	82db 3524 	callf	0x6a48 <_l_sys_irq_restore>

000075c2 <.LBB472>:
L_SIGNAL(l_u8, LIN_Target_Angle)
L_SIGNAL(l_u8, LIN_MOTOR1_State)
L_SIGNAL(l_u8, LIN_MOTOR2_State)
L_SIGNAL(l_u8, LIN_MOTOR3_State)
L_SIGNAL(l_u8, LIN_MOTOR4_State)
L_SIGNAL(l_u8, LIN_MOTOR5_State)
    75c2:	62d8 1024 	lod	AL, 0x1024 <_ml_ConfiguredNAD>
    75c6:	42d8 102c 	mov	0x102c <.LASF1417+0x5>, AL

000075ca <.LBB474>:
L_SIGNAL(l_u16, LIN_MOTOR3_Reserve2)
L_SIGNAL(l_u16, LIN_MOTOR3_Reserve3)
L_SIGNAL(l_u16, LIN_MOTOR4_Reserve1)
L_SIGNAL(l_u16, LIN_MOTOR4_Reserve2)
L_SIGNAL(l_u16, LIN_MOTOR4_Reserve3)
L_SIGNAL(l_u16, LIN_MOTOR5_Reserve1)
    75ca:	72d8 10a8 	lod	A, 0x10a8 <_u16_CONV_Target_Angle>
    75ce:	0ea7      	lod	C, ML.7
    75d0:	52d8 1046 	mov	0x1046 <.LASF1417+0x1f>, A

000075d4 <.LBB476>:
L_SIGNAL(l_u16, LIN_MOTOR5_Reserve2)
    75d4:	72d8 10aa 	lod	A, 0x10aa <_g_u16PositionSensor>
    75d8:	52d8 1048 	mov	0x1048 <.LASF1417+0x21>, A

000075dc <.LBB478>:
L_SIGNAL(l_u16, LIN_MOTOR5_Reserve3)
    75dc:	0ea7      	lod	C, ML.7
    75de:	72d8 11e2 	lod	A, 0x11e2 <_g_u16VDDA>
    75e2:	52d8 104a 	mov	0x104a <.LASF1417+0x23>, A

000075e6 <.L15>:
		l_u16_wr_LIN_MOTOR5_Reserve2(g_u16PositionSensor);
		l_u16_wr_LIN_MOTOR5_Reserve3(g_u16VDDA);
	}

    /* do lin period (non time critical) stuff */
    lin22_BackgroundHandler();
    75e6:	82db 3447 	callf	0x688e <_lin22_BackgroundHandler>

000075ea <.LBE408>:
        	// 5ms task
        }

        background_Handler();

		if(PWM_CAPTURE_bNewValidData == true)
    75ea:	62d8 11f6 	lod	AL, 0x11f6 <_PWM_CAPTURE_bNewValidData>
    75ee:	1d01      	jne	0x75f2 <.LBB480>
    75f0:	004c      	jmp	0x768a <.L17>

000075f2 <.LBB480>:
		{
			static uint16_t u16_CONV_Target_Angle_pre;
			PWM_CAPTURE_bNewValidData = false;
    75f2:	6400      	lod	YL, #0
    75f4:	46d8 11f6 	mov	0x11f6 <_PWM_CAPTURE_bNewValidData>, YL

000075f8 <.LM118>:
			pwm_Start(0u);
    75f8:	7000      	lod	A, #0
    75fa:	11d4      	call	0x79a4 <_pwm_Start>

000075fc <.LBB481>:
    75fc:	0ea7      	lod	C, ML.7
    75fe:	72d8 11f4 	lod	A, 0x11f4 <_g_u16PWM_CAPTURE_u16HighPeriod>
    7602:	7ad8 11e2 	lod	Y, 0x11e2 <_g_u16VDDA>
    7606:	4821      	mulu	YA, A, Y
    7608:	58a2      	mov	[S-8], YA

0000760a <.LBE481>:

			u16_CONV_Target_Angle = (uint16_t)(mulU32_U16byU16(g_u16PWM_CAPTURE_u16HighPeriod, g_u16VDDA) / g_u16PWM_CAPTURE_u16PwmPeriod);
    760a:	7ed8 11f2 	lod	X, 0x11f2 <_g_u16PWM_CAPTURE_u16PwmPeriod>
    760e:	4ccb      	movu	D, X
    7610:	4c83      	push	D

00007612 <.LCFI8>:
    7612:	58e4      	mov	YA, [S-12]
    7614:	82db 2dfe 	callf	0x5bfc <___udivsi3>
    7618:	5c03      	dec	S, #4

0000761a <.LCFI9>:
    761a:	52d8 10a8 	mov	0x10a8 <_u16_CONV_Target_Angle>, A

0000761e <.LM121>:

			if((abs)(u16_CONV_Target_Angle - u16_CONV_Target_Angle_pre) > 50){
    761e:	7ee2      	lod	X, A
    7620:	2ad8 10a0 	sub	X, 0x10a0 <___u16_CONV_Target_Angle_pre_7977>
    7624:	1d81      	jnn	0x7628 <.L56>
    7626:	5cce      	neg	X

00007628 <.L56>:
    7628:	2c32      	cmp	X, #50
    762a:	1b0d      	jsle	0x7646 <.L18>

0000762c <.LM122>:
				g_Rotate_Done = 0;	// LIN_Target   clear
    762c:	6400      	lod	YL, #0
    762e:	46d8 10a3 	mov	0x10a3 <_g_Rotate_Done>, YL

00007632 <.LM123>:
				u16_Target_Angle_LCL = u16_CONV_Target_Angle - Angle_Hysteresis; //     
    7632:	7ee2      	lod	X, A
    7634:	2ad8 104e 	sub	X, 0x104e <_Angle_Hysteresis>
    7638:	5ed8 10a6 	mov	0x10a6 <_u16_Target_Angle_LCL>, X

0000763c <.LM124>:
				u16_Target_Angle_UCL = u16_CONV_Target_Angle + Angle_Hysteresis; //     
    763c:	7ed8 104e 	lod	X, 0x104e <_Angle_Hysteresis>
    7640:	22e2      	add	X, A
    7642:	5ed8 10a4 	mov	0x10a4 <_u16_Target_Angle_UCL>, X

00007646 <.L18>:
			}

			u16_CONV_Target_Angle_pre = u16_CONV_Target_Angle;
    7646:	52d8 10a0 	mov	0x10a0 <___u16_CONV_Target_Angle_pre_7977>, A

0000764a <.LM126>:

			u16_Angle_Gap = (abs)(g_u16PositionSensor - u16_CONV_Target_Angle); //     Error
    764a:	7ed8 10aa 	lod	X, 0x10aa <_g_u16PositionSensor>
    764e:	7aee      	lod	Y, X
    7650:	eae2      	sub	Y, A
    7652:	72e6      	lod	A, Y
    7654:	1d81      	jnn	0x7658 <.L57>
    7656:	5cc2      	neg	A

00007658 <.L57>:
    7658:	52d8 11e0 	mov	0x11e0 <_u16_Angle_Gap>, A

0000765c <.LM127>:

			u16_Duty_Dec_Range = 23;		//   :   +/- 1
    765c:	7817      	lod	Y, #23
    765e:	5ad8 11de 	mov	0x11de <_u16_Duty_Dec_Range>, Y

00007662 <.LM128>:

			if(u16_Angle_Gap > u16_Duty_Dec_Range)
    7662:	aee6      	cmp	A, Y
    7664:	1b25      	jsle	0x76b0 <.L19>

00007666 <.LM129>:
			{
				SetDuty = 3276;	// Duty 80%, Output Torque  
    7666:	72da 0ccc 	lod	A, #3276

0000766a <.L53>:
			}
			else if(u16_Angle_Gap <= u16_Duty_Dec_Range)
			{
				SetDuty = 13104;	// Duty 80%, Output Torque  
    766a:	52d8 11e4 	mov	0x11e4 <_SetDuty>, A

0000766e <.LM131>:
			}

			if(g_Rotate_Done == 0U)	//    Motor 
    766e:	62d8 10a3 	lod	AL, 0x10a3 <_g_Rotate_Done>
    7672:	1d0b      	jne	0x768a <.L17>
    7674:	72d8 10a6 	lod	A, 0x10a6 <_u16_Target_Angle_LCL>

00007678 <.LM132>:
			{
				if((g_u16PositionSensor <= u16_Target_Angle_UCL) && (g_u16PositionSensor >=u16_Target_Angle_LCL))
    7678:	2ed8 10a4 	cmp	X, 0x10a4 <_u16_Target_Angle_UCL>
    767c:	1e23      	jug	0x76c4 <.L22>

0000767e <.LM133>:
    767e:	2ee2      	cmp	X, A
    7680:	181a      	jc	0x76b6 <.L23>

00007682 <.LM134>:
				{
					pwm_Stop();	// STOP
    7682:	11ed      	call	0x7a5e <_pwm_Stop>

00007684 <.LM135>:
					g_Rotate_Done = 1;	//    Set
    7684:	6001      	lod	AL, #1
    7686:	42d8 10a3 	mov	0x10a3 <_g_Rotate_Done>, AL

0000768a <.L17>:
				}
			}
		}


        if (!g_bElectricDefect)
    768a:	62d8 10bb 	lod	AL, 0x10bb <_g_bElectricDefect>
    768e:	1901      	je	0x7692 <.LM137>
    7690:	0647      	jmp	0x7320 <.L24>

00007692 <.LM137>:
        {
        	e8ErrorVoltage = protection_GetErrorVoltage();
    7692:	72d8 10c0 	lod	A, 0x10c0 <_g_e8ErrorVoltage>
    7696:	52d8 11ee 	mov	0x11ee <_e8ErrorVoltage>, A

0000769a <.LM138>:
        	e8ErrorOverTemperature = protection_GetErrorOverTemperature();
    769a:	72d8 10be 	lod	A, 0x10be <_g_e8ErrorOverTemperature>
    769e:	0ea7      	lod	C, ML.7
    76a0:	52d8 11e8 	mov	0x11e8 <_e8ErrorOverTemperature>, A

000076a4 <.LM139>:
        	e8ShortOcc = protection_GetShortOcc();
    76a4:	72d8 10bc 	lod	A, 0x10bc <_g_e8ShortOcc>
    76a8:	52d8 11f0 	mov	0x11f0 <_e8ShortOcc>, A
    76ac:	0ea7      	lod	C, ML.7
    76ae:	0638      	jmp	0x7320 <.L24>

000076b0 <.L19>:
			{
				SetDuty = 3276;	// Duty 80%, Output Torque  
			}
			else if(u16_Angle_Gap <= u16_Duty_Dec_Range)
			{
				SetDuty = 13104;	// Duty 80%, Output Torque  
    76b0:	72da 3330 	lod	A, #13104
    76b4:	07da      	jmp	0x766a <.L53>

000076b6 <.L23>:
					pwm_Stop();	// STOP
					g_Rotate_Done = 1;	//    Set
				}
				else if(g_u16PositionSensor < u16_Target_Angle_LCL)
				{
					pwm_SetDutyCycle(0, SetDuty);	// CCW Rotate
    76b6:	72d8 11e4 	lod	A, 0x11e4 <_SetDuty>
    76ba:	52df      	push	A

000076bc <.LCFI10>:
    76bc:	7000      	lod	A, #0

000076be <.L54>:
				}
				else if(g_u16PositionSensor  > u16_Target_Angle_UCL) // && (adcMotor > mtrStop_Hysteresis_Plus))
				{
					pwm_SetDutyCycle(1, SetDuty);	// CW Rotate
    76be:	1152      	call	0x7964 <_pwm_SetDutyCycle>
    76c0:	5c01      	dec	S, #2

000076c2 <.LCFI11>:
    76c2:	07e3      	jmp	0x768a <.L17>

000076c4 <.L22>:
				if((g_u16PositionSensor <= u16_Target_Angle_UCL) && (g_u16PositionSensor >=u16_Target_Angle_LCL))
				{
					pwm_Stop();	// STOP
					g_Rotate_Done = 1;	//    Set
				}
				else if(g_u16PositionSensor < u16_Target_Angle_LCL)
    76c4:	2ee2      	cmp	X, A
    76c6:	1877      	jc	0x76b6 <.L23>

000076c8 <.LM144>:
				{
					pwm_SetDutyCycle(0, SetDuty);	// CCW Rotate
				}
				else if(g_u16PositionSensor  > u16_Target_Angle_UCL) // && (adcMotor > mtrStop_Hysteresis_Plus))
				{
					pwm_SetDutyCycle(1, SetDuty);	// CW Rotate
    76c8:	72d8 11e4 	lod	A, 0x11e4 <_SetDuty>
    76cc:	52df      	push	A

000076ce <.LCFI12>:
    76ce:	7001      	lod	A, #1
    76d0:	07f6      	jmp	0x76be <.L54>

000076d2 <_EVENT_UnderVoltage>:
 * \image html diode.png
 * \image latex diode.png
 */
void EVENT_UnderVoltage(void)
{
    g_bUnderVoltageDetected = true;
    76d2:	6001      	lod	AL, #1
    76d4:	42d8 10ba 	mov	0x10ba <_g_bUnderVoltageDetected>, AL

000076d8 <.LM147>:
}
    76d8:	5401      	ret

000076da <__CTIMER0_3_INT>:

/** Timer1 INT3 handler for LIN AA frame timeout */
INTERRUPT void _CTIMER0_3_INT(void)
{
	/* nop */
}
    76da:	72cb      	pop	M
    76dc:	5401      	ret

000076de <_protection_Init>:
    76de:	5801      	inc	S, #2

000076e0 <.LCFI0>:
    76e0:	7800      	lod	Y, #0
    76e2:	5ad8 10c0 	mov	0x10c0 <_g_e8ErrorVoltage>, Y

000076e6 <.LM3>:
    76e6:	5ad8 10be 	mov	0x10be <_g_e8ErrorOverTemperature>, Y

000076ea <.LM4>:
    76ea:	0ea7      	lod	C, ML.7
    76ec:	5ad8 10bc 	mov	0x10bc <_g_e8ShortOcc>, Y

000076f0 <.LM5>:
    76f0:	5adf      	push	Y

000076f2 <.LCFI1>:
    76f2:	54ca 007d 	pushw	#125

000076f6 <.LCFI2>:
    76f6:	7003      	lod	A, #3
    76f8:	5a05      	mov	[S-6], Y
    76fa:	13e4      	call	0x7ec4 <_swtimer_register>

000076fc <.LM6>:
    76fc:	7a05      	lod	Y, [S-6]
    76fe:	5adf      	push	Y

00007700 <.LCFI3>:
    7700:	54ca 0bb8 	pushw	#3000

00007704 <.LCFI4>:
    7704:	7004      	lod	A, #4
    7706:	13de      	call	0x7ec4 <_swtimer_register>

00007708 <.LM7>:
    7708:	82db 3117 	callf	0x622e <_diagnostic_Init>

0000770c <.LCFI5>:
    770c:	540b      	ret	#12

0000770e <_protection_CheckShort>:
 *   Stop
 * \enduml
 */
void protection_CheckShort(void)
{
    if (diagnostic_IsOVCPending())
    770e:	82db 317b 	callf	0x62f6 <_diagnostic_IsOVCPending>
    7712:	ac00      	cmp	A, #0
    7714:	1907      	je	0x7724 <.L6>

00007716 <.LM20>:
    {
        if (g_e8ShortOcc == C_ERR_SHORT_NO)
    7716:	72d8 10bc 	lod	A, 0x10bc <_g_e8ShortOcc>
    771a:	1d03      	jne	0x7722 <.L5>

0000771c <.LM21>:
        {
            g_e8ShortOcc = C_ERR_SHORT_OC;
    771c:	7001      	lod	A, #1

0000771e <.L13>:
    }
    else if (diagnostic_IsVDSPending())
    {
        if (g_e8ShortOcc == C_ERR_SHORT_NO)
        {
            g_e8ShortOcc = C_ERR_SHORT_VDS;
    771e:	52d8 10bc 	mov	0x10bc <_g_e8ShortOcc>, A

00007722 <.L5>:
    }
    else
    {
        /* MISRA C-2012 Rule 15.7 */
    }
}
    7722:	5401      	ret

00007724 <.L6>:
        if (g_e8ShortOcc == C_ERR_SHORT_NO)
        {
            g_e8ShortOcc = C_ERR_SHORT_OC;
        }
    }
    else if (diagnostic_IsVDSPending())
    7724:	82db 3180 	callf	0x6300 <_diagnostic_IsVDSPending>
    7728:	ac00      	cmp	A, #0
    772a:	197b      	je	0x7722 <.L5>

0000772c <.LM25>:
    {
        if (g_e8ShortOcc == C_ERR_SHORT_NO)
    772c:	72d8 10bc 	lod	A, 0x10bc <_g_e8ShortOcc>
    7730:	1d78      	jne	0x7722 <.L5>

00007732 <.LM26>:
        {
            g_e8ShortOcc = C_ERR_SHORT_VDS;
    7732:	7002      	lod	A, #2
    7734:	07f4      	jmp	0x771e <.L13>

00007736 <_protection_CheckSupplyMotorVoltage>:
 * \enduml
 *
 * @param[in]  a_u16SupplyMotorVoltage  VSM voltage [10mV]
 */
void protection_CheckSupplyMotorVoltage(uint16_t a_u16SupplyMotorVoltage)
{
    7736:	5801      	inc	S, #2

00007738 <.LCFI6>:
    if (diagnostic_IsOVPending())
    7738:	5201      	mov	[S-2], A
    773a:	82db 3159 	callf	0x62b2 <_diagnostic_IsOVPending>

0000773e <.LVL8>:
    773e:	7a01      	lod	Y, [S-2]
    7740:	ac00      	cmp	A, #0
    7742:	1909      	je	0x7756 <.L15>

00007744 <.LM29>:
    {
        if (g_e8ErrorVoltage != C_ERR_VOLTAGE_OVER_HW)
    7744:	72d8 10c0 	lod	A, 0x10c0 <_g_e8ErrorVoltage>
    7748:	ac04      	cmp	A, #4
    774a:	1d01      	jne	0x774e <.LM30>
    774c:	0040      	jmp	0x77ce <.L14>

0000774e <.LM30>:
        {
            g_e8ErrorVoltage = C_ERR_VOLTAGE_OVER_HW;
    774e:	7004      	lod	A, #4

00007750 <.L41>:
    }
    else if (diagnostic_IsUVPending())
    {
        if (g_e8ErrorVoltage != C_ERR_VOLTAGE_UNDER_HW)
        {
            g_e8ErrorVoltage = C_ERR_VOLTAGE_UNDER_HW;
    7750:	52d8 10c0 	mov	0x10c0 <_g_e8ErrorVoltage>, A
    7754:	5403      	ret	#4

00007756 <.L15>:
        if (g_e8ErrorVoltage != C_ERR_VOLTAGE_OVER_HW)
        {
            g_e8ErrorVoltage = C_ERR_VOLTAGE_OVER_HW;
        }
    }
    else if (diagnostic_IsUVPending())
    7756:	5a01      	mov	[S-2], Y
    7758:	82db 3149 	callf	0x6292 <_diagnostic_IsUVPending>
    775c:	7a01      	lod	Y, [S-2]
    775e:	ac00      	cmp	A, #0
    7760:	1907      	je	0x7770 <.L18>

00007762 <.LM33>:
    {
        if (g_e8ErrorVoltage != C_ERR_VOLTAGE_UNDER_HW)
    7762:	72d8 10c0 	lod	A, 0x10c0 <_g_e8ErrorVoltage>
    7766:	ac02      	cmp	A, #2
    7768:	1d01      	jne	0x776c <.LM34>
    776a:	0031      	jmp	0x77ce <.L14>

0000776c <.LM34>:
        {
            g_e8ErrorVoltage = C_ERR_VOLTAGE_UNDER_HW;
    776c:	7002      	lod	A, #2
    776e:	07f0      	jmp	0x7750 <.L41>

00007770 <.L18>:
        }
    }
    else if (a_u16SupplyMotorVoltage < ((uint16_t)(C_APPL_UVOLT - C_VOLTAGE_HYS)))
    7770:	eeda 02ed 	cmp	Y, #749
    7774:	1e14      	jug	0x779e <.L20>

00007776 <.LM36>:
    {
        if (swtimer_isTriggered(SWTIMER_PROTECTION_DELAY_VSM))
    7776:	7003      	lod	A, #3
    7778:	13dc      	call	0x7f32 <_swtimer_isTriggered>
    777a:	ac00      	cmp	A, #0
    777c:	1909      	je	0x7790 <.L21>

0000777e <.LM37>:
        {
            if (g_e8ErrorVoltage != C_ERR_VOLTAGE_UNDER)
    777e:	72d8 10c0 	lod	A, 0x10c0 <_g_e8ErrorVoltage>
    7782:	ac01      	cmp	A, #1
    7784:	1905      	je	0x7790 <.L21>

00007786 <.LM38>:
            {
                g_e8ErrorVoltage = C_ERR_VOLTAGE_UNDER;
    7786:	7001      	lod	A, #1
    7788:	52d8 10c0 	mov	0x10c0 <_g_e8ErrorVoltage>, A

0000778c <.LM39>:
                swtimer_stop(SWTIMER_PROTECTION_DELAY_VSM);
    778c:	7003      	lod	A, #3

0000778e <.L42>:
    778e:	13c1      	call	0x7f12 <_swtimer_stop>

00007790 <.L21>:
            }
        }
        if (!swtimer_isRunning(SWTIMER_PROTECTION_DELAY_VSM))
    7790:	7003      	lod	A, #3
    7792:	13c6      	call	0x7f20 <_swtimer_isRunning>
    7794:	ac00      	cmp	A, #0
    7796:	1d1b      	jne	0x77ce <.L14>

00007798 <.LM41>:
        {
            swtimer_start(SWTIMER_PROTECTION_DELAY_VSM);
    7798:	7003      	lod	A, #3
    779a:	13aa      	call	0x7ef0 <_swtimer_start>
    779c:	5403      	ret	#4

0000779e <.L20>:
        }
    }
    else if (a_u16SupplyMotorVoltage > ((uint16_t)(C_APPL_OVOLT + C_VOLTAGE_HYS)))
    779e:	eeda 0672 	cmp	Y, #1650
    77a2:	1a0c      	jule	0x77bc <.L22>

000077a4 <.LM43>:
    {
        if (swtimer_isTriggered(SWTIMER_PROTECTION_DELAY_VSM))
    77a4:	7003      	lod	A, #3
    77a6:	13c5      	call	0x7f32 <_swtimer_isTriggered>
    77a8:	ac00      	cmp	A, #0
    77aa:	1972      	je	0x7790 <.L21>

000077ac <.LM44>:
        {
            if (g_e8ErrorVoltage != C_ERR_VOLTAGE_OVER)
    77ac:	72d8 10c0 	lod	A, 0x10c0 <_g_e8ErrorVoltage>
    77b0:	ac03      	cmp	A, #3
    77b2:	196e      	je	0x7790 <.L21>

000077b4 <.LM45>:
            {
                g_e8ErrorVoltage = C_ERR_VOLTAGE_OVER;
    77b4:	7003      	lod	A, #3
    77b6:	52d8 10c0 	mov	0x10c0 <_g_e8ErrorVoltage>, A
    77ba:	07e9      	jmp	0x778e <.L42>

000077bc <.L22>:
        if (!swtimer_isRunning(SWTIMER_PROTECTION_DELAY_VSM))
        {
            swtimer_start(SWTIMER_PROTECTION_DELAY_VSM);
        }
    }
    else if ((a_u16SupplyMotorVoltage >= ((uint16_t)(C_APPL_UVOLT + C_VOLTAGE_HYS))) &&
    77bc:	e2da fcae 	add	Y, #64686
    77c0:	eeda 02bc 	cmp	Y, #700
    77c4:	1e04      	jug	0x77ce <.L14>

000077c6 <.LM47>:
             (a_u16SupplyMotorVoltage <= ((uint16_t)(C_APPL_OVOLT - C_VOLTAGE_HYS))))
    {
        g_e8ErrorVoltage = C_ERR_VOLTAGE_IN_RANGE;
    77c6:	52d8 10c0 	mov	0x10c0 <_g_e8ErrorVoltage>, A

000077ca <.LM48>:
        swtimer_stop(SWTIMER_PROTECTION_DELAY_VSM);
    77ca:	7003      	lod	A, #3
    77cc:	13a2      	call	0x7f12 <_swtimer_stop>

000077ce <.L14>:
    }
    else
    {
        /* MISRA C-2012 Rule 15.7 */
    }
}
    77ce:	5403      	ret	#4

000077d0 <_protection_CheckChipTemperature>:
 * \enduml
 *
 * @param[in]  a_i16ChipTemperature  chip internal temperature sensor [C]
 */
void protection_CheckChipTemperature(int16_t a_i16ChipTemperature)
{
    77d0:	5801      	inc	S, #2

000077d2 <.LCFI7>:
    if (diagnostic_IsOVTPending())
    77d2:	5201      	mov	[S-2], A
    77d4:	82db 316b 	callf	0x62d6 <_diagnostic_IsOVTPending>

000077d8 <.LVL17>:
    77d8:	7a01      	lod	Y, [S-2]
    77da:	ac00      	cmp	A, #0
    77dc:	190a      	je	0x77f2 <.L44>

000077de <.LM52>:
    {
        if (g_e8ErrorOverTemperature != C_ERR_TEMP_ALARM)
    77de:	72d8 10be 	lod	A, 0x10be <_g_e8ErrorOverTemperature>
    77e2:	ac02      	cmp	A, #2
    77e4:	191d      	je	0x7820 <.L43>

000077e6 <.LM53>:
        {
            g_e8ErrorOverTemperature = C_ERR_TEMP_ALARM;
    77e6:	7002      	lod	A, #2

000077e8 <.L53>:
            swtimer_start(SWTIMER_PROTECTION_DELAY_OVT);
        }
    }
    else if (a_i16ChipTemperature < (int16_t)(C_APPL_OTEMP - C_TEMPERATURE_HYS))
    {
        g_e8ErrorOverTemperature = C_ERR_TEMP_NO;
    77e8:	52d8 10be 	mov	0x10be <_g_e8ErrorOverTemperature>, A

000077ec <.LM55>:
        swtimer_stop(SWTIMER_PROTECTION_DELAY_OVT);
    77ec:	7004      	lod	A, #4
    77ee:	1391      	call	0x7f12 <_swtimer_stop>

000077f0 <.LM56>:
    }
    else
    {
        /* MISRA C-2012 Rule 15.7 */
    }
}
    77f0:	0017      	jmp	0x7820 <.L43>

000077f2 <.L44>:
        {
            g_e8ErrorOverTemperature = C_ERR_TEMP_ALARM;
            swtimer_stop(SWTIMER_PROTECTION_DELAY_OVT);
        }
    }
    else if (a_i16ChipTemperature > (int16_t)(C_APPL_OTEMP + C_TEMPERATURE_HYS))
    77f2:	ec7b      	cmp	Y, #123
    77f4:	1b13      	jsle	0x781c <.L47>

000077f6 <.LM58>:
    {
        if (swtimer_isTriggered(SWTIMER_PROTECTION_DELAY_OVT))
    77f6:	7004      	lod	A, #4
    77f8:	139c      	call	0x7f32 <_swtimer_isTriggered>
    77fa:	ac00      	cmp	A, #0
    77fc:	1908      	je	0x780e <.L48>

000077fe <.LM59>:
        {
            if (g_e8ErrorOverTemperature == C_ERR_TEMP_NO)
    77fe:	72d8 10be 	lod	A, 0x10be <_g_e8ErrorOverTemperature>
    7802:	1d05      	jne	0x780e <.L48>

00007804 <.LM60>:
            {
                g_e8ErrorOverTemperature = C_ERR_TEMP_WARNING;
    7804:	7001      	lod	A, #1
    7806:	52d8 10be 	mov	0x10be <_g_e8ErrorOverTemperature>, A

0000780a <.LM61>:

                swtimer_stop(SWTIMER_PROTECTION_DELAY_OVT);
    780a:	7004      	lod	A, #4
    780c:	1382      	call	0x7f12 <_swtimer_stop>

0000780e <.L48>:
            }
        }
        if (!swtimer_isRunning(SWTIMER_PROTECTION_DELAY_OVT))
    780e:	7004      	lod	A, #4
    7810:	1387      	call	0x7f20 <_swtimer_isRunning>
    7812:	ac00      	cmp	A, #0
    7814:	1d05      	jne	0x7820 <.L43>

00007816 <.LM63>:
        {
            swtimer_start(SWTIMER_PROTECTION_DELAY_OVT);
    7816:	7004      	lod	A, #4
    7818:	136b      	call	0x7ef0 <_swtimer_start>
    781a:	5403      	ret	#4

0000781c <.L47>:
        }
    }
    else if (a_i16ChipTemperature < (int16_t)(C_APPL_OTEMP - C_TEMPERATURE_HYS))
    781c:	ec74      	cmp	Y, #116
    781e:	1b64      	jsle	0x77e8 <.L53>

00007820 <.L43>:
    }
    else
    {
        /* MISRA C-2012 Rule 15.7 */
    }
}
    7820:	5403      	ret	#4

00007822 <_pwm_Init>:
 *    |______|______|       |______|_
 *     <-LT->|<-LT->|        <-LT->|
 *
 */
void pwm_Init(void)
{
    7822:	5801      	inc	S, #2

00007824 <.LCFI0>:
    u8Status = 0u;
    7824:	6000      	lod	AL, #0
    7826:	42d8 10cc 	mov	0x10cc <_u8Status>, AL

0000782a <.LBB1165>:
#if defined (IO_PWM_MASTER1__START_GET)
#define PWM1_MASTER_DISABLE pwm1_master_disable

STATIC INLINE void pwm1_master_disable(void)
{
    IO_HOST(PWM_MASTER1, STOP) = 1u << IO_OFFSET(PWM_MASTER1, STOP);
    782a:	7802      	lod	Y, #2
    782c:	0ea7      	lod	C, ML.7
    782e:	5ad8 013c 	mov	0x13c <.LASF1257+0x2>, Y

00007832 <.LBB1167>:
#if defined (IO_PWM_SLAVE1__START_GET)
#define PWM1_DISABLE pwm1_disable

STATIC INLINE void pwm1_disable(void)
{
    IO_HOST(PWM_SLAVE1, STOP) = 1u << IO_OFFSET(PWM_SLAVE1, STOP);
    7832:	5ad8 0146 	mov	0x146 <.LLST19+0x2>, Y

00007836 <.LBB1169>:
#if defined (IO_PWM_SLAVE2__START_GET)
#define PWM2_DISABLE pwm2_disable

STATIC INLINE void pwm2_disable(void)
{
    IO_HOST(PWM_SLAVE2, STOP) = 1u << IO_OFFSET(PWM_SLAVE2, STOP);
    7836:	5ad8 0150 	mov	0x150 <_PWM_SLAVE2+0x8>, Y

0000783a <.LBB1171>:
#if defined (IO_PWM_SLAVE3__START_GET)
#define PWM3_DISABLE pwm3_disable

STATIC INLINE void pwm3_disable(void)
{
    IO_HOST(PWM_SLAVE3, STOP) = 1u << IO_OFFSET(PWM_SLAVE3, STOP);
    783a:	0ea7      	lod	C, ML.7
    783c:	5ad8 015a 	mov	0x15a <.LLST16+0x3>, Y

00007840 <.LBB1173>:
#if defined (IO_PWM_MASTER2__START_GET)
#define PWM2_MASTER_DISABLE pwm2_master_disable

STATIC INLINE void pwm2_master_disable(void)
{
    IO_HOST(PWM_MASTER2, STOP) = 1u << IO_OFFSET(PWM_MASTER2, STOP);
    7840:	5ad8 0164 	mov	0x164 <_PWM_MASTER2+0x8>, Y

00007844 <.LBB1175>:
                                    uint16_t CMP_,
                                    PwmMode_t MODE_,
                                    PwmPolarity_t POL_,
                                    uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_MASTER1, PSCLM, ((DIV_)-1) & 0x0Fu,
    7844:	7008      	lod	A, #8
    7846:	0ea7      	lod	C, ML.7
    7848:	52d8 013c 	mov	0x13c <.LASF1257+0x2>, A

0000784c <.LM9>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 0u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_MASTER1, PER, PERIOD_);
    784c:	7eda 0640 	lod	X, #1600
    7850:	5ed8 013a 	mov	0x13a <.LASF1257>, X

00007854 <.LM10>:
    IO_SET(PWM_MASTER1, CMP, CMP_);
    7854:	0ea7      	lod	C, ML.7
    7856:	72da 010b 	lod	A, #267
    785a:	52d8 0134 	mov	0x134 <_PWM_MASTER1>, A

0000785e <.LM11>:
    IO_SET(PWM_MASTER1, LT, LT_);
    785e:	7000      	lod	A, #0
    7860:	0ea7      	lod	C, ML.7
    7862:	52d8 0138 	mov	0x138 <_PWM_MASTER1+0x4>, A

00007866 <.LM12>:
    IO_SET(PWM_MASTER1, HT, HT_);
    7866:	52d8 0136 	mov	0x136 <_PWM_MASTER1+0x2>, A

0000786a <.LBB1177>:
#define PWM1_INIT pwm1_init

STATIC INLINE void pwm1_init(uint8_t DIV_, uint8_t DIVN_, uint16_t LT_, uint16_t HT_,
                             uint16_t CMP_, PwmMode_t MODE_, PwmPolarity_t POL_, uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_SLAVE1, PSCLM, ((DIV_)-1) & 0x0Fu,
    786a:	7c0c      	lod	X, #12
    786c:	0ea7      	lod	C, ML.7
    786e:	5ed8 0146 	mov	0x146 <.LLST19+0x2>, X

00007872 <.LM14>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 1u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_SLAVE1, CMP, CMP_);
    7872:	7eda 0215 	lod	X, #533
    7876:	5ed8 013e 	mov	0x13e <_PWM_SLAVE1>, X

0000787a <.LM15>:
    IO_SET(PWM_SLAVE1, LT, LT_);
    787a:	0ea7      	lod	C, ML.7
    787c:	52d8 0142 	mov	0x142 <.LASF1438>, A

00007880 <.LM16>:
    IO_SET(PWM_SLAVE1, HT, HT_);
    7880:	52d8 0140 	mov	0x140 <_PWM_SLAVE1+0x2>, A

00007884 <.LBB1179>:
#define PWM2_INIT pwm2_init

STATIC INLINE void pwm2_init(uint8_t DIV_, uint8_t DIVN_, uint16_t LT_, uint16_t HT_,
                             uint16_t CMP_, PwmMode_t MODE_, PwmPolarity_t POL_, uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_SLAVE2, PSCLM, ((DIV_)-1) & 0x0Fu,
    7884:	7c0c      	lod	X, #12
    7886:	0ea7      	lod	C, ML.7
    7888:	5ed8 0150 	mov	0x150 <_PWM_SLAVE2+0x8>, X

0000788c <.LM18>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 1u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_SLAVE2, CMP, CMP_);
    788c:	7eda 0320 	lod	X, #800
    7890:	5ed8 0148 	mov	0x148 <_PWM_SLAVE2>, X

00007894 <.LM19>:
    IO_SET(PWM_SLAVE2, LT, LT_);
    7894:	0ea7      	lod	C, ML.7
    7896:	52d8 014c 	mov	0x14c <_PWM_SLAVE2+0x4>, A

0000789a <.LM20>:
    IO_SET(PWM_SLAVE2, HT, HT_);
    789a:	52d8 014a 	mov	0x14a <_PWM_SLAVE2+0x2>, A

0000789e <.LBB1181>:
#define PWM3_INIT pwm3_init

STATIC INLINE void pwm3_init(uint8_t DIV_, uint8_t DIVN_, uint16_t LT_, uint16_t HT_,
                             uint16_t CMP_, PwmMode_t MODE_, PwmPolarity_t POL_, uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_SLAVE3, PSCLM, ((DIV_)-1) & 0x0Fu,
    789e:	7c0c      	lod	X, #12
    78a0:	0ea7      	lod	C, ML.7
    78a2:	5ed8 015a 	mov	0x15a <.LLST16+0x3>, X

000078a6 <.LM22>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 1u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_SLAVE3, CMP, CMP_);
    78a6:	7eda 042a 	lod	X, #1066
    78aa:	5ed8 0152 	mov	0x152 <_PWM_SLAVE3>, X

000078ae <.LM23>:
    IO_SET(PWM_SLAVE3, LT, LT_);
    78ae:	0ea7      	lod	C, ML.7
    78b0:	52d8 0156 	mov	0x156 <_PWM_SLAVE3+0x4>, A

000078b4 <.LM24>:
    IO_SET(PWM_SLAVE3, HT, HT_);
    78b4:	52d8 0154 	mov	0x154 <_PWM_SLAVE3+0x2>, A

000078b8 <.LBB1183>:
                                    uint16_t CMP_,
                                    PwmMode_t MODE_,
                                    PwmPolarity_t POL_,
                                    uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_MASTER2, PSCLM, ((DIV_)-1) & 0x0Fu,
    78b8:	7c08      	lod	X, #8
    78ba:	0ea7      	lod	C, ML.7
    78bc:	5ed8 0164 	mov	0x164 <_PWM_MASTER2+0x8>, X

000078c0 <.LM26>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 0u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_MASTER2, PER, PERIOD_);
    78c0:	7eda 0640 	lod	X, #1600
    78c4:	5ed8 0162 	mov	0x162 <_PWM_MASTER2+0x6>, X

000078c8 <.LM27>:
    IO_SET(PWM_MASTER2, CMP, CMP_);
    78c8:	0ea7      	lod	C, ML.7
    78ca:	7eda 0535 	lod	X, #1333
    78ce:	5ed8 015c 	mov	0x15c <_PWM_MASTER2>, X

000078d2 <.LM28>:
    IO_SET(PWM_MASTER2, LT, LT_);
    78d2:	52d8 0160 	mov	0x160 <_PWM_MASTER2+0x4>, A

000078d6 <.LM29>:
    IO_SET(PWM_MASTER2, HT, HT_);
    78d6:	0ea7      	lod	C, ML.7
    78d8:	52d8 015e 	mov	0x15e <_PWM_MASTER2+0x2>, A

000078dc <.LBB1185>:
#if defined (IO_PWM_MASTER1__START_GET)
#define PWM1_MASTER_ENABLE pwm1_master_enable

STATIC INLINE void pwm1_master_enable(void)
{
    IO_HOST(PWM_MASTER1, START) = 1u << IO_OFFSET(PWM_MASTER1, START);
    78dc:	7c01      	lod	X, #1
    78de:	5ed8 013c 	mov	0x13c <.LASF1257+0x2>, X

000078e2 <.LBB1187>:
#if defined (IO_PWM_SLAVE1__START_GET)
#define PWM1_ENABLE pwm1_enable

STATIC INLINE void pwm1_enable(void)
{
    IO_HOST(PWM_SLAVE1, START) = 1u << IO_OFFSET(PWM_SLAVE1, START);
    78e2:	0ea7      	lod	C, ML.7
    78e4:	5ed8 0146 	mov	0x146 <.LLST19+0x2>, X

000078e8 <.LBB1189>:
#if defined (IO_PWM_SLAVE2__START_GET)
#define PWM2_ENABLE pwm2_enable

STATIC INLINE void pwm2_enable(void)
{
    IO_HOST(PWM_SLAVE2, START) = 1u << IO_OFFSET(PWM_SLAVE2, START);
    78e8:	5ed8 0150 	mov	0x150 <_PWM_SLAVE2+0x8>, X

000078ec <.LBB1191>:
#if defined (IO_PWM_SLAVE3__START_GET)
#define PWM3_ENABLE pwm3_enable

STATIC INLINE void pwm3_enable(void)
{
    IO_HOST(PWM_SLAVE3, START) = 1u << IO_OFFSET(PWM_SLAVE3, START);
    78ec:	5ed8 015a 	mov	0x15a <.LLST16+0x3>, X

000078f0 <.LBB1193>:
#if defined (IO_PWM_MASTER2__START_GET)
#define PWM2_MASTER_ENABLE pwm2_master_enable

STATIC INLINE void pwm2_master_enable(void)
{
    IO_HOST(PWM_MASTER2, START) = 1u << IO_OFFSET(PWM_MASTER2, START);
    78f0:	0ea7      	lod	C, ML.7
    78f2:	5ed8 0164 	mov	0x164 <_PWM_MASTER2+0x8>, X

000078f6 <.LBB1195>:
    78f6:	7eda eeee 	lod	X, #61166
    78fa:	5ed8 0216 	mov	0x216 <_PORT_DRV_CTRL>, X

000078fe <.LBE1195>:
                                DRV_CTRL_TRISTATE,  /* W */
                                DRV_CTRL_TRISTATE); /* T */

    /* enable digital part of the driver */
    //drvcfg_Enable(); in motor3ph_pwm_private.h
    IO_SET(PORT_DRV2_PROT, DIS_DRV, 0u);
    78fe:	0ea7      	lod	C, ML.7
    7900:	42d8 021a 	mov	0x21a <_PORT_DRV2_PROT>, AL

00007904 <.LM37>:

    IO_SET(PORT_DRV_OUT, ENABLE_DRVSUP, 0x1u);      /* enable driver supply */
    7904:	62d8 020e 	lod	AL, 0x20e <_PORT_DRV_OUT>
    7908:	8401      	or	AL, #1
    790a:	42d8 020e 	mov	0x20e <_PORT_DRV_OUT>, AL

0000790e <.LBB1197>:
    }
}

STATIC INLINE void DELAY(const uint16_t loops)
{
    delay_cycles(loops);
    790e:	7050      	lod	A, #80
    7910:	5a01      	mov	[S-2], Y
    7912:	82db 10f8 	callf	0x21f0 <_delay_cycles>

00007916 <.LBE1197>:

    /* wait some time to have Vddaf to stabilize */
    DELAY_US(10u);

    /* enable the driver */
    IO_SET(PORT_DRV_OUT,
    7916:	72d8 020e 	lod	A, 0x20e <_PORT_DRV_OUT>
    791a:	b6da f001 	and	A, #61441
    791e:	a6da 09c2 	or	A, #2498
    7922:	0ea7      	lod	C, ML.7
    7924:	52d8 020e 	mov	0x20e <_PORT_DRV_OUT>, A

00007928 <.LBB1200>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    7928:	7ee3      	lod	X, M

0000792a <.LBB1203>:
    return 1;
}

STATIC INLINE uint16_t mlx16_di_enter_system_mode(void)
{
    __asm__ __volatile__ (".word OPCODE_CALL_FP_ENTER_SYSTEM_MODE_PRIO_0");
    792a:	503d      	call	fp1:0xE8

0000792c <.LBE1203>:
           DRVMOD_OPTION, 0x0u,
           PARALLEL_MODE_DRV, 0x1u);				/* enable parallel mode U+V, W+T driver */

    /* configure pwm update sync interrupt - CNT ISR */
    ENTER_SECTION(ATOMIC_SYSTEM_MODE);
    Itc_SetPrio(PWM_MASTER1_END, 3u);
    792c:	62d8 008a 	lod	AL, 0x8a <__mlx4_flash_table_size+0x2>
    7930:	943f      	and	AL, #63
    7932:	42d8 008a 	mov	0x8a <__mlx4_flash_table_size+0x2>, AL

00007936 <.LBB1205>:

#define PWM1_MASTER_CNTI_ENABLE pwm1_master_cnti_enable

STATIC INLINE void pwm1_master_cnti_enable(void)
{
    Itc_Clear(PWM_MASTER1_END);
    7936:	6080      	lod	AL, #-128
    7938:	42d8 0053 	mov	0x53 <.LLST24+0x1>, AL

0000793c <.LM44>:
    Itc_Enable(PWM_MASTER1_END);
    793c:	0ea7      	lod	C, ML.7
    793e:	62d8 006f 	lod	AL, 0x6f <.LASF730+0x10>
    7942:	8480      	or	AL, #-128
    7944:	42d8 006f 	mov	0x6f <.LASF730+0x10>, AL

00007948 <.LBB1207>:
#if defined (IO_PWM_SLAVE2__START_GET)
#define PWM2_CMPI_ENABLE pwm2_cmpi_enable

STATIC INLINE void pwm2_cmpi_enable(void)
{
    Itc_Clear(PWM_SLAVE2_CMP);
    7948:	7a01      	lod	Y, [S-2]
    794a:	46d8 0054 	mov	0x54 <.LLST24+0x2>, YL

0000794e <.LM46>:
    Itc_Enable(PWM_SLAVE2_CMP);
    794e:	62d8 0070 	lod	AL, 0x70 <.LASF730+0x11>
    7952:	8402      	or	AL, #2
    7954:	42d8 0070 	mov	0x70 <.LASF730+0x11>, AL

00007958 <.LBB1209>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    7958:	5ee3      	mov	M, X

0000795a <.LBE1200>:
    pwm1_master_cnti_enable();
    pwm2_cmpi_enable();		// pwm2
    EXIT_SECTION();

    u16DutyCycleMax = 0x4000;
    795a:	72da 4000 	lod	A, #16384
    795e:	52d8 10ce 	mov	0x10ce <_u16DutyCycleMax>, A

00007962 <.LM49>:

}
    7962:	5403      	ret	#4

00007964 <_pwm_SetDutyCycle>:
 * @param[in]  u8Channels    The channel(s) to update the duty cycle for.
 * @param[in]  u16DutyCycle  The new pwm duty cycle (u16DutyCycle < u16DutyCycleMax).
 */
extern uint16_t g_u16debug_2, g_u16debug_5;
void pwm_SetDutyCycle(uint8_t dir, uint16_t u16DutyCycle)
{
    7964:	5801      	inc	S, #2

00007966 <.LCFI1>:
    7966:	7ad8 10ce 	lod	Y, 0x10ce <_u16DutyCycleMax>

0000796a <.LM51>:
    796a:	7e05      	lod	X, [S-6]
    796c:	eeee      	cmp	Y, X
    796e:	1a01      	jule	0x7972 <.L3>
    7970:	7aee      	lod	Y, X

00007972 <.L3>:
     * |     _____________     |
     * |____|             |____|
     */

    /* Change direction */
    switch (dir)
    7972:	ac00      	cmp	A, #0
    7974:	190f      	je	0x7994 <.L5>
    7976:	ac01      	cmp	A, #1
    7978:	1912      	je	0x799e <.L6>

0000797a <.L4>:
MATHLIB_INLINE_STATIC __inline__ uint16_t mulU16hi_U16byU16(uint16_t multiplicand, uint16_t multiplier)
{
    uint16_t result;
    uint16_t result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    797a:	72e6      	lod	A, Y
    797c:	4822 0c7e 	mulu	YA, A, #3198

00007980 <.LBE1213>:
            break;
    }    /* Change direction */

    u16LT = mulU16hi_U16byU16(u16DutyCycle, PWM_PERIOD << 1);

	u16LTcopy[0] = u16LT;                       /* U */
    7980:	5ad8 10c2 	mov	0x10c2 <_u16LTcopy>, Y

00007984 <.LM55>:
	u16LTcopy[1] = u16LT;                       /* V */
    7984:	5ad8 10c4 	mov	0x10c4 <_u16LTcopy+0x2>, Y

00007988 <.LM56>:
	u16LTcopy[2] = u16LT;                       /* W */
    7988:	5ad8 10c6 	mov	0x10c6 <_u16LTcopy+0x4>, Y

0000798c <.LM57>:
	u16LTcopy[3] = u16LT;                       /* T */
    798c:	0ea7      	lod	C, ML.7
    798e:	5ad8 10c8 	mov	0x10c8 <_u16LTcopy+0x6>, Y

00007992 <.LM58>:
}
    7992:	5403      	ret	#4

00007994 <.L5>:
    7994:	72da dd00 	lod	A, #56576

00007998 <.L7>:
    7998:	52d8 0216 	mov	0x216 <_PORT_DRV_CTRL>, A
    799c:	07ee      	jmp	0x797a <.L4>

0000799e <.L6>:
    799e:	72da 33dd 	lod	A, #13277

000079a2 <.LVL20>:
    79a2:	07fa      	jmp	0x7998 <.L7>

000079a4 <_pwm_Start>:
 * This function will start the pwm driver and will enable the
 * output of the pwm signals on the driver pins.
 * @param[in]  u16DutyCycle  The new pwm duty cycle (u16DutyCycle < u16DutyCycleMax).
 */
void pwm_Start(uint16_t u16DutyCycle)
{
    79a4:	5801      	inc	S, #2

000079a6 <.LCFI2>:
    79a6:	5201      	mov	[S-2], A

000079a8 <.LM61>:
    if (((IO_HOST(PORT_DIAG_IN, OVT_MEM) & u16LastDiagErr) == 0u) &&
    79a8:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>

000079ac <.LVL22>:
    79ac:	b6d8 10ca 	and	A, 0x10ca <_u16LastDiagErr>
    79b0:	1901      	je	0x79b4 <.LM62>
    79b2:	0054      	jmp	0x7a5c <.L8>

000079b4 <.LM62>:
        (IO_GET(PORT_SUPP_IN, UV_VS_IT) == 0u) &&
    79b4:	72d8 01e0 	lod	A, 0x1e0 <_PORT_SUPP_IN>

000079b8 <.LM63>:
 * output of the pwm signals on the driver pins.
 * @param[in]  u16DutyCycle  The new pwm duty cycle (u16DutyCycle < u16DutyCycleMax).
 */
void pwm_Start(uint16_t u16DutyCycle)
{
    if (((IO_HOST(PORT_DIAG_IN, OVT_MEM) & u16LastDiagErr) == 0u) &&
    79b8:	9404      	and	AL, #4
    79ba:	1901      	je	0x79be <.LM64>
    79bc:	004f      	jmp	0x7a5c <.L8>

000079be <.LM64>:
        (IO_GET(PORT_SUPP_IN, UV_VS_IT) == 0u) &&
        (IO_GET(PORT_SUPP_IN, OV_VS_IT) == 0u))
    79be:	72d8 01e0 	lod	A, 0x1e0 <_PORT_SUPP_IN>

000079c2 <.LM65>:
 * @param[in]  u16DutyCycle  The new pwm duty cycle (u16DutyCycle < u16DutyCycleMax).
 */
void pwm_Start(uint16_t u16DutyCycle)
{
    if (((IO_HOST(PORT_DIAG_IN, OVT_MEM) & u16LastDiagErr) == 0u) &&
        (IO_GET(PORT_SUPP_IN, UV_VS_IT) == 0u) &&
    79c2:	b410      	and	A, #16
    79c4:	1901      	je	0x79c8 <.LM66>
    79c6:	004a      	jmp	0x7a5c <.L8>

000079c8 <.LM66>:
        (IO_GET(PORT_SUPP_IN, OV_VS_IT) == 0u))
    {
        /* errors are gone */
        u16LastDiagErr = 0u;
    79c8:	52d8 10ca 	mov	0x10ca <_u16LastDiagErr>, A

000079cc <.LM67>:

        if (u8Status == 0u)
    79cc:	62d8 10cc 	lod	AL, 0x10cc <_u8Status>
    79d0:	1901      	je	0x79d4 <.LM67+0x8>
    79d2:	0044      	jmp	0x7a5c <.L8>
    79d4:	66e0      	lod	YL, AL
    79d6:	5cf6      	usex	Y

000079d8 <.LM68>:
        {
            /* clear UV_VS_MEM flag */
            IO_SET(PORT_DRV1_PROT, DIS_UV_VS, 1u);
    79d8:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    79dc:	8420      	or	AL, #32
    79de:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

000079e2 <.LM69>:
            IO_SET(PORT_DRV1_PROT, DIS_UV_VS, 0u);
    79e2:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    79e6:	94df      	and	AL, #-33
    79e8:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

000079ec <.LM70>:

            /* clear OV_VS_MEM flag */
            IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 1u);
    79ec:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    79f0:	8408      	or	AL, #8
    79f2:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

000079f6 <.LM71>:
            IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 0u);
    79f6:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    79fa:	94f7      	and	AL, #-9
    79fc:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

00007a00 <.LBB1219>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    7a00:	7ee3      	lod	X, M

00007a02 <.LBB1222>:
    7a02:	503d      	call	fp1:0xE8

00007a04 <.LBE1222>:

            /* (Re-)enable interrupts if they where disabled in interrupt handler */
            ENTER_SECTION(ATOMIC_SYSTEM_MODE);
            Itc_Clear(DIAG);
    7a04:	6008      	lod	AL, #8
    7a06:	42d8 0055 	mov	0x55 <.LLST24+0x3>, AL

00007a0a <.LM75>:
            Itc_Enable(DIAG);
    7a0a:	62d8 0071 	lod	AL, 0x71 <.LASF730+0x12>
    7a0e:	8408      	or	AL, #8
    7a10:	42d8 0071 	mov	0x71 <.LASF730+0x12>, AL

00007a14 <.LM76>:
            Itc_Clear(UV_VS);
    7a14:	6080      	lod	AL, #-128
    7a16:	42d8 0050 	mov	0x50 <__data_size+0x8>, AL

00007a1a <.LM77>:
            Itc_Enable(UV_VS);
    7a1a:	0ea7      	lod	C, ML.7
    7a1c:	62d8 006c 	lod	AL, 0x6c <.LASF730+0xd>
    7a20:	8480      	or	AL, #-128
    7a22:	42d8 006c 	mov	0x6c <.LASF730+0xd>, AL

00007a26 <.LM78>:
            Itc_Clear(OV_VS);
    7a26:	6004      	lod	AL, #4
    7a28:	42d8 0055 	mov	0x55 <.LLST24+0x3>, AL

00007a2c <.LM79>:
            Itc_Enable(OV_VS);
    7a2c:	0ea7      	lod	C, ML.7
    7a2e:	62d8 0071 	lod	AL, 0x71 <.LASF730+0x12>
    7a32:	8404      	or	AL, #4
    7a34:	42d8 0071 	mov	0x71 <.LASF730+0x12>, AL

00007a38 <.LBB1224>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    7a38:	5ee3      	mov	M, X

00007a3a <.LBE1219>:
//			Itc_Clear(PWM_MASTER1_END);
//			Itc_Enable(PWM_MASTER1_END);
            EXIT_SECTION();

            pwm_SetDutyCycle(0, u16DutyCycle);
    7a3a:	7e01      	lod	X, [S-2]
    7a3c:	5edf      	push	X

00007a3e <.LCFI3>:
    7a3e:	72e6      	lod	A, Y
    7a40:	1791      	call	0x7964 <_pwm_SetDutyCycle>

00007a42 <.LBB1228>:
    7a42:	72da 1100 	lod	A, #4352
    7a46:	52d8 0216 	mov	0x216 <_PORT_DRV_CTRL>, A

00007a4a <.LBE1228>:
            MotorDriverUVWTSelectSource(DRV_CTRL_PWM_MASTER1,  /* U - Phase A */
            							DRV_CTRL_PWM_MASTER1,  /* V - Phase A */
										DRV_CTRL_PWM_SLAVE1,   /* W - Phase B */
										DRV_CTRL_PWM_SLAVE1);  /* T - Phase B */

            IO_SET(PORT_DRV_OUT, ENABLE_DRV, 0xFu);     /* enable drivers of phases U,V,W,T */
    7a4a:	62d8 020e 	lod	AL, 0x20e <_PORT_DRV_OUT>
    7a4e:	843c      	or	AL, #60
    7a50:	42d8 020e 	mov	0x20e <_PORT_DRV_OUT>, AL

00007a54 <.LM84>:


            u8Status = 1u;
    7a54:	6001      	lod	AL, #1
    7a56:	42d8 10cc 	mov	0x10cc <_u8Status>, AL
    7a5a:	5c01      	dec	S, #2

00007a5c <.L8>:
        else
        {
            /* Already running */
        }
    }
}
    7a5c:	5403      	ret	#4

00007a5e <_pwm_Stop>:
    7a5e:	72da dddd 	lod	A, #56797
    7a62:	52d8 0216 	mov	0x216 <_PORT_DRV_CTRL>, A

00007a66 <.LBE1230>:
    							DRV_CTRL_LOW, 		/* V */
								DRV_CTRL_LOW,		/* W */
								DRV_CTRL_LOW);      /* T */

    /* stop pwm modules output */
    IO_SET(PWM_MASTER1, LT, 0u);                    /* U */
    7a66:	7000      	lod	A, #0
    7a68:	0ea7      	lod	C, ML.7
    7a6a:	52d8 0138 	mov	0x138 <_PWM_MASTER1+0x4>, A

00007a6e <.LM93>:
    IO_SET(PWM_SLAVE1, LT, 0u);                     /* V */
    7a6e:	52d8 0142 	mov	0x142 <.LASF1438>, A

00007a72 <.LM94>:
    IO_SET(PWM_SLAVE2, LT, 0u);                     /* W */
    7a72:	52d8 014c 	mov	0x14c <_PWM_SLAVE2+0x4>, A

00007a76 <.LM95>:
    IO_SET(PWM_SLAVE3, LT, 0u);                     /* T */
    7a76:	0ea7      	lod	C, ML.7
    7a78:	52d8 0156 	mov	0x156 <_PWM_SLAVE3+0x4>, A

00007a7c <.LM96>:

    u8Status = 0u;
    7a7c:	42d8 10cc 	mov	0x10cc <_u8Status>, AL

00007a80 <.LM97>:
}
    7a80:	5401      	ret

00007a82 <_pwm_Disable>:
    7a82:	72da eeee 	lod	A, #61166
    7a86:	52d8 0216 	mov	0x216 <_PORT_DRV_CTRL>, A

00007a8a <.LBE1232>:
                                DRV_CTRL_TRISTATE,  /* V */
                                DRV_CTRL_TRISTATE,  /* W */
                                DRV_CTRL_TRISTATE); /* T */

    /* stop pwm modules output */
    IO_SET(PWM_MASTER1, LT, 0u);                    /* U */
    7a8a:	7800      	lod	Y, #0
    7a8c:	0ea7      	lod	C, ML.7
    7a8e:	5ad8 0138 	mov	0x138 <_PWM_MASTER1+0x4>, Y

00007a92 <.LM101>:
    IO_SET(PWM_SLAVE1, LT, 0u);                     /* V */
    7a92:	5ad8 0142 	mov	0x142 <.LASF1438>, Y

00007a96 <.LM102>:
    IO_SET(PWM_SLAVE2, LT, 0u);                     /* W */
    7a96:	5ad8 014c 	mov	0x14c <_PWM_SLAVE2+0x4>, Y

00007a9a <.LM103>:
    IO_SET(PWM_SLAVE3, LT, 0u);                     /* T */
    7a9a:	0ea7      	lod	C, ML.7
    7a9c:	5ad8 0156 	mov	0x156 <_PWM_SLAVE3+0x4>, Y

00007aa0 <.LM104>:

    IO_SET(PORT_DRV_OUT,
    7aa0:	62d8 020e 	lod	AL, 0x20e <_PORT_DRV_OUT>
    7aa4:	94c0      	and	AL, #-64
    7aa6:	42d8 020e 	mov	0x20e <_PORT_DRV_OUT>, AL

00007aaa <.LM105>:
           ENABLE_DRV, 0x0u,                        /* disable drivers of all phases */
           ENABLE_DRVSUP, 0x0u,                     /* disable driver supply */
           ENABLE_DRVMOD_CPCLK, 0x0u);              /* disable driver clock */

    IO_SET(PORT_DRV2_PROT, DIS_DRV, 1u);            /* disable digital part of the driver */
    7aaa:	6001      	lod	AL, #1
    7aac:	42d8 021a 	mov	0x21a <_PORT_DRV2_PROT>, AL

00007ab0 <.LBB1234>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    7ab0:	7ee3      	lod	X, M

00007ab2 <.LBB1237>:
    7ab2:	503d      	call	fp1:0xE8

00007ab4 <.LBE1237>:

    ENTER_SECTION(ATOMIC_SYSTEM_MODE);
    Itc_Disable(DIAG);
    7ab4:	62d8 0071 	lod	AL, 0x71 <.LASF730+0x12>
    7ab8:	94f7      	and	AL, #-9
    7aba:	42d8 0071 	mov	0x71 <.LASF730+0x12>, AL

00007abe <.LM109>:
    Itc_Disable(UV_VS);
    7abe:	62d8 006c 	lod	AL, 0x6c <.LASF730+0xd>
    7ac2:	947f      	and	AL, #127
    7ac4:	42d8 006c 	mov	0x6c <.LASF730+0xd>, AL

00007ac8 <.LM110>:
    Itc_Disable(OV_VS);
    7ac8:	62d8 0071 	lod	AL, 0x71 <.LASF730+0x12>
    7acc:	94fb      	and	AL, #-5
    7ace:	42d8 0071 	mov	0x71 <.LASF730+0x12>, AL

00007ad2 <.LBB1239>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    7ad2:	5ee3      	mov	M, X

00007ad4 <.LBE1234>:
    EXIT_SECTION();

    u8Status = 0u;
    7ad4:	46d8 10cc 	mov	0x10cc <_u8Status>, YL

00007ad8 <.LM113>:
}
    7ad8:	5401      	ret

00007ada <__PWM_MASTER1_END_INT>:
 *
 * This function will handle the end of period interrupt to produce a
 * synchronized PWM LT update.
 */
INTERRUPT void _PWM_MASTER1_END_INT(void)
{
    7ada:	52df      	push	A

00007adc <.LCFI5>:
    IO_SET(PWM_MASTER1, LT, u16LTcopy[0]);          /* U */
    7adc:	72d8 10c2 	lod	A, 0x10c2 <_u16LTcopy>
    7ae0:	52d8 0138 	mov	0x138 <_PWM_MASTER1+0x4>, A

00007ae4 <.LM116>:
    IO_SET(PWM_SLAVE1, LT, u16LTcopy[1]);           /* V */
    7ae4:	72d8 10c4 	lod	A, 0x10c4 <_u16LTcopy+0x2>
    7ae8:	0ea7      	lod	C, ML.7
    7aea:	52d8 0142 	mov	0x142 <.LASF1438>, A

00007aee <.LM117>:
    IO_SET(PWM_SLAVE2, LT, u16LTcopy[2]);           /* W */
    7aee:	72d8 10c6 	lod	A, 0x10c6 <_u16LTcopy+0x4>
    7af2:	52d8 014c 	mov	0x14c <_PWM_SLAVE2+0x4>, A

00007af6 <.LM118>:
    IO_SET(PWM_SLAVE3, LT, u16LTcopy[3]);           /* T */
    7af6:	0ea7      	lod	C, ML.7
    7af8:	72d8 10c8 	lod	A, 0x10c8 <_u16LTcopy+0x6>
    7afc:	52d8 0156 	mov	0x156 <_PWM_SLAVE3+0x4>, A

00007b00 <.LM119>:

//    ENTER_SECTION(ATOMIC_SYSTEM_MODE);
//    Itc_Disable(PWM_MASTER1_END);
//    EXIT_SECTION();
}
    7b00:	72cf      	pop	A

00007b02 <.LCFI6>:
    7b02:	72cb      	pop	M
    7b04:	5401      	ret

00007b06 <__PWM_SLAVE2_CMP_INT>:

INTERRUPT void _PWM_SLAVE2_CMP_INT(void)
{
}
    7b06:	72cb      	pop	M
    7b08:	5401      	ret

00007b0a <__DIAG_INT>:
 *
 * This function will handle the generic motor driver
 * interrupt.
 */
INTERRUPT void _DIAG_INT(void)
{
    7b0a:	5edf      	push	X

00007b0c <.LCFI7>:
    7b0c:	5adf      	push	Y

00007b0e <.LCFI8>:
    7b0e:	52df      	push	A

00007b10 <.LCFI9>:
    7b10:	4c83      	push	D

00007b12 <.LCFI10>:
    /* remember the diagnostic error, all diagnostic errors need to be
     * cleared before the driver can be started again
     */
    u16LastDiagErr = IO_HOST(PORT_DIAG_IN, OVT_MEM);
    7b12:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>
    7b16:	52d8 10ca 	mov	0x10ca <_u16LastDiagErr>, A

00007b1a <.LM124>:

    pwm_Stop();
    7b1a:	17a1      	call	0x7a5e <_pwm_Stop>

00007b1c <.LM125>:

    /* disable the interrupt, otherwise the interrupt will be called continuously */
    Itc_Disable(DIAG);
    7b1c:	62d8 0071 	lod	AL, 0x71 <.LASF730+0x12>
    7b20:	94f7      	and	AL, #-9
    7b22:	42d8 0071 	mov	0x71 <.LASF730+0x12>, AL

00007b26 <.LM126>:
}
    7b26:	4cc3      	pop	D

00007b28 <.LCFI11>:
    7b28:	72cf      	pop	A

00007b2a <.LCFI12>:
    7b2a:	7acf      	pop	Y

00007b2c <.LCFI13>:
    7b2c:	7ecf      	pop	X

00007b2e <.LCFI14>:
    7b2e:	72cb      	pop	M
    7b30:	5401      	ret

00007b32 <_pwm_capture_Init>:
/**
 * Prepare module and resources
 */
void pwm_capture_Init(void)
{
    PWM_CAPTURE_u16HighPeriod = 0u;
    7b32:	7800      	lod	Y, #0
    7b34:	5ad8 10e0 	mov	0x10e0 <_PWM_CAPTURE_u16HighPeriod>, Y

00007b38 <.LM3>:
    PWM_CAPTURE_u16LowPeriod = 0u;
    7b38:	5ad8 10de 	mov	0x10de <_PWM_CAPTURE_u16LowPeriod>, Y

00007b3c <.LM4>:
    PWM_CAPTURE_u16PwmPeriod = 0u;
    7b3c:	0ea7      	lod	C, ML.7
    7b3e:	5ad8 10dc 	mov	0x10dc <_PWM_CAPTURE_u16PwmPeriod>, Y

00007b42 <.LM5>:
    PWM_CAPTURE_bNewValidData = false;
    7b42:	46d8 11f6 	mov	0x11f6 <_PWM_CAPTURE_bNewValidData>, YL

00007b46 <.LM6>:
    PWM_CAPTURE_u8OverflowCounter = 0u;
    7b46:	46d8 10da 	mov	0x10da <_PWM_CAPTURE_u8OverflowCounter>, YL

00007b4a <.LBB843>:
    IO_SET(PORT_TIMER_CFG, TIMER1_CHA_SEL, (uint16_t)sel);
}
#elif defined(IO_PORT_TIMER_CFG1__TIMER1_CHA_SEL_GET)
STATIC INLINE void CTimer1_ChanASel(CTimerCHinputSelect_t sel)
{
    IO_SET(PORT_TIMER_CFG1, TIMER1_CHA_SEL, (uint16_t)sel);
    7b4a:	0ea7      	lod	C, ML.7
    7b4c:	62d8 023c 	lod	AL, 0x23c <_PORT_TIMER_CFG1>
    7b50:	94e0      	and	AL, #-32
    7b52:	8404      	or	AL, #4
    7b54:	42d8 023c 	mov	0x23c <_PORT_TIMER_CFG1>, AL

00007b58 <.LBB847>:
    IO_SET(PORT_TIMER_CFG, TIMER1_CHB_SEL, (uint16_t)sel);
}
#elif defined(IO_PORT_TIMER_CFG1__TIMER1_CHB_SEL_GET)
STATIC INLINE void CTimer1_ChanBSel(CTimerCHinputSelect_t sel)
{
    IO_SET(PORT_TIMER_CFG1, TIMER1_CHB_SEL, (uint16_t)sel);
    7b58:	72d8 023c 	lod	A, 0x23c <_PORT_TIMER_CFG1>
    7b5c:	d4e0      	and	AH, #-32
    7b5e:	c404      	or	AH, #4
    7b60:	52d8 023c 	mov	0x23c <_PORT_TIMER_CFG1>, A

00007b64 <.LBB849>:
    IO_SET(MLX16, CTIMER1_1_PEND, 1u);
}

STATIC INLINE void CTimer1_Int2_Clear(void)
{
    IO_SET(MLX16, CTIMER1_2_PEND, 1u);
    7b64:	6002      	lod	AL, #2
    7b66:	42d8 0053 	mov	0x53 <.LLST24+0x1>, AL

00007b6a <.LBB851>:
    IO_SET(MLX16, CTIMER1_1_ITC, 1u);
}

STATIC INLINE void CTimer1_Int2_Enable(void)
{
    IO_SET(MLX16, CTIMER1_2_PEND, 1u);
    7b6a:	0ea7      	lod	C, ML.7
    7b6c:	42d8 0053 	mov	0x53 <.LLST24+0x1>, AL

00007b70 <.LM11>:
    IO_SET(MLX16, CTIMER1_2_ITC, 1u);
    7b70:	62d8 006f 	lod	AL, 0x6f <.LASF730+0x10>
    7b74:	8402      	or	AL, #2
    7b76:	42d8 006f 	mov	0x6f <.LASF730+0x10>, AL

00007b7a <.LBE851>:
    /* Clear / enable interrupts */
    CTimer1_Int2_Clear();
    CTimer1_Int2_Enable();
    /* Interrupt priority 5 to avoid interrupting motor task -
     *  update fw_vectors as well */
    Itc_SetPrio(CTIMER1_2, PRIO_CTIMER1_2_INT);
    7b7a:	62d8 0089 	lod	AL, 0x89 <__mlx4_flash_table_size+0x1>
    7b7e:	94f3      	and	AL, #-13
    7b80:	42d8 0089 	mov	0x89 <__mlx4_flash_table_size+0x1>, AL

00007b84 <.LBB853>:
    IO_SET(MLX16, CTIMER1_2_PEND, 1u);
}

STATIC INLINE void CTimer1_Int3_Clear(void)
{
    IO_SET(MLX16, CTIMER1_3_PEND, 1u);
    7b84:	6004      	lod	AL, #4
    7b86:	42d8 0053 	mov	0x53 <.LLST24+0x1>, AL

00007b8a <.LBB855>:
    IO_SET(MLX16, CTIMER1_2_ITC, 1u);
}

STATIC INLINE void CTimer1_Int3_Enable(void)
{
    IO_SET(MLX16, CTIMER1_3_PEND, 1u);
    7b8a:	0ea7      	lod	C, ML.7
    7b8c:	42d8 0053 	mov	0x53 <.LLST24+0x1>, AL

00007b90 <.LM15>:
    IO_SET(MLX16, CTIMER1_3_ITC, 1u);
    7b90:	62d8 006f 	lod	AL, 0x6f <.LASF730+0x10>
    7b94:	8404      	or	AL, #4
    7b96:	42d8 006f 	mov	0x6f <.LASF730+0x10>, AL

00007b9a <.LBE855>:
    CTimer1_Int3_Clear();
    CTimer1_Int3_Enable();
    Itc_SetPrio(CTIMER1_3, PRIO_CTIMER1_3_INT);
    7b9a:	62d8 0089 	lod	AL, 0x89 <__mlx4_flash_table_size+0x1>
    7b9e:	94cf      	and	AL, #-49
    7ba0:	42d8 0089 	mov	0x89 <__mlx4_flash_table_size+0x1>, AL

00007ba4 <.LBB857>:
{
    return IO_GET(CTIMER0, TREGB);
}
static INLINE uint16_t CTimer1_GetCapturedA(void)
{
    return IO_GET(CTIMER1, TREGA);
    7ba4:	72d8 0122 	lod	A, 0x122 <_CTIMER1+0x2>

00007ba8 <.LBB859>:
}
static INLINE uint16_t CTimer1_GetCapturedB(void)
{
    return IO_GET(CTIMER1, TREGB);
    7ba8:	72d8 0120 	lod	A, 0x120 <_CTIMER1>

00007bac <.LBB861>:

#ifdef IO_CTIMER1__START_GET
STATIC INLINE void CTimer1_CaptureInit(CTimer_Config_t cfg, uint16_t capa,
                                       uint16_t capb)
{
    IO_SET(CTIMER1, TREGA, capa);
    7bac:	0ea7      	lod	C, ML.7
    7bae:	5ad8 0122 	mov	0x122 <_CTIMER1+0x2>, Y

00007bb2 <.LM20>:
    IO_SET(CTIMER1, TREGB, capb);
    7bb2:	5ad8 0120 	mov	0x120 <_CTIMER1>, Y

00007bb6 <.LM21>:
    IO_SET(CTIMER1, DIV, (uint16_t)cfg.clockDivider,
    7bb6:	72d8 0126 	lod	A, 0x126 <.LASF688+0x1>
    7bba:	0ea7      	lod	C, ML.7
    7bbc:	b6da 03c0 	and	A, #960
    7bc0:	a6da d418 	or	A, #54296
    7bc4:	52d8 0126 	mov	0x126 <.LASF688+0x1>, A

00007bc8 <.LM22>:
           MODE, (uint16_t)eTimerModeDualCapture,
           EDGA, (uint16_t)cfg.edgeSelectorA,
           EDGB, (uint16_t)cfg.edgeSelectorB,
           ENCMP, (uint16_t)cfg.enCmp);
    IO_SET(CTIMER1, START, 1u);
    7bc8:	0ea7      	lod	C, ML.7
    7bca:	62d8 0126 	lod	AL, 0x126 <.LASF688+0x1>
    7bce:	94fc      	and	AL, #-4
    7bd0:	8401      	or	AL, #1
    7bd2:	42d8 0126 	mov	0x126 <.LASF688+0x1>, AL

00007bd6 <.LBE843>:
    PWM_CAPTURE_u16PwmPeriod = 0u;
    PWM_CAPTURE_bNewValidData = false;
    PWM_CAPTURE_u8OverflowCounter = 0u;

    InitDualCaptureMode();
}
    7bd6:	5401      	ret

00007bd8 <_pwm_capture_Start>:


#ifdef IO_CTIMER1__START_GET
STATIC INLINE void CTimer1_Start(void)
{
    IO_SET(CTIMER1, START, 1u);
    7bd8:	62d8 0126 	lod	AL, 0x126 <.LASF688+0x1>
    7bdc:	94fc      	and	AL, #-4
    7bde:	8401      	or	AL, #1
    7be0:	42d8 0126 	mov	0x126 <.LASF688+0x1>, AL

00007be4 <.LBE954>:
 * start the timer but keep values as is
 */
void pwm_capture_Start(void)
{
    StartDualCaptureMode();
    PWM_CAPTURE_bNewValidData = false;
    7be4:	6000      	lod	AL, #0
    7be6:	42d8 11f6 	mov	0x11f6 <_PWM_CAPTURE_bNewValidData>, AL

00007bea <.LM37>:
}
    7bea:	5401      	ret

00007bec <_pwm_capture_GetDutyCycleFrequency>:
 * @param[out] a_u16Dutycycle the PWM input duty cycle [%]
 * @param[out] a_u16Frequency the PWM input frequency [Hz]
 * @return true if a valid PWM input duty cycle has been applied
 */
bool pwm_capture_GetDutyCycleFrequency(uint16_t * a_u16DutyCycle, uint16_t * a_u16Frequency)
{
    7bec:	5809      	inc	S, #10

00007bee <.LCFI0>:
    7bee:	5207      	mov	[S-8], A

00007bf0 <.LM43>:
    bool retVal = false;

    if (PWM_CAPTURE_bNewValidData)
    7bf0:	62d8 11f6 	lod	AL, 0x11f6 <_PWM_CAPTURE_bNewValidData>

00007bf4 <.LVL7>:
    7bf4:	66e0      	lod	YL, AL
    7bf6:	5cf6      	usex	Y
    7bf8:	5a05      	mov	[S-6], Y
    7bfa:	8c00      	cmp	AL, #0
    7bfc:	1924      	je	0x7c46 <.L6>

00007bfe <.LBB982>:
    {
        uint16_t u16DutyCycle =
            divU16_U32byU16(mulU32_U16byU16(PWM_CAPTURE_u16HighPeriod,
    7bfe:	7ed8 10dc 	lod	X, 0x10dc <_PWM_CAPTURE_u16PwmPeriod>
    7c02:	72d8 10e0 	lod	A, 0x10e0 <_PWM_CAPTURE_u16HighPeriod>

00007c06 <.LBB983>:
 */
MATHLIB_INLINE_STATIC __inline__ uint32_t mulU32_U16byU16(uint16_t multiplicand, uint16_t multiplier)
{
    uint32_t result;

    __asm__ __volatile__ (
    7c06:	4802 0064 	mulu	D, A, #100

00007c0a <.LBE983>:
                                            PWM_CAPTURE_100PERCENT) + (PWM_CAPTURE_u16PwmPeriod / 2),
    7c0a:	72d8 10dc 	lod	A, 0x10dc <_PWM_CAPTURE_u16PwmPeriod>

00007c0e <.LVL10>:
    7c0e:	4432      	lsr	A
    7c10:	4cf2      	usex	YA

00007c12 <.LM47>:
    bool retVal = false;

    if (PWM_CAPTURE_bNewValidData)
    {
        uint16_t u16DutyCycle =
            divU16_U32byU16(mulU32_U16byU16(PWM_CAPTURE_u16HighPeriod,
    7c12:	4c00      	add	D, YA

00007c14 <.LBB985>:
MATHLIB_INLINE_STATIC __inline__ uint16_t divU16_U32byU16(uint32_t dividend, uint16_t divisor)
{
    uint16_t result;
    uint16_t result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    7c14:	4c80      	mov	YA, D
    7c16:	4c63      	divu	YA, X
    7c18:	4c63      	divu	YA, X
    7c1a:	5209      	mov	[S-10], A

00007c1c <.LBE985>:
                                            PWM_CAPTURE_100PERCENT) + (PWM_CAPTURE_u16PwmPeriod / 2),
                            PWM_CAPTURE_u16PwmPeriod);
        *a_u16DutyCycle = u16DutyCycle;
    7c1c:	7a07      	lod	Y, [S-8]
    7c1e:	52f0      	mov	[Y], A

00007c20 <.LM50>:

        uint16_t u16Frequency = divU16_U32byU16(PWM_CAPTURE_SAMPLING_FREQUENCY, PWM_CAPTURE_u16PwmPeriod);
    7c20:	7ed8 10dc 	lod	X, 0x10dc <_PWM_CAPTURE_u16PwmPeriod>

00007c24 <.LBB987>:
    7c24:	4ce2 e848 	mov	YA, #125000
    7c28:	0001 
    7c2a:	4c63      	divu	YA, X
    7c2c:	4c63      	divu	YA, X

00007c2e <.LBE987>:
        *a_u16Frequency = u16Frequency;
    7c2e:	7e0d      	lod	X, [S-14]
    7c30:	52f8      	mov	[X], A

00007c32 <.LM53>:

        #ifdef PWM_CAPTURE_HAS_PWM_PERIOD_DYNAMIC_CHECK
        PWM_CAPTURE_u16FrequencyValid = u16Frequency;
    7c32:	52d8 10d8 	mov	0x10d8 <_PWM_CAPTURE_u16FrequencyValid>, A

00007c36 <.LM54>:
        PWM_CAPTURE_u16DutyCycleValid = u16DutyCycle;
    7c36:	7209      	lod	A, [S-10]
    7c38:	52d8 10d6 	mov	0x10d6 <_PWM_CAPTURE_u16DutyCycleValid>, A

00007c3c <.L7>:
        PWM_CAPTURE_u16DutyCycleValid = 0xFFFF;
        PWM_CAPTURE_u16FrequencyValid = 0xFFFF;
    }
#endif

    PWM_CAPTURE_bNewValidData = false;
    7c3c:	6000      	lod	AL, #0
    7c3e:	42d8 11f6 	mov	0x11f6 <_PWM_CAPTURE_bNewValidData>, AL

00007c42 <.LM56>:

    return retVal;
}
    7c42:	7205      	lod	A, [S-6]
    7c44:	540b      	ret	#12

00007c46 <.L6>:
        #endif

        retVal = true;
    }
#ifdef PWM_CAPTURE_HAS_PWM_PERIOD_DYNAMIC_CHECK
    else if ((PWM_CAPTURE_u16ValidPeriodCount > (PWM_CAPTURE_CHECK_VALID_PERIODS_MIN)) &&
    7c46:	72d8 10d2 	lod	A, 0x10d2 <_PWM_CAPTURE_u16ValidPeriodCount>
    7c4a:	ac3e      	cmp	A, #62
    7c4c:	1a0f      	jule	0x7c6c <.L8>

00007c4e <.LM58>:
             (PWM_CAPTURE_u16DutyCycleValid != 0xFFFF) && (PWM_CAPTURE_u16FrequencyValid != 0xFFFF))
    7c4e:	7ed8 10d6 	lod	X, 0x10d6 <_PWM_CAPTURE_u16DutyCycleValid>

00007c52 <.LM59>:
        #endif

        retVal = true;
    }
#ifdef PWM_CAPTURE_HAS_PWM_PERIOD_DYNAMIC_CHECK
    else if ((PWM_CAPTURE_u16ValidPeriodCount > (PWM_CAPTURE_CHECK_VALID_PERIODS_MIN)) &&
    7c52:	2cff      	cmp	X, #-1
    7c54:	190b      	je	0x7c6c <.L8>

00007c56 <.LM60>:
             (PWM_CAPTURE_u16DutyCycleValid != 0xFFFF) && (PWM_CAPTURE_u16FrequencyValid != 0xFFFF))
    7c56:	72d8 10d8 	lod	A, 0x10d8 <_PWM_CAPTURE_u16FrequencyValid>
    7c5a:	acff      	cmp	A, #-1
    7c5c:	1907      	je	0x7c6c <.L8>

00007c5e <.LM61>:
    {
        *a_u16DutyCycle = PWM_CAPTURE_u16DutyCycleValid;
    7c5e:	7a07      	lod	Y, [S-8]
    7c60:	5ef0      	mov	[Y], X

00007c62 <.LM62>:
 * @param[out] a_u16Dutycycle the PWM input duty cycle [%]
 * @param[out] a_u16Frequency the PWM input frequency [Hz]
 * @return true if a valid PWM input duty cycle has been applied
 */
bool pwm_capture_GetDutyCycleFrequency(uint16_t * a_u16DutyCycle, uint16_t * a_u16Frequency)
{
    7c62:	7e0d      	lod	X, [S-14]

00007c64 <.LM63>:
#ifdef PWM_CAPTURE_HAS_PWM_PERIOD_DYNAMIC_CHECK
    else if ((PWM_CAPTURE_u16ValidPeriodCount > (PWM_CAPTURE_CHECK_VALID_PERIODS_MIN)) &&
             (PWM_CAPTURE_u16DutyCycleValid != 0xFFFF) && (PWM_CAPTURE_u16FrequencyValid != 0xFFFF))
    {
        *a_u16DutyCycle = PWM_CAPTURE_u16DutyCycleValid;
        *a_u16Frequency = PWM_CAPTURE_u16FrequencyValid;
    7c64:	52f8      	mov	[X], A

00007c66 <.LM64>:
        retVal = true;
    7c66:	7001      	lod	A, #1
    7c68:	5205      	mov	[S-6], A
    7c6a:	07e8      	jmp	0x7c3c <.L7>

00007c6c <.L8>:
    }
    else
    {
        PWM_CAPTURE_u16DutyCycleValid = 0xFFFF;
    7c6c:	70ff      	lod	A, #-1
    7c6e:	52d8 10d6 	mov	0x10d6 <_PWM_CAPTURE_u16DutyCycleValid>, A

00007c72 <.LM66>:
        PWM_CAPTURE_u16FrequencyValid = 0xFFFF;
    7c72:	52d8 10d8 	mov	0x10d8 <_PWM_CAPTURE_u16FrequencyValid>, A
    7c76:	0ea7      	lod	C, ML.7
    7c78:	07e1      	jmp	0x7c3c <.L7>

00007c7a <_pwm_capture_GetFrequency>:
 * @warning capture should be started before calling this function
 * @param[out] a_uFrequency the PWM input frequency [Hz]
 * @return true if a valid pwm frequency has been applied
 */
bool pwm_capture_GetFrequency(uint16_t * a_uFrequency)
{
    7c7a:	5801      	inc	S, #2

00007c7c <.LCFI4>:
    uint16_t u16DutyCycle;
    return pwm_capture_GetDutyCycleFrequency(&u16DutyCycle, a_uFrequency);
    7c7c:	52df      	push	A

00007c7e <.LCFI5>:
    7c7e:	72ef      	lod	A, S

00007c80 <.LVL23>:
    7c80:	a0fc      	add	A, #-4

00007c82 <.LVL24>:
    7c82:	17b4      	call	0x7bec <_pwm_capture_GetDutyCycleFrequency>

00007c84 <.LCFI6>:
}
    7c84:	5405      	ret	#6

00007c86 <__CTIMER1_2_INT>:

/**
 * Overrun A, Overrun B, Overflow interrupt
 */
INTERRUPT void _CTIMER1_2_INT(void)
{
    7c86:	5edf      	push	X

00007c88 <.LCFI7>:
    7c88:	52df      	push	A

00007c8a <.LCFI8>:
    7c8a:	7eda b2a3 	lod	X, #45731

00007c8e <.LM74>:
        static bool bRetVal;

//        bRetVal = IO_GET(PORT_LIN_XTX_CFG, LIN_IN_SOFT) ? true : false;


       if(bRetVal != 0)
    7c8e:	62d8 10d0 	lod	AL, 0x10d0 <___bRetVal_6479>

00007c92 <.LM75>:
       {
    	    IO_SET(PORT_LIN_XKEY, LIN_XKEY, 0xB2A3);
    7c92:	5ed8 01c6 	mov	0x1c6 <__bss_size>, X

00007c96 <.LM76>:
        static bool bRetVal;

//        bRetVal = IO_GET(PORT_LIN_XTX_CFG, LIN_IN_SOFT) ? true : false;


       if(bRetVal != 0)
    7c96:	1d01      	jne	0x7c9a <.LM77>
    7c98:	0049      	jmp	0x7d2c <.L18>

00007c9a <.LM77>:
       {
    	    IO_SET(PORT_LIN_XKEY, LIN_XKEY, 0xB2A3);

    	   IO_SET(PORT_LIN_XTX_CFG, LIN_IN_SOFT ,1u);
    7c9a:	62d8 01ec 	lod	AL, 0x1ec <_PORT_LIN_XTX_CFG>
    7c9e:	8480      	or	AL, #-128
    7ca0:	42d8 01ec 	mov	0x1ec <_PORT_LIN_XTX_CFG>, AL

00007ca4 <.LM78>:
    	   IO_SET(PORT_LIN_XTX_CFG, LIN_OUT_SOFT ,0u);
    7ca4:	62d8 01ec 	lod	AL, 0x1ec <_PORT_LIN_XTX_CFG>
    7ca8:	94bf      	and	AL, #-65
    7caa:	42d8 01ec 	mov	0x1ec <_PORT_LIN_XTX_CFG>, AL

00007cae <.LM79>:
    	   bRetVal = 0;
    7cae:	6000      	lod	AL, #0

00007cb0 <.L23>:
       {
    	    IO_SET(PORT_LIN_XKEY, LIN_XKEY, 0xB2A3);

    	   IO_SET(PORT_LIN_XTX_CFG, LIN_IN_SOFT ,0u);
    	   IO_SET(PORT_LIN_XTX_CFG, LIN_OUT_SOFT ,1u);
    	   bRetVal = 1;
    7cb0:	42d8 10d0 	mov	0x10d0 <___bRetVal_6479>, AL

00007cb4 <.LM81>:
       }

        if (bRetVal)
    7cb4:	62d8 10d0 	lod	AL, 0x10d0 <___bRetVal_6479>
    7cb8:	1d01      	jne	0x7cbc <.LBB989>
    7cba:	0044      	jmp	0x7d44 <.L20>

00007cbc <.LBB989>:

STATIC INLINE bool softio_toggle(GpioIo_t IO)
{
    bool success = false;
    if(IO <= MAXIO_INDEX) {
        IO_HOST(PORT_IO_OUT_SOFT, IO_OUT_SOFT) ^= ((uint16_t)0x01u << (uint16_t)IO);
    7cbc:	72d8 01e6 	lod	A, 0x1e6 <_PORT_IO_OUT_SOFT>
    7cc0:	bc02      	xor	A, #2

00007cc2 <.L24>:
    7cc2:	52d8 01e6 	mov	0x1e6 <_PORT_IO_OUT_SOFT>, A

00007cc6 <.LBB994>:
{
    return IO_GET(CTIMER0, TREGB);
}
static INLINE uint16_t CTimer1_GetCapturedA(void)
{
    return IO_GET(CTIMER1, TREGA);
    7cc6:	72d8 0122 	lod	A, 0x122 <_CTIMER1+0x2>

00007cca <.LBB996>:
}
static INLINE uint16_t CTimer1_GetCapturedB(void)
{
    return IO_GET(CTIMER1, TREGB);
    7cca:	72d8 0120 	lod	A, 0x120 <_CTIMER1>

00007cce <.LBE996>:
	//////////

    (void)CTimer1_GetCapturedA();
    (void)CTimer1_GetCapturedB();

    (void)IO_HOST(CTIMER1, OVRA);
    7cce:	0ea7      	lod	C, ML.7
    7cd0:	72d8 0126 	lod	A, 0x126 <.LASF688+0x1>

00007cd4 <.LM86>:

    PWM_CAPTURE_bNewValidData = false;
    7cd4:	6000      	lod	AL, #0
    7cd6:	42d8 11f6 	mov	0x11f6 <_PWM_CAPTURE_bNewValidData>, AL

00007cda <.LM87>:
    PWM_CAPTURE_u8OverflowCounter++;
    7cda:	0ea7      	lod	C, ML.7
    7cdc:	62d8 10da 	lod	AL, 0x10da <_PWM_CAPTURE_u8OverflowCounter>
    7ce0:	8001      	add	AL, #1
    7ce2:	42d8 10da 	mov	0x10da <_PWM_CAPTURE_u8OverflowCounter>, AL

00007ce6 <.LM88>:

    if (PWM_CAPTURE_u8OverflowCounter > PWM_CAPTURE_OVERFLOW_MAX)
    7ce6:	62d8 10da 	lod	AL, 0x10da <_PWM_CAPTURE_u8OverflowCounter>
    7cea:	8c01      	cmp	AL, #1
    7cec:	1a0b      	jule	0x7d04 <.L22>

00007cee <.LM89>:
    {
        PWM_CAPTURE_u8OverflowCounter = PWM_CAPTURE_OVERFLOW_MAX;
    7cee:	6001      	lod	AL, #1
    7cf0:	42d8 10da 	mov	0x10da <_PWM_CAPTURE_u8OverflowCounter>, AL

00007cf4 <.LM90>:

#define C_INVALID_PWM_CAPTURE_PERIOD		0x5555U
#define C_INVALID_PWM_CAPTURE_HIGHVALUE		0xFFFFU

        g_u16PWM_CAPTURE_u16PwmPeriod = C_INVALID_PWM_CAPTURE_PERIOD;
    7cf4:	72da 5555 	lod	A, #21845
    7cf8:	0ea7      	lod	C, ML.7
    7cfa:	52d8 11f2 	mov	0x11f2 <_g_u16PWM_CAPTURE_u16PwmPeriod>, A

00007cfe <.LM91>:
        g_u16PWM_CAPTURE_u16HighPeriod = C_INVALID_PWM_CAPTURE_HIGHVALUE;
    7cfe:	70ff      	lod	A, #-1
    7d00:	52d8 11f4 	mov	0x11f4 <_g_u16PWM_CAPTURE_u16HighPeriod>, A

00007d04 <.L22>:
}

#ifdef IO_CTIMER1__START_GET
STATIC INLINE void CTimer1_Stop(void)
{
    IO_SET(CTIMER1, STOP, 1u);
    7d04:	62d8 0126 	lod	AL, 0x126 <.LASF688+0x1>
    7d08:	94fc      	and	AL, #-4
    7d0a:	8402      	or	AL, #2
    7d0c:	42d8 0126 	mov	0x126 <.LASF688+0x1>, AL

00007d10 <.LBB1000>:
    IO_SET(MLX16, CTIMER1_1_PEND, 1u);
}

STATIC INLINE void CTimer1_Int2_Clear(void)
{
    IO_SET(MLX16, CTIMER1_2_PEND, 1u);
    7d10:	6002      	lod	AL, #2
    7d12:	42d8 0053 	mov	0x53 <.LLST24+0x1>, AL

00007d16 <.LBB1002>:


#ifdef IO_CTIMER1__START_GET
STATIC INLINE void CTimer1_Start(void)
{
    IO_SET(CTIMER1, START, 1u);
    7d16:	0ea7      	lod	C, ML.7
    7d18:	62d8 0126 	lod	AL, 0x126 <.LASF688+0x1>
    7d1c:	94fc      	and	AL, #-4
    7d1e:	8401      	or	AL, #1
    7d20:	42d8 0126 	mov	0x126 <.LASF688+0x1>, AL

00007d24 <.LBE1002>:
    }
#endif
    CTimer1_Stop();
    CTimer1_Int2_Clear();
    CTimer1_Start();
}
    7d24:	72cf      	pop	A

00007d26 <.LCFI9>:
    7d26:	7ecf      	pop	X

00007d28 <.LCFI10>:
    7d28:	72cb      	pop	M
    7d2a:	5401      	ret

00007d2c <.L18>:
       }
       else
       {
    	    IO_SET(PORT_LIN_XKEY, LIN_XKEY, 0xB2A3);

    	   IO_SET(PORT_LIN_XTX_CFG, LIN_IN_SOFT ,0u);
    7d2c:	62d8 01ec 	lod	AL, 0x1ec <_PORT_LIN_XTX_CFG>
    7d30:	947f      	and	AL, #127
    7d32:	42d8 01ec 	mov	0x1ec <_PORT_LIN_XTX_CFG>, AL

00007d36 <.LM97>:
    	   IO_SET(PORT_LIN_XTX_CFG, LIN_OUT_SOFT ,1u);
    7d36:	62d8 01ec 	lod	AL, 0x1ec <_PORT_LIN_XTX_CFG>
    7d3a:	8440      	or	AL, #64
    7d3c:	42d8 01ec 	mov	0x1ec <_PORT_LIN_XTX_CFG>, AL

00007d40 <.LM98>:
    	   bRetVal = 1;
    7d40:	6001      	lod	AL, #1
    7d42:	07b6      	jmp	0x7cb0 <.L23>

00007d44 <.L20>:
    7d44:	72d8 01e6 	lod	A, 0x1e6 <_PORT_IO_OUT_SOFT>
    7d48:	bc04      	xor	A, #4
    7d4a:	07bb      	jmp	0x7cc2 <.L24>

00007d4c <__CTIMER1_3_INT>:

/**
 * Capture B interrupt
 */
INTERRUPT void _CTIMER1_3_INT(void)
{
    7d4c:	5edf      	push	X

00007d4e <.LCFI12>:
    7d4e:	5adf      	push	Y

00007d50 <.LCFI13>:
    7d50:	52df      	push	A

00007d52 <.LCFI14>:
    7d52:	4c83      	push	D

00007d54 <.LCFI15>:
    7d54:	5809      	inc	S, #10

00007d56 <.LBB1005>:
{
    return IO_GET(CTIMER0, TREGB);
}
static INLINE uint16_t CTimer1_GetCapturedA(void)
{
    return IO_GET(CTIMER1, TREGA);
    7d56:	72d8 0122 	lod	A, 0x122 <_CTIMER1+0x2>

00007d5a <.LBB1007>:
}
static INLINE uint16_t CTimer1_GetCapturedB(void)
{
    return IO_GET(CTIMER1, TREGB);
    7d5a:	7ed8 0120 	lod	X, 0x120 <_CTIMER1>

00007d5e <.LBE1007>:
    uint16_t capA = CTimer1_GetCapturedA();
    uint16_t capB = CTimer1_GetCapturedB();
    PWM_CAPTURE_u16PwmPeriod = capB + capA;
    7d5e:	a2ee      	add	A, X
    7d60:	52d8 10dc 	mov	0x10dc <_PWM_CAPTURE_u16PwmPeriod>, A

00007d64 <.LM104>:
    PWM_CAPTURE_u16HighPeriod = capB;
    7d64:	5ed8 10e0 	mov	0x10e0 <_PWM_CAPTURE_u16HighPeriod>, X

00007d68 <.LM105>:

    g_u16PWM_CAPTURE_u16PwmPeriod = PWM_CAPTURE_u16PwmPeriod;
    7d68:	72d8 10dc 	lod	A, 0x10dc <_PWM_CAPTURE_u16PwmPeriod>
    7d6c:	0ea7      	lod	C, ML.7
    7d6e:	52d8 11f2 	mov	0x11f2 <_g_u16PWM_CAPTURE_u16PwmPeriod>, A

00007d72 <.LM106>:
    g_u16PWM_CAPTURE_u16HighPeriod = PWM_CAPTURE_u16HighPeriod;
    7d72:	72d8 10e0 	lod	A, 0x10e0 <_PWM_CAPTURE_u16HighPeriod>
    7d76:	52d8 11f4 	mov	0x11f4 <_g_u16PWM_CAPTURE_u16HighPeriod>, A

00007d7a <.LBB1009>:
/**
 * check capture inputs to be valid and calculate output data
 */
static INLINE void CheckInputs(void)
{
    if (PWM_CAPTURE_u8OverflowCounter == 0u)
    7d7a:	0ea7      	lod	C, ML.7
    7d7c:	62d8 10da 	lod	AL, 0x10da <_PWM_CAPTURE_u8OverflowCounter>
    7d80:	4205      	mov	[S-6], AL
    7d82:	1901      	je	0x7d86 <.LM108>
    7d84:	0053      	jmp	0x7e2c <.L26>

00007d86 <.LM108>:
    {
        if ((PWM_CAPTURE_u16PwmPeriod >= PWM_CAPTURE_MIN_PERIOD) &&
    7d86:	72d8 10dc 	lod	A, 0x10dc <_PWM_CAPTURE_u16PwmPeriod>
    7d8a:	ac70      	cmp	A, #112
    7d8c:	1e01      	jug	0x7d90 <.LM109>
    7d8e:	0041      	jmp	0x7e12 <.L27>

00007d90 <.LM109>:
            (PWM_CAPTURE_u16PwmPeriod <= PWM_CAPTURE_MAX_PERIOD))
    7d90:	72d8 10dc 	lod	A, 0x10dc <_PWM_CAPTURE_u16PwmPeriod>

00007d94 <.LM110>:
 */
static INLINE void CheckInputs(void)
{
    if (PWM_CAPTURE_u8OverflowCounter == 0u)
    {
        if ((PWM_CAPTURE_u16PwmPeriod >= PWM_CAPTURE_MIN_PERIOD) &&
    7d94:	aeda 09c4 	cmp	A, #2500
    7d98:	1a01      	jule	0x7d9c <.LBB1011>
    7d9a:	003b      	jmp	0x7e12 <.L27>

00007d9c <.LBB1011>:
            (PWM_CAPTURE_u16PwmPeriod <= PWM_CAPTURE_MAX_PERIOD))
        {
#ifdef PWM_CAPTURE_HAS_PWM_PERIOD_DYNAMIC_CHECK
            /** If PWM input period is almost the same as last cycle */
            uint16_t Period93 = (uint16_t)(mulU32_U16byU16(PWM_CAPTURE_u16PeriodPrevious, 15) >> 4);
    7d9c:	72d8 10d4 	lod	A, 0x10d4 <_PWM_CAPTURE_u16PeriodPrevious>

00007da0 <.LBB1012>:
 */
MATHLIB_INLINE_STATIC __inline__ uint32_t mulU32_U16byU16(uint16_t multiplicand, uint16_t multiplier)
{
    uint32_t result;

    __asm__ __volatile__ (
    7da0:	4802 000f 	mulu	D, A, #15

00007da4 <.LBE1012>:
            uint16_t Period106 = (uint16_t)(mulU32_U16byU16(PWM_CAPTURE_u16PeriodPrevious, 17) >> 4);
    7da4:	72d8 10d4 	lod	A, 0x10d4 <_PWM_CAPTURE_u16PeriodPrevious>

00007da8 <.LBB1014>:
    7da8:	4822 0011 	mulu	YA, A, #17

00007dac <.LVL34>:
    7dac:	58a0      	mov	[S-4], YA

00007dae <.LBE1014>:

            if ((PWM_CAPTURE_u16PwmPeriod >= Period93) &&
    7dae:	7ed8 10dc 	lod	X, 0x10dc <_PWM_CAPTURE_u16PwmPeriod>

00007db2 <.LM116>:
        if ((PWM_CAPTURE_u16PwmPeriod >= PWM_CAPTURE_MIN_PERIOD) &&
            (PWM_CAPTURE_u16PwmPeriod <= PWM_CAPTURE_MAX_PERIOD))
        {
#ifdef PWM_CAPTURE_HAS_PWM_PERIOD_DYNAMIC_CHECK
            /** If PWM input period is almost the same as last cycle */
            uint16_t Period93 = (uint16_t)(mulU32_U16byU16(PWM_CAPTURE_u16PeriodPrevious, 15) >> 4);
    7db2:	4c80      	mov	YA, D
    7db4:	48a3      	lsr	YA, #4
    7db6:	58a3      	mov	[S-10], YA

00007db8 <.LM117>:
            uint16_t Period106 = (uint16_t)(mulU32_U16byU16(PWM_CAPTURE_u16PeriodPrevious, 17) >> 4);

            if ((PWM_CAPTURE_u16PwmPeriod >= Period93) &&
    7db8:	2e09      	cmp	X, [S-10]
    7dba:	1820      	jc	0x7dfc <.L28>

00007dbc <.LM118>:
                (PWM_CAPTURE_u16PwmPeriod <= Period106))
    7dbc:	7ed8 10dc 	lod	X, 0x10dc <_PWM_CAPTURE_u16PwmPeriod>

00007dc0 <.LM119>:
            (PWM_CAPTURE_u16PwmPeriod <= PWM_CAPTURE_MAX_PERIOD))
        {
#ifdef PWM_CAPTURE_HAS_PWM_PERIOD_DYNAMIC_CHECK
            /** If PWM input period is almost the same as last cycle */
            uint16_t Period93 = (uint16_t)(mulU32_U16byU16(PWM_CAPTURE_u16PeriodPrevious, 15) >> 4);
            uint16_t Period106 = (uint16_t)(mulU32_U16byU16(PWM_CAPTURE_u16PeriodPrevious, 17) >> 4);
    7dc0:	58e0      	mov	YA, [S-4]
    7dc2:	48a3      	lsr	YA, #4

00007dc4 <.LM120>:

            if ((PWM_CAPTURE_u16PwmPeriod >= Period93) &&
    7dc4:	2ee2      	cmp	X, A
    7dc6:	1e1a      	jug	0x7dfc <.L28>

00007dc8 <.LM121>:
                (PWM_CAPTURE_u16PwmPeriod <= Period106))
            {
                /* 2 edges detected, so valid period found */
                if (PWM_CAPTURE_u16ValidPeriodCount < PWM_CAPTURE_CHECK_VALID_PERIODS_MAX)
    7dc8:	72d8 10d2 	lod	A, 0x10d2 <_PWM_CAPTURE_u16ValidPeriodCount>

00007dcc <.LVL38>:
    7dcc:	aeda 00f9 	cmp	A, #249
    7dd0:	1e13      	jug	0x7df8 <.L29>

00007dd2 <.LM122>:
                {
                    PWM_CAPTURE_u16ValidPeriodCount++;
    7dd2:	72d8 10d2 	lod	A, 0x10d2 <_PWM_CAPTURE_u16ValidPeriodCount>
    7dd6:	a001      	add	A, #1
    7dd8:	52d8 10d2 	mov	0x10d2 <_PWM_CAPTURE_u16ValidPeriodCount>, A

00007ddc <.LM123>:
                    PWM_CAPTURE_bNewValidData = false;
    7ddc:	6205      	lod	AL, [S-6]

00007dde <.L33>:
            {
                if (PWM_CAPTURE_u16ValidPeriodCount > 1)
                {
                    PWM_CAPTURE_u16ValidPeriodCount -= 2;
                }
                PWM_CAPTURE_bNewValidData = false;
    7dde:	42d8 11f6 	mov	0x11f6 <_PWM_CAPTURE_bNewValidData>, AL

00007de2 <.LM125>:
            }
            PWM_CAPTURE_u16PeriodPrevious = PWM_CAPTURE_u16PwmPeriod;
    7de2:	72d8 10dc 	lod	A, 0x10dc <_PWM_CAPTURE_u16PwmPeriod>
    7de6:	52d8 10d4 	mov	0x10d4 <_PWM_CAPTURE_u16PeriodPrevious>, A

00007dea <.L25>:
    g_u16PWM_CAPTURE_u16PwmPeriod = PWM_CAPTURE_u16PwmPeriod;
    g_u16PWM_CAPTURE_u16HighPeriod = PWM_CAPTURE_u16HighPeriod;


    CheckInputs();
}
    7dea:	5c09      	dec	S, #10
    7dec:	4cc3      	pop	D

00007dee <.LCFI17>:
    7dee:	72cf      	pop	A

00007df0 <.LCFI18>:
    7df0:	7acf      	pop	Y

00007df2 <.LCFI19>:
    7df2:	7ecf      	pop	X

00007df4 <.LCFI20>:
    7df4:	72cb      	pop	M
    7df6:	5401      	ret

00007df8 <.L29>:
                    PWM_CAPTURE_u16ValidPeriodCount++;
                    PWM_CAPTURE_bNewValidData = false;
                }
                else
                {
                    PWM_CAPTURE_bNewValidData = true;
    7df8:	6001      	lod	AL, #1
    7dfa:	07f1      	jmp	0x7dde <.L33>

00007dfc <.L28>:
                }
            }
            else
            {
                if (PWM_CAPTURE_u16ValidPeriodCount > 1)
    7dfc:	72d8 10d2 	lod	A, 0x10d2 <_PWM_CAPTURE_u16ValidPeriodCount>
    7e00:	ac01      	cmp	A, #1
    7e02:	1a05      	jule	0x7e0e <.L31>

00007e04 <.LM129>:
                {
                    PWM_CAPTURE_u16ValidPeriodCount -= 2;
    7e04:	72d8 10d2 	lod	A, 0x10d2 <_PWM_CAPTURE_u16ValidPeriodCount>
    7e08:	a0fe      	add	A, #-2
    7e0a:	52d8 10d2 	mov	0x10d2 <_PWM_CAPTURE_u16ValidPeriodCount>, A

00007e0e <.L31>:
                }
                PWM_CAPTURE_bNewValidData = false;
    7e0e:	6000      	lod	AL, #0
    7e10:	07e6      	jmp	0x7dde <.L33>

00007e12 <.L27>:
            }
            PWM_CAPTURE_u16PeriodPrevious = PWM_CAPTURE_u16PwmPeriod;
        }
        else
        {
            PWM_CAPTURE_bNewValidData = false;
    7e12:	6000      	lod	AL, #0
    7e14:	42d8 11f6 	mov	0x11f6 <_PWM_CAPTURE_bNewValidData>, AL

00007e18 <.LM132>:
            if (PWM_CAPTURE_u16ValidPeriodCount > 1)
    7e18:	72d8 10d2 	lod	A, 0x10d2 <_PWM_CAPTURE_u16ValidPeriodCount>
    7e1c:	ac01      	cmp	A, #1
    7e1e:	1a65      	jule	0x7dea <.L25>

00007e20 <.LM133>:
            {
                PWM_CAPTURE_u16ValidPeriodCount -= 2;
    7e20:	72d8 10d2 	lod	A, 0x10d2 <_PWM_CAPTURE_u16ValidPeriodCount>
    7e24:	a0fe      	add	A, #-2
    7e26:	52d8 10d2 	mov	0x10d2 <_PWM_CAPTURE_u16ValidPeriodCount>, A
    7e2a:	07df      	jmp	0x7dea <.L25>

00007e2c <.L26>:
#endif
        }
    }
    else
    {
        PWM_CAPTURE_u8OverflowCounter--;
    7e2c:	62d8 10da 	lod	AL, 0x10da <_PWM_CAPTURE_u8OverflowCounter>
    7e30:	80ff      	add	AL, #-1
    7e32:	42d8 10da 	mov	0x10da <_PWM_CAPTURE_u8OverflowCounter>, AL

00007e36 <.LM135>:
    g_u16PWM_CAPTURE_u16PwmPeriod = PWM_CAPTURE_u16PwmPeriod;
    g_u16PWM_CAPTURE_u16HighPeriod = PWM_CAPTURE_u16HighPeriod;


    CheckInputs();
}
    7e36:	07d9      	jmp	0x7dea <.L25>

00007e38 <_pwm_communication_Init>:
/**
 * Initialization HW and SW resources
 */
void pwm_communication_Init(void)
{
    pwm_capture_Init();
    7e38:	067c      	jmp	0x7b32 <_pwm_capture_Init>

00007e3a <_pwm_communication_Start>:
 * Start pwm communication capture
 */
void pwm_communication_Start(void)
{
    pwm_communication_u16Speed = 0u;
    pwm_communication_bValid = false;
    7e3a:	6000      	lod	AL, #0
    7e3c:	42d8 10e4 	mov	0x10e4 <_pwm_communication_bValid>, AL

00007e40 <.LM9>:
    pwm_communication_u16PreviousSpeed = 0u;
    7e40:	7000      	lod	A, #0
    7e42:	0ea7      	lod	C, ML.7
    7e44:	52d8 10e2 	mov	0x10e2 <_pwm_communication_u16PreviousSpeed>, A

00007e48 <.LM10>:

    pwm_capture_Start();
    7e48:	06c7      	jmp	0x7bd8 <_pwm_capture_Start>

00007e4a <_swtimer_init>:
 * Initialize Core Timer and start.
 */
void swtimer_init(void)
{
    /* Init clock error conversion */
    conv_clock_error_init();
    7e4a:	82db 2fb4 	callf	0x5f68 <_conv_clock_error_init>

00007e4e <.LBB220>:
/** STIMER_SET_MODE sets the simple timer's mode
 * @param[in] mode new Simple Timer's mode
 */
STATIC INLINE void STIMER_SET_MODE( STimerClk_t mode )
{
    IO_SET(STIMER, MODE, (uint16_t)mode);
    7e4e:	72b2      	lod	A, io:0x32 <_STIMER+0x2>
    7e50:	d43f      	and	AH, #63
    7e52:	c480      	or	AH, #-128
    7e54:	52b2      	mov	io:0x32 <_STIMER+0x2>, A

00007e56 <.LBB223>:
/** STIMER_SET_VALUE sets the simple timer's mode
 * @param[in] value is new 14-bit timer value
 */
STATIC INLINE void STIMER_SET_VALUE( uint16_t value )
{
    IO_SET(STIMER, VALUE, value);
    7e56:	72b2      	lod	A, io:0x32 <_STIMER+0x2>
    7e58:	b6da c000 	and	A, #49152
    7e5c:	a6da 03e8 	or	A, #1000
    7e60:	52b2      	mov	io:0x32 <_STIMER+0x2>, A

00007e62 <.LBB225>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    7e62:	7ee3      	lod	X, M

00007e64 <.LBB228>:
    return 1;
}

STATIC INLINE uint16_t mlx16_enter_system_mode_keep_prio(void)
{
    __asm__ __volatile__ (".word OPCODE_CALL_FP_ENTER_SYSTEM_MODE_KEEP_PRIO");
    7e64:	503c      	call	fp1:0xE0

00007e66 <.LBE228>:
    STIMER_INIT(STIMER_1US_CLOCK, CT_PERIODIC_RATE);

    /* Enable Timer interrupt */
    #ifndef UNITTEST
    ENTER_SECTION(SYSTEM_MODE);
    Itc_Clear(STIMER);
    7e66:	6010      	lod	AL, #16
    7e68:	42d8 0052 	mov	0x52 <.LLST24>, AL

00007e6c <.LM8>:
    Itc_Enable(STIMER);
    7e6c:	62d8 006e 	lod	AL, 0x6e <.LASF730+0xf>
    7e70:	8410      	or	AL, #16
    7e72:	42d8 006e 	mov	0x6e <.LASF730+0xf>, AL

00007e76 <.LM9>:
    Itc_SetPrio(STIMER, PRIO_STIMER_INT);
    7e76:	62d8 0088 	lod	AL, 0x88 <__mlx4_flash_table_size>
    7e7a:	8403      	or	AL, #3
    7e7c:	42d8 0088 	mov	0x88 <__mlx4_flash_table_size>, AL

00007e80 <.LBB230>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    7e80:	5ee3      	mov	M, X

00007e82 <.LBE225>:
    EXIT_SECTION();
    #endif

    /* Clear all */
    (void)memset((void *)g_pTimer, 0, sizeof(g_pTimer) / sizeof(uint8_t));
    7e82:	7eda 11f8 	lod	X, #4600
    7e86:	7000      	lod	A, #0
    7e88:	54ea      	mov	Cx, #10
    7e8a:	52de      	mov	[X++], A
    7e8c:	52de      	mov	[X++], A
    7e8e:	1ffd      	djnz	Cx, 0x7e8a <.LASF1994+0x5>

00007e90 <.LM12>:
}
    7e90:	5401      	ret

00007e92 <_swtimer_deinit>:
/** STIMER_SET_MODE sets the simple timer's mode
 * @param[in] mode new Simple Timer's mode
 */
STATIC INLINE void STIMER_SET_MODE( STimerClk_t mode )
{
    IO_SET(STIMER, MODE, (uint16_t)mode);
    7e92:	72b2      	lod	A, io:0x32 <_STIMER+0x2>
    7e94:	d43f      	and	AH, #63
    7e96:	52b2      	mov	io:0x32 <_STIMER+0x2>, A

00007e98 <.LBB236>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    7e98:	7ee3      	lod	X, M

00007e9a <.LBB239>:
    7e9a:	503c      	call	fp1:0xE0

00007e9c <.LBE239>:
    STIMER_SET_MODE(STIMER_DISABLE_CLOCK);  /* switch off */

    /* Disable Timer interrupt */
    #ifndef UNITTEST
    ENTER_SECTION(SYSTEM_MODE);
    Itc_Disable(STIMER);
    7e9c:	62d8 006e 	lod	AL, 0x6e <.LASF730+0xf>
    7ea0:	94ef      	and	AL, #-17
    7ea2:	42d8 006e 	mov	0x6e <.LASF730+0xf>, AL

00007ea6 <.LBB241>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    7ea6:	5ee3      	mov	M, X

00007ea8 <.LBE236>:
    EXIT_SECTION();
    #endif
}
    7ea8:	5401      	ret

00007eaa <_swtimer_calibrate>:
void swtimer_calibrate(uint16_t u16ADC_Value)
{
    int16_t i16ClockCountCorrection = 0;

    /* Get clock count correction */
    i16ClockCountCorrection = conv_clock_error_speed(u16ADC_Value);
    7eaa:	82db 2fc8 	callf	0x5f90 <_conv_clock_error_speed>

00007eae <.LM33>:

    i16ClockCountCorrection = conv_clock_error_correct_period(CT_PERIODIC_RATE, i16ClockCountCorrection);
    7eae:	52df      	push	A

00007eb0 <.LCFI0>:
    7eb0:	72da 03e8 	lod	A, #1000

00007eb4 <.LVL20>:
    7eb4:	82db 2fde 	callf	0x5fbc <_conv_clock_error_correct_period>

00007eb8 <.LBB251>:
/** STIMER_SET_VALUE sets the simple timer's mode
 * @param[in] value is new 14-bit timer value
 */
STATIC INLINE void STIMER_SET_VALUE( uint16_t value )
{
    IO_SET(STIMER, VALUE, value);
    7eb8:	7eb2      	lod	X, io:0x32 <_STIMER+0x2>
    7eba:	36da c000 	and	X, #49152
    7ebe:	a6ee      	or	A, X

00007ec0 <.LVL22>:
    7ec0:	52b2      	mov	io:0x32 <_STIMER+0x2>, A

00007ec2 <.LBE251>:
    STIMER_SET_VALUE(i16ClockCountCorrection);
}
    7ec2:	5403      	ret	#4

00007ec4 <_swtimer_register>:
 */
bool swtimer_register(swtimer_id_t a_e8Id, uint16_t a_u15Load, swtimer_mode_t a_eMode)
{
    bool bRetVal = false;

    if ((a_e8Id < SWTIMER_NR_OF) && (a_u15Load < 0x8000))
    7ec4:	ac09      	cmp	A, #9
    7ec6:	1e12      	jug	0x7eec <.L17>

00007ec8 <.LM38>:
 * @param  a_u15Load  a 15-bit load value [0:0x8000] x CT_PERIODIC_RATE us
 * @param  a_eMode  timer mode, single shot or repetitive
 * @return  true  in case of success
 */
bool swtimer_register(swtimer_id_t a_e8Id, uint16_t a_u15Load, swtimer_mode_t a_eMode)
{
    7ec8:	7a03      	lod	Y, [S-4]

00007eca <.LM39>:
    bool bRetVal = false;

    if ((a_e8Id < SWTIMER_NR_OF) && (a_u15Load < 0x8000))
    7eca:	ec00      	cmp	Y, #0
    7ecc:	1a8f      	jsl	0x7eec <.L17>

00007ece <.LM40>:
    {
        g_pTimer[a_e8Id].bRepetitive = (a_eMode == REPETITIVE) ? 1u : 0u;
    7ece:	44a2      	asl	A, #2

00007ed0 <.LVL24>:
    7ed0:	7ee2      	lod	X, A
    7ed2:	22da 11f8 	add	X, #4600

00007ed6 <.LM41>:
 * @param  a_u15Load  a 15-bit load value [0:0x8000] x CT_PERIODIC_RATE us
 * @param  a_eMode  timer mode, single shot or repetitive
 * @return  true  in case of success
 */
bool swtimer_register(swtimer_id_t a_e8Id, uint16_t a_u15Load, swtimer_mode_t a_eMode)
{
    7ed6:	7205      	lod	A, [S-6]

00007ed8 <.LM42>:
    bool bRetVal = false;

    if ((a_e8Id < SWTIMER_NR_OF) && (a_u15Load < 0x8000))
    {
        g_pTimer[a_e8Id].bRepetitive = (a_eMode == REPETITIVE) ? 1u : 0u;
    7ed8:	ac01      	cmp	A, #1
    7eda:	5c82      	se	A

00007edc <.LM43>:
        g_pTimer[a_e8Id].u15Load = a_u15Load;
    7edc:	f6da 7fff 	and	Y, #32767
    7ee0:	b401      	and	A, #1
    7ee2:	4452      	rr	A
    7ee4:	a6e6      	or	A, Y
    7ee6:	52f8      	mov	[X], A

00007ee8 <.LM44>:
        bRetVal = true;
    7ee8:	7001      	lod	A, #1
    7eea:	5401      	ret

00007eec <.L17>:
 * @param  a_eMode  timer mode, single shot or repetitive
 * @return  true  in case of success
 */
bool swtimer_register(swtimer_id_t a_e8Id, uint16_t a_u15Load, swtimer_mode_t a_eMode)
{
    bool bRetVal = false;
    7eec:	7000      	lod	A, #0

00007eee <.LM46>:
        g_pTimer[a_e8Id].bRepetitive = (a_eMode == REPETITIVE) ? 1u : 0u;
        g_pTimer[a_e8Id].u15Load = a_u15Load;
        bRetVal = true;
    }
    return bRetVal;
}
    7eee:	5401      	ret

00007ef0 <_swtimer_start>:
 * Start a software timer
 * @param[in]  a_e8Id  Timer id
 */
void swtimer_start(swtimer_id_t a_e8Id)
{
    g_pTimer[a_e8Id].u15Current = g_pTimer[a_e8Id].u15Load;
    7ef0:	44a2      	asl	A, #2

00007ef2 <.LVL29>:
    7ef2:	7ee2      	lod	X, A
    7ef4:	22da 11f8 	add	X, #4600
    7ef8:	7af8      	lod	Y, [X]
    7efa:	f6da 7fff 	and	Y, #32767
    7efe:	72fa      	lod	A, [X+2]
    7f00:	b6da 8000 	and	A, #32768
    7f04:	a6e6      	or	A, Y
    7f06:	52fa      	mov	[X+2], A

00007f08 <.LM49>:
    g_pTimer[a_e8Id].bTriggered = 0u;
    7f08:	2003      	add	X, #3
    7f0a:	62f8      	lod	AL, [X]
    7f0c:	947f      	and	AL, #127
    7f0e:	42f8      	mov	[X], AL

00007f10 <.LM50>:
}
    7f10:	5401      	ret

00007f12 <_swtimer_stop>:
 * Stop a software timer.
 * @param[in]  a_e8Id  Timer id
 */
void swtimer_stop(swtimer_id_t a_e8Id)
{
    g_pTimer[a_e8Id].u15Current = 0u;
    7f12:	44a2      	asl	A, #2

00007f14 <.LVL31>:
    7f14:	7ee2      	lod	X, A
    7f16:	22da 11fa 	add	X, #4602
    7f1a:	7000      	lod	A, #0
    7f1c:	52f8      	mov	[X], A

00007f1e <.LM53>:
    g_pTimer[a_e8Id].bTriggered = 0u;
}
    7f1e:	5401      	ret

00007f20 <_swtimer_isRunning>:
 * @param[in]  a_e8Id  Timer id
 * @return  true  if running
 */
bool swtimer_isRunning(swtimer_id_t a_e8Id)
{
    return ((g_pTimer[a_e8Id].u15Current != 0u) ? true : false);
    7f20:	44a2      	asl	A, #2

00007f22 <.LVL35>:
    7f22:	7ee2      	lod	X, A
    7f24:	22da 11fa 	add	X, #4602
    7f28:	72f8      	lod	A, [X]
    7f2a:	b6da 7fff 	and	A, #32767
    7f2e:	5ca2      	sne	A

00007f30 <.LM61>:
}
    7f30:	5401      	ret

00007f32 <_swtimer_isTriggered>:
 * Check if a software timer has expired and clear it by timer id.
 * @param[in]  a_e8Id  Timer id
 * @return  true  if expired
 */
bool swtimer_isTriggered(swtimer_id_t a_e8Id)
{
    7f32:	5801      	inc	S, #2

00007f34 <.LCFI2>:
    bool lb_trigged = false;

    if (g_pTimer[a_e8Id].bTriggered != 0u)
    7f34:	44a2      	asl	A, #2

00007f36 <.LVL38>:
    7f36:	5201      	mov	[S-2], A
    7f38:	7ee2      	lod	X, A
    7f3a:	22da 11fb 	add	X, #4603
    7f3e:	66f8      	lod	YL, [X]
    7f40:	62e8      	lod	AL, YL
    7f42:	4440      	rl	AL
    7f44:	9401      	and	AL, #1
    7f46:	5cf2      	usex	A
    7f48:	7ee2      	lod	X, A
    7f4a:	62e8      	lod	AL, YL
    7f4c:	1d88      	jnn	0x7f5e <.L26>

00007f4e <.LM64>:
    {
        g_pTimer[a_e8Id].bTriggered = 0u;
    7f4e:	7e01      	lod	X, [S-2]
    7f50:	22da 11fb 	add	X, #4603
    7f54:	62e8      	lod	AL, YL
    7f56:	947f      	and	AL, #127
    7f58:	42f8      	mov	[X], AL

00007f5a <.LM65>:
        lb_trigged = true;
    7f5a:	7001      	lod	A, #1
    7f5c:	5403      	ret	#4

00007f5e <.L26>:
 * @param[in]  a_e8Id  Timer id
 * @return  true  if expired
 */
bool swtimer_isTriggered(swtimer_id_t a_e8Id)
{
    bool lb_trigged = false;
    7f5e:	72ee      	lod	A, X

00007f60 <.LM67>:
        g_pTimer[a_e8Id].bTriggered = 0u;
        lb_trigged = true;
    }

    return (lb_trigged);
}
    7f60:	5403      	ret	#4

00007f62 <_swtimer_enterIrq>:
/* ---------------------------------------------
 * Weak, default function implementation
 * --------------------------------------------- */

WEAK void swtimer_enterIrq(void)
{}
    7f62:	5401      	ret

00007f64 <_swtimer_exitIrq>:
    7f64:	5401      	ret

00007f66 <_swtimer_triggerIrq>:
{}

WEAK void swtimer_triggerIrq(uint16_t id)
{
    (void)id;
}
    7f66:	5401      	ret

00007f68 <__STIMER_INT>:

/**
 * The core timer interrupt service routine.
 */
INTERRUPT void _STIMER_INT(void)
{
    7f68:	5edf      	push	X

00007f6a <.LCFI3>:
    7f6a:	5adf      	push	Y

00007f6c <.LCFI4>:
    7f6c:	52df      	push	A

00007f6e <.LCFI5>:
    7f6e:	4c83      	push	D

00007f70 <.LCFI6>:
    7f70:	5807      	inc	S, #8

00007f72 <.LCFI7>:
    swtimer_enterIrq();
    7f72:	17f7      	call	0x7f62 <_swtimer_enterIrq>

00007f74 <.LBB253>:

    /* Count-down all the registered SW timers, trigger when 0 is reached */
    for (uint16_t index = 0u; index < (uint16_t)SWTIMER_NR_OF; index++)
    7f74:	7000      	lod	A, #0
    7f76:	5205      	mov	[S-6], A

00007f78 <.L33>:
    {
        uint16_t value = g_pTimer[index].u15Current;
    7f78:	7205      	lod	A, [S-6]
    7f7a:	44a2      	asl	A, #2
    7f7c:	5201      	mov	[S-2], A
    7f7e:	7ee2      	lod	X, A
    7f80:	22da 11fa 	add	X, #4602
    7f84:	7ef8      	lod	X, [X]

00007f86 <.LM76>:

        if (value != 0u)
    7f86:	72ee      	lod	A, X
    7f88:	d47f      	and	AH, #127
    7f8a:	ac00      	cmp	A, #0
    7f8c:	1926      	je	0x7fda <.L31>
    7f8e:	72ee      	lod	A, X
    7f90:	b6da 7fff 	and	A, #32767

00007f94 <.LM77>:
        {
            value--;

            if (value == 0u)
    7f94:	7ae2      	lod	Y, A
    7f96:	e0ff      	add	Y, #-1

00007f98 <.LVL47>:
    7f98:	5a07      	mov	[S-8], Y
    7f9a:	ac01      	cmp	A, #1
    7f9c:	1d12      	jne	0x7fc2 <.L32>

00007f9e <.LM78>:
            {
                /* Trigger state */
                g_pTimer[index].bTriggered = 1u;
    7f9e:	7a01      	lod	Y, [S-2]

00007fa0 <.LVL48>:
    7fa0:	e2da 11f8 	add	Y, #4600
    7fa4:	7ee6      	lod	X, Y
    7fa6:	2003      	add	X, #3
    7fa8:	62f8      	lod	AL, [X]
    7faa:	8480      	or	AL, #-128
    7fac:	42f8      	mov	[X], AL

00007fae <.LM79>:

                /* Callback event */
                swtimer_triggerIrq(index);
    7fae:	7205      	lod	A, [S-6]
    7fb0:	5a03      	mov	[S-4], Y
    7fb2:	17d9      	call	0x7f66 <_swtimer_triggerIrq>

00007fb4 <.LM80>:

                if (g_pTimer[index].bRepetitive != 0u)
    7fb4:	7a03      	lod	Y, [S-4]
    7fb6:	62f1      	lod	AL, [Y+1]
    7fb8:	1d84      	jnn	0x7fc2 <.L32>

00007fba <.LM81>:
                {
                    /* Reload periodic timers */
                    value = g_pTimer[index].u15Load;
    7fba:	72f0      	lod	A, [Y]
    7fbc:	b6da 7fff 	and	A, #32767
    7fc0:	5207      	mov	[S-8], A

00007fc2 <.L32>:
                }
            }

            g_pTimer[index].u15Current = value;
    7fc2:	7205      	lod	A, [S-6]
    7fc4:	44a2      	asl	A, #2
    7fc6:	7ae2      	lod	Y, A
    7fc8:	e2da 11f8 	add	Y, #4600
    7fcc:	7207      	lod	A, [S-8]
    7fce:	d47f      	and	AH, #127
    7fd0:	7ef2      	lod	X, [Y+2]
    7fd2:	36da 8000 	and	X, #32768
    7fd6:	26e2      	or	X, A
    7fd8:	5ef2      	mov	[Y+2], X

00007fda <.L31>:
INTERRUPT void _STIMER_INT(void)
{
    swtimer_enterIrq();

    /* Count-down all the registered SW timers, trigger when 0 is reached */
    for (uint16_t index = 0u; index < (uint16_t)SWTIMER_NR_OF; index++)
    7fda:	7205      	lod	A, [S-6]
    7fdc:	a001      	add	A, #1

00007fde <.LVL53>:
    7fde:	5205      	mov	[S-6], A
    7fe0:	ac0a      	cmp	A, #10
    7fe2:	1d4a      	jne	0x7f78 <.L33>

00007fe4 <.LBE253>:

            g_pTimer[index].u15Current = value;
        }
    }

    swtimer_exitIrq();
    7fe4:	17bf      	call	0x7f64 <_swtimer_exitIrq>

00007fe6 <.LM85>:
}
    7fe6:	5c07      	dec	S, #8

00007fe8 <.LVL55>:
    7fe8:	4cc3      	pop	D

00007fea <.LCFI8>:
    7fea:	72cf      	pop	A

00007fec <.LCFI9>:
    7fec:	7acf      	pop	Y

00007fee <.LCFI10>:
    7fee:	7ecf      	pop	X

00007ff0 <.LCFI11>:
    7ff0:	72cb      	pop	M
    7ff2:	5401      	ret

00007ff4 <__updateCRC8>:
/**
 * @brief Calculate and update CRC8 on one page
 * @param[in]  config  page data
 */
static void _updateCRC8(page_t * config)
{
    7ff4:	5801      	inc	S, #2

00007ff6 <.LCFI0>:
    7ff6:	7ae2      	lod	Y, A

00007ff8 <.LM2>:
    uint16_t u16CRC;

    config->crc8 = (uint16_t)0x00;
    7ff8:	6000      	lod	AL, #0

00007ffa <.LVL1>:
    7ffa:	42f0      	mov	[Y], AL

00007ffc <.LM3>:

    u16CRC = nvram_CalcCRC((void *)config, sizeof(page_t) / sizeof(uint16_t));
    7ffc:	54ca 0004 	pushw	#4

00008000 <.LCFI1>:
    8000:	72e6      	lod	A, Y
    8002:	5a03      	mov	[S-4], Y
    8004:	82db 1540 	callf	0x2a80 <_nvram_CalcCRC>

00008008 <.LM4>:

    config->crc8 = (uint16_t)(0xFFU - u16CRC);
    8008:	bcff      	xor	A, #-1

0000800a <.LVL3>:
    800a:	7a03      	lod	Y, [S-4]
    800c:	42f0      	mov	[Y], AL

0000800e <.LCFI2>:
}
    800e:	5405      	ret	#6

00008010 <_unirom_Init>:
/* ---------------------------------------------
 * Public Functions Implementation
 * --------------------------------------------- */

void unirom_Init(void)
{}
    8010:	5401      	ret

00008012 <_unirom_LoadUserConfig>:

bool unirom_LoadUserConfig(void)
{
    8012:	5803      	inc	S, #4

00008014 <.LBB90>:
}

#ifndef UNITTEST
STATIC INLINE void EEPROM_ClearErrorFlags(void)
{
    IO_SET(EEPROM_FLASH,
    8014:	600f      	lod	AL, #15
    8016:	42d8 0188 	mov	0x188 <.LLST17+0x5>, AL

0000801a <.LBE92>:
        EEPROM_ClearErrorFlags();

        uint16_t eeprom_address = NV_ADDR_PATTERN + (page * sizeof(page_t) / sizeof(uint8_t));

        /* copy one page from EEPROM to RAM */
        memcpy((void*)&l_ramCopy.page[page], (void*)eeprom_address, sizeof(page_t) / sizeof(uint8_t));
    801a:	7eda 10e6 	lod	X, #4326
    801e:	0ea7      	lod	C, ML.7
    8020:	7ada 0840 	lod	Y, #2112
    8024:	0ea7      	lod	C, ML.7
    8026:	54c6      	movsw	[X++], [Y++]
    8028:	54c6      	movsw	[X++], [Y++]
    802a:	54c6      	movsw	[X++], [Y++]
    802c:	54c6      	movsw	[X++], [Y++]

0000802e <.LBB95>:
}
#endif /* UNITTEST */

STATIC INLINE bool EEPROM_GetErrorFlags(void)
{
    return (IO_GET(EEPROM_FLASH, EE_DATA_CORRUPTED_1) != 0u) || (IO_GET(EEPROM_FLASH, EE_DATA_CORRUPTED_2) != 0u);
    802e:	72d8 0188 	lod	A, 0x188 <.LLST17+0x5>
    8032:	9402      	and	AL, #2
    8034:	1924      	je	0x807e <.L4>

00008036 <.L6>:
        }
        else
        {
            if (nvram_CalcCRC((void *)&l_ramCopy.page[page], sizeof(page_t) / sizeof(uint16_t)) != 0xFF)
            {
                retVal = false;  /* CRC error */
    8036:	7000      	lod	A, #0

00008038 <.L12>:
void unirom_Init(void)
{}

bool unirom_LoadUserConfig(void)
{
    bool retVal = true;
    8038:	5201      	mov	[S-2], A

0000803a <.LM14>:
}

#ifndef UNITTEST
STATIC INLINE void EEPROM_ClearErrorFlags(void)
{
    IO_SET(EEPROM_FLASH,
    803a:	600f      	lod	AL, #15

0000803c <.LVL9>:
    803c:	42d8 0188 	mov	0x188 <.LLST17+0x5>, AL

00008040 <.LM15>:
        EEPROM_ClearErrorFlags();

        uint16_t eeprom_address = NV_ADDR_PATTERN + (page * sizeof(page_t) / sizeof(uint8_t));

        /* copy one page from EEPROM to RAM */
        memcpy((void*)&l_ramCopy.page[page], (void*)eeprom_address, sizeof(page_t) / sizeof(uint8_t));
    8040:	7eda 10ee 	lod	X, #4334
    8044:	7ada 0848 	lod	Y, #2120
    8048:	0ea7      	lod	C, ML.7
    804a:	54c6      	movsw	[X++], [Y++]
    804c:	54c6      	movsw	[X++], [Y++]
    804e:	54c6      	movsw	[X++], [Y++]
    8050:	54c6      	movsw	[X++], [Y++]

00008052 <.LM16>:
}
#endif /* UNITTEST */

STATIC INLINE bool EEPROM_GetErrorFlags(void)
{
    return (IO_GET(EEPROM_FLASH, EE_DATA_CORRUPTED_1) != 0u) || (IO_GET(EEPROM_FLASH, EE_DATA_CORRUPTED_2) != 0u);
    8052:	72d8 0188 	lod	A, 0x188 <.LLST17+0x5>
    8056:	9402      	and	AL, #2
    8058:	1d0e      	jne	0x8076 <.L7>
    805a:	72d8 0188 	lod	A, 0x188 <.LLST17+0x5>

0000805e <.LM17>:

        if (EEPROM_GetErrorFlags())
    805e:	9408      	and	AL, #8
    8060:	1d0a      	jne	0x8076 <.L7>

00008062 <.LM18>:
        {
            retVal = false;  /* ECC error */
        }
        else
        {
            if (nvram_CalcCRC((void *)&l_ramCopy.page[page], sizeof(page_t) / sizeof(uint16_t)) != 0xFF)
    8062:	54ca 0004 	pushw	#4

00008066 <.LCFI4>:
    8066:	72da 10ee 	lod	A, #4334
    806a:	82db 1540 	callf	0x2a80 <_nvram_CalcCRC>
    806e:	5c01      	dec	S, #2

00008070 <.LCFI5>:
    8070:	aeda 00ff 	cmp	A, #255
    8074:	1902      	je	0x807a <.L8>

00008076 <.L7>:
            {
                retVal = false;  /* CRC error */
    8076:	7000      	lod	A, #0
    8078:	5201      	mov	[S-2], A

0000807a <.L8>:
            }
        }
    }

    return retVal;
}
    807a:	7201      	lod	A, [S-2]
    807c:	5405      	ret	#6

0000807e <.L4>:
    807e:	72d8 0188 	lod	A, 0x188 <.LLST17+0x5>

00008082 <.LM22>:
        uint16_t eeprom_address = NV_ADDR_PATTERN + (page * sizeof(page_t) / sizeof(uint8_t));

        /* copy one page from EEPROM to RAM */
        memcpy((void*)&l_ramCopy.page[page], (void*)eeprom_address, sizeof(page_t) / sizeof(uint8_t));

        if (EEPROM_GetErrorFlags())
    8082:	9408      	and	AL, #8
    8084:	1d58      	jne	0x8036 <.L6>

00008086 <.LM23>:
        {
            retVal = false;  /* ECC error */
        }
        else
        {
            if (nvram_CalcCRC((void *)&l_ramCopy.page[page], sizeof(page_t) / sizeof(uint16_t)) != 0xFF)
    8086:	54ca 0004 	pushw	#4

0000808a <.LCFI6>:
    808a:	72da 10e6 	lod	A, #4326
    808e:	82db 1540 	callf	0x2a80 <_nvram_CalcCRC>
    8092:	5c01      	dec	S, #2

00008094 <.LCFI7>:
    8094:	aeda 00ff 	cmp	A, #255
    8098:	1d4e      	jne	0x8036 <.L6>

0000809a <.LM24>:
void unirom_Init(void)
{}

bool unirom_LoadUserConfig(void)
{
    bool retVal = true;
    809a:	7001      	lod	A, #1
    809c:	07cd      	jmp	0x8038 <.L12>

0000809e <_unirom_StoreUserConfig>:
    /* store RAM to eeprom */
    return unirom_StoreUserConfig();
}

bool unirom_StoreUserConfig(void)
{
    809e:	5803      	inc	S, #4

000080a0 <.LBB141>:
 * @param[in]  address  page data in EEPROM
 * @retval  true  in case of success
 */
static bool _pageVerify(page_t * config, uint16_t * address)
{
    return (memcmp((void *)config, (void *)address, sizeof(page_t) / sizeof(uint8_t)) == 0);
    80a0:	7eda 10e6 	lod	X, #4326
    80a4:	5e03      	mov	[S-4], X
    80a6:	7ada 0840 	lod	Y, #2112
    80aa:	7000      	lod	A, #0
    80ac:	54e8      	mov	Cx, #8
    80ae:	6ade      	lod	AH, [X++]
    80b0:	cad6      	sub	AH, [Y++]
    80b2:	1d02      	jne	0x80b8 <.L23>
    80b4:	1ffc      	djnz	Cx, 0x80ae <.LASF884+0x8>
    80b6:	0001      	jmp	0x80ba <.L24>

000080b8 <.L23>:
    80b8:	4412      	rrc	A

000080ba <.L24>:
    for (uint8_t page = 0u; page < sizeof(user_pattern_t) / sizeof(page_t); page++)
    {
        uint16_t eeprom_address = NV_ADDR_PATTERN + (page * sizeof(page_t) / sizeof(uint8_t));

        /* Check if EEPROM and RAM copy are not the same */
        if (!_pageVerify(&l_ramCopy.page[page], (uint16_t *)eeprom_address))
    80ba:	ac00      	cmp	A, #0
    80bc:	1911      	je	0x80e0 <.L15>

000080be <.LBB146>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    80be:	7ae3      	lod	Y, M

000080c0 <.LBB150>:
    return 1;
}

STATIC INLINE uint16_t mlx16_di_enter_system_mode(void)
{
    __asm__ __volatile__ (".word OPCODE_CALL_FP_ENTER_SYSTEM_MODE_PRIO_0");
    80c0:	503d      	call	fp1:0xE8

000080c2 <.LBE150>:
        {
            /* write to eeprom page */
            ENTER_SECTION(ATOMIC_SYSTEM_MODE);
            EEPROM_WriteWord64_blocking(eeprom_address, (void *)&l_ramCopy.page[page], EE_WRITE_KEY);
    80c2:	54ca 0007 	pushw	#7

000080c6 <.LCFI9>:
    80c6:	7eda 10e6 	lod	X, #4326
    80ca:	5edf      	push	X

000080cc <.LCFI10>:
    80cc:	72da 0840 	lod	A, #2112
    80d0:	5a05      	mov	[S-6], Y
    80d2:	1126      	call	0x8320 <_EEPROM_WriteWord64_blocking>

000080d4 <.LBB153>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    80d4:	7a05      	lod	Y, [S-6]
    80d6:	5ae3      	mov	M, Y

000080d8 <.LBB163>:
    80d8:	0f7f      	lod	C, io:0x0f.7

000080da <.LBE165>:
}

/** WDG_conditionalAwdRefresh acknowledges the AWD timer if its window is opened */
STATIC INLINE void WDG_conditionalAwdRefresh(void)
{
    if (IO_GET(AWD, WIN_OPEN) != 0u) {
    80da:	5c03      	dec	S, #4

000080dc <.LCFI11>:
    80dc:	1c01      	jnc	0x80e0 <.L15>

000080de <.LM34>:
        IO_SET(AWD, ACK, 1u);
    80de:	0b76      	setb	io:0x0e.6

000080e0 <.L15>:
 * @param[in]  address  page data in EEPROM
 * @retval  true  in case of success
 */
static bool _pageVerify(page_t * config, uint16_t * address)
{
    return (memcmp((void *)config, (void *)address, sizeof(page_t) / sizeof(uint8_t)) == 0);
    80e0:	7eda 10ee 	lod	X, #4334

000080e4 <.LVL24>:
    80e4:	7ada 0848 	lod	Y, #2120
    80e8:	7000      	lod	A, #0
    80ea:	54e8      	mov	Cx, #8
    80ec:	6ade      	lod	AH, [X++]
    80ee:	cad6      	sub	AH, [Y++]
    80f0:	1d02      	jne	0x80f6 <.L26>
    80f2:	1ffc      	djnz	Cx, 0x80ec <.Ldebug_line0+0x6>
    80f4:	0001      	jmp	0x80f8 <.L27>

000080f6 <.L26>:
    80f6:	4412      	rrc	A

000080f8 <.L27>:
    for (uint8_t page = 0u; page < sizeof(user_pattern_t) / sizeof(page_t); page++)
    {
        uint16_t eeprom_address = NV_ADDR_PATTERN + (page * sizeof(page_t) / sizeof(uint8_t));

        /* Check if EEPROM and RAM copy are not the same */
        if (!_pageVerify(&l_ramCopy.page[page], (uint16_t *)eeprom_address))
    80f8:	ac00      	cmp	A, #0
    80fa:	1910      	je	0x811c <.L17>

000080fc <.LM37>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    80fc:	7ae3      	lod	Y, M

000080fe <.LM38>:
    80fe:	503d      	call	fp1:0xE8

00008100 <.LM39>:
        {
            /* write to eeprom page */
            ENTER_SECTION(ATOMIC_SYSTEM_MODE);
            EEPROM_WriteWord64_blocking(eeprom_address, (void *)&l_ramCopy.page[page], EE_WRITE_KEY);
    8100:	54ca 0007 	pushw	#7

00008104 <.LCFI12>:
    8104:	54ca 10ee 	pushw	#4334

00008108 <.LCFI13>:
    8108:	72da 0848 	lod	A, #2120
    810c:	5a05      	mov	[S-6], Y
    810e:	1108      	call	0x8320 <_EEPROM_WriteWord64_blocking>

00008110 <.LM40>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    8110:	7a05      	lod	Y, [S-6]
    8112:	5ae3      	mov	M, Y

00008114 <.LM41>:
    8114:	0f7f      	lod	C, io:0x0f.7

00008116 <.LM42>:
}

/** WDG_conditionalAwdRefresh acknowledges the AWD timer if its window is opened */
STATIC INLINE void WDG_conditionalAwdRefresh(void)
{
    if (IO_GET(AWD, WIN_OPEN) != 0u) {
    8116:	5c03      	dec	S, #4

00008118 <.LCFI14>:
    8118:	1c01      	jnc	0x811c <.L17>

0000811a <.LM43>:
        IO_SET(AWD, ACK, 1u);
    811a:	0b76      	setb	io:0x0e.6

0000811c <.L17>:
            WDG_conditionalAwdRefresh();  /* Restart watchdog */
        }
    }

    return true;
}
    811c:	7001      	lod	A, #1
    811e:	5405      	ret	#6

00008120 <_unirom_ResetUserConfig>:

    return retVal;
}

bool unirom_ResetUserConfig(const user_pattern_t * def_config)
{
    8120:	5801      	inc	S, #2

00008122 <.LCFI15>:
    /* restore ram copy  */
    memcpy((void*)&l_ramCopy, (void*)def_config, sizeof(user_pattern_t) / sizeof(uint8_t));
    8122:	7ada 10e6 	lod	Y, #4326
    8126:	5a01      	mov	[S-2], Y
    8128:	7ee2      	lod	X, A
    812a:	54e0      	mov	Cx, #0
    812c:	54cc      	movsb	[Y++], [X++]
    812e:	1ffe      	djnz	Cx, 0x812c <.LASF898+0x8>

00008130 <.LBB173>:

    /* restore CRC8 of all pages */
    for (uint8_t page = 0u; page < sizeof(user_pattern_t) / sizeof(page_t); page++)
    {
        _updateCRC8(&l_ramCopy.page[page]);
    8130:	72da 10e6 	lod	A, #4326
    8134:	175f      	call	0x7ff4 <__updateCRC8>
    8136:	72da 10ee 	lod	A, #4334
    813a:	175c      	call	0x7ff4 <__updateCRC8>

0000813c <.LBE173>:
    }

    /* store RAM to eeprom */
    return unirom_StoreUserConfig();
    813c:	17b0      	call	0x809e <_unirom_StoreUserConfig>

0000813e <.LM49>:
}
    813e:	5403      	ret	#4

00008140 <_unirom_WritePage>:
    }
    return retVal;
}

bool unirom_WritePage(uint8_t page, uint8_t* data, uint8_t len)
{
    8140:	5809      	inc	S, #10

00008142 <.LCFI24>:
    8142:	660f      	lod	YL, [S-16]
    8144:	5cf6      	usex	Y
    8146:	5a01      	mov	[S-2], Y

00008148 <.LM76>:
    bool retVal = false;

    if (len <= 7u)
    8148:	ec07      	cmp	Y, #7
    814a:	1a01      	jule	0x814e <.LM76+0x6>
    814c:	0031      	jmp	0x81b0 <.L49>
    814e:	44a2      	asl	A, #2
    8150:	4422      	asl	A

00008152 <.LVL59>:
    8152:	5209      	mov	[S-10], A

00008154 <.LM77>:
    {
        if (memcmp((void *)l_ramCopy.page[page].payload, (void *)data, len) != 0)  /* are the new data different ? */
    8154:	a2da 10e7 	add	A, #4327
    8158:	5205      	mov	[S-6], A
    815a:	5207      	mov	[S-8], A

0000815c <.LM78>:
    }
    return retVal;
}

bool unirom_WritePage(uint8_t page, uint8_t* data, uint8_t len)
{
    815c:	7e0d      	lod	X, [S-14]

0000815e <.LM79>:
    bool retVal = false;

    if (len <= 7u)
    {
        if (memcmp((void *)l_ramCopy.page[page].payload, (void *)data, len) != 0)  /* are the new data different ? */
    815e:	ec00      	cmp	Y, #0
    8160:	1927      	je	0x81b0 <.L49>
    8162:	7ae2      	lod	Y, A
    8164:	7201      	lod	A, [S-2]

00008166 <.L61>:
    8166:	52df      	push	A
    8168:	6ad6      	lod	AH, [Y++]
    816a:	cade      	sub	AH, [X++]
    816c:	1d04      	jne	0x8176 <.L62>
    816e:	72cf      	pop	A
    8170:	a801      	sub	A, #1
    8172:	1d79      	jne	0x8166 <.L61>
    8174:	0002      	jmp	0x817a <.L63>

00008176 <.L62>:
    8176:	5c01      	dec	S, #2
    8178:	4412      	rrc	A

0000817a <.L63>:
    817a:	ac00      	cmp	A, #0
    817c:	1919      	je	0x81b0 <.L49>

0000817e <.LM80>:
        {
            memcpy((void*)&l_ramCopy.page[page].payload[0], (void *)data, len);  /* write the data to the ram copy */
    817e:	7e0d      	lod	X, [S-14]
    8180:	72ee      	lod	A, X
    8182:	a201      	add	A, [S-2]
    8184:	7a05      	lod	Y, [S-6]
    8186:	0ea7      	lod	C, ML.7

00008188 <.L64>:
    8188:	54cc      	movsb	[Y++], [X++]
    818a:	2ee2      	cmp	X, A
    818c:	1d7d      	jne	0x8188 <.L64>

0000818e <.LM81>:
            memset((void*)&l_ramCopy.page[page].payload[len], 0, 7u - len);  /* clear non-used data with 0 */
    818e:	7c07      	lod	X, #7
    8190:	2a01      	sub	X, [S-2]
    8192:	7a01      	lod	Y, [S-2]
    8194:	e209      	add	Y, [S-10]
    8196:	e2da 10e7 	add	Y, #4327
    819a:	2c00      	cmp	X, #0
    819c:	1903      	je	0x81a4 <.L47>
    819e:	6000      	lod	AL, #0
    81a0:	42d6      	mov	[Y++], AL

000081a2 <L0>:
    81a2:	1bfe      	djnz	X, 0x81a0 <.LM81+0x12>

000081a4 <.L47>:

            _updateCRC8(&l_ramCopy.page[page]);  /* update CRC8 of that page */
    81a4:	7209      	lod	A, [S-10]
    81a6:	a2da 10e6 	add	A, #4326
    81aa:	1724      	call	0x7ff4 <__updateCRC8>

000081ac <.LM83>:

            retVal = true;
    81ac:	7001      	lod	A, #1
    81ae:	540b      	ret	#12

000081b0 <.L49>:
    return retVal;
}

bool unirom_WritePage(uint8_t page, uint8_t* data, uint8_t len)
{
    bool retVal = false;
    81b0:	7000      	lod	A, #0

000081b2 <.LM85>:
            retVal = true;
        }
    }

    return retVal;
}
    81b2:	540b      	ret	#12

000081b4 <_unirom_ReadPage>:

bool unirom_ReadPage(uint8_t page, uint8_t* data, uint8_t len)
{
    81b4:	5805      	inc	S, #6

000081b6 <.LCFI25>:
    81b6:	660b      	lod	YL, [S-12]
    81b8:	5cf6      	usex	Y

000081ba <.LM87>:
    bool retVal = false;

    if (len <= 7u)
    81ba:	ec07      	cmp	Y, #7
    81bc:	1a02      	jule	0x81c2 <.L66>

000081be <.L68>:
    return retVal;
}

bool unirom_ReadPage(uint8_t page, uint8_t* data, uint8_t len)
{
    bool retVal = false;
    81be:	7000      	lod	A, #0
    81c0:	5407      	ret	#8

000081c2 <.L66>:
    81c2:	44a2      	asl	A, #2
    81c4:	4422      	asl	A

000081c6 <.LVL67>:
    81c6:	5205      	mov	[S-6], A

000081c8 <.LM89>:

    if (len <= 7u)
    {
        if (nvram_CalcCRC((void*)&l_ramCopy.page[page], sizeof(page_t) / sizeof(uint16_t)) == 0xFF)  /* check crc of the page */
    81c8:	a2da 10e6 	add	A, #4326
    81cc:	54ca 0004 	pushw	#4

000081d0 <.LCFI26>:
    81d0:	5a05      	mov	[S-6], Y
    81d2:	82db 1540 	callf	0x2a80 <_nvram_CalcCRC>
    81d6:	5c01      	dec	S, #2

000081d8 <.LCFI27>:
    81d8:	7a03      	lod	Y, [S-4]
    81da:	aeda 00ff 	cmp	A, #255
    81de:	1d6f      	jne	0x81be <.L68>

000081e0 <.LM90>:
        {
            memcpy((void*)data, (void *)l_ramCopy.page[page].payload, len);  /* read from ram copy */
    81e0:	7205      	lod	A, [S-6]
    81e2:	a2da 10e7 	add	A, #4327
    81e6:	ec00      	cmp	Y, #0
    81e8:	190a      	je	0x81fe <.L69>
    81ea:	7e09      	lod	X, [S-10]
    81ec:	5e05      	mov	[S-6], X
    81ee:	7ee2      	lod	X, A
    81f0:	e2e2      	add	Y, A
    81f2:	72e6      	lod	A, Y
    81f4:	7a05      	lod	Y, [S-6]
    81f6:	0ea7      	lod	C, ML.7

000081f8 <.L73>:
    81f8:	54cc      	movsb	[Y++], [X++]
    81fa:	2ee2      	cmp	X, A
    81fc:	1d7d      	jne	0x81f8 <.L73>

000081fe <.L69>:

            retVal = true;
    81fe:	7001      	lod	A, #1

00008200 <.LM92>:
        }
    }
    return retVal;
}
    8200:	5407      	ret	#8

00008202 <_CalculateTemperature3pLinearize>:
    8202:	7ed8 09b0 	lod	X, 0x9b0 <.LASF2082+0x6>
    8206:	54e4      	mov	Cx, #4
    8208:	44fe      	asr	X, #2
    820a:	1ffe      	djnz	Cx, 0x8208 <_CalculateTemperature3pLinearize+0x6>

0000820c <.LM3>:
    820c:	7ad8 09b4 	lod	Y, 0x9b4 <.LASF2082+0xa>
    8210:	eae2      	sub	Y, A
    8212:	72e6      	lod	A, Y

00008214 <.LVL2>:
    8214:	7ad8 09b8 	lod	Y, 0x9b8 <.LASF2082+0xe>

00008218 <.LM4>:
    8218:	ac00      	cmp	A, #0
    821a:	1e93      	jsge	0x8242 <.L2>

0000821c <.LBB6>:
    821c:	5cf6      	usex	Y

0000821e <.L8>:
    821e:	4831      	muls	YA, A, Y

00008220 <.LBE8>:
    8220:	4cb2 0000 	cmp	YA, #0
    8224:	0000 
    8226:	1e84      	jsge	0x8230 <.L5>
    8228:	4cc0      	mov	D, YA
    822a:	4c0a 007f 	addu	D, #127
    822e:	4c80      	mov	YA, D

00008230 <.L5>:
    8230:	48b6      	asr	YA, #7

00008232 <.LM8>:
    8232:	2c00      	cmp	X, #0
    8234:	1d04      	jne	0x823e <.L6>

00008236 <.LM9>:
    8236:	66d8 09b6 	lod	YL, 0x9b6 <.LASF2082+0xc>
    823a:	5ce6      	ssex	Y
    823c:	7ee6      	lod	X, Y

0000823e <.L6>:
    823e:	a2ee      	add	A, X

00008240 <.LM11>:
    8240:	5401      	ret

00008242 <.L2>:
    8242:	6400      	lod	YL, #0
    8244:	7ae8      	swap	Y

00008246 <.LVL10>:
    8246:	07eb      	jmp	0x821e <.L8>

00008248 <_SetSystemSpeed>:
    8248:	5801      	inc	S, #2

0000824a <.LCFI0>:
    824a:	7ee2      	lod	X, A

0000824c <.LM2>:
    824c:	62d8 0180 	lod	AL, 0x180 <_EEPROM_FLASH+0xa>

00008250 <.LVL1>:
    8250:	8407      	or	AL, #7
    8252:	42d8 0180 	mov	0x180 <_EEPROM_FLASH+0xa>, AL

00008256 <.LM3>:
    8256:	62d8 0191 	lod	AL, 0x191 <.Lframe0+0x1>
    825a:	840f      	or	AL, #15
    825c:	42d8 0191 	mov	0x191 <.Lframe0+0x1>, AL

00008260 <.LBB118>:
    8260:	7ad8 01cc 	lod	Y, 0x1cc <_TRIM_RCO32M>

00008264 <.LBE118>:
    8264:	72ee      	lod	A, X
    8266:	b6da 03ff 	and	A, #1023

0000826a <.LM6>:
    826a:	f6da fc00 	and	Y, #64512
    826e:	a6e6      	or	A, Y
    8270:	52d8 01cc 	mov	0x1cc <_TRIM_RCO32M>, A

00008274 <.LM7>:
    8274:	6205      	lod	AL, [S-6]
    8276:	42d8 0200 	mov	0x200 <_PORT_CLOCK_CTRL>, AL

0000827a <.LM8>:
    827a:	7aee      	lod	Y, X
    827c:	7ae8      	swap	Y
    827e:	44b6      	lsr	Y, #2
    8280:	f403      	and	Y, #3
    8282:	e004      	add	Y, #4

00008284 <.LM9>:
    8284:	5cf2      	usex	A
    8286:	5201      	mov	[S-2], A
    8288:	6205      	lod	AL, [S-6]
    828a:	1904      	je	0x8294 <.L2>

0000828c <.LM10>:
    828c:	72ee      	lod	A, X
    828e:	d480      	and	AH, #-128
    8290:	5ca2      	sne	A
    8292:	eae2      	sub	Y, A

00008294 <.L2>:
    8294:	62d8 0191 	lod	AL, 0x191 <.Lframe0+0x1>
    8298:	94f0      	and	AL, #-16
    829a:	86e8      	or	AL, YL
    829c:	42d8 0191 	mov	0x191 <.Lframe0+0x1>, AL

000082a0 <.LM12>:
    82a0:	7aee      	lod	Y, X

000082a2 <.LVL6>:
    82a2:	7ae8      	swap	Y
    82a4:	44b6      	lsr	Y, #2
    82a6:	44b6      	lsr	Y, #2
    82a8:	f403      	and	Y, #3
    82aa:	e001      	add	Y, #1

000082ac <.LM13>:
    82ac:	7201      	lod	A, [S-2]
    82ae:	1906      	je	0x82bc <.L3>

000082b0 <.LM14>:
    82b0:	36da 4000 	and	X, #16384

000082b4 <.LVL8>:
    82b4:	5cae      	sne	X
    82b6:	eaee      	sub	Y, X

000082b8 <.LM15>:
    82b8:	1d01      	jne	0x82bc <.L3>

000082ba <.LM16>:
    82ba:	7801      	lod	Y, #1

000082bc <.L3>:
    82bc:	62d8 0180 	lod	AL, 0x180 <_EEPROM_FLASH+0xa>
    82c0:	94f8      	and	AL, #-8
    82c2:	86e8      	or	AL, YL
    82c4:	42d8 0180 	mov	0x180 <_EEPROM_FLASH+0xa>, AL

000082c8 <.LM18>:
    82c8:	5403      	ret	#4

000082ca <_EEPROM_BusyChecks>:
    82ca:	72d8 0186 	lod	A, 0x186 <.LLST17+0x3>
    82ce:	d440      	and	AH, #64
    82d0:	1906      	je	0x82de <.L2>

000082d2 <.LM3>:
    82d2:	62d8 0186 	lod	AL, 0x186 <.LLST17+0x3>
    82d6:	8401      	or	AL, #1

000082d8 <.L7>:
    82d8:	42d8 0186 	mov	0x186 <.LLST17+0x3>, AL

000082dc <.L1>:
    82dc:	5401      	ret

000082de <.L2>:
    82de:	72d8 0186 	lod	A, 0x186 <.LLST17+0x3>
    82e2:	d410      	and	AH, #16
    82e4:	197b      	je	0x82dc <.L1>

000082e6 <.LM7>:
    82e6:	62d8 0186 	lod	AL, 0x186 <.LLST17+0x3>
    82ea:	940f      	and	AL, #15
    82ec:	07f5      	jmp	0x82d8 <.L7>

000082ee <_EEPROM_WriteWord64_non_blocking>:
    82ee:	5801      	inc	S, #2

000082f0 <.LCFI0>:
    82f0:	7ae2      	lod	Y, A

000082f2 <.LM35>:
    82f2:	62d8 0186 	lod	AL, 0x186 <.LLST17+0x3>

000082f6 <.LVL6>:
    82f6:	940f      	and	AL, #15
    82f8:	4200      	mov	[S-1], AL
    82fa:	6207      	lod	AL, [S-8]
    82fc:	44a0      	asl	AL, #2
    82fe:	44a0      	asl	AL, #2
    8300:	4201      	mov	[S-2], AL
    8302:	6200      	lod	AL, [S-1]
    8304:	8601      	or	AL, [S-2]
    8306:	42d8 0186 	mov	0x186 <.LLST17+0x3>, AL

0000830a <.LM36>:
    830a:	6000      	lod	AL, #0
    830c:	42d8 0187 	mov	0x187 <.LLST17+0x4>, AL

00008310 <.LM37>:
    8310:	7e05      	lod	X, [S-6]

00008312 <.LBB282>:
    8312:	72ee      	lod	A, X
    8314:	a008      	add	A, #8
    8316:	0ea7      	lod	C, ML.7

00008318 <.L17>:
    8318:	54ce      	movsw	[Y++], [X++]
    831a:	2ee2      	cmp	X, A
    831c:	1d7d      	jne	0x8318 <.L17>

0000831e <.LBE282>:
    831e:	5403      	ret	#4

00008320 <_EEPROM_WriteWord64_blocking>:
    8320:	5801      	inc	S, #2

00008322 <.LCFI1>:
    8322:	7ed8 0186 	lod	X, 0x186 <.LLST17+0x3>

00008326 <.L24>:
    8326:	2c00      	cmp	X, #0
    8328:	1e86      	jsge	0x8336 <.L19>

0000832a <.LM42>:
    832a:	5201      	mov	[S-2], A
    832c:	17ce      	call	0x82ca <_EEPROM_BusyChecks>

0000832e <.LM43>:
    832e:	7ed8 0186 	lod	X, 0x186 <.LLST17+0x3>
    8332:	7201      	lod	A, [S-2]
    8334:	07f8      	jmp	0x8326 <.L24>

00008336 <.L19>:
    8336:	7e07      	lod	X, [S-8]

00008338 <.LM45>:
    8338:	5edf      	push	X

0000833a <.LCFI2>:
    833a:	7e07      	lod	X, [S-8]

0000833c <.LM47>:
    833c:	5edf      	push	X

0000833e <.LCFI3>:
    833e:	17d7      	call	0x82ee <_EEPROM_WriteWord64_non_blocking>

00008340 <.LM48>:
    8340:	5c03      	dec	S, #4

00008342 <.L21>:
    8342:	72d8 0186 	lod	A, 0x186 <.LLST17+0x3>
    8346:	d420      	and	AH, #32
    8348:	1d7c      	jne	0x8342 <.L21>

0000834a <.LM50>:
    834a:	5403      	ret	#4

0000834c <_VERSION_getFwAppVersion>:
    834c:	72d8 d7ee 	lod	A, 0xd7ee <__fw_app_version_start+0x2>
    8350:	72e4      	swap	A

00008352 <.LVL1>:
    8352:	7ad8 d7ec 	lod	Y, 0xd7ec <__fw_app_version_start>
    8356:	7ae8      	swap	Y

00008358 <.LM3>:
    8358:	5401      	ret

0000835a <_gpio_configureOutput>:
    835a:	5803      	inc	S, #4

0000835c <.LCFI0>:
    835c:	5201      	mov	[S-2], A

0000835e <.LM2>:
    835e:	ac03      	cmp	A, #3
    8360:	1e24      	jug	0x83aa <.L5>

00008362 <.LM3>:
    8362:	72d8 01ea 	lod	A, 0x1ea <_PORT_IO_CFG0>

00008366 <.LVL2>:
    8366:	5203      	mov	[S-4], A

00008368 <.LM4>:
    8368:	7c0f      	lod	X, #15
    836a:	7201      	lod	A, [S-2]

0000836c <.LVL4>:
    836c:	44a2      	asl	A, #2
    836e:	7ae2      	lod	Y, A
    8370:	ac00      	cmp	A, #0
    8372:	1b03      	jsle	0x837a <.L6>
    8374:	42e9      	mov	Cx, AL
    8376:	442e      	asl	X
    8378:	1ffe      	djnz	Cx, 0x8376 <.LVL4+0xa>

0000837a <.L6>:
    837a:	3cff      	xor	X, #-1
    837c:	3603      	and	X, [S-4]

0000837e <.LM5>:
    837e:	7207      	lod	A, [S-8]
    8380:	ec00      	cmp	Y, #0
    8382:	1b03      	jsle	0x838a <.L8>
    8384:	46e9      	mov	Cx, YL
    8386:	4422      	asl	A
    8388:	1ffe      	djnz	Cx, 0x8386 <.LASF1991>

0000838a <.L8>:
    838a:	26e2      	or	X, A

0000838c <.LM6>:
    838c:	5ed8 01ea 	mov	0x1ea <_PORT_IO_CFG0>, X

00008390 <.LM7>:
    8390:	7ed8 023a 	lod	X, 0x23a <_PORT_IO_ENABLE>

00008394 <.LVL7>:
    8394:	7201      	lod	A, [S-2]
    8396:	ac0f      	cmp	A, #15
    8398:	1e06      	jug	0x83a6 <.L3>
    839a:	44e2      	sfb	A

0000839c <.L4>:
    839c:	a6ee      	or	A, X
    839e:	52d8 023a 	mov	0x23a <_PORT_IO_ENABLE>, A

000083a2 <.LM8>:
    83a2:	7001      	lod	A, #1
    83a4:	5405      	ret	#6

000083a6 <.L3>:
    83a6:	7000      	lod	A, #0

000083a8 <.LVL10>:
    83a8:	07f9      	jmp	0x839c <.L4>

000083aa <.L5>:
    83aa:	7000      	lod	A, #0

000083ac <.LM11>:
    83ac:	5405      	ret	#6

000083ae <_softio_configureOutput>:
    83ae:	54ca 0007 	pushw	#7

000083b2 <.LCFI0>:
    83b2:	17d3      	call	0x835a <_gpio_configureOutput>

000083b4 <.LCFI1>:
    83b4:	5403      	ret	#4

000083b6 <_ldt_Tick>:
    83b6:	5809      	inc	S, #10

000083b8 <.LCFI35>:
    83b8:	5207      	mov	[S-8], A
    83ba:	620d      	lod	AL, [S-14]

000083bc <.LVL114>:
    83bc:	5cf2      	usex	A
    83be:	5209      	mov	[S-10], A

000083c0 <.LBB60>:
    83c0:	7ad8 1000 	lod	Y, 0x1000 <_ldtMe>
    83c4:	7ee6      	lod	X, Y
    83c6:	200c      	add	X, #12
    83c8:	5e03      	mov	[S-4], X
    83ca:	62f8      	lod	AL, [X]
    83cc:	1906      	je	0x83da <.L86>

000083ce <.LM190>:
    83ce:	6064      	lod	AL, #100
    83d0:	20fd      	add	X, #-3
    83d2:	42f8      	mov	[X], AL

000083d4 <.LM191>:
    83d4:	6000      	lod	AL, #0
    83d6:	7e03      	lod	X, [S-4]
    83d8:	42f8      	mov	[X], AL

000083da <.L86>:
    83da:	7ee6      	lod	X, Y
    83dc:	2009      	add	X, #9
    83de:	62f8      	lod	AL, [X]
    83e0:	4203      	mov	[S-4], AL
    83e2:	5cf2      	usex	A
    83e4:	5205      	mov	[S-6], A
    83e6:	7207      	lod	A, [S-8]
    83e8:	ae05      	cmp	A, [S-6]
    83ea:	1c17      	jnc	0x841a <.L87>

000083ec <.LM193>:
    83ec:	6203      	lod	AL, [S-4]
    83ee:	8a07      	sub	AL, [S-8]

000083f0 <.L98>:
    83f0:	42f8      	mov	[X], AL

000083f2 <.LBB63>:
    83f2:	7ee6      	lod	X, Y
    83f4:	200d      	add	X, #13
    83f6:	e00a      	add	Y, #10
    83f8:	62f8      	lod	AL, [X]
    83fa:	1904      	je	0x8404 <.L89>

000083fc <.LM196>:
    83fc:	6064      	lod	AL, #100
    83fe:	42f0      	mov	[Y], AL

00008400 <.LM197>:
    8400:	6000      	lod	AL, #0
    8402:	42f8      	mov	[X], AL

00008404 <.L89>:
    8404:	62f0      	lod	AL, [Y]
    8406:	4205      	mov	[S-6], AL
    8408:	5cf2      	usex	A
    840a:	7ee2      	lod	X, A
    840c:	7209      	lod	A, [S-10]
    840e:	aeee      	cmp	A, X
    8410:	1c06      	jnc	0x841e <.L90>

00008412 <.LM199>:
    8412:	6205      	lod	AL, [S-6]
    8414:	8a0d      	sub	AL, [S-14]

00008416 <.L99>:
    8416:	42f0      	mov	[Y], AL

00008418 <.LBE63>:
    8418:	540b      	ret	#12

0000841a <.L87>:
    841a:	6000      	lod	AL, #0
    841c:	07e9      	jmp	0x83f0 <.L98>

0000841e <.L90>:
    841e:	6000      	lod	AL, #0
    8420:	07fa      	jmp	0x8416 <.L99>

00008422 <_ml_GetProtectedID>:
    8422:	62d8 0e47 	lod	AL, 0xe47 <_LinProtectedID>
    8426:	5cf2      	usex	A

00008428 <.LM11>:
    8428:	5401      	ret

0000842a <_ml_SetFixedBaudRate>:
    842a:	5801      	inc	S, #2

0000842c <.LCFI1>:
    842c:	7ee2      	lod	X, A

0000842e <.LM24>:
    842e:	a2da fc18 	add	A, #64536

00008432 <.LVL18>:
    8432:	aeda 4a38 	cmp	A, #19000
    8436:	1e22      	jug	0x847c <.L16>

00008438 <.LM25>:
    8438:	7205      	lod	A, [S-6]

0000843a <.LBB36>:
    843a:	4822 2710 	mulu	YA, A, #10000

0000843e <.LVL21>:
    843e:	442e      	asl	X

00008440 <.LBB38>:
    8440:	4c63      	divu	YA, X
    8442:	4c63      	divu	YA, X
    8444:	7ae2      	lod	Y, A

00008446 <.LBE38>:
    8446:	7000      	lod	A, #0

00008448 <.LVL24>:
    8448:	5201      	mov	[S-2], A
    844a:	7c0c      	lod	X, #12

0000844c <.L15>:
    844c:	72e6      	lod	A, Y
    844e:	a2da fc27 	add	A, #64551
    8452:	aeda 03fb 	cmp	A, #1019
    8456:	1e0c      	jug	0x8470 <.L14>

00008458 <.LM30>:
    8458:	a2da 03de 	add	A, #990
    845c:	4cf2      	usex	YA

0000845e <.LBB40>:
    845e:	7c0a      	lod	X, #10
    8460:	4c63      	divu	YA, X
    8462:	4c63      	divu	YA, X

00008464 <.LBE40>:
    8464:	5cf2      	usex	A

00008466 <.LVL28>:
    8466:	52df      	push	A

00008468 <.LCFI2>:
    8468:	7203      	lod	A, [S-4]
    846a:	82db 11b4 	callf	0x2368 <_ml_SetBaudRate>

0000846e <.LCFI3>:
    846e:	5405      	ret	#6

00008470 <.L14>:
    8470:	4436      	lsr	Y

00008472 <.LM34>:
    8472:	6201      	lod	AL, [S-2]
    8474:	8001      	add	AL, #1
    8476:	5cf2      	usex	A
    8478:	5201      	mov	[S-2], A

0000847a <.LVL34>:
    847a:	1be8      	djnz	X, 0x844c <.L15>

0000847c <.L16>:
    847c:	7001      	lod	A, #1

0000847e <.LM36>:
    847e:	5403      	ret	#4

00008480 <_ml_Init>:
    8480:	5801      	inc	S, #2

00008482 <.LCFI4>:
    8482:	5201      	mov	[S-2], A
    8484:	82db 1fa9 	callf	0x3f52 <_ml_InitLinModule>

00008488 <.LM39>:
    8488:	7a01      	lod	Y, [S-2]
    848a:	ac00      	cmp	A, #0
    848c:	1d29      	jne	0x84e0 <.L18>

0000848e <.LM40>:
    848e:	7e07      	lod	X, [S-8]

00008490 <.LM41>:
    8490:	5edf      	push	X

00008492 <.LCFI5>:
    8492:	52df      	push	A

00008494 <.LCFI6>:
    8494:	54ca 0001 	pushw	#1

00008498 <.LCFI7>:
    8498:	52df      	push	A

0000849a <.LCFI8>:
    849a:	7001      	lod	A, #1

0000849c <.LVL38>:
    849c:	5a09      	mov	[S-10], Y
    849e:	82db 115d 	callf	0x22ba <_ml_SetOptions>

000084a2 <.LM42>:
    84a2:	5c07      	dec	S, #8

000084a4 <.LCFI9>:
    84a4:	7a01      	lod	Y, [S-2]
    84a6:	ac00      	cmp	A, #0
    84a8:	1d1b      	jne	0x84e0 <.L18>

000084aa <.LM43>:
    84aa:	ec01      	cmp	Y, #1
    84ac:	1d0c      	jne	0x84c6 <.L20>

000084ae <.L26>:
    84ae:	82db 11ba 	callf	0x2374 <_ml_SetAutoBaudRateMode>

000084b2 <.L21>:
    84b2:	ac00      	cmp	A, #0
    84b4:	1d15      	jne	0x84e0 <.L18>

000084b6 <.LM46>:
    84b6:	7205      	lod	A, [S-6]

000084b8 <.LM47>:
    84b8:	aeda 3a98 	cmp	A, #15000
    84bc:	5c80      	sc	A
    84be:	4422      	asl	A
    84c0:	82db 1151 	callf	0x22a2 <_ml_SetSlewRate>

000084c4 <.LVL43>:
    84c4:	5403      	ret	#4

000084c6 <.L20>:
    84c6:	ec02      	cmp	Y, #2
    84c8:	1d02      	jne	0x84ce <.L22>

000084ca <.LM49>:
    84ca:	7001      	lod	A, #1

000084cc <.LVL44>:
    84cc:	07f0      	jmp	0x84ae <.L26>

000084ce <.L22>:
    84ce:	ec00      	cmp	Y, #0
    84d0:	1d06      	jne	0x84de <.L24>

000084d2 <.LM51>:
    84d2:	7209      	lod	A, [S-10]

000084d4 <.LM52>:
    84d4:	52df      	push	A

000084d6 <.LCFI10>:
    84d6:	7207      	lod	A, [S-8]
    84d8:	17a8      	call	0x842a <_ml_SetFixedBaudRate>

000084da <.LVL47>:
    84da:	5c01      	dec	S, #2

000084dc <.LCFI11>:
    84dc:	07ea      	jmp	0x84b2 <.L21>

000084de <.L24>:
    84de:	7001      	lod	A, #1

000084e0 <.L18>:
    84e0:	5403      	ret	#4
