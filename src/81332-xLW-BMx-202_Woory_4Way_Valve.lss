mlx16-gcc (Melexis Mlx16-GCC v3.1.115.15) 7.5.0
Copyright (C) 2017 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


81332-xLW-BMx-202_Woory_4Way_Valve.elf:     file format elf32-mlx16-fx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .fw_vectors   00000240  00005800  00005800  00000194  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .mlx4_cst_tables_ram 0000005e  00000e80  00005a40  000003d4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .mlx4_par_tables_ram 00000088  00000f00  00005a9e  00000432  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .lin_ram_flash 00000012  00001000  00001000  00000194  2**0
                  ALLOC
  4 .dp.data      00000008  00001012  00005b26  000004ba  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000090  0000101a  00005b2e  000004c2  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000380  000010aa  00005bbe  00000552  2**1
                  ALLOC
  7 .flash_data   0000481a  00005bbe  00005bbe  00000552  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .flash_fill   0000340c  0000a3d8  0000a3d8  00004d6c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .fw_product_id 00000008  0000d7e4  0000d7e4  00008178  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 10 .fw_app_version 00000004  0000d7ec  0000d7ec  00008180  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 11 .fw_pltf_version 00000004  0000d7f0  0000d7f0  00008184  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 12 .fw_prot_key  00000008  0000d7f4  0000d7f4  00008188  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 13 .flash_crc    00000004  0000d7fc  0000d7fc  00008190  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 14 .debug_frame  00002134  00000000  00000000  00008194  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_info   00083597  00000000  00000000  0000a2c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_abbrev 000065ad  00000000  00000000  0008d85f  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    00005340  00000000  00000000  00093e0c  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_aranges 00000d88  00000000  00000000  0009914c  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_line   0000d58b  00000000  00000000  00099ed4  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_str    0000f1ec  00000000  00000000  000a745f  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .comment      00000055  00000000  00000000  000b664b  2**0
                  CONTENTS, READONLY

Disassembly of section .fw_vectors:

00005800 <__fw_vectors>:
 * @return  void
 */
void l_ifc_wake_up_sl1 (void)
{
    (void)ml_WakeUp();
}
    5800:	54f0      	mov	UPr, #0
 */
void protection_Start(void)
{
    g_e8ShortOcc = C_ERR_SHORT_NO;
    diagnostic_Start();
}
    5802:	76da 45f9 	jmpf	0x8bf2 <_fw_start>
    5806:	a255      	add	A, [S-86]
    5808:	54f8      	mov	UPr, #8
    580a:	76da 1b23 	jmpf	0x3646 <__fatal>
    580e:	0000      	nop
    5810:	54f8      	mov	UPr, #8
    5812:	76da 1b23 	jmpf	0x3646 <__fatal>
    5816:	0000      	nop
    5818:	54f8      	mov	UPr, #8
    581a:	76da 1b23 	jmpf	0x3646 <__fatal>
    581e:	0000      	nop
    5820:	54f8      	mov	UPr, #8
    5822:	76da 1b23 	jmpf	0x3646 <__fatal>
    5826:	0100      	jmp	0x5a28 <.LASF768+0x7>
    5828:	54f8      	mov	UPr, #8
    582a:	76da 1b23 	jmpf	0x3646 <__fatal>
    582e:	0000      	nop
    5830:	54f0      	mov	UPr, #0
    5832:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5836:	0000      	nop
    5838:	54f0      	mov	UPr, #0
    583a:	76da 4406 	jmpf	0x880c <_Generic_INT>
    583e:	0000      	nop
    5840:	54f0      	mov	UPr, #0
    5842:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5846:	0000      	nop
    5848:	54f0      	mov	UPr, #0
    584a:	76da 4406 	jmpf	0x880c <_Generic_INT>
    584e:	0000      	nop
    5850:	54f0      	mov	UPr, #0
    5852:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5856:	0000      	nop
    5858:	54f0      	mov	UPr, #0
    585a:	76da 4406 	jmpf	0x880c <_Generic_INT>
    585e:	0000      	nop
    5860:	54f0      	mov	UPr, #0
    5862:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5866:	0000      	nop
    5868:	54f0      	mov	UPr, #0
    586a:	76da 42f9 	jmpf	0x85f2 <__UV_VS_INT>
    586e:	0000      	nop
    5870:	54f0      	mov	UPr, #0
    5872:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5876:	0000      	nop
    5878:	54f1      	mov	UPr, #1
    587a:	76da 4406 	jmpf	0x880c <_Generic_INT>
    587e:	0000      	nop
    5880:	54f1      	mov	UPr, #1
    5882:	76da 4313 	jmpf	0x8626 <__OVT_INT>
    5886:	0000      	nop
    5888:	54f1      	mov	UPr, #1
    588a:	76da 431c 	jmpf	0x8638 <__OVC_INT>
    588e:	0000      	nop
    5890:	54f1      	mov	UPr, #1
    5892:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5896:	0000      	nop
    5898:	54f1      	mov	UPr, #1
    589a:	76da 4406 	jmpf	0x880c <_Generic_INT>
    589e:	0000      	nop
    58a0:	54f1      	mov	UPr, #1
    58a2:	76da 4406 	jmpf	0x880c <_Generic_INT>
    58a6:	0000      	nop
    58a8:	54f1      	mov	UPr, #1
    58aa:	76da 4406 	jmpf	0x880c <_Generic_INT>
    58ae:	0000      	nop
    58b0:	54f1      	mov	UPr, #1
    58b2:	76da 4406 	jmpf	0x880c <_Generic_INT>
    58b6:	0000      	nop
    58b8:	54f1      	mov	UPr, #1
    58ba:	76da 4406 	jmpf	0x880c <_Generic_INT>
    58be:	0000      	nop
    58c0:	54f1      	mov	UPr, #1
    58c2:	76da 4406 	jmpf	0x880c <_Generic_INT>
    58c6:	0000      	nop
    58c8:	54f1      	mov	UPr, #1
    58ca:	76da 4406 	jmpf	0x880c <_Generic_INT>
    58ce:	0000      	nop
    58d0:	54f5      	mov	UPr, #5
    58d2:	76da 4de7 	jmpf	0x9bce <__STIMER_INT>
    58d6:	0000      	nop
    58d8:	54f2      	mov	UPr, #2
    58da:	76da 4406 	jmpf	0x880c <_Generic_INT>
    58de:	0000      	nop
    58e0:	54f2      	mov	UPr, #2
    58e2:	76da 4406 	jmpf	0x880c <_Generic_INT>
    58e6:	0000      	nop
    58e8:	54f2      	mov	UPr, #2
    58ea:	76da 4bbb 	jmpf	0x9776 <__CTIMER0_3_INT>
    58ee:	0000      	nop
    58f0:	54f2      	mov	UPr, #2
    58f2:	76da 4406 	jmpf	0x880c <_Generic_INT>
    58f6:	0000      	nop
    58f8:	54f2      	mov	UPr, #2
    58fa:	76da 4406 	jmpf	0x880c <_Generic_INT>
    58fe:	0000      	nop
    5900:	54f2      	mov	UPr, #2
    5902:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5906:	0000      	nop
    5908:	54f2      	mov	UPr, #2
    590a:	76da 4406 	jmpf	0x880c <_Generic_INT>
    590e:	0000      	nop
    5910:	54f2      	mov	UPr, #2
    5912:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5916:	0000      	nop
    5918:	54f2      	mov	UPr, #2
    591a:	76da 4406 	jmpf	0x880c <_Generic_INT>
    591e:	0000      	nop
    5920:	54f2      	mov	UPr, #2
    5922:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5926:	0000      	nop
    5928:	54f2      	mov	UPr, #2
    592a:	76da 4d46 	jmpf	0x9a8c <__PWM_MASTER1_END_INT>
    592e:	0000      	nop
    5930:	54f2      	mov	UPr, #2
    5932:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5936:	0000      	nop
    5938:	54f2      	mov	UPr, #2
    593a:	76da 4d5c 	jmpf	0x9ab8 <__PWM_SLAVE2_CMP_INT>
    593e:	0000      	nop
    5940:	54f2      	mov	UPr, #2
    5942:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5946:	0000      	nop
    5948:	54f2      	mov	UPr, #2
    594a:	76da 4406 	jmpf	0x880c <_Generic_INT>
    594e:	0000      	nop
    5950:	54f2      	mov	UPr, #2
    5952:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5956:	0000      	nop
    5958:	54f3      	mov	UPr, #3
    595a:	76da 3ba1 	jmpf	0x7742 <__ADC_SAR_INT>
    595e:	0000      	nop
    5960:	54f2      	mov	UPr, #2
    5962:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5966:	0000      	nop
    5968:	54f2      	mov	UPr, #2
    596a:	76da 4406 	jmpf	0x880c <_Generic_INT>
    596e:	0000      	nop
    5970:	54f2      	mov	UPr, #2
    5972:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5976:	0000      	nop
    5978:	54f4      	mov	UPr, #4
    597a:	76da 447e 	jmpf	0x88fc <__COLIN_LIN_INT>
    597e:	0000      	nop
    5980:	54f2      	mov	UPr, #2
    5982:	76da 430a 	jmpf	0x8614 <__OV_VS_INT>
    5986:	0000      	nop
    5988:	54f2      	mov	UPr, #2
    598a:	76da 4d5e 	jmpf	0x9abc <__DIAG_INT>
    598e:	0000      	nop
    5990:	54f2      	mov	UPr, #2
    5992:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5996:	0000      	nop
    5998:	54f2      	mov	UPr, #2
    599a:	76da 4406 	jmpf	0x880c <_Generic_INT>
    599e:	0000      	nop
    59a0:	54f2      	mov	UPr, #2
    59a2:	76da 4406 	jmpf	0x880c <_Generic_INT>
    59a6:	0000      	nop
    59a8:	54f2      	mov	UPr, #2
    59aa:	76da 4406 	jmpf	0x880c <_Generic_INT>
    59ae:	0000      	nop
    59b0:	54f2      	mov	UPr, #2
    59b2:	76da 4406 	jmpf	0x880c <_Generic_INT>
    59b6:	0000      	nop
    59b8:	54f2      	mov	UPr, #2
    59ba:	76da 4406 	jmpf	0x880c <_Generic_INT>
    59be:	0000      	nop
    59c0:	54f2      	mov	UPr, #2
    59c2:	76da 4406 	jmpf	0x880c <_Generic_INT>
    59c6:	0000      	nop
    59c8:	54f2      	mov	UPr, #2
    59ca:	76da 4406 	jmpf	0x880c <_Generic_INT>
    59ce:	0000      	nop
    59d0:	54f2      	mov	UPr, #2
    59d2:	76da 4406 	jmpf	0x880c <_Generic_INT>
    59d6:	0000      	nop
    59d8:	54f2      	mov	UPr, #2
    59da:	76da 4406 	jmpf	0x880c <_Generic_INT>
    59de:	0000      	nop
    59e0:	54f2      	mov	UPr, #2
    59e2:	76da 4406 	jmpf	0x880c <_Generic_INT>
    59e6:	0000      	nop
    59e8:	54f2      	mov	UPr, #2
    59ea:	76da 4406 	jmpf	0x880c <_Generic_INT>
    59ee:	0000      	nop
    59f0:	54f2      	mov	UPr, #2
    59f2:	76da 4406 	jmpf	0x880c <_Generic_INT>
    59f6:	0000      	nop
    59f8:	54f2      	mov	UPr, #2
    59fa:	76da 4406 	jmpf	0x880c <_Generic_INT>
    59fe:	0000      	nop
    5a00:	54f2      	mov	UPr, #2
    5a02:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5a06:	0000      	nop
    5a08:	54f2      	mov	UPr, #2
    5a0a:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5a0e:	0000      	nop
    5a10:	54f2      	mov	UPr, #2
    5a12:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5a16:	0000      	nop
    5a18:	54f2      	mov	UPr, #2
    5a1a:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5a1e:	0000      	nop
    5a20:	54f4      	mov	UPr, #4
    5a22:	76da 4edf 	jmpf	0x9dbe <__UDFR_INT>
    5a26:	0000      	nop
    5a28:	54f4      	mov	UPr, #4
    5a2a:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5a2e:	0000      	nop
    5a30:	54f2      	mov	UPr, #2
    5a32:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5a36:	0000      	nop
    5a38:	54f6      	mov	UPr, #6
    5a3a:	76da 4406 	jmpf	0x880c <_Generic_INT>
    5a3e:	0000      	nop

Disassembly of section .mlx4_cst_tables_ram:

00000e80 <__mlx4_cst_tables_ram_start>:
 e80:	a55a      	or	A, dp:0x5a <.Lframe0+0x6>
 e82:	5aa5      	mov	io:0x25 <.LLST1+0x7>, Y
 e84:	0000      	nop
 e86:	0000      	nop
 e88:	0000      	nop
 e8a:	0000      	nop
 e8c:	0000      	nop
 e8e:	0000      	nop
 e90:	0000      	nop
 e92:	0000      	nop
 e94:	0000      	nop
 e96:	0000      	nop
 e98:	4104      	mov	dp:0x4 <_RST_CTRL+0x2>, AL
 e9a:	2000      	add	X, #0
 e9c:	0000      	nop
 e9e:	0000      	nop
 ea0:	01e0      	jmp	0x1262 <.LASF1020+0x3>
 ea2:	0003      	jmp	0xeaa <.LLST6+0x5>
 ea4:	0005      	jmp	0xeb0 <.LASF1761+0x5>
 ea6:	0000      	nop
 ea8:	4233      	mov	[S-52], AL
 eaa:	5f50      	mov	ep:0x50 <.LASF1525+0x3>, X
 eac:	7c6d      	lod	X, #109
 eae:	998a      	subc	AL, dp:0x8a <__mlx4_flash_table_size+0x2>
 eb0:	140e      	call	0x6ce <.LASF1583+0x2>
 eb2:	201a      	add	X, #26
 eb4:	2c26      	cmp	X, #38
 eb6:	3832      	subc	X, #50
 eb8:	0248      	jmp	0x134a <.LASF1449+0x1>
 eba:	c852      	sub	AH, #82
 ebc:	6f03      	lod	YH, ep:0x3 <_RST_CTRL+0x1>
 ebe:	ff05      	xor	Y, ep:0x5 <_RST_CTRL+0x3>
 ec0:	0000      	nop
 ec2:	e0ac      	add	Y, #-84
 ec4:	0001      	jmp	0xec8 <.LLST7+0x3>
 ec6:	0200      	jmp	0x12c8 <_sensor>
 ec8:	7da0      	lod	X, dp:0xa0 <.LASF1556>
 eca:	d70a      	and	AH, ep:0xa <_MUPET>
 ecc:	39e4      	subc	X, dp:0xe4 <.LASF2089+0x3>
 ece:	934e      	adc	AL, ep:0x4e <.LASF1525+0x1>
 ed0:	d3e0      	adc	AH, ep:0xe0 <.LLST12>
 ed2:	a497      	or	A, #-105
 ed4:	2c1f      	cmp	X, #31
 ed6:	5b68      	mov	ep:0x68 <__mlx4_cst_tables_ram_size+0xa>, Y
 ed8:	a81f      	sub	A, #31
 eda:	b47f      	and	A, #127
 edc:	00b2      	jmp	0x1042 <_l_sAdcAvgObject+0xa>

Disassembly of section .mlx4_par_tables_ram:

00000f00 <_INDXtbl>:
 f00:	4040      	jmp	fp2:0x00
 f02:	4040      	jmp	fp2:0x00
 f04:	4040      	jmp	fp2:0x00
 f06:	4040      	jmp	fp2:0x00
 f08:	4040      	jmp	fp2:0x00
 f0a:	4040      	jmp	fp2:0x00
 f0c:	4040      	jmp	fp2:0x00
 f0e:	4040      	jmp	fp2:0x00
 f10:	4040      	jmp	fp2:0x00
 f12:	4040      	jmp	fp2:0x00
 f14:	4040      	jmp	fp2:0x00
 f16:	4040      	jmp	fp2:0x00
 f18:	4040      	jmp	fp2:0x00
 f1a:	4040      	jmp	fp2:0x00
 f1c:	4040      	jmp	fp2:0x00
 f1e:	4040      	jmp	fp2:0x00
 f20:	4040      	jmp	fp2:0x00
 f22:	4040      	jmp	fp2:0x00
 f24:	4040      	jmp	fp2:0x00
 f26:	4040      	jmp	fp2:0x00
 f28:	4040      	jmp	fp2:0x00
 f2a:	4040      	jmp	fp2:0x00
 f2c:	4040      	jmp	fp2:0x00
 f2e:	4040      	jmp	fp2:0x00
 f30:	4040      	jmp	fp2:0x00
 f32:	4040      	jmp	fp2:0x00
 f34:	4040      	jmp	fp2:0x00
 f36:	4040      	jmp	fp2:0x00
 f38:	4040      	jmp	fp2:0x00
 f3a:	4040      	jmp	fp2:0x00
 f3c:	1110      	call	0x115e <.LLST7>
 f3e:	c0c0      	add	AH, #-64

00000f40 <_PARAMtbl>:
 f40:	0f2f      	lod	C, io:0x05.7
 f42:	a0a0      	add	A, #-96
 f44:	a0a0      	add	A, #-96
 f46:	a0a0      	add	A, #-96
 f48:	a0a0      	add	A, #-96
 f4a:	a0a0      	add	A, #-96
 f4c:	a0a0      	add	A, #-96
 f4e:	a0a0      	add	A, #-96
 f50:	2707      	or	X, ep:0x7 <_FUNC_TEST+0x1>
 f52:	a0a0      	add	A, #-96
 f54:	a0a0      	add	A, #-96
 f56:	a0a0      	add	A, #-96
 f58:	a0a0      	add	A, #-96
 f5a:	a0a0      	add	A, #-96
 f5c:	a0a0      	add	A, #-96
 f5e:	a0a0      	add	A, #-96
 f60:	a0a0      	add	A, #-96
 f62:	a0a0      	add	A, #-96
 f64:	a0a0      	add	A, #-96
 f66:	a0a0      	add	A, #-96
 f68:	a0a0      	add	A, #-96
 f6a:	a0a0      	add	A, #-96
 f6c:	a0a0      	add	A, #-96
 f6e:	a0a0      	add	A, #-96
 f70:	a0a0      	add	A, #-96
 f72:	a0a0      	add	A, #-96
 f74:	a0a0      	add	A, #-96
 f76:	a0a0      	add	A, #-96
 f78:	a0a0      	add	A, #-96
 f7a:	a0a0      	add	A, #-96
 f7c:	a0a0      	add	A, #-96
 f7e:	a0a0      	add	A, #-96

00000f80 <_AUTOADDtbl>:
 f80:	2610      	or	X, [S-17]
 f82:	0626      	jmp	0xbd0 <.Lframe0+0x4>
 f84:	0000      	nop
 f86:	0000      	nop

Disassembly of section .flash_data:

00005bbe <.LC0>:
    5bbe:	9201      	adc	AL, [S-2]
    5bc0:	0011      	jmp	0x5be4 <.LASF693+0x4>

00005bc1 <___clz_tab>:
    5bc1:	0100 0202 0303 0303 0404 0404 0404 0404     ................
    5bd1:	0505 0505 0505 0505 0505 0505 0505 0505     ................
    5be1:	0606 0606 0606 0606 0606 0606 0606 0606     ................
    5bf1:	0606 0606 0606 0606 0606 0606 0606 0606     ................
    5c01:	0707 0707 0707 0707 0707 0707 0707 0707     ................
    5c11:	0707 0707 0707 0707 0707 0707 0707 0707     ................
    5c21:	0707 0707 0707 0707 0707 0707 0707 0707     ................
    5c31:	0707 0707 0707 0707 0707 0707 0707 0707     ................
    5c41:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5c51:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5c61:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5c71:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5c81:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5c91:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5ca1:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5cb1:	0808 0808 0808 0808 0808 0808 0808 0808     ................
    5cc1:	0900                                             .

00005cc2 <.L189>:
    5cc2:	3609      	and	X, [S-10]
    5cc4:	363b      	and	X, [S-60]
    5cc6:	36a3      	and	X, io:0x23 <.LLST1+0x5>
    5cc8:	36b2      	and	X, io:0x32 <_STIMER+0x2>
    5cca:	36e8      	and	X, YL
    5ccc:	3738      	and	X, ep:0x38 <_MLX16>
    5cce:	388f      	subc	X, #-113
    5cd0:	38f9      	subc	X, #-7
    5cd2:	3a61      	subc	X, [S-98]
    5cd4:	3a6f      	subc	X, [S-112]
    5cd6:	3a89      	subc	X, io:0x9 <__data_dp_size+0x1>

00005cd8 <.L227>:
    5cd8:	375e      	and	X, ep:0x5e <__mlx4_cst_tables_ram_size>
    5cda:	3768      	and	X, ep:0x68 <__mlx4_cst_tables_ram_size+0xa>
    5cdc:	378e      	and	X, ep:0x8e <.LASF1526+0x2>
    5cde:	37ee      	and	X, ep:0xee <.LASF779+0x6>
    5ce0:	36e5      	and	X, MH
    5ce2:	3837      	subc	X, #55
    5ce4:	36e5      	and	X, MH
    5ce6:	3868      	subc	X, #104
    5ce8:	387a      	subc	X, #122
    5cea:	3889      	subc	X, #-119

00005cec <.L15>:
    5cec:	3c18      	xor	X, #24
    5cee:	3c1e      	xor	X, #30
    5cf0:	3c2f      	xor	X, #47
    5cf2:	3c35      	xor	X, #53
    5cf4:	3c3b      	xor	X, #59
    5cf6:	3c41      	xor	X, #65
    5cf8:	3c47      	xor	X, #71
    5cfa:	3c4d      	xor	X, #77

00005cfc <_IGNconversionMap>:
    5cfc:	0132 0000 028a 0000 015b 0000 0384 0000     2.......[.......
    5d0c:	0178 0000 04b0 0000 019b 0000 0708 0000     x...............

00005d1c <.L37>:
    5d1c:	3efd      	xor	X, [X+5]
    5d1e:	3f05      	xor	X, ep:0x5 <_RST_CTRL+0x3>
    5d20:	3f93      	xor	X, ep:0x93 <__data_size+0x3>
    5d22:	3fd7      	xor	X, ep:0xd7 <.LASF1988+0x7>
    5d24:	4001      	jmp	fp0:0x08
    5d26:	4043      	jmp	fp2:0x18
    5d28:	4056      	jmp	fp2:0xB0
    5d2a:	4066      	jmp	fp3:0x30

00005d2c <_eeprom_defaults>:
    5d2c:	01ab 1192 0000 0000 00ff 0000 0000 0000     ................
    5d3c:	00ff 0000 0000 0000                         ........

00005d44 <.L58>:
    5d44:	4895      	asr	D, #6
    5d46:	48b7      	asr	YA, #8
    5d48:	48ad      	lsr	YA, #14
    5d4a:	48c1      	asl	D, #2
    5d4c:	48c9      	asl	D, #10
    5d4e:	48ce      	asl	D, #15
    5d50:	48ab      	lsr	YA, #12

00005d52 <.L31>:
    5d52:	497f      	mov	dp:0x7f <.LASF2132+0xb>, AH
    5d54:	4976      	mov	dp:0x76 <.LASF2132+0x2>, AH
    5d56:	497f      	mov	dp:0x7f <.LASF2132+0xb>, AH
    5d58:	498c      	mov	dp:0x8c <.LASF1526>, AH
    5d5a:	498c      	mov	dp:0x8c <.LASF1526>, AH
    5d5c:	498c      	mov	dp:0x8c <.LASF1526>, AH
    5d5e:	498c      	mov	dp:0x8c <.LASF1526>, AH
    5d60:	498c      	mov	dp:0x8c <.LASF1526>, AH
    5d62:	497f      	mov	dp:0x7f <.LASF2132+0xb>, AH
    5d64:	498c      	mov	dp:0x8c <.LASF1526>, AH
    5d66:	498c      	mov	dp:0x8c <.LASF1526>, AH
    5d68:	498c      	mov	dp:0x8c <.LASF1526>, AH
    5d6a:	4976      	mov	dp:0x76 <.LASF2132+0x2>, AH

00005d6c <___VPC_Fwv_Resp_flags_mask_3801>:
    5d6c:	ffe0 01ff                                   ....

00005d70 <___VPC_Fwv_Ctrl_flags_mask_3849>:
    5d70:	001f 0200                                   ....

00005d74 <_frameList>:
    5d74:	0000 5d7e 0000 5d7c                         ..~]..|]

00005d7c <_l_sl1_VPC_Fwv_Ctrl_frame>:
    5d7c:	49bf                                        .I

00005d7e <_l_sl1_VPC_Fwv_Resp_frame>:
    5d7e:	49ee                                        .I

00005d80 <_ml_ProductID>:
    5d80:	0000 0000 00ff                              ......

00005d86 <_ml_InitialNAD>:
    5d86:	0001                                        ..

00005d88 <_ATAN_LUT>:
    5d88:	0000 00a3 0146 01e9 028c 032f 03d2 0475     ....F...../...u.
    5d98:	0517 05ba 065d 0700 07a2 0845 08e7 098a     ....].....E.....
    5da8:	0a2c 0acf 0b71 0c13 0cb5 0d57 0df9 0e9a     ,...q.....W.....
    5db8:	0f3c 0fdd 107f 1120 11c1 1262 1303 13a4     <..... ...b.....
    5dc8:	1444 14e5 1585 1625 16c5 1765 1804 18a4     D.....%...e.....
    5dd8:	1943 19e2 1a80 1b1f 1bbd 1c5c 1cfa 1d97     C.........\.....
    5de8:	1e35 1ed2 1f6f 200c 20a9 2145 21e1 227d     5...o.. . E!.!}"
    5df8:	2319 23b4 2450 24ea 2585 261f 26ba 2753     .#.#P$.$.%.&.&S'
    5e08:	27ed 2886 291f 29b8 2a50 2ae8 2b80 2c17     .'.(.).)P*.*.+.,
    5e18:	2caf 2d46 2ddc 2e72 2f08 2f9e 3033 30c8     .,F-.-r.././30.0
    5e28:	315d 31f1 3285 3319 33ac 343f 34d2 3564     ]1.1.2.3.3?4.4d5
    5e38:	35f6 3687 3719 37a9 383a 38ca 395a 39e9     .5.6.7.7:8.8Z9.9
    5e48:	3a78 3b07 3b95 3c23 3cb1 3d3e 3dcb 3e58     x:.;.;#<.<>=.=X>
    5e58:	3ee4 3f6f 3ffb 4086 4110 419a 4224 42ad     .>o?.?.@.A.A$B.B
    5e68:	4336 43bf 4447 44cf 4556 45dd 4664 46ea     6C.CGD.DVE.EdF.F
    5e78:	4770 47f5 487a 48ff 4983 4a07 4a8b 4b0d     pG.GzH.H.I.J.J.K
    5e88:	4b90 4c12 4c94 4d15 4d96 4e17 4e97 4f17     .K.L.L.M.M.N.N.O
    5e98:	4f96 5015 5093 5111 518f 520c 5289 5306     .O.P.P.Q.Q.R.R.S
    5ea8:	5382 53fd 5478 54f3 556e 55e8 5661 56da     .S.SxT.TnU.UaV.V
    5eb8:	5753 57cb 5843 58ba 5932 59a8 5a1e 5a94     SW.WCX.X2Y.Y.Z.Z
    5ec8:	5b0a 5b7f 5bf3 5c67 5cdb 5d4e 5dc1 5e34     .[.[.[g\.\N].]4^
    5ed8:	5ea6 5f18 5f89 5ffa 606a 60db 614a 61b9     .^._._._j`.`Ja.a
    5ee8:	6228 6297 6305 6373 63e0 644d 64b9 6525     (b.b.csc.cMd.d%e
    5ef8:	6591 65fc 6667 66d1 673b 67a5 680e 6877     .e.egf.f;g.g.hwh
    5f08:	68e0 6948 69b0 6a17 6a7e 6ae4 6b4b 6bb0     .hHi.i.j~j.jKk.k
    5f18:	6c16 6c7b 6cdf 6d44 6da8 6e0b 6e6e 6ed1     .l{l.lDm.m.nnn.n
    5f28:	6f33 6f95 6ff7 7058 70b9 7119 717a 71d9     3o.o.oXp.p.qzq.q
    5f38:	7239 7298 72f6 7355 73b3 7410 746d 74ca     9r.r.rUs.s.tmt.t
    5f48:	7527 7583 75df 763a 7695 76f0 774a 77a4     'u.u.u:v.v.vJw.w
    5f58:	77fe 7857 78b0 7909 7961 79b9 7a10 7a68     .wWx.x.yay.y.zhz
    5f68:	7abf 7b15 7b6b 7bc1 7c17 7c6c 7cc1 7d16     .z.{k{.{.|l|.|.}
    5f78:	7d6a 7dbe 7e11 7e65 7eb7 7f0a 7f5c 7fae     j}.}.~e~.~..\...
    5f88:	8000 8051                                   ..Q.

00005f8c <___gtsf2>:
    5f8c:	581b      	inc	S, #28

00005f8e <.LCFI0>:
    5f8e:	58a0      	mov	[S-4], YA

00005f90 <.LM3>:
    5f90:	7221      	lod	A, [S-34]

00005f92 <.LVL1>:
    5f92:	5207      	mov	[S-8], A
    5f94:	721f      	lod	A, [S-32]
    5f96:	5205      	mov	[S-6], A

00005f98 <.LM4>:
    5f98:	7eef      	lod	X, S
    5f9a:	20ee      	add	X, #-18
    5f9c:	5edf      	push	X

00005f9e <.LCFI1>:
    5f9e:	72ef      	lod	A, S
    5fa0:	a0fa      	add	A, #-6
    5fa2:	112d      	call	0x61fe <___unpack_f>

00005fa4 <.LM5>:
    5fa4:	7eef      	lod	X, S
    5fa6:	20e2      	add	X, #-30
    5fa8:	5edf      	push	X

00005faa <.LCFI2>:
    5faa:	72ef      	lod	A, S
    5fac:	a0f4      	add	A, #-12
    5fae:	1127      	call	0x61fe <___unpack_f>

00005fb0 <.LM6>:
    5fb0:	7215      	lod	A, [S-22]
    5fb2:	5c03      	dec	S, #4

00005fb4 <.LCFI3>:
    5fb4:	ac01      	cmp	A, #1
    5fb6:	1a0a      	jule	0x5fcc <.L4>

00005fb8 <.LM7>:
    5fb8:	721b      	lod	A, [S-28]
    5fba:	ac01      	cmp	A, #1
    5fbc:	1a07      	jule	0x5fcc <.L4>

00005fbe <.LM8>:
    5fbe:	7eef      	lod	X, S
    5fc0:	20e4      	add	X, #-28
    5fc2:	5edf      	push	X

00005fc4 <.LCFI4>:
    5fc4:	72ef      	lod	A, S
    5fc6:	a0ec      	add	A, #-20
    5fc8:	1178      	call	0x62ba <___fpcmp_parts_f>

00005fca <.LCFI5>:
    5fca:	541f      	ret	#32

00005fcc <.L4>:
    5fcc:	70ff      	lod	A, #-1

00005fce <.LM10>:
    5fce:	541d      	ret	#30

00005fd0 <___floatsisf>:
    5fd0:	580d      	inc	S, #14

00005fd2 <.LCFI0>:
    5fd2:	58a0      	mov	[S-4], YA

00005fd4 <.LM2>:
    5fd4:	7c03      	lod	X, #3
    5fd6:	5e0d      	mov	[S-14], X

00005fd8 <.LM3>:
    5fd8:	7e01      	lod	X, [S-2]
    5fda:	5c8f      	sn	X
    5fdc:	5e0b      	mov	[S-12], X

00005fde <.LM4>:
    5fde:	4cc0      	mov	D, YA
    5fe0:	4caa 0000 	cmpu	D, #0
    5fe4:	1d06      	jne	0x5ff2 <.L2>

00005fe6 <.LM5>:
    5fe6:	7002      	lod	A, #2

00005fe8 <.LVL1>:
    5fe8:	520d      	mov	[S-14], A

00005fea <.L3>:
    5fea:	72ef      	lod	A, S
    5fec:	a0f2      	add	A, #-14
    5fee:	1057      	call	0x609e <___pack_f>
    5ff0:	540f      	ret	#16

00005ff2 <.L2>:
    5ff2:	7c1e      	lod	X, #30
    5ff4:	5e09      	mov	[S-10], X

00005ff6 <.LM8>:
    5ff6:	58c0      	mov	D, [S-4]
    5ff8:	4caa 0000 	cmpu	D, #0
    5ffc:	1e87      	jsge	0x600c <.L6>

00005ffe <.LM9>:
    5ffe:	4c92 0000 	cmp	D, #-2147483648
    6002:	8000 
    6004:	1918      	je	0x6036 <.L8>

00006006 <.LM10>:
    6006:	4c80      	mov	YA, D

00006008 <.LVL5>:
    6008:	4cf0      	neg	YA
    600a:	58a0      	mov	[S-4], YA

0000600c <.L6>:
    600c:	58e0      	mov	YA, [S-4]
    600e:	1017      	call	0x603e <___clzsi2>

00006010 <.LBE6>:
    6010:	7ee2      	lod	X, A
    6012:	20ff      	add	X, #-1

00006014 <.LVL8>:
    6014:	ac01      	cmp	A, #1
    6016:	1d03      	jne	0x601e <.L7>

00006018 <.LM13>:
    6018:	58e0      	mov	YA, [S-4]
    601a:	58a2      	mov	[S-8], YA
    601c:	07e6      	jmp	0x5fea <.L3>

0000601e <.L7>:
    601e:	58e0      	mov	YA, [S-4]
    6020:	2c00      	cmp	X, #0
    6022:	1b04      	jsle	0x602c <.L9>
    6024:	5edf      	push	X

00006026 <.L10>:
    6026:	48e0      	asl	YA, #1
    6028:	1bfe      	djnz	X, 0x6026 <.L10>
    602a:	7ecf      	pop	X

0000602c <.L9>:
    602c:	58a2      	mov	[S-8], YA

0000602e <.LM15>:
    602e:	701e      	lod	A, #30
    6030:	aaee      	sub	A, X
    6032:	5209      	mov	[S-10], A
    6034:	07da      	jmp	0x5fea <.L3>

00006036 <.L8>:
    6036:	4ce2 0000 	mov	YA, #-822083584
    603a:	cf00 

0000603c <.LBE5>:
    603c:	540f      	ret	#16

0000603e <___clzsi2>:
    603e:	580b      	inc	S, #12

00006040 <.LCFI0>:
    6040:	58a0      	mov	[S-4], YA

00006042 <.LBB2>:
    6042:	4cc0      	mov	D, YA
    6044:	4c92 ffff 	cmp	D, #65535
    6048:	0000 
    604a:	1e1b      	jug	0x6082 <.L2>

0000604c <.LM3>:
    604c:	4caa 00ff 	cmpu	D, #255
    6050:	1a20      	jule	0x6092 <.L4>

00006052 <.LM4>:
    6052:	4cfa 0008 	movs	YA, #8

00006056 <.L6>:
    6056:	58a2      	mov	[S-8], YA

00006058 <.LVL3>:
    6058:	4cda 0020 	movs	D, #32
    605c:	4c80      	mov	YA, D

0000605e <.LVL4>:
    605e:	aa07      	sub	A, [S-8]
    6060:	fa05      	subc	Y, [S-6]
    6062:	58a4      	mov	[S-12], YA
    6064:	7e07      	lod	X, [S-8]
    6066:	58e0      	mov	YA, [S-4]
    6068:	2c00      	cmp	X, #0
    606a:	1b02      	jsle	0x6070 <.L7>

0000606c <.L8>:
    606c:	48a0      	lsr	YA, #1
    606e:	1bfe      	djnz	X, 0x606c <.L8>

00006070 <.L7>:
    6070:	a2da 5bc1 	add	A, #23489
    6074:	7ae2      	lod	Y, A
    6076:	62f0      	lod	AL, [Y]
    6078:	5cf2      	usex	A

0000607a <.LBE2>:
    607a:	7e0b      	lod	X, [S-12]
    607c:	2ae2      	sub	X, A
    607e:	72ee      	lod	A, X

00006080 <.LM6>:
    6080:	540d      	ret	#14

00006082 <.L2>:
    6082:	58c0      	mov	D, [S-4]
    6084:	4c92 ffff 	cmp	D, #16777215
    6088:	00ff 
    608a:	1a06      	jule	0x6098 <.L5>

0000608c <.LM8>:
    608c:	4cfa 0018 	movs	YA, #24

00006090 <.LVL6>:
    6090:	07e2      	jmp	0x6056 <.L6>

00006092 <.L4>:
    6092:	4cfa 0000 	movs	YA, #0

00006096 <.LVL8>:
    6096:	07df      	jmp	0x6056 <.L6>

00006098 <.L5>:
    6098:	4cfa 0010 	movs	YA, #16

0000609c <.LVL10>:
    609c:	07dc      	jmp	0x6056 <.L6>

0000609e <___pack_f>:
    609e:	580d      	inc	S, #14

000060a0 <.LCFI0>:
    60a0:	7ee2      	lod	X, A

000060a2 <.LM2>:
    60a2:	7ae2      	lod	Y, A
    60a4:	e006      	add	Y, #6
    60a6:	72f0      	lod	A, [Y]

000060a8 <.LVL1>:
    60a8:	5207      	mov	[S-8], A
    60aa:	72f2      	lod	A, [Y+2]
    60ac:	5205      	mov	[S-6], A

000060ae <.LM3>:
    60ae:	72fa      	lod	A, [X+2]
    60b0:	520d      	mov	[S-14], A

000060b2 <.LM4>:
    60b2:	72f8      	lod	A, [X]

000060b4 <.LVL4>:
    60b4:	ac01      	cmp	A, #1
    60b6:	1e29      	jug	0x610a <.L2>

000060b8 <.LM5>:
    60b8:	58c2      	mov	D, [S-8]
    60ba:	4886      	lsr	D, #7

000060bc <.LM6>:
    60bc:	4c80      	mov	YA, D
    60be:	f43f      	and	Y, #63

000060c0 <.LM7>:
    60c0:	e440      	or	Y, #64
    60c2:	58a2      	mov	[S-8], YA

000060c4 <.LM8>:
    60c4:	7ada 00ff 	lod	Y, #255
    60c8:	5a0b      	mov	[S-12], Y

000060ca <.L3>:
    60ca:	4cfa 0000 	movs	YA, #0
    60ce:	58a0      	mov	[S-4], YA
    60d0:	7a07      	lod	Y, [S-8]
    60d2:	5a03      	mov	[S-4], Y
    60d4:	7205      	lod	A, [S-6]
    60d6:	b47f      	and	A, #127
    60d8:	7e01      	lod	X, [S-2]
    60da:	3480      	and	X, #-128
    60dc:	a6ee      	or	A, X
    60de:	5201      	mov	[S-2], A

000060e0 <.LM10>:
    60e0:	620b      	lod	AL, [S-12]
    60e2:	5cf2      	usex	A
    60e4:	4862 0080 	mulu	A, A, #128
    60e8:	7ae2      	lod	Y, A
    60ea:	7e01      	lod	X, [S-2]
    60ec:	36da 807f 	and	X, #32895
    60f0:	e6ee      	or	Y, X
    60f2:	5a01      	mov	[S-2], Y

000060f4 <.LM11>:
    60f4:	720d      	lod	A, [S-14]
    60f6:	b401      	and	A, #1
    60f8:	4452      	rr	A
    60fa:	7ae2      	lod	Y, A
    60fc:	7e01      	lod	X, [S-2]
    60fe:	36da 7fff 	and	X, #32767
    6102:	e6ee      	or	Y, X
    6104:	5a01      	mov	[S-2], Y

00006106 <.LM12>:
    6106:	58e0      	mov	YA, [S-4]

00006108 <.LM13>:
    6108:	540f      	ret	#16

0000610a <.L2>:
    610a:	ac04      	cmp	A, #4
    610c:	1d01      	jne	0x6110 <.LM15>
    610e:	0073      	jmp	0x61f6 <.L16>

00006110 <.LM15>:
    6110:	ac02      	cmp	A, #2
    6112:	1d01      	jne	0x6116 <.LM16>
    6114:	0067      	jmp	0x61e4 <.L13>

00006116 <.LM16>:
    6116:	58c2      	mov	D, [S-8]
    6118:	4caa 0000 	cmpu	D, #0
    611c:	1d01      	jne	0x6120 <.LM17>
    611e:	0068      	jmp	0x61f0 <.L14>

00006120 <.LM17>:
    6120:	7efc      	lod	X, [X+4]

00006122 <.LVL12>:
    6122:	2c82      	cmp	X, #-126
    6124:	1a81      	jsl	0x6128 <.LBB10>
    6126:	0039      	jmp	0x619a <.L4>

00006128 <.LBB10>:
    6128:	7082      	lod	A, #-126
    612a:	aaee      	sub	A, X
    612c:	7ee2      	lod	X, A

0000612e <.LM19>:
    612e:	ac19      	cmp	A, #25
    6130:	1f2e      	jsg	0x618e <.L15>

00006132 <.LBB11>:
    6132:	4c80      	mov	YA, D

00006134 <.LVL15>:
    6134:	2c00      	cmp	X, #0
    6136:	1b04      	jsle	0x6140 <.L26>
    6138:	5edf      	push	X

0000613a <.L27>:
    613a:	48a0      	lsr	YA, #1
    613c:	1bfe      	djnz	X, 0x613a <.L27>
    613e:	7ecf      	pop	X

00006140 <.L26>:
    6140:	58a4      	mov	[S-12], YA

00006142 <.LM21>:
    6142:	4cfa ffff 	movs	YA, #65535
    6146:	2c00      	cmp	X, #0
    6148:	1b02      	jsle	0x614e <.L28>

0000614a <.L29>:
    614a:	48e0      	asl	YA, #1
    614c:	1bfe      	djnz	X, 0x614a <.L29>

0000614e <.L28>:
    614e:	bcff      	xor	A, #-1
    6150:	fcff      	xor	Y, #-1
    6152:	b607      	and	A, [S-8]
    6154:	f605      	and	Y, [S-6]
    6156:	a6e6      	or	A, Y
    6158:	5ca2      	sne	A
    615a:	4cc8      	movu	D, A

0000615c <.LM22>:
    615c:	4c80      	mov	YA, D
    615e:	a60b      	or	A, [S-12]
    6160:	e609      	or	Y, [S-10]
    6162:	4cc0      	mov	D, YA

00006164 <.L5>:
    6164:	4c80      	mov	YA, D
    6166:	b47f      	and	A, #127
    6168:	7800      	lod	Y, #0
    616a:	4cb2 0040 	cmp	YA, #64
    616e:	0000 
    6170:	1d11      	jne	0x6194 <.L6>

00006172 <.LM24>:
    6172:	4c80      	mov	YA, D
    6174:	9480      	and	AL, #-128
    6176:	1902      	je	0x617c <.L7>

00006178 <.LM25>:
    6178:	4c0a 0040 	addu	D, #64

0000617c <.L7>:
    617c:	4c92 ffff 	cmp	D, #1073741823
    6180:	3fff 
    6182:	5cb4      	sug	Y
    6184:	5a0b      	mov	[S-12], Y

00006186 <.LM27>:
    6186:	4c80      	mov	YA, D

00006188 <.L25>:
    6188:	48a6      	lsr	YA, #7

0000618a <.LVL25>:
    618a:	58a2      	mov	[S-8], YA

0000618c <.LVL26>:
    618c:	079e      	jmp	0x60ca <.L3>

0000618e <.L15>:
    618e:	4cda 0000 	movs	D, #0
    6192:	07e8      	jmp	0x6164 <.L5>

00006194 <.L6>:
    6194:	4c0a 003f 	addu	D, #63
    6198:	07f1      	jmp	0x617c <.L7>

0000619a <.L4>:
    619a:	2c7f      	cmp	X, #127
    619c:	1f2c      	jsg	0x61f6 <.L16>

0000619e <.LM32>:
    619e:	58e2      	mov	YA, [S-8]
    61a0:	b47f      	and	A, #127
    61a2:	7800      	lod	Y, #0
    61a4:	4cb2 0040 	cmp	YA, #64
    61a8:	0000 
    61aa:	1d10      	jne	0x61cc <.L8>

000061ac <.LM33>:
    61ac:	58e2      	mov	YA, [S-8]
    61ae:	9480      	and	AL, #-128
    61b0:	1904      	je	0x61ba <.L9>

000061b2 <.LM34>:
    61b2:	58c2      	mov	D, [S-8]
    61b4:	4c0a 0040 	addu	D, #64

000061b8 <.L23>:
    61b8:	5882      	mov	[S-8], D

000061ba <.L9>:
    61ba:	58c2      	mov	D, [S-8]
    61bc:	4caa 0000 	cmpu	D, #0
    61c0:	1a89      	jsl	0x61d4 <.L10>

000061c2 <.LM37>:
    61c2:	72ee      	lod	A, X
    61c4:	a07f      	add	A, #127
    61c6:	520b      	mov	[S-12], A

000061c8 <.L11>:
    61c8:	58e2      	mov	YA, [S-8]
    61ca:	07de      	jmp	0x6188 <.L25>

000061cc <.L8>:
    61cc:	58c2      	mov	D, [S-8]
    61ce:	4c0a 003f 	addu	D, #63
    61d2:	07f2      	jmp	0x61b8 <.L23>

000061d4 <.L10>:
    61d4:	58e2      	mov	YA, [S-8]
    61d6:	48a0      	lsr	YA, #1
    61d8:	58a2      	mov	[S-8], YA

000061da <.LM41>:
    61da:	7aee      	lod	Y, X
    61dc:	e2da 0080 	add	Y, #128
    61e0:	5a0b      	mov	[S-12], Y

000061e2 <.LVL37>:
    61e2:	07f2      	jmp	0x61c8 <.L11>

000061e4 <.L13>:
    61e4:	7000      	lod	A, #0
    61e6:	520b      	mov	[S-12], A

000061e8 <.L24>:
    61e8:	4cda 0000 	movs	D, #0
    61ec:	5882      	mov	[S-8], D

000061ee <.LVL40>:
    61ee:	076d      	jmp	0x60ca <.L3>

000061f0 <.L14>:
    61f0:	7000      	lod	A, #0
    61f2:	520b      	mov	[S-12], A
    61f4:	076a      	jmp	0x60ca <.L3>

000061f6 <.L16>:
    61f6:	7ada 00ff 	lod	Y, #255
    61fa:	5a0b      	mov	[S-12], Y
    61fc:	07f5      	jmp	0x61e8 <.L24>

000061fe <___unpack_f>:
    61fe:	5807      	inc	S, #8

00006200 <.LCFI0>:
    6200:	5201      	mov	[S-2], A

00006202 <.LM2>:
    6202:	7ee2      	lod	X, A
    6204:	72de      	lod	A, [X++]

00006206 <.LVL1>:
    6206:	5207      	mov	[S-8], A
    6208:	66f8      	lod	YL, [X]
    620a:	4603      	mov	[S-4], YL
    620c:	f47f      	and	Y, #127
    620e:	5a05      	mov	[S-6], Y

00006210 <.LM3>:
    6210:	7af8      	lod	Y, [X]

00006212 <.LM4>:
    6212:	7e01      	lod	X, [S-2]
    6214:	62fb      	lod	AL, [X+3]

00006216 <.LM5>:
    6216:	4440      	rl	AL
    6218:	9401      	and	AL, #1
    621a:	5cf2      	usex	A

0000621c <.LM6>:
    621c:	7e0b      	lod	X, [S-12]

0000621e <.LM7>:
    621e:	52fa      	mov	[X+2], A

00006220 <.LM8>:
    6220:	72e6      	lod	A, Y
    6222:	44b2      	lsr	A, #2
    6224:	44b2      	lsr	A, #2
    6226:	44b2      	lsr	A, #2
    6228:	4432      	lsr	A
    622a:	b6da 00ff 	and	A, #255

0000622e <.LVL4>:
    622e:	f6da 7f80 	and	Y, #32640
    6232:	1d19      	jne	0x6266 <.L2>

00006234 <.LM9>:
    6234:	58c2      	mov	D, [S-8]
    6236:	4caa 0000 	cmpu	D, #0
    623a:	1d03      	jne	0x6242 <.L3>

0000623c <.LM10>:
    623c:	7002      	lod	A, #2

0000623e <.L12>:
    623e:	52f8      	mov	[X], A
    6240:	5409      	ret	#10

00006242 <.L3>:
    6242:	58c2      	mov	D, [S-8]

00006244 <.LVL7>:
    6244:	48c6      	asl	D, #7

00006246 <.LM13>:
    6246:	7e0b      	lod	X, [S-12]
    6248:	7803      	lod	Y, #3
    624a:	5af8      	mov	[X], Y
    624c:	7c81      	lod	X, #-127

0000624e <.L5>:
    624e:	48c0      	asl	D, #1

00006250 <.LM15>:
    6250:	7aee      	lod	Y, X
    6252:	20ff      	add	X, #-1

00006254 <.LM16>:
    6254:	4c92 ffff 	cmp	D, #1073741823
    6258:	3fff 
    625a:	1a79      	jule	0x624e <.L5>
    625c:	7e0b      	lod	X, [S-12]
    625e:	5afc      	mov	[X+4], Y

00006260 <.LM17>:
    6260:	2006      	add	X, #6
    6262:	4c87      	mov	[X], D
    6264:	5409      	ret	#10

00006266 <.L2>:
    6266:	aeda 00ff 	cmp	A, #255
    626a:	1d1c      	jne	0x62a4 <.L6>

0000626c <.LM19>:
    626c:	58c2      	mov	D, [S-8]
    626e:	4caa 0000 	cmpu	D, #0
    6272:	1d03      	jne	0x627a <.L7>

00006274 <.LM20>:
    6274:	7e0b      	lod	X, [S-12]
    6276:	7004      	lod	A, #4

00006278 <.LVL11>:
    6278:	07e2      	jmp	0x623e <.L12>

0000627a <.L7>:
    627a:	58e2      	mov	YA, [S-8]

0000627c <.LVL13>:
    627c:	7000      	lod	A, #0
    627e:	f440      	and	Y, #64

00006280 <.LM22>:
    6280:	7e0b      	lod	X, [S-12]

00006282 <.LM23>:
    6282:	4cb2 0000 	cmp	YA, #0
    6286:	0000 
    6288:	190b      	je	0x62a0 <.L8>

0000628a <.LM24>:
    628a:	7001      	lod	A, #1

0000628c <.L11>:
    628c:	52f8      	mov	[X], A

0000628e <.LM26>:
    628e:	7e0b      	lod	X, [S-12]
    6290:	2006      	add	X, #6
    6292:	58e2      	mov	YA, [S-8]
    6294:	48e6      	asl	YA, #7
    6296:	9480      	and	AL, #-128
    6298:	f6da dfff 	and	Y, #57343

0000629c <.L13>:
    629c:	4ca7      	mov	[X], YA

0000629e <.LM28>:
    629e:	5409      	ret	#10

000062a0 <.L8>:
    62a0:	7000      	lod	A, #0
    62a2:	07f4      	jmp	0x628c <.L11>

000062a4 <.L6>:
    62a4:	a081      	add	A, #-127

000062a6 <.LVL18>:
    62a6:	7e0b      	lod	X, [S-12]
    62a8:	52fc      	mov	[X+4], A

000062aa <.LM31>:
    62aa:	7003      	lod	A, #3
    62ac:	52f8      	mov	[X], A

000062ae <.LM32>:
    62ae:	2006      	add	X, #6
    62b0:	58e2      	mov	YA, [S-8]
    62b2:	48e6      	asl	YA, #7
    62b4:	e6da 4000 	or	Y, #16384
    62b8:	07f1      	jmp	0x629c <.L13>

000062ba <___fpcmp_parts_f>:
    62ba:	5803      	inc	S, #4

000062bc <.LCFI0>:
    62bc:	5201      	mov	[S-2], A

000062be <.LM2>:
    62be:	7ee2      	lod	X, A
    62c0:	72f8      	lod	A, [X]

000062c2 <.LVL1>:
    62c2:	ac01      	cmp	A, #1
    62c4:	1a14      	jule	0x62ee <.L22>

000062c6 <.LM3>:
    62c6:	7e07      	lod	X, [S-8]

000062c8 <.LM4>:
    62c8:	7af8      	lod	Y, [X]
    62ca:	ec01      	cmp	Y, #1
    62cc:	1a10      	jule	0x62ee <.L22>

000062ce <.LM5>:
    62ce:	ac04      	cmp	A, #4
    62d0:	1d09      	jne	0x62e4 <.L3>
    62d2:	7e01      	lod	X, [S-2]
    62d4:	72fa      	lod	A, [X+2]

000062d6 <.LM6>:
    62d6:	ec04      	cmp	Y, #4
    62d8:	1d16      	jne	0x6306 <.L33>

000062da <.LM7>:
    62da:	7e07      	lod	X, [S-8]
    62dc:	7efa      	lod	X, [X+2]
    62de:	2ae2      	sub	X, A
    62e0:	72ee      	lod	A, X
    62e2:	5405      	ret	#6

000062e4 <.L3>:
    62e4:	ec04      	cmp	Y, #4
    62e6:	1d05      	jne	0x62f2 <.L5>

000062e8 <.L7>:
    62e8:	7e07      	lod	X, [S-8]
    62ea:	72fa      	lod	A, [X+2]
    62ec:	190e      	je	0x630a <.L24>

000062ee <.L22>:
    62ee:	7001      	lod	A, #1
    62f0:	5405      	ret	#6

000062f2 <.L5>:
    62f2:	ac02      	cmp	A, #2
    62f4:	1d04      	jne	0x62fe <.L6>

000062f6 <.LM12>:
    62f6:	ec02      	cmp	Y, #2
    62f8:	1d77      	jne	0x62e8 <.L7>

000062fa <.L23>:
    62fa:	7000      	lod	A, #0
    62fc:	5405      	ret	#6

000062fe <.L6>:
    62fe:	7e01      	lod	X, [S-2]
    6300:	72fa      	lod	A, [X+2]

00006302 <.LM14>:
    6302:	ec02      	cmp	Y, #2
    6304:	1d04      	jne	0x630e <.L8>

00006306 <.L33>:
    6306:	ac00      	cmp	A, #0
    6308:	1972      	je	0x62ee <.L22>

0000630a <.L24>:
    630a:	70ff      	lod	A, #-1

0000630c <.LM17>:
    630c:	5405      	ret	#6

0000630e <.L8>:
    630e:	7e07      	lod	X, [S-8]
    6310:	7efa      	lod	X, [X+2]
    6312:	5e03      	mov	[S-4], X
    6314:	2ee2      	cmp	X, A
    6316:	1d77      	jne	0x6306 <.L33>

00006318 <.LM19>:
    6318:	7e01      	lod	X, [S-2]
    631a:	7afc      	lod	Y, [X+4]
    631c:	7e07      	lod	X, [S-8]
    631e:	72fc      	lod	A, [X+4]
    6320:	eee2      	cmp	Y, A
    6322:	1b02      	jsle	0x6328 <.L10>

00006324 <.L35>:
    6324:	7203      	lod	A, [S-4]
    6326:	07ef      	jmp	0x6306 <.L33>

00006328 <.L10>:
    6328:	eee2      	cmp	Y, A
    632a:	1e83      	jsge	0x6332 <.L11>

0000632c <.L27>:
    632c:	7e03      	lod	X, [S-4]
    632e:	1d5f      	jne	0x62ee <.L22>
    6330:	07ec      	jmp	0x630a <.L24>

00006332 <.L11>:
    6332:	7e01      	lod	X, [S-2]
    6334:	2006      	add	X, #6
    6336:	4cc7      	mov	D, [X]
    6338:	7e07      	lod	X, [S-8]
    633a:	2006      	add	X, #6
    633c:	4ce7      	mov	YA, [X]
    633e:	4c90      	cmp	D, YA
    6340:	1e71      	jug	0x6324 <.L35>

00006342 <.LM24>:
    6342:	1874      	jc	0x632c <.L27>
    6344:	07da      	jmp	0x62fa <.L23>

00006346 <_AppLinInit>:
    6346:	6000      	lod	AL, #0
    6348:	42d8 10ad 	mov	0x10ad <_Fwv_lin_sleep_enable>, AL

0000634c <.LM3>:
    634c:	42d8 10ac 	mov	0x10ac <_Fwv_lin_frame_Error>, AL

00006350 <.LM4>:
    6350:	5401      	ret

00006352 <_AppLinTask>:
}

void AppLinTask(void)
{

	if (g_u8LinErrorCnt > (uint8_t)3u)
    6352:	62d8 1187 	lod	AL, 0x1187 <_g_u8LinErrorCnt>
    6356:	8c03      	cmp	AL, #3
    6358:	1a03      	jule	0x6360 <.L3>

0000635a <.LM7>:
	{
		Fwv_lin_frame_Error = 1;
    635a:	6001      	lod	AL, #1
    635c:	42d8 10ac 	mov	0x10ac <_Fwv_lin_frame_Error>, AL

00006360 <.L3>:
L_FLAGS(l_sl1_flags.mapped, s_Fwv_CommErr, signal, Fwv_CommErr)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_SW_Version, signal, Fwv_SW_Version)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Stall_State, signal, Fwv_Stall_State)

L_FLAGS(l_sl1_flags.mapped, f_VPC_Fwv_Resp, frame, VPC_Fwv_Resp)
L_FLAGS(l_sl1_flags.mapped, f_VPC_Fwv_Ctrl, frame, VPC_Fwv_Ctrl)
    6360:	62d8 13d7 	lod	AL, 0x13d7 <_l_sl1_flags+0x3>

00006364 <.LBE14>:
	}

	/* VPC_Fwv_Master Frame handling */
	if (l_flg_tst_f_VPC_Fwv_Ctrl() != 0u)
    6364:	9402      	and	AL, #2
    6366:	1915      	je	0x6392 <.L4>

00006368 <.LBB16>:
    6368:	82db 4780 	callf	0x8f00 <_l_sys_irq_disable>
    636c:	7ee2      	lod	X, A

0000636e <.LVL1>:
    636e:	62d8 13d7 	lod	AL, 0x13d7 <_l_sl1_flags+0x3>

00006372 <.LVL2>:
    6372:	94fd      	and	AL, #-3
    6374:	42d8 13d7 	mov	0x13d7 <_l_sl1_flags+0x3>, AL
    6378:	72ee      	lod	A, X
    637a:	82db 4788 	callf	0x8f10 <_l_sys_irq_restore>

0000637e <.LBE16>:
	{
		l_flg_clr_f_VPC_Fwv_Ctrl();
		ValveLinGetCommand();
    637e:	109d      	call	0x64ba <_ValveLinGetCommand>

00006380 <.LM12>:
		Fwv_Request_Event = 1;
    6380:	6001      	lod	AL, #1
    6382:	42d8 10ab 	mov	0x10ab <_Fwv_Request_Event>, AL

00006386 <.LM13>:
		g_u8LinErrorCnt = 0;
    6386:	6000      	lod	AL, #0
    6388:	0ea7      	lod	C, ML.7
    638a:	42d8 1187 	mov	0x1187 <_g_u8LinErrorCnt>, AL

0000638e <.LM14>:
		Fwv_lin_frame_Error = 0;
    638e:	42d8 10ac 	mov	0x10ac <_Fwv_lin_frame_Error>, AL

00006392 <.L4>:
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Position_Sensor_Fault, signal, Fwv_Position_Sensor_Fault)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_CommErr, signal, Fwv_CommErr)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_SW_Version, signal, Fwv_SW_Version)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Stall_State, signal, Fwv_Stall_State)

L_FLAGS(l_sl1_flags.mapped, f_VPC_Fwv_Resp, frame, VPC_Fwv_Resp)
    6392:	62d8 13d7 	lod	AL, 0x13d7 <_l_sl1_flags+0x3>

00006396 <.LBE18>:
	}

	/* VPC_Fwv_Slave Frame handling */
	if (l_flg_tst_f_VPC_Fwv_Resp() != 0u)
    6396:	9401      	and	AL, #1
    6398:	1915      	je	0x63c4 <.L5>

0000639a <.LBB20>:
    639a:	82db 4780 	callf	0x8f00 <_l_sys_irq_disable>
    639e:	7ee2      	lod	X, A

000063a0 <.LVL6>:
    63a0:	62d8 13d7 	lod	AL, 0x13d7 <_l_sl1_flags+0x3>

000063a4 <.LVL7>:
    63a4:	94fe      	and	AL, #-2
    63a6:	42d8 13d7 	mov	0x13d7 <_l_sl1_flags+0x3>, AL
    63aa:	72ee      	lod	A, X
    63ac:	82db 4788 	callf	0x8f10 <_l_sys_irq_restore>

000063b0 <.LBE20>:
	{
		l_flg_clr_f_VPC_Fwv_Resp();
		ValveLinUpdateSignals();
    63b0:	10b2      	call	0x6516 <_ValveLinUpdateSignals>

000063b2 <.LM19>:
		Fwv_Response_Event = 1;
    63b2:	6001      	lod	AL, #1
    63b4:	42d8 10aa 	mov	0x10aa <__data_end>, AL

000063b8 <.LM20>:
		g_u8LinErrorCnt = 0;
    63b8:	6000      	lod	AL, #0
    63ba:	0ea7      	lod	C, ML.7
    63bc:	42d8 1187 	mov	0x1187 <_g_u8LinErrorCnt>, AL

000063c0 <.LM21>:
		Fwv_lin_frame_Error = 0;
    63c0:	42d8 10ac 	mov	0x10ac <_Fwv_lin_frame_Error>, AL

000063c4 <.L5>:
		l_u8_wr_DEBUG1_U8_7((uint8_t)(g_u16DebugData[3]));
		l_u8_wr_DEBUG1_U8_8((uint8_t)(g_u16DebugData[3] >> 8));
	}
#endif
	/* do lin period (non time critical) stuff */
	lin22_BackgroundHandler();
    63c4:	76da 4686 	jmpf	0x8d0c <_lin22_BackgroundHandler>

000063c8 <_AppLinSleepEnter>:
}

void AppLinSleepEnter(void)
{
	Fwv_lin_sleep_enable = 1;
    63c8:	6001      	lod	AL, #1
    63ca:	42d8 10ad 	mov	0x10ad <_Fwv_lin_sleep_enable>, AL

000063ce <.LM26>:
	lin22_GotoSleep(); /* switch to sleep mode */
    63ce:	76da 46b8 	jmpf	0x8d70 <_lin22_GotoSleep>

000063d2 <_check_protect_mode>:
	return status;
}
static uint16_t check_protect_mode(void)
{
	uint16_t status = 0;
	if ((valve.diag.vs.state == VS_UNDERVOLTAGE) || (valve.diag.vs.state == VS_OVERVOLTAGE) || (valve.diag.temp.state == TEMPERATURE_HIGH))
    63d2:	72d8 123c 	lod	A, 0x123c <.LASF2154+0x3>
    63d6:	a0ff      	add	A, #-1
    63d8:	ac01      	cmp	A, #1
    63da:	1a1e      	jule	0x6418 <.L8>

000063dc <.LM3>:
    63dc:	72d8 1246 	lod	A, 0x1246 <.LLST1+0x6>

000063e0 <.LM4>:
	}
	return status;
}
static uint16_t check_protect_mode(void)
{
	uint16_t status = 0;
    63e0:	ac02      	cmp	A, #2
    63e2:	5c8e      	se	X

000063e4 <.L2>:
	if ((valve.diag.vs.state == VS_UNDERVOLTAGE) || (valve.diag.vs.state == VS_OVERVOLTAGE) || (valve.diag.temp.state == TEMPERATURE_HIGH))
	{
		status = 1;
	}
	if ((valve.diag.stallFault & STALL_MASK_TEMPORARY) != 0)
    63e4:	62d8 1266 	lod	AL, 0x1266 <.LLST4>
    63e8:	9401      	and	AL, #1
    63ea:	1901      	je	0x63ee <.L3>

000063ec <.LM6>:
	{
		status = 1;
    63ec:	7c01      	lod	X, #1

000063ee <.L3>:
	}
	if ((valve.diag.motorFault & FAULT_MASK_OVER_CURRENT) != 0)
    63ee:	62d8 1265 	lod	AL, 0x1265 <.LASF1020+0x6>
    63f2:	9440      	and	AL, #64
    63f4:	1901      	je	0x63f8 <.L4>

000063f6 <.LM8>:
	{
		status = 1;
    63f6:	7c01      	lod	X, #1

000063f8 <.L4>:
	}
	if (valve.diag.McuFault != 0)
    63f8:	62d8 125e 	lod	AL, 0x125e <.LLST3+0xb>
    63fc:	1901      	je	0x6400 <.L5>

000063fe <.LM10>:
	{
		status = 1;
    63fe:	7c01      	lod	X, #1

00006400 <.L5>:
	}
#if 1
	if ((valve.diag.gmr.state != 0) || (valve.pos.fault != 0))
    6400:	62d8 1254 	lod	AL, 0x1254 <.LLST3+0x1>
    6404:	1d0b      	jne	0x641c <.L10>

00006406 <.LM12>:
    6406:	62d8 1212 	lod	AL, 0x1212 <.LASF1440+0x6>
    640a:	1d08      	jne	0x641c <.L10>

0000640c <.L6>:
	{
		status = 1;
	}
#endif
	if (valve.linLiveTimeOut == 0)
    640c:	72d8 1200 	lod	A, 0x1200 <_valve+0x4>
    6410:	1d01      	jne	0x6414 <.L1>

00006412 <.LM14>:
	{
		status = 1;
    6412:	7c01      	lod	X, #1

00006414 <.L1>:
	}
	return status;
}
    6414:	72ee      	lod	A, X
    6416:	5401      	ret

00006418 <.L8>:
static uint16_t check_protect_mode(void)
{
	uint16_t status = 0;
	if ((valve.diag.vs.state == VS_UNDERVOLTAGE) || (valve.diag.vs.state == VS_OVERVOLTAGE) || (valve.diag.temp.state == TEMPERATURE_HIGH))
	{
		status = 1;
    6418:	7c01      	lod	X, #1
    641a:	07e4      	jmp	0x63e4 <.L2>

0000641c <.L10>:
		status = 1;
	}
#if 1
	if ((valve.diag.gmr.state != 0) || (valve.pos.fault != 0))
	{
		status = 1;
    641c:	7c01      	lod	X, #1

0000641e <.LVL9>:
    641e:	07f6      	jmp	0x640c <.L6>

00006420 <_ValveFaultReset>:
	{
	}
}
static void ValveFaultReset(void)
{
	u16EventState = NONE_ERROR;
    6420:	7000      	lod	A, #0
    6422:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

00006426 <.LM20>:
	valve.comm.faultMode = 0;
    6426:	42d8 122b 	mov	0x122b <.Lframe0+0x3>, AL

0000642a <.LM21>:
	MotClearFaultFlag(0);
    642a:	82db 3e59 	callf	0x7cb2 <_MotClearFaultFlag>

0000642e <.LM22>:
	MotClearStallFlag(0);
    642e:	0ea7      	lod	C, ML.7
    6430:	7000      	lod	A, #0
    6432:	82db 3e4a 	callf	0x7c94 <_MotClearStallFlag>

00006436 <.LM23>:
	valve.pos.fault = 0;
	valve.diag.gmr.state = 0;
	valve.diag.McuFault = 0;

	valve.diag.motOcRetryCnt = 0;
    6436:	6000      	lod	AL, #0
    6438:	42d8 1269 	mov	0x1269 <.LLST4+0x3>, AL

0000643c <.LM24>:
{
	u16EventState = NONE_ERROR;
	valve.comm.faultMode = 0;
	MotClearFaultFlag(0);
	MotClearStallFlag(0);
	valve.pos.fault = 0;
    643c:	0ea7      	lod	C, ML.7
    643e:	7000      	lod	A, #0
    6440:	52d8 1212 	mov	0x1212 <.LASF1440+0x6>, A

00006444 <.LM25>:
	valve.diag.gmr.state = 0;
    6444:	52d8 1254 	mov	0x1254 <.LLST3+0x1>, A

00006448 <.LM26>:
	valve.diag.McuFault = 0;
    6448:	0ea7      	lod	C, ML.7
    644a:	52d8 125e 	mov	0x125e <.LLST3+0xb>, A

0000644e <.LM27>:

	valve.diag.motOcRetryCnt = 0;
	valve.diag.ObstructionRetryCnt = 0;
	valve.pos.retryCnt = 0;
	valve.diag.gmr.retryCnt = 0;
	valve.diag.mcuRetryCnt = 0;
    644e:	42d8 1260 	mov	0x1260 <.LASF1020+0x1>, AL

00006452 <.LM28>:
	valve.diag.vs.UVretryCnt = 0;
    6452:	52d8 1244 	mov	0x1244 <.LLST1+0x4>, A

00006456 <.LM29>:
	valve.diag.vs.OVretryCnt = 0;
	valve.diag.temp.retryCnt = 0;
    6456:	0ea7      	lod	C, ML.7
    6458:	52d8 1248 	mov	0x1248 <.LLST1+0x8>, A

0000645c <.LM30>:
}
    645c:	5401      	ret

0000645e <_ValveErrorReset>:
	} diag;
} valve;

static void ValveErrorReset(void)
{
	if (valve.state == VALVE_PROTECTION)
    645e:	72d8 11fc 	lod	A, 0x11fc <_valve>
    6462:	ac07      	cmp	A, #7
    6464:	1d12      	jne	0x648a <.L21>

00006466 <.LM33>:
	{

		valve.diag.motOcRetryCnt = 0;
    6466:	6000      	lod	AL, #0
    6468:	42d8 1269 	mov	0x1269 <.LLST4+0x3>, AL

0000646c <.LM34>:
		valve.diag.ObstructionRetryCnt = 0;
    646c:	42d8 1260 	mov	0x1260 <.LASF1020+0x1>, AL

00006470 <.LM35>:
		valve.pos.retryCnt = 0;
    6470:	0ea7      	lod	C, ML.7
    6472:	42d8 1213 	mov	0x1213 <.LASF1440+0x7>, AL

00006476 <.LM36>:
		valve.diag.gmr.retryCnt = 0;
    6476:	42d8 1255 	mov	0x1255 <.LLST3+0x2>, AL

0000647a <.LM37>:
		valve.diag.mcuRetryCnt = 0;
    647a:	42d8 125f 	mov	0x125f <.LASF1020>, AL

0000647e <.LM38>:
		valve.diag.vs.UVretryCnt = 0;
    647e:	0ea7      	lod	C, ML.7
    6480:	7000      	lod	A, #0
    6482:	52d8 1244 	mov	0x1244 <.LLST1+0x4>, A

00006486 <.LM39>:
		valve.diag.vs.OVretryCnt = 0;
		valve.diag.temp.retryCnt = 0;
    6486:	52d8 1248 	mov	0x1248 <.LLST1+0x8>, A

0000648a <.L21>:
	}
	if (valve.state == VALVE_FAULT)
	{
	}
}
    648a:	5401      	ret

0000648c <_check_fault_mode>:
	return nextState;
}
static uint16_t check_fault_mode(void)
{
	uint16_t status = 0;
	if (valve.motorMotion == MOTION_FAULT)
    648c:	72d8 1208 	lod	A, 0x1208 <.LLST13+0x6>
    6490:	ac07      	cmp	A, #7
    6492:	1d05      	jne	0x649e <.L24>

00006494 <.LM43>:

		if ((valve.diag.motorFault & FAULT_MASK_PHASE_A_OPEN) != 0)
		{
			status = 1;
		}
		else if ((valve.diag.motorFault & FAULT_MASK_PHASE_A_SHORT) != 0)
    6494:	62d8 1265 	lod	AL, 0x1265 <.LASF1020+0x6>
    6498:	9411      	and	AL, #17

0000649a <.LM44>:
		{
			status = 1;
    649a:	5ca2      	sne	A
    649c:	5401      	ret

0000649e <.L24>:
		else
		{
			status = 0;
		}
	}
	else if (valve.motorMotion == MOTION_STALL)
    649e:	ac06      	cmp	A, #6
    64a0:	1d0a      	jne	0x64b6 <.L27>

000064a2 <.LM46>:
	{

		if (valve.state != VALVE_CALIBRATION)
    64a2:	72d8 11fc 	lod	A, 0x11fc <_valve>
    64a6:	ac05      	cmp	A, #5
    64a8:	1906      	je	0x64b6 <.L27>

000064aa <.LBB121>:
		{
			if ((valve.diag.stallFault & STALL_MASK_PERMENT) != 0)
    64aa:	62d8 1266 	lod	AL, 0x1266 <.LLST4>
    64ae:	4430      	lsr	AL
    64b0:	9401      	and	AL, #1
    64b2:	5cf2      	usex	A
    64b4:	5401      	ret

000064b6 <.L27>:
			status = 0;
		}
	}
	else
	{
		status = 0;
    64b6:	7000      	lod	A, #0

000064b8 <.LM49>:
	}
	return status;
}
    64b8:	5401      	ret

000064ba <_ValveLinGetCommand>:
}
void ValveLinGetCommand(void)
{
	int16_t pos;

	valve.comm.Enable = l_bool_rd_Fwv_MoveEnable();
    64ba:	62d8 1195 	lod	AL, 0x1195 <_l_signals+0x1>
    64be:	42d8 1225 	mov	0x1225 <.LLST14+0xc>, AL

000064c2 <.LBB122>:
 * Define API functions using templates
 */

L_SIGNAL(l_u8, Fwv_Target_Mode)
L_SIGNAL(l_bool, Fwv_MoveEnable)
L_SIGNAL(l_bool, Fwv_Initial)
    64c2:	66d8 1196 	lod	YL, 0x1196 <_l_signals+0x2>

000064c6 <.LBE122>:

	if (l_bool_rd_Fwv_Initial() != valve.comm.Initial)
    64c6:	0ea7      	lod	C, ML.7
    64c8:	62d8 1226 	lod	AL, 0x1226 <.LLST14+0xd>
    64cc:	8ee8      	cmp	AL, YL
    64ce:	1909      	je	0x64e2 <.L30>

000064d0 <.LBB124>:
    64d0:	62d8 1196 	lod	AL, 0x1196 <_l_signals+0x2>

000064d4 <.LBE124>:
	{
		valve.comm.Initial = l_bool_rd_Fwv_Initial();
    64d4:	42d8 1226 	mov	0x1226 <.LLST14+0xd>, AL

000064d8 <.LM56>:
		if (valve.comm.Initial)
    64d8:	1904      	je	0x64e2 <.L30>

000064da <.LM57>:
		{
			valve.calibration.req2Cal = 1;
    64da:	6001      	lod	AL, #1
    64dc:	42d8 1216 	mov	0x1216 <.LASF1440+0xa>, AL

000064e0 <.LM58>:
			ValveFaultReset();
    64e0:	179f      	call	0x6420 <_ValveFaultReset>

000064e2 <.L30>:
L_SIGNAL(l_bool, Fwv_ForcedDiag)
    64e2:	62d8 1197 	lod	AL, 0x1197 <_l_signals+0x3>

000064e6 <.LBE126>:
		}
	}

	valve.comm.ForcedDiag = l_bool_rd_Fwv_ForcedDiag();
    64e6:	42d8 1227 	mov	0x1227 <.LLST14+0xe>, AL

000064ea <.LM61>:

	if ((valve.comm.ForcedDiag == 0) && (valve.comm.Enable != 0))
    64ea:	1d0f      	jne	0x650a <.L28>

000064ec <.LM62>:
    64ec:	62d8 1225 	lod	AL, 0x1225 <.LLST14+0xc>
    64f0:	190c      	je	0x650a <.L28>

000064f2 <.LBB128>:

/*
 * Define API functions using templates
 */

L_SIGNAL(l_u8, Fwv_Target_Mode)
    64f2:	62d8 1194 	lod	AL, 0x1194 <_l_signals>

000064f6 <.LBE128>:
	{

		valve.comm.targetMode = l_u8_rd_Fwv_Target_Mode();
    64f6:	42d8 1224 	mov	0x1224 <.LLST14+0xb>, AL

000064fa <.LM65>:
		if (valve.comm.targetMode == C_MODE_A)
    64fa:	66e0      	lod	YL, AL
    64fc:	5cf6      	usex	Y
    64fe:	8c00      	cmp	AL, #0
    6500:	1d05      	jne	0x650c <.L35>

00006502 <.LBB130>:

#endif
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    6502:	72d8 120e 	lod	A, 0x120e <.LASF1440+0x2>

00006506 <.L42>:
    6506:	52d8 120a 	mov	0x120a <.LLST13+0x8>, A

0000650a <.L28>:
#endif
	}
	else
	{
	}
}
    650a:	5401      	ret

0000650c <.L35>:
		if (valve.comm.targetMode == C_MODE_A)
		{
			pos = valve.pos.modeAngle[C_MODE_A];
			ValveTargetAngleUpdate(pos);
		}
		else if (valve.comm.targetMode == C_MODE_B)
    650c:	ec01      	cmp	Y, #1
    650e:	1d7d      	jne	0x650a <.L28>

00006510 <.LM69>:

#endif
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    6510:	72d8 1210 	lod	A, 0x1210 <.LASF1440+0x4>
    6514:	07f8      	jmp	0x6506 <.L42>

00006516 <_ValveLinUpdateSignals>:
	else
	{
	}
}
void ValveLinUpdateSignals(void) /*20250714*/
{
    6516:	5803      	inc	S, #4

00006518 <.LBB136>:
L_SIGNAL(l_bool, Fwv_MoveEnable)
L_SIGNAL(l_bool, Fwv_Initial)
L_SIGNAL(l_bool, Fwv_ForcedDiag)
L_SIGNAL(l_u8, Fwv_Reserved1)
L_SIGNAL(l_u8, Fwv_Actual_Mode)
    6518:	62d8 1229 	lod	AL, 0x1229 <.Lframe0+0x1>
    651c:	42d8 1199 	mov	0x1199 <_l_signals+0x5>, AL

00006520 <.LBE136>:
	/* Byte 0 */
	l_u8_wr_Fwv_Actual_Mode(valve.comm.actualMode);

	l_bool_wr_Fwv_Position_Fault(valve.pos.fault);
    6520:	62d8 1212 	lod	AL, 0x1212 <.LASF1440+0x6>
    6524:	5ca2      	sne	A

00006526 <.LBB138>:
L_SIGNAL(l_bool, Fwv_Position_Fault)
    6526:	42d8 119a 	mov	0x119a <_l_signals+0x6>, AL

0000652a <.LBE138>:
	//	if (valve.state==VALVE_FAULT)
	if (valve.comm.faultMode != 0) /*20250714*/
    652a:	62d8 122b 	lod	AL, 0x122b <.Lframe0+0x3>
    652e:	66e0      	lod	YL, AL
    6530:	5cf6      	usex	Y
    6532:	7ee6      	lod	X, Y
    6534:	8c00      	cmp	AL, #0
    6536:	190f      	je	0x6556 <.L44>

00006538 <.LBB140>:
L_SIGNAL(l_bool, Fwv_FaultMode)
    6538:	6401      	lod	YL, #1
    653a:	46d8 119b 	mov	0x119b <_l_signals+0x7>, YL

0000653e <.L45>:
	}
	else
	{
		l_bool_wr_Fwv_FaultMode(0);
	}
	if (valve.state == VALVE_PROTECTION)
    653e:	7ad8 11fc 	lod	Y, 0x11fc <_valve>
    6542:	5a03      	mov	[S-4], Y
    6544:	ec07      	cmp	Y, #7
    6546:	1d0c      	jne	0x6560 <.L46>

00006548 <.LM77>:
	{
		if (valve.comm.faultMode == 0) /*20250714*/
    6548:	2c00      	cmp	X, #0
    654a:	1d08      	jne	0x655c <.L47>

0000654c <.LBB142>:
L_SIGNAL(l_bool, Fwv_ProtectMode)
    654c:	6401      	lod	YL, #1

0000654e <.L91>:
    654e:	46d8 119c 	mov	0x119c <_l_signals+0x8>, YL

00006552 <.L48>:
L_SIGNAL(l_bool, Fwv_InitialSta)
    6552:	6400      	lod	YL, #0
    6554:	000c      	jmp	0x656e <.L92>

00006556 <.L44>:
L_SIGNAL(l_bool, Fwv_Initial)
L_SIGNAL(l_bool, Fwv_ForcedDiag)
L_SIGNAL(l_u8, Fwv_Reserved1)
L_SIGNAL(l_u8, Fwv_Actual_Mode)
L_SIGNAL(l_bool, Fwv_Position_Fault)
L_SIGNAL(l_bool, Fwv_FaultMode)
    6556:	42d8 119b 	mov	0x119b <_l_signals+0x7>, AL
    655a:	07f1      	jmp	0x653e <.L45>

0000655c <.L47>:
L_SIGNAL(l_bool, Fwv_ProtectMode)
    655c:	6400      	lod	YL, #0
    655e:	07f7      	jmp	0x654e <.L91>

00006560 <.L46>:
    6560:	6400      	lod	YL, #0
    6562:	46d8 119c 	mov	0x119c <_l_signals+0x8>, YL

00006566 <.LBE153>:
	}
	else
	{
		l_bool_wr_Fwv_ProtectMode(0);
	}
	if (valve.state == VALVE_CALIBRATION)
    6566:	7a03      	lod	Y, [S-4]
    6568:	ec05      	cmp	Y, #5
    656a:	1d73      	jne	0x6552 <.L48>

0000656c <.LBB155>:
L_SIGNAL(l_bool, Fwv_InitialSta)
    656c:	6401      	lod	YL, #1

0000656e <.L92>:
    656e:	46d8 119d 	mov	0x119d <_l_signals+0x9>, YL

00006572 <.LM84>:
	}
	else
	{
		l_bool_wr_Fwv_InitialSta(0);
	}
	if (valve.comm.faultMode != 0) /*20250714*/
    6572:	2c00      	cmp	X, #0
    6574:	1904      	je	0x657e <.L50>

00006576 <.LM85>:
	{
		if (valve.diag.calFault != 0)
    6576:	62d8 1264 	lod	AL, 0x1264 <.LASF1020+0x5>
    657a:	1901      	je	0x657e <.L50>

0000657c <.LBB158>:
L_SIGNAL(l_bool, Fwv_Calibration_Fail)
    657c:	6001      	lod	AL, #1

0000657e <.L50>:
    657e:	42d8 119e 	mov	0x119e <_l_signals+0xa>, AL

00006582 <.LBE160>:
	{
		l_bool_wr_Fwv_Calibration_Fail(0);
	}

	/* Byte 1 */
	l_bool_wr_Fwv_MoveEnable_Status(valve.comm.moving);
    6582:	62d8 122a 	lod	AL, 0x122a <.Lframe0+0x2>
    6586:	5ca2      	sne	A

00006588 <.LBB162>:
L_SIGNAL(l_bool, Fwv_MoveEnable_Status)
    6588:	42d8 119f 	mov	0x119f <_l_signals+0xb>, AL

0000658c <.LVL35>:
    658c:	62d8 1266 	lod	AL, 0x1266 <.LLST4>
    6590:	66e0      	lod	YL, AL
    6592:	5cf6      	usex	Y
    6594:	5a01      	mov	[S-2], Y

00006596 <.LBE162>:

	if (valve.motorMotion == MOTION_FAULT) /*20250714*/
    6596:	7ad8 1208 	lod	Y, 0x1208 <.LLST13+0x6>
    659a:	ec07      	cmp	Y, #7
    659c:	1d23      	jne	0x65e4 <.L53>

0000659e <.LM90>:
	{
		if ((valve.diag.stallFault != 0) && (valve.comm.faultMode != 0))
    659e:	7201      	lod	A, [S-2]
    65a0:	1904      	je	0x65aa <.L54>

000065a2 <.LM91>:
    65a2:	2c00      	cmp	X, #0
    65a4:	1902      	je	0x65aa <.L54>

000065a6 <.L100>:
L_SIGNAL(l_bool, Fwv_Motor_Stall)
    65a6:	6001      	lod	AL, #1
    65a8:	0001      	jmp	0x65ac <.L93>

000065aa <.L54>:
    65aa:	6000      	lod	AL, #0

000065ac <.L93>:
    65ac:	42d8 11a0 	mov	0x11a0 <_l_signals+0xc>, AL

000065b0 <.L55>:
		{
			l_bool_wr_Fwv_Motor_Stall(0);
		}
	}

	if (((valve.diag.motorFault & FAULT_MASK_PHASE_A_OPEN) != 0) && (valve.comm.faultMode != 0)) /*20250714*/
    65b0:	62d8 1265 	lod	AL, 0x1265 <.LASF1020+0x6>
    65b4:	4201      	mov	[S-2], AL
    65b6:	9401      	and	AL, #1
    65b8:	191c      	je	0x65f2 <.L57>

000065ba <.LM94>:
    65ba:	2c00      	cmp	X, #0
    65bc:	191a      	je	0x65f2 <.L57>

000065be <.LBB168>:
L_SIGNAL(l_bool, Fwv_Short_Circuit)
L_SIGNAL(l_bool, Fwv_Open_Circuit)
    65be:	6001      	lod	AL, #1

000065c0 <.L94>:
    65c0:	42d8 11a2 	mov	0x11a2 <_l_signals+0xe>, AL

000065c4 <.LBE170>:
	}
	else
	{
		l_bool_wr_Fwv_Open_Circuit(0);
	}
	if (((valve.diag.motorFault & FAULT_MASK_PHASE_A_SHORT) != 0) && (valve.comm.faultMode != 0)) /*20250714*/
    65c4:	6201      	lod	AL, [S-2]
    65c6:	9410      	and	AL, #16
    65c8:	1916      	je	0x65f6 <.L59>

000065ca <.LM97>:
    65ca:	2c00      	cmp	X, #0
    65cc:	1914      	je	0x65f6 <.L59>

000065ce <.LBB173>:
L_SIGNAL(l_bool, Fwv_ProtectMode)
L_SIGNAL(l_bool, Fwv_InitialSta)
L_SIGNAL(l_bool, Fwv_Calibration_Fail)
L_SIGNAL(l_bool, Fwv_MoveEnable_Status)
L_SIGNAL(l_bool, Fwv_Motor_Stall)
L_SIGNAL(l_bool, Fwv_Short_Circuit)
    65ce:	6001      	lod	AL, #1

000065d0 <.L95>:
    65d0:	42d8 11a1 	mov	0x11a1 <_l_signals+0xd>, AL

000065d4 <.LBE175>:
	else
	{
		l_bool_wr_Fwv_Short_Circuit(0);
	}

	if (valve.diag.vs.state == VS_NORMAL)
    65d4:	72d8 123c 	lod	A, 0x123c <.LASF2154+0x3>
    65d8:	1d10      	jne	0x65fa <.L61>

000065da <.LBB178>:
L_SIGNAL(l_bool, Fwv_Open_Circuit)
L_SIGNAL(l_bool, Fwv_Undervoltage)
    65da:	42d8 11a3 	mov	0x11a3 <_l_signals+0xf>, AL

000065de <.L96>:
L_SIGNAL(l_bool, Fwv_Overvoltage)
    65de:	42d8 11a4 	mov	0x11a4 <_l_signals+0x10>, AL
    65e2:	0013      	jmp	0x660a <.L62>

000065e4 <.L53>:
			l_bool_wr_Fwv_Motor_Stall(0);
		}
	}
	else
	{
		if ((valve.diag.stallFault & STALL_MASK_TEMPORARY) != 0)
    65e4:	9401      	and	AL, #1
    65e6:	66e0      	lod	YL, AL
    65e8:	9401      	and	AL, #1
    65ea:	1d5d      	jne	0x65a6 <.L100>

000065ec <.LBB183>:
L_SIGNAL(l_bool, Fwv_FaultMode)
L_SIGNAL(l_bool, Fwv_ProtectMode)
L_SIGNAL(l_bool, Fwv_InitialSta)
L_SIGNAL(l_bool, Fwv_Calibration_Fail)
L_SIGNAL(l_bool, Fwv_MoveEnable_Status)
L_SIGNAL(l_bool, Fwv_Motor_Stall)
    65ec:	46d8 11a0 	mov	0x11a0 <_l_signals+0xc>, YL
    65f0:	07df      	jmp	0x65b0 <.L55>

000065f2 <.L57>:
L_SIGNAL(l_bool, Fwv_Short_Circuit)
L_SIGNAL(l_bool, Fwv_Open_Circuit)
    65f2:	6000      	lod	AL, #0
    65f4:	07e5      	jmp	0x65c0 <.L94>

000065f6 <.L59>:
L_SIGNAL(l_bool, Fwv_ProtectMode)
L_SIGNAL(l_bool, Fwv_InitialSta)
L_SIGNAL(l_bool, Fwv_Calibration_Fail)
L_SIGNAL(l_bool, Fwv_MoveEnable_Status)
L_SIGNAL(l_bool, Fwv_Motor_Stall)
L_SIGNAL(l_bool, Fwv_Short_Circuit)
    65f6:	6000      	lod	AL, #0
    65f8:	07eb      	jmp	0x65d0 <.L95>

000065fa <.L61>:
    65fa:	6400      	lod	YL, #0

000065fc <.LM106>:
	if (valve.diag.vs.state == VS_NORMAL)
	{
		l_bool_wr_Fwv_Undervoltage(0);
		l_bool_wr_Fwv_Overvoltage(0);
	}
	else if (valve.diag.vs.state == VS_UNDERVOLTAGE)
    65fc:	ac01      	cmp	A, #1
    65fe:	1901      	je	0x6602 <.LBB187>
    6600:	0036      	jmp	0x666e <.L63>

00006602 <.LBB187>:
L_SIGNAL(l_bool, Fwv_Open_Circuit)
L_SIGNAL(l_bool, Fwv_Undervoltage)
    6602:	42d8 11a3 	mov	0x11a3 <_l_signals+0xf>, AL

00006606 <.LBB189>:
L_SIGNAL(l_bool, Fwv_Overvoltage)
    6606:	46d8 11a4 	mov	0x11a4 <_l_signals+0x10>, YL

0000660a <.L62>:
	}
	else
	{
	}

	if ((valve.diag.motorFault & FAULT_MASK_OVER_CURRENT) != 0)
    660a:	6201      	lod	AL, [S-2]
    660c:	9440      	and	AL, #64
    660e:	66e0      	lod	YL, AL
    6610:	6201      	lod	AL, [S-2]
    6612:	9440      	and	AL, #64
    6614:	1932      	je	0x667a <.L64>

00006616 <.LBB191>:
L_SIGNAL(l_bool, Fwv_Overcurrent)
    6616:	6001      	lod	AL, #1
    6618:	42d8 11a5 	mov	0x11a5 <_l_signals+0x11>, AL

0000661c <.L65>:
	else
	{
		l_bool_wr_Fwv_Overcurrent(0);
	}

	if (valve.diag.temp.state == TEMPERATURE_HIGH)
    661c:	72d8 1246 	lod	A, 0x1246 <.LLST1+0x6>
    6620:	ac02      	cmp	A, #2
    6622:	1d2e      	jne	0x6680 <.L66>

00006624 <.LBB193>:
L_SIGNAL(l_bool, Fwv_Overtemperature)
    6624:	6001      	lod	AL, #1

00006626 <.L97>:
    6626:	42d8 11a6 	mov	0x11a6 <_l_signals+0x12>, AL

0000662a <.LBE195>:
	{
		l_bool_wr_Fwv_Overtemperature(0);
	}

	/* Byte 2 [2..0] */
	if (valve.state == VALVE_DIAGRUN)
    662a:	7a03      	lod	Y, [S-4]
    662c:	ec04      	cmp	Y, #4
    662e:	1d2a      	jne	0x6684 <.L68>

00006630 <.LBB198>:
L_SIGNAL(l_bool, Fwv_Diag_Forced_Status)
    6630:	6001      	lod	AL, #1

00006632 <.L98>:
    6632:	42d8 11a7 	mov	0x11a7 <_l_signals+0x13>, AL

00006636 <.LBE200>:
	}
	else
	{
		l_bool_wr_Fwv_Diag_Forced_Status(0);
	}
	l_bool_wr_Fwv_Position_Sensor_Fault(valve.diag.gmr.state);
    6636:	62d8 1254 	lod	AL, 0x1254 <.LLST3+0x1>
    663a:	5ca2      	sne	A

0000663c <.LBB203>:
L_SIGNAL(l_bool, Fwv_Position_Sensor_Fault)
    663c:	42d8 11a8 	mov	0x11a8 <_l_signals+0x14>, AL

00006640 <.LBE203>:
	l_bool_wr_Fwv_CommErr(valve.diag.linError);
    6640:	62d8 125c 	lod	AL, 0x125c <.LLST3+0x9>
    6644:	5ca2      	sne	A

00006646 <.LBB205>:
L_SIGNAL(l_bool, Fwv_CommErr)
    6646:	42d8 11a9 	mov	0x11a9 <.LASF1418>, AL

0000664a <.LBE205>:
	valve.diag.linError = 0;
    664a:	6000      	lod	AL, #0
    664c:	42d8 125c 	mov	0x125c <.LLST3+0x9>, AL

00006650 <.LBB207>:
L_SIGNAL(l_u16, Fwv_SW_Version)
    6650:	0ea7      	lod	C, ML.7
    6652:	7801      	lod	Y, #1
    6654:	5ad8 11aa 	mov	0x11aa <.LASF1418+0x1>, Y

00006658 <.LBE207>:
	/* Byte 2 [7..3] and Byte 3 ~ 4*/
	l_u16_wr_Fwv_SW_Version(SW_VERSION);
#if 1
	int16_t pos = valve.pos.currentAngle;
    6658:	7ed8 120c 	lod	X, 0x120c <.LASF1440>
    665c:	5e01      	mov	[S-2], X

0000665e <.LM122>:
	if (pos >= (valve.pos.modeAngle[C_MODE_A] - (int16_t)C_VALVE_ACCURACY_ANGLE))
    665e:	7ed8 120e 	lod	X, 0x120e <.LASF1440+0x2>

00006662 <.LVL65>:
    6662:	20ec      	add	X, #-20
    6664:	2e01      	cmp	X, [S-2]
    6666:	1f10      	jsg	0x6688 <.L70>

00006668 <.L99>:
L_SIGNAL(l_u8, Fwv_Stall_State)
    6668:	42d8 11ac 	mov	0x11ac <.LASF1418+0x3>, AL
    666c:	5405      	ret	#6

0000666e <.L63>:
	else if (valve.diag.vs.state == VS_UNDERVOLTAGE)
	{
		l_bool_wr_Fwv_Undervoltage(1);
		l_bool_wr_Fwv_Overvoltage(0);
	}
	else if (valve.diag.vs.state == VS_OVERVOLTAGE)
    666e:	ac02      	cmp	A, #2
    6670:	1d4c      	jne	0x660a <.L62>

00006672 <.LBB211>:
L_SIGNAL(l_bool, Fwv_Calibration_Fail)
L_SIGNAL(l_bool, Fwv_MoveEnable_Status)
L_SIGNAL(l_bool, Fwv_Motor_Stall)
L_SIGNAL(l_bool, Fwv_Short_Circuit)
L_SIGNAL(l_bool, Fwv_Open_Circuit)
L_SIGNAL(l_bool, Fwv_Undervoltage)
    6672:	46d8 11a3 	mov	0x11a3 <_l_signals+0xf>, YL

00006676 <.LBE211>:
L_SIGNAL(l_bool, Fwv_Overvoltage)
    6676:	6001      	lod	AL, #1
    6678:	07b2      	jmp	0x65de <.L96>

0000667a <.L64>:
L_SIGNAL(l_bool, Fwv_Overcurrent)
    667a:	46d8 11a5 	mov	0x11a5 <_l_signals+0x11>, YL
    667e:	07ce      	jmp	0x661c <.L65>

00006680 <.L66>:
L_SIGNAL(l_bool, Fwv_Overtemperature)
    6680:	6000      	lod	AL, #0
    6682:	07d1      	jmp	0x6626 <.L97>

00006684 <.L68>:
L_SIGNAL(l_bool, Fwv_Diag_Forced_Status)
    6684:	6000      	lod	AL, #0
    6686:	07d5      	jmp	0x6632 <.L98>

00006688 <.L70>:
	int16_t pos = valve.pos.currentAngle;
	if (pos >= (valve.pos.modeAngle[C_MODE_A] - (int16_t)C_VALVE_ACCURACY_ANGLE))
	{
		l_u8_wr_Fwv_Stall_State(0);
	}
	else if (pos <= (valve.pos.modeAngle[C_MODE_B] + (int16_t)C_VALVE_ACCURACY_ANGLE))
    6688:	7ed8 1210 	lod	X, 0x1210 <.LASF1440+0x4>
    668c:	2014      	add	X, #20
    668e:	2e01      	cmp	X, [S-2]
    6690:	1eeb      	jsge	0x6668 <.L99>

00006692 <.LBB218>:
L_SIGNAL(l_bool, Fwv_Position_Sensor_Fault)
L_SIGNAL(l_bool, Fwv_CommErr)
L_SIGNAL(l_u16, Fwv_SW_Version)
L_SIGNAL(l_u8, Fwv_Stall_State)
    6692:	46d8 11ac 	mov	0x11ac <.LASF1418+0x3>, YL

00006696 <.LBE218>:

		l_u8_wr_Fwv_Stall_State(3);
	}

#endif
}
    6696:	5405      	ret	#6

00006698 <_get_valve_mode>:
	return status;
}
tValveState get_valve_mode(void)
{
	return valve.state;
}
    6698:	72d8 11fc 	lod	A, 0x11fc <_valve>
    669c:	5401      	ret

0000669e <_get_valve_voltage>:
uint16_t get_valve_voltage(void)
{
	return valve.diag.vs.voltage;
}
    669e:	72d8 123e 	lod	A, 0x123e <.LASF2154+0x5>
    66a2:	5401      	ret

000066a4 <_get_valve_temperature>:
int16_t get_valve_temperature(void)
{
	return valve.diag.temp.deg;
}
    66a4:	72d8 124a 	lod	A, 0x124a <.LLST1+0xa>
    66a8:	5401      	ret

000066aa <_get_valve_motCurrent>:
uint16_t get_valve_motCurrent(void)
{
	return valve.diag.motorCurrent;
}
    66aa:	72d8 125a 	lod	A, 0x125a <.LLST3+0x7>
    66ae:	5401      	ret

000066b0 <_AppValveInit>:

void AppValveInit(void)
{

	valve.state = VALVE_INIT;
    66b0:	7000      	lod	A, #0
    66b2:	52d8 11fc 	mov	0x11fc <_valve>, A

000066b6 <.LM151>:
	valve.lastState = VALVE_INIT;
    66b6:	52d8 11fe 	mov	0x11fe <_valve+0x2>, A

000066ba <.LM152>:
	valve.elapsedTime = 0;
    66ba:	0ea7      	lod	C, ML.7
    66bc:	52d8 1202 	mov	0x1202 <.LLST13>, A

000066c0 <.LM153>:
	valve.sleepState = 0;
    66c0:	52d8 1206 	mov	0x1206 <.LLST13+0x4>, A

000066c4 <.LM154>:
	valve.initStatus = 0;
	valve.linLiveTimeOut = 4000;
    66c4:	7eda 0fa0 	lod	X, #4000
    66c8:	0ea7      	lod	C, ML.7
    66ca:	5ed8 1200 	mov	0x1200 <_valve+0x4>, X

000066ce <.LM155>:
	valve.pos.currentAngle = 0;
	valve.pos.targetAngle = 0;
    66ce:	52d8 120a 	mov	0x120a <.LLST13+0x8>, A
    66d2:	52d8 120c 	mov	0x120c <.LASF1440>, A

000066d6 <.LM156>:
	valve.lastState = VALVE_INIT;
	valve.elapsedTime = 0;
	valve.sleepState = 0;
	valve.initStatus = 0;
	valve.linLiveTimeOut = 4000;
	valve.pos.currentAngle = 0;
    66d6:	0ea7      	lod	C, ML.7
    66d8:	7eda 0b45 	lod	X, #2885
    66dc:	5ed8 120e 	mov	0x120e <.LASF1440+0x2>, X

000066e0 <.LM157>:
	valve.pos.targetAngle = 0;
	valve.pos.modeAngle[C_MODE_A] = (int16_t)C_VALVE_MODE_A_ANGLE;
    66e0:	7eda 07c1 	lod	X, #1985
    66e4:	0ea7      	lod	C, ML.7
    66e6:	5ed8 1210 	mov	0x1210 <.LASF1440+0x4>, X

000066ea <.LM158>:
	valve.pos.modeAngle[C_MODE_B] = (int16_t)C_VALVE_MODE_B_ANGLE;
    66ea:	52d8 1212 	mov	0x1212 <.LASF1440+0x6>, A

000066ee <.LM159>:
	valve.pos.fault = 0;
	valve.pos.retryCnt = 0;

	valve.calibration.req2Cal = 0;
    66ee:	42d8 1216 	mov	0x1216 <.LASF1440+0xa>, AL

000066f2 <.LM160>:
	valve.calibration.req1Cal = 0;
    66f2:	0ea7      	lod	C, ML.7
    66f4:	42d8 1217 	mov	0x1217 <.LASF1440+0xb>, AL

000066f8 <.LM161>:
	valve.calibration.offsetDone = 0;
    66f8:	42d8 1215 	mov	0x1215 <.LASF1440+0x9>, AL

000066fc <.LM162>:
	valve.comm.ForcedDiag = 0;
	valve.comm.targetMode = 0xFFu;
	valve.comm.lastMode = 0xFFu;
	valve.comm.actualMode = C_MODE_B;
	valve.comm.moving = 0;
	valve.comm.timeOut = 5000;
    66fc:	7eda 1388 	lod	X, #5000
    6700:	0ea7      	lod	C, ML.7
    6702:	5ed8 1222 	mov	0x1222 <.LLST14+0x9>, X
    6706:	7eda 00ff 	lod	X, #255
    670a:	5ed8 1224 	mov	0x1224 <.LLST14+0xb>, X

0000670e <.LM163>:
	valve.calibration.req2Cal = 0;
	valve.calibration.req1Cal = 0;
	valve.calibration.offsetDone = 0;

	valve.comm.Initial = 0;
	valve.comm.Enable = 0;
    670e:	0ea7      	lod	C, ML.7
    6710:	52d8 1226 	mov	0x1226 <.LLST14+0xd>, A

00006714 <.LM164>:
	valve.comm.ForcedDiag = 0;
    6714:	7eda 01ff 	lod	X, #511
    6718:	5ed8 1228 	mov	0x1228 <.Lframe0>, X

0000671c <.LM165>:
	valve.comm.targetMode = 0xFFu;
	valve.comm.lastMode = 0xFFu;
	valve.comm.actualMode = C_MODE_B;
    671c:	0ea7      	lod	C, ML.7
    671e:	52d8 122a 	mov	0x122a <.Lframe0+0x2>, A

00006722 <.LM166>:
	valve.comm.moving = 0;
	valve.comm.timeOut = 5000;
	valve.comm.faultMode = 0;

	valve.diag.protType = NONE_ERROR;
    6722:	52d8 1262 	mov	0x1262 <.LASF1020+0x3>, A

00006726 <.LM167>:
	valve.diag.calFault = 0;
	valve.diag.motorFault = 0;
	valve.diag.stallFault = 0;
	valve.diag.McuFault = 0;
	valve.diag.mcuRetryCnt = 0;
	valve.diag.vs.state = VS_UNDEF;
    6726:	7c03      	lod	X, #3
    6728:	0ea7      	lod	C, ML.7
    672a:	5ed8 123c 	mov	0x123c <.LASF2154+0x3>, X

0000672e <.LM168>:
	valve.diag.vs.UVretryCnt = 0;
    672e:	52d8 1244 	mov	0x1244 <.LLST1+0x4>, A

00006732 <.LM169>:
	valve.diag.vs.OVretryCnt = 0;
	valve.diag.ign.state = IGN_UNDEF;
    6732:	7802      	lod	Y, #2
    6734:	0ea7      	lod	C, ML.7
    6736:	5ad8 124e 	mov	0x124e <.LASF1845+0x1>, Y

0000673a <.LM170>:
	valve.diag.ign.uvTimer = 0;
	valve.diag.temp.state = TEMPERATURE_UNDEF;
    673a:	5ed8 1246 	mov	0x1246 <.LLST1+0x6>, X

0000673e <.LM171>:
	valve.diag.temp.retryCnt = 0;
    673e:	52d8 1248 	mov	0x1248 <.LLST1+0x8>, A

00006742 <.LM172>:
	valve.diag.mcuRetryCnt = 0;
	valve.diag.vs.state = VS_UNDEF;
	valve.diag.vs.UVretryCnt = 0;
	valve.diag.vs.OVretryCnt = 0;
	valve.diag.ign.state = IGN_UNDEF;
	valve.diag.ign.uvTimer = 0;
    6742:	0ea7      	lod	C, ML.7
    6744:	52d8 1252 	mov	0x1252 <.LASF1845+0x5>, A
    6748:	52d8 1254 	mov	0x1254 <.LLST3+0x1>, A

0000674c <.LM173>:
	valve.comm.moving = 0;
	valve.comm.timeOut = 5000;
	valve.comm.faultMode = 0;

	valve.diag.protType = NONE_ERROR;
	valve.diag.calFault = 0;
    674c:	52d8 1264 	mov	0x1264 <.LASF1020+0x5>, A

00006750 <.LM174>:
	valve.diag.motorFault = 0;
    6750:	0ea7      	lod	C, ML.7
    6752:	52d8 1266 	mov	0x1266 <.LLST4>, A

00006756 <.LM175>:
	valve.diag.ign.uvTimer = 0;
	valve.diag.temp.state = TEMPERATURE_UNDEF;
	valve.diag.temp.retryCnt = 0;
	valve.diag.gmr.state = 0;
	valve.diag.gmr.retryCnt = 0;
	valve.diag.stallRetryCnt = 0;
    6756:	52d8 1268 	mov	0x1268 <.LLST4+0x2>, A

0000675a <.LM176>:
	valve.diag.calRetryCnt = 0;
	valve.diag.ObstructionRetryCnt = 0;
	valve.diag.motOcRetryCnt = 0;
    675a:	52d8 126a 	mov	0x126a <.LLST4+0x4>, A

0000675e <.LM177>:
	valve.diag.motOpenRetryCnt = 0;
	valve.diag.motShortRetryCnt = 0;
	valve.diag.linError = 0;
    675e:	0ea7      	lod	C, ML.7
    6760:	52d8 125c 	mov	0x125c <.LLST3+0x9>, A

00006764 <.LM178>:
	valve.diag.linErrRetryCnt = 0;
    6764:	52d8 125e 	mov	0x125e <.LLST3+0xb>, A

00006768 <.LM179>:
	valve.diag.protType = NONE_ERROR;
	valve.diag.calFault = 0;
	valve.diag.motorFault = 0;
	valve.diag.stallFault = 0;
	valve.diag.McuFault = 0;
	valve.diag.mcuRetryCnt = 0;
    6768:	42d8 1260 	mov	0x1260 <.LASF1020+0x1>, AL

0000676c <.LM180>:
	valve.diag.motOcRetryCnt = 0;
	valve.diag.motOpenRetryCnt = 0;
	valve.diag.motShortRetryCnt = 0;
	valve.diag.linError = 0;
	valve.diag.linErrRetryCnt = 0;
	if (eeprom_ReadValveConfig(&valve_gmr_data))
    676c:	0ea7      	lod	C, ML.7
    676e:	72da 1324 	lod	A, #4900
    6772:	82db 433c 	callf	0x8678 <_eeprom_ReadValveConfig>
    6776:	ac00      	cmp	A, #0
    6778:	1913      	je	0x67a0 <.L109>

0000677a <.LM181>:
	{
		valve.memory.offset = (int16_t)valve_gmr_data.E1DATA0; // 250709-2 - EEPROM Load 1st -> Global Variables
    677a:	72d8 1324 	lod	A, 0x1324 <_valve_gmr_data>
    677e:	52d8 1234 	mov	0x1234 <.LLST15+0x8>, A

00006782 <.LM182>:
		if ((valve.memory.offset > 0) && (valve.memory.offset <= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT))
    6782:	7ee2      	lod	X, A
    6784:	20ff      	add	X, #-1
    6786:	2eda 0e0f 	cmp	X, #3599
    678a:	1e02      	jug	0x6790 <.L110>

0000678c <.LM183>:
		{

			set_gmr_sensor_offset(valve.memory.offset);
    678c:	82db 3bf8 	callf	0x77f0 <_set_gmr_sensor_offset>

00006790 <.L110>:
		}
		valve.memory.lastAngle = (int16_t)valve_gmr_data.E1DATA1; // 250709-2 - EEPROM Load 2nd -> Global Variables
		valve.memory.code_1 = valve_gmr_data.E1DATA2;			  // 250709-2 - EEPROM Load 3rd -> Global Variables
    6790:	7ada 1236 	lod	Y, #4662
    6794:	7eda 1326 	lod	X, #4902
    6798:	0ea7      	lod	C, ML.7
    679a:	54ce      	movsw	[Y++], [X++]
    679c:	0ea7      	lod	C, ML.7
    679e:	54ce      	movsw	[Y++], [X++]

000067a0 <.L109>:
	}
	else
	{
	}
	if (eeprom_ReadDiagConfig(&valve_diag_data))
    67a0:	72da 131e 	lod	A, #4894
    67a4:	82db 437d 	callf	0x86fa <_eeprom_ReadDiagConfig>
    67a8:	ac00      	cmp	A, #0
    67aa:	1912      	je	0x67d0 <.L108>

000067ac <.LM186>:
	{
		valve.memory.state = valve_diag_data.E1DATA0;
    67ac:	7ed8 131e 	lod	X, 0x131e <_valve_diag_data>
    67b0:	5ed8 122e 	mov	0x122e <.LLST15+0x2>, X

000067b4 <.LM187>:
		valve.memory.value = valve_diag_data.E1DATA1;
    67b4:	72d8 1320 	lod	A, 0x1320 <.LLST10>
    67b8:	0ea7      	lod	C, ML.7
    67ba:	52d8 1232 	mov	0x1232 <.LLST15+0x6>, A

000067be <.LM188>:
		valve.memory.code_2 = valve_diag_data.E1DATA2;
    67be:	7ad8 1322 	lod	Y, 0x1322 <.LLST10+0x2>
    67c2:	5ad8 123a 	mov	0x123a <.LASF2154+0x1>, Y

000067c6 <.LM189>:
		u16EventState = valve.memory.state;
    67c6:	0ea7      	lod	C, ML.7
    67c8:	5ed8 10b6 	mov	0x10b6 <_u16EventState>, X

000067cc <.LM190>:
		u16EventValue = valve.memory.value;
    67cc:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

000067d0 <.L108>:
	}
	else
	{
	}
}
    67d0:	5401      	ret

000067d2 <_AppValveTask>:
 * \brief Actuator task called by every 1ms
 *
 */

void AppValveTask(void)
{
    67d2:	5807      	inc	S, #8

000067d4 <.LBB278>:
	}
	return status;
}
static void valveDiagVs(void)
{
	valve.diag.vs.voltage = get_conv_supply_voltage();
    67d4:	82db 3c56 	callf	0x78ac <_get_conv_supply_voltage>

000067d8 <.LVL82>:
    67d8:	52d8 123e 	mov	0x123e <.LASF2154+0x5>, A

000067dc <.LM194>:
	switch (valve.diag.vs.state)
    67dc:	7ed8 123c 	lod	X, 0x123c <.LASF2154+0x3>
    67e0:	2c01      	cmp	X, #1
    67e2:	1d01      	jne	0x67e6 <.LASF1324+0x6>
    67e4:	0048      	jmp	0x6876 <.L120>
    67e6:	1807      	jc	0x67f6 <.L121>
    67e8:	2c02      	cmp	X, #2
    67ea:	1d01      	jne	0x67ee <.LM195>
    67ec:	0059      	jmp	0x68a0 <.L122>

000067ee <.LM195>:
				}
			}
			else
#endif
	{
		valve.diag.vs.uvTimer = 0u;
    67ee:	7000      	lod	A, #0
    67f0:	52d8 1240 	mov	0x1240 <.LLST1>, A
    67f4:	005f      	jmp	0x68b4 <.L538>

000067f6 <.L121>:
{
	valve.diag.vs.voltage = get_conv_supply_voltage();
	switch (valve.diag.vs.state)
	{
	case VS_NORMAL:
		if (valve.diag.vs.voltage <= VS_UNDER_STOP)
    67f6:	aeda 0320 	cmp	A, #800
    67fa:	1e21      	jug	0x683e <.L123>

000067fc <.LM197>:
		{
			valve.diag.vs.uvTimer++;
    67fc:	72d8 1240 	lod	A, 0x1240 <.LLST1>
    6800:	a001      	add	A, #1

00006802 <.LM198>:
			if (valve.diag.vs.uvTimer >= VS_ENTER_COUNT)
    6802:	aeda 03e7 	cmp	A, #999
    6806:	1e14      	jug	0x6830 <.L124>

00006808 <.LM199>:
	switch (valve.diag.vs.state)
	{
	case VS_NORMAL:
		if (valve.diag.vs.voltage <= VS_UNDER_STOP)
		{
			valve.diag.vs.uvTimer++;
    6808:	52d8 1240 	mov	0x1240 <.LLST1>, A

0000680c <.L125>:
	break;
	}
}
static void valveDiagTemp(void)
{
	valve.diag.temp.deg = get_conv_ic_temperature();
    680c:	82db 3c59 	callf	0x78b2 <_get_conv_ic_temperature>
    6810:	52d8 124a 	mov	0x124a <.LLST1+0xa>, A

00006814 <.LM201>:

	switch (valve.diag.temp.state)
    6814:	7ed8 1246 	lod	X, 0x1246 <.LLST1+0x6>
    6818:	2c01      	cmp	X, #1
    681a:	1d01      	jne	0x681e <.LM201+0xa>
    681c:	0061      	jmp	0x68e0 <.L135>
    681e:	1c01      	jnc	0x6822 <.LASF1064>
    6820:	004c      	jmp	0x68ba <.L136>
    6822:	2c02      	cmp	X, #2
    6824:	1d01      	jne	0x6828 <.L535>
    6826:	007f      	jmp	0x6926 <.L137>

00006828 <.L535>:

			}
			else
#endif
	{
		valve.diag.temp.timer = 0u;
    6828:	7000      	lod	A, #0
    682a:	52d8 124c 	mov	0x124c <.LLST1+0xc>, A
    682e:	0055      	jmp	0x68da <.L546>

00006830 <.L124>:
		if (valve.diag.vs.voltage <= VS_UNDER_STOP)
		{
			valve.diag.vs.uvTimer++;
			if (valve.diag.vs.uvTimer >= VS_ENTER_COUNT)
			{
				valve.diag.vs.uvTimer = 0u;
    6830:	7000      	lod	A, #0
    6832:	52d8 1240 	mov	0x1240 <.LLST1>, A

00006836 <.LM204>:
				valve.diag.vs.state = VS_UNDERVOLTAGE;
    6836:	7001      	lod	A, #1

00006838 <.L542>:
			else
#endif
	{
		valve.diag.vs.uvTimer = 0u;
		valve.diag.vs.ovTimer = 0u;
		valve.diag.vs.state = VS_NORMAL;
    6838:	52d8 123c 	mov	0x123c <.LASF2154+0x3>, A
    683c:	07e7      	jmp	0x680c <.L125>

0000683e <.L123>:
    683e:	7ed8 1242 	lod	X, 0x1242 <.LLST1+0x2>

00006842 <.LM206>:
			{
				valve.diag.vs.uvTimer = 0u;
				valve.diag.vs.state = VS_UNDERVOLTAGE;
			}
		}
		else if (valve.diag.vs.voltage >= VS_OVER_STOP)
    6842:	aeda 06a3 	cmp	A, #1699
    6846:	1a0d      	jule	0x6862 <.L126>

00006848 <.LM207>:
		{
			valve.diag.vs.ovTimer++;
    6848:	2001      	add	X, #1

0000684a <.LM208>:
			if (valve.diag.vs.ovTimer >= VS_ENTER_COUNT)
    684a:	2eda 03e7 	cmp	X, #999
    684e:	1e03      	jug	0x6856 <.L127>

00006850 <.L540>:
		else
		{
#if 1
			if (valve.diag.vs.ovTimer > 0)
			{
				valve.diag.vs.ovTimer--;
    6850:	5ed8 1242 	mov	0x1242 <.LLST1+0x2>, X
    6854:	07db      	jmp	0x680c <.L125>

00006856 <.L127>:
		else if (valve.diag.vs.voltage >= VS_OVER_STOP)
		{
			valve.diag.vs.ovTimer++;
			if (valve.diag.vs.ovTimer >= VS_ENTER_COUNT)
			{
				valve.diag.vs.ovTimer = 0u;
    6856:	7000      	lod	A, #0
    6858:	52d8 1242 	mov	0x1242 <.LLST1+0x2>, A

0000685c <.LM211>:
				valve.diag.vs.state = VS_OVERVOLTAGE;
    685c:	7002      	lod	A, #2
    685e:	0ea7      	lod	C, ML.7
    6860:	07eb      	jmp	0x6838 <.L542>

00006862 <.L126>:
			}
		}
		else
		{
#if 1
			if (valve.diag.vs.uvTimer > 0)
    6862:	72d8 1240 	lod	A, 0x1240 <.LLST1>
    6866:	1903      	je	0x686e <.L132>

00006868 <.LM213>:
			{
				valve.diag.vs.uvTimer--;
    6868:	a0ff      	add	A, #-1
    686a:	52d8 1240 	mov	0x1240 <.LLST1>, A

0000686e <.L132>:
			}
		}
		else
		{
#if 1
			if (valve.diag.vs.ovTimer > 0)
    686e:	2c00      	cmp	X, #0
    6870:	194d      	je	0x680c <.L125>

00006872 <.LM215>:
			{
				valve.diag.vs.ovTimer--;
    6872:	20ff      	add	X, #-1
    6874:	07ed      	jmp	0x6850 <.L540>

00006876 <.L120>:
    6876:	7ed8 1240 	lod	X, 0x1240 <.LLST1>

0000687a <.LM216>:
#endif
		}
		break;
	case VS_UNDERVOLTAGE:

		if (valve.diag.vs.voltage >= VS_UNDER_RETURN)
    687a:	aeda 0383 	cmp	A, #899
    687e:	1a0b      	jule	0x6896 <.L130>

00006880 <.LM217>:
		{
			valve.diag.vs.uvTimer++;
    6880:	2001      	add	X, #1

00006882 <.LM218>:
			if (valve.diag.vs.uvTimer >= VS_ENTER_COUNT)
    6882:	2eda 03e7 	cmp	X, #999
    6886:	1e03      	jug	0x688e <.L131>

00006888 <.L539>:
		else
		{
#if 1
			if (valve.diag.vs.uvTimer > 0)
			{
				valve.diag.vs.uvTimer--;
    6888:	5ed8 1240 	mov	0x1240 <.LLST1>, X
    688c:	07bf      	jmp	0x680c <.L125>

0000688e <.L131>:
		if (valve.diag.vs.voltage >= VS_UNDER_RETURN)
		{
			valve.diag.vs.uvTimer++;
			if (valve.diag.vs.uvTimer >= VS_ENTER_COUNT)
			{
				valve.diag.vs.uvTimer = 0u;
    688e:	7000      	lod	A, #0
    6890:	52d8 1240 	mov	0x1240 <.LLST1>, A
    6894:	07d1      	jmp	0x6838 <.L542>

00006896 <.L130>:
			}
		}
		else
		{
#if 1
			if (valve.diag.vs.uvTimer > 0)
    6896:	2c00      	cmp	X, #0
    6898:	1d01      	jne	0x689c <.LM222>
    689a:	07b8      	jmp	0x680c <.L125>

0000689c <.LM222>:
			{
				valve.diag.vs.uvTimer--;
    689c:	20ff      	add	X, #-1
    689e:	07f4      	jmp	0x6888 <.L539>

000068a0 <.L122>:
    68a0:	7ed8 1242 	lod	X, 0x1242 <.LLST1+0x2>

000068a4 <.LM223>:
#endif
		}
		break;
	case VS_OVERVOLTAGE:

		if (valve.diag.vs.voltage <= VS_OVER_RETURN)
    68a4:	aeda 0640 	cmp	A, #1600
    68a8:	1e62      	jug	0x686e <.L132>

000068aa <.LM224>:
		{
			valve.diag.vs.ovTimer++;
    68aa:	2001      	add	X, #1

000068ac <.LM225>:
			if (valve.diag.vs.ovTimer >= VS_ENTER_COUNT)
    68ac:	2eda 03e7 	cmp	X, #999
    68b0:	1a4f      	jule	0x6850 <.L540>

000068b2 <.LM226>:
			{
				valve.diag.vs.ovTimer = 0u;
    68b2:	7000      	lod	A, #0

000068b4 <.L538>:
			}
			else
#endif
	{
		valve.diag.vs.uvTimer = 0u;
		valve.diag.vs.ovTimer = 0u;
    68b4:	52d8 1242 	mov	0x1242 <.LLST1+0x2>, A
    68b8:	07bf      	jmp	0x6838 <.L542>

000068ba <.L136>:
    68ba:	7ed8 124c 	lod	X, 0x124c <.LLST1+0xc>

000068be <.LM228>:
	valve.diag.temp.deg = get_conv_ic_temperature();

	switch (valve.diag.temp.state)
	{
	case TEMPERATURE_NORMAL:
		if (valve.diag.temp.deg > (int16_t)TEMP_OVER_STOP)
    68be:	aeda 00af 	cmp	A, #175
    68c2:	1f01      	jsg	0x68c6 <.LM229>
    68c4:	0035      	jmp	0x6930 <.L143>

000068c6 <.LM229>:
		{
			valve.diag.temp.timer++;
    68c6:	2001      	add	X, #1

000068c8 <.LM230>:
			if (valve.diag.temp.timer >= TEMP_ENTER_COUNT)
    68c8:	2c63      	cmp	X, #99
    68ca:	1e03      	jug	0x68d2 <.L139>

000068cc <.L544>:
		else
		{
#if 1
			if (valve.diag.temp.timer > 0)
			{
				valve.diag.temp.timer--;
    68cc:	5ed8 124c 	mov	0x124c <.LLST1+0xc>, X
    68d0:	0011      	jmp	0x68f4 <.L140>

000068d2 <.L139>:
		if (valve.diag.temp.deg > (int16_t)TEMP_OVER_STOP)
		{
			valve.diag.temp.timer++;
			if (valve.diag.temp.timer >= TEMP_ENTER_COUNT)
			{
				valve.diag.temp.timer = 0u;
    68d2:	7000      	lod	A, #0
    68d4:	52d8 124c 	mov	0x124c <.LLST1+0xc>, A

000068d8 <.LM233>:
				valve.diag.temp.state = TEMPERATURE_HIGH;
    68d8:	7002      	lod	A, #2

000068da <.L546>:
			}
			else
#endif
	{
		valve.diag.temp.timer = 0u;
		valve.diag.temp.state = TEMPERATURE_NORMAL;
    68da:	52d8 1246 	mov	0x1246 <.LLST1+0x6>, A
    68de:	000a      	jmp	0x68f4 <.L140>

000068e0 <.L135>:
    68e0:	7ed8 124c 	lod	X, 0x124c <.LLST1+0xc>

000068e4 <.LM235>:
#endif
		}
		break;
	case TEMPERATURE_LOW:

		if (valve.diag.temp.deg >= (int16_t)TEMP_UNDER_RETURN)
    68e4:	ac31      	cmp	A, #49
    68e6:	1b24      	jsle	0x6930 <.L143>

000068e8 <.L543>:
		{
			valve.diag.temp.timer++;
    68e8:	2001      	add	X, #1
    68ea:	5ed8 124c 	mov	0x124c <.LLST1+0xc>, X

000068ee <.LM237>:
			if (valve.diag.temp.timer >= TEMP_ENTER_COUNT)
    68ee:	2c63      	cmp	X, #99
    68f0:	1a01      	jule	0x68f4 <.L140>
    68f2:	079a      	jmp	0x6828 <.L535>

000068f4 <.L140>:
	}
}
static void valveDiagIgn(void)
{
	static uint16_t ignNormalTimer = 0;
	valve.diag.ign.voltage = get_conv_ignition_voltage();
    68f4:	82db 3cf5 	callf	0x79ea <_get_conv_ignition_voltage>
    68f8:	52d8 1250 	mov	0x1250 <.LASF1845+0x3>, A

000068fc <.LM239>:

	switch (valve.diag.ign.state)
    68fc:	7ed8 124e 	lod	X, 0x124e <.LASF1845+0x1>
    6900:	191b      	je	0x6938 <.L146>
    6902:	2c01      	cmp	X, #1
    6904:	1d01      	jne	0x6908 <.LM240>
    6906:	0037      	jmp	0x6976 <.L147>

00006908 <.LM240>:
#endif
		}
		break;

	default: /* VS_INIT */
		if (valve.diag.ign.voltage > IGN_UNDER_STOP)
    6908:	aeda 02bc 	cmp	A, #700
    690c:	1e01      	jug	0x6910 <.LM241>
    690e:	0067      	jmp	0x69de <.L154>

00006910 <.LM241>:
		{
			ignNormalTimer += 1;
    6910:	72d8 10b2 	lod	A, 0x10b2 <___ignNormalTimer_5213>
    6914:	a001      	add	A, #1
    6916:	52d8 10b2 	mov	0x10b2 <___ignNormalTimer_5213>, A
    691a:	7c00      	lod	X, #0

0000691c <.LM242>:
			if (ignNormalTimer >= 10u)
    691c:	ac09      	cmp	A, #9
    691e:	1a28      	jule	0x6970 <.L155>

00006920 <.LM243>:
			{
				valve.diag.ign.state = IGN_NORMAL;
    6920:	5ed8 124e 	mov	0x124e <.LASF1845+0x1>, X
    6924:	0025      	jmp	0x6970 <.L155>

00006926 <.L137>:
    6926:	7ed8 124c 	lod	X, 0x124c <.LLST1+0xc>

0000692a <.LBE287>:
#endif
		}
		break;
	case TEMPERATURE_HIGH:

		if (valve.diag.temp.deg <= (int16_t)TEMP_OVER_RETURN)
    692a:	aeda 00a5 	cmp	A, #165
    692e:	1b5c      	jsle	0x68e8 <.L543>

00006930 <.L143>:
			}
		}
		else
		{
#if 1
			if (valve.diag.temp.timer > 0)
    6930:	2c00      	cmp	X, #0
    6932:	1960      	je	0x68f4 <.L140>

00006934 <.LM246>:
			{
				valve.diag.temp.timer--;
    6934:	20ff      	add	X, #-1
    6936:	07ca      	jmp	0x68cc <.L544>

00006938 <.L146>:
    6938:	7ed8 1252 	lod	X, 0x1252 <.LASF1845+0x5>

0000693c <.LM247>:
	valve.diag.ign.voltage = get_conv_ignition_voltage();

	switch (valve.diag.ign.state)
	{
	case IGN_NORMAL:
		if (valve.diag.ign.voltage <= IGN_UNDER_STOP)
    693c:	aeda 02bc 	cmp	A, #700
    6940:	1e14      	jug	0x696a <.L148>

00006942 <.LM248>:
		{
			valve.diag.ign.uvTimer++;
    6942:	2001      	add	X, #1
    6944:	5ed8 1252 	mov	0x1252 <.LASF1845+0x5>, X

00006948 <.LM249>:
			if (valve.diag.ign.uvTimer >= IGN_ENTER_COUNT)
    6948:	2eda 01f3 	cmp	X, #499
    694c:	1a0a      	jule	0x6962 <.L158>

0000694e <.L157>:
			{
				valve.diag.ign.uvTimer = 0u;
    694e:	7000      	lod	A, #0
    6950:	52d8 1252 	mov	0x1252 <.LASF1845+0x5>, A

00006954 <.LM251>:
				valve.diag.ign.state = IGN_OFF;
    6954:	7001      	lod	A, #1

00006956 <.L547>:
		{
			valve.diag.ign.uvTimer++;
			if (valve.diag.ign.uvTimer >= IGN_ENTER_COUNT)
			{
				valve.diag.ign.uvTimer = 0u;
				valve.diag.ign.state = IGN_NORMAL;
    6956:	52d8 124e 	mov	0x124e <.LASF1845+0x1>, A

0000695a <.L150>:

static void ValvePowerOffTask(void)
{
	int16_t cOffset = 0, cPos = 0, diff = 0;

	if (valve.diag.ign.state == IGN_OFF)
    695a:	72d8 124e 	lod	A, 0x124e <.LASF1845+0x1>
    695e:	ac01      	cmp	A, #1
    6960:	1915      	je	0x698c <.L325>

00006962 <.L158>:
			}
		}
	}
	else
	{
		valve.ignOffCnt = 0;
    6962:	7000      	lod	A, #0
    6964:	52d8 1204 	mov	0x1204 <.LLST13+0x2>, A
    6968:	0030      	jmp	0x69ca <.L548>

0000696a <.L148>:
			}
		}
		else
		{
#if 1
			if (valve.diag.ign.uvTimer > 0)
    696a:	2c00      	cmp	X, #0
    696c:	197a      	je	0x6962 <.L158>

0000696e <.L567>:
		else
		{
#if 1
			if (valve.diag.ign.uvTimer > 0)
			{
				valve.diag.ign.uvTimer--;
    696e:	20ff      	add	X, #-1

00006970 <.L155>:
			ignNormalTimer += 1;
			if (ignNormalTimer >= 10u)
			{
				valve.diag.ign.state = IGN_NORMAL;
			}
			valve.diag.ign.uvTimer = 0u;
    6970:	5ed8 1252 	mov	0x1252 <.LASF1845+0x5>, X
    6974:	07f2      	jmp	0x695a <.L150>

00006976 <.L147>:
    6976:	7ed8 1252 	lod	X, 0x1252 <.LASF1845+0x5>

0000697a <.LM258>:
		}
		break;

	case IGN_OFF:

		if (valve.diag.ign.voltage >= IGN_UNDER_RETURN)
    697a:	aeda 031f 	cmp	A, #799
    697e:	1a2c      	jule	0x69d8 <.L151>

00006980 <.LM259>:
		{
			valve.diag.ign.uvTimer++;
    6980:	2001      	add	X, #1

00006982 <.LM260>:
			if (valve.diag.ign.uvTimer >= IGN_ENTER_COUNT)
    6982:	2eda 01f3 	cmp	X, #499
    6986:	1e24      	jug	0x69d0 <.L152>

00006988 <.LM261>:

	case IGN_OFF:

		if (valve.diag.ign.voltage >= IGN_UNDER_RETURN)
		{
			valve.diag.ign.uvTimer++;
    6988:	5ed8 1252 	mov	0x1252 <.LASF1845+0x5>, X

0000698c <.L325>:
{
	int16_t cOffset = 0, cPos = 0, diff = 0;

	if (valve.diag.ign.state == IGN_OFF)
	{
		if (valve.ignOffCnt < 0xffffu)
    698c:	72d8 1204 	lod	A, 0x1204 <.LLST13+0x2>
    6990:	acff      	cmp	A, #-1
    6992:	1903      	je	0x699a <.L159>

00006994 <.LM263>:
		{
			valve.ignOffCnt += 1;
    6994:	a001      	add	A, #1
    6996:	52d8 1204 	mov	0x1204 <.LLST13+0x2>, A

0000699a <.L159>:
		}

		if (valve.ignOffCnt >= 60000u) /*60sec*/
    699a:	72d8 1204 	lod	A, 0x1204 <.LLST13+0x2>
    699e:	aeda ea5f 	cmp	A, #59999
    69a2:	1e01      	jug	0x69a6 <.LM265>
    69a4:	0066      	jmp	0x6a72 <.L160>

000069a6 <.LM265>:
		{
			if (valve.sleepState == 0)
    69a6:	62d8 1206 	lod	AL, 0x1206 <.LLST13+0x4>
    69aa:	66e0      	lod	YL, AL
    69ac:	5cf6      	usex	Y
    69ae:	8c00      	cmp	AL, #0
    69b0:	1901      	je	0x69b4 <.LM266>
    69b2:	002e      	jmp	0x6a10 <.L161>

000069b4 <.LM266>:
			{
				/*sleep ready -> calibration  (  quick cal,  full cal */
				if ((check_fault_mode() == 0) && (check_protect_mode() == 0))
    69b4:	156b      	call	0x648c <_check_fault_mode>
    69b6:	ac00      	cmp	A, #0
    69b8:	1d26      	jne	0x6a06 <.L162>
    69ba:	150b      	call	0x63d2 <_check_protect_mode>
    69bc:	ac00      	cmp	A, #0
    69be:	1d23      	jne	0x6a06 <.L162>

000069c0 <.LM267>:
				{
					ValveFaultReset();
    69c0:	152f      	call	0x6420 <_ValveFaultReset>

000069c2 <.LM268>:
					valve.calibration.req1Cal = 1;
    69c2:	6001      	lod	AL, #1
    69c4:	42d8 1217 	mov	0x1217 <.LASF1440+0xb>, AL

000069c8 <.L163>:
				else
				{
					ValveFaultReset();
					valve.calibration.req2Cal = 1;
				}
				valve.sleepState = 1;
    69c8:	6001      	lod	AL, #1

000069ca <.L548>:
		}
	}
	else
	{
		valve.ignOffCnt = 0;
		valve.sleepState = 0;
    69ca:	42d8 1206 	mov	0x1206 <.LLST13+0x4>, AL
    69ce:	0051      	jmp	0x6a72 <.L160>

000069d0 <.L152>:
		if (valve.diag.ign.voltage >= IGN_UNDER_RETURN)
		{
			valve.diag.ign.uvTimer++;
			if (valve.diag.ign.uvTimer >= IGN_ENTER_COUNT)
			{
				valve.diag.ign.uvTimer = 0u;
    69d0:	7000      	lod	A, #0
    69d2:	52d8 1252 	mov	0x1252 <.LASF1845+0x5>, A
    69d6:	07bf      	jmp	0x6956 <.L547>

000069d8 <.L151>:
			}
		}
		else
		{
#if 1
			if (valve.diag.ign.uvTimer > 0)
    69d8:	2c00      	cmp	X, #0
    69da:	1958      	je	0x698c <.L325>
    69dc:	07c8      	jmp	0x696e <.L567>

000069de <.L154>:
    69de:	7c00      	lod	X, #0

000069e0 <.LM273>:
			{
				valve.diag.ign.state = IGN_NORMAL;
			}
			valve.diag.ign.uvTimer = 0u;
		}
		else if (valve.diag.ign.voltage < IGN_UNDER_STOP)
    69e0:	aeda 02bc 	cmp	A, #700
    69e4:	190b      	je	0x69fc <.L156>

000069e6 <.LM274>:
		{
			valve.diag.ign.voltage = 0;
    69e6:	5ed8 1250 	mov	0x1250 <.LASF1845+0x3>, X

000069ea <.LM275>:
			valve.diag.ign.uvTimer++;
    69ea:	72d8 1252 	lod	A, 0x1252 <.LASF1845+0x5>
    69ee:	a001      	add	A, #1
    69f0:	52d8 1252 	mov	0x1252 <.LASF1845+0x5>, A

000069f4 <.LM276>:
			if (valve.diag.ign.uvTimer >= 10u)
    69f4:	ac09      	cmp	A, #9
    69f6:	1a01      	jule	0x69fa <.LASF244+0x2>
    69f8:	07aa      	jmp	0x694e <.L157>
    69fa:	07af      	jmp	0x695a <.L150>

000069fc <.L156>:
				valve.diag.ign.state = IGN_OFF;
			}
		}
		else
		{
			valve.diag.ign.uvTimer = 0u;
    69fc:	5ed8 1252 	mov	0x1252 <.LASF1845+0x5>, X

00006a00 <.LM278>:
			ignNormalTimer = 0;
    6a00:	5ed8 10b2 	mov	0x10b2 <___ignNormalTimer_5213>, X
    6a04:	07aa      	jmp	0x695a <.L150>

00006a06 <.L162>:
					ValveFaultReset();
					valve.calibration.req1Cal = 1;
				}
				else
				{
					ValveFaultReset();
    6a06:	150c      	call	0x6420 <_ValveFaultReset>

00006a08 <.LM280>:
					valve.calibration.req2Cal = 1;
    6a08:	6001      	lod	AL, #1
    6a0a:	42d8 1216 	mov	0x1216 <.LASF1440+0xa>, AL
    6a0e:	07dc      	jmp	0x69c8 <.L163>

00006a10 <.L161>:
				}
				valve.sleepState = 1;
			}
			else
			{
				if (valve.state != VALVE_CALIBRATION)
    6a10:	72d8 11fc 	lod	A, 0x11fc <_valve>
    6a14:	ac05      	cmp	A, #5
    6a16:	192d      	je	0x6a72 <.L160>

00006a18 <.LM282>:
				{
					if (valve.sleepState == 1)
    6a18:	ec01      	cmp	Y, #1
    6a1a:	1d28      	jne	0x6a6c <.L164>

00006a1c <.LM283>:
					{
						/* */
						cOffset = get_gmr_sensor_offset();
    6a1c:	82db 3bfb 	callf	0x77f6 <_get_gmr_sensor_offset>

00006a20 <.LM284>:
						cPos = valve.pos.currentAngle;
    6a20:	7ad8 120c 	lod	Y, 0x120c <.LASF1440>

00006a24 <.LM285>:
						diff = cPos - valve.memory.lastAngle;
						if (diff < 0)
						{
							diff = -diff;
						}
						if ((cOffset != valve.memory.offset) || (diff > (int16_t)C_VALVE_ACCURACY_ANGLE))
    6a24:	aed8 1234 	cmp	A, 0x1234 <.LLST15+0x8>
    6a28:	1d07      	jne	0x6a38 <.L165>

00006a2a <.LM286>:
					if (valve.sleepState == 1)
					{
						/* */
						cOffset = get_gmr_sensor_offset();
						cPos = valve.pos.currentAngle;
						diff = cPos - valve.memory.lastAngle;
    6a2a:	7ee6      	lod	X, Y
    6a2c:	2ad8 1236 	sub	X, 0x1236 <.LLST15+0xa>

00006a30 <.LM287>:
						if (diff < 0)
						{
							diff = -diff;
						}
						if ((cOffset != valve.memory.offset) || (diff > (int16_t)C_VALVE_ACCURACY_ANGLE))
    6a30:	1d81      	jnn	0x6a34 <.L577>
    6a32:	5cce      	neg	X

00006a34 <.L577>:
    6a34:	2c14      	cmp	X, #20
    6a36:	1b06      	jsle	0x6a44 <.L166>

00006a38 <.L165>:
						{
							valve_gmr_write((uint16_t)cOffset, (uint16_t)cPos, 0x5555);
    6a38:	54ca 5555 	pushw	#21845

00006a3c <.LCFI2>:
    6a3c:	5adf      	push	Y

00006a3e <.LCFI3>:
    6a3e:	82db 43be 	callf	0x877c <_valve_gmr_write>

00006a42 <.LVL98>:
    6a42:	5c03      	dec	S, #4

00006a44 <.L166>:
						}
						if ((u16EventState != valve.memory.state) || (u16EventValue != valve.memory.value))
    6a44:	72d8 10b6 	lod	A, 0x10b6 <_u16EventState>
    6a48:	7ed8 10b4 	lod	X, 0x10b4 <_u16EventValue>
    6a4c:	7ad8 122e 	lod	Y, 0x122e <.LLST15+0x2>
    6a50:	eee2      	cmp	Y, A
    6a52:	1d04      	jne	0x6a5c <.L167>
    6a54:	7ad8 1232 	lod	Y, 0x1232 <.LLST15+0x6>
    6a58:	eeee      	cmp	Y, X
    6a5a:	1906      	je	0x6a68 <.L168>

00006a5c <.L167>:
						{
							valve_diag_write(u16EventState, u16EventValue, 0xAAAA);
    6a5c:	54ca aaaa 	pushw	#43690

00006a60 <.LCFI5>:
    6a60:	5edf      	push	X

00006a62 <.LCFI6>:
    6a62:	82db 43cc 	callf	0x8798 <_valve_diag_write>
    6a66:	5c03      	dec	S, #4

00006a68 <.L168>:
						}
						valve.sleepState = 2;
    6a68:	6002      	lod	AL, #2
    6a6a:	07af      	jmp	0x69ca <.L548>

00006a6c <.L164>:
					}
					else
					{
						MotRequestHardStop();
    6a6c:	82db 3e28 	callf	0x7c50 <_MotRequestHardStop>

00006a70 <.LM293>:
						AppLinSleepEnter();
    6a70:	14ab      	call	0x63c8 <_AppLinSleepEnter>

00006a72 <.L160>:
	valveDiagVs();
	valveDiagTemp();
	valveDiagIgn();

	ValvePowerOffTask();
	valve.motorMotion = MotGetState();
    6a72:	82db 3e7c 	callf	0x7cf8 <_MotGetState>
    6a76:	52d8 1208 	mov	0x1208 <.LLST13+0x6>, A

00006a7a <.LM295>:
	valve.diag.motorFault = MotGetFaultState();
    6a7a:	82db 3e83 	callf	0x7d06 <_MotGetFaultState>
    6a7e:	42d8 1265 	mov	0x1265 <.LASF1020+0x6>, AL

00006a82 <.LM296>:
	valve.diag.stallFault = MotGetStallState();
    6a82:	82db 3e7f 	callf	0x7cfe <_MotGetStallState>
    6a86:	42d8 1266 	mov	0x1266 <.LLST4>, AL

00006a8a <.LBB302>:
		break;
	}
}
static void valveDiagSensor(void)
{
	uint8_t sensor_f = SensorGetState();
    6a8a:	82db 3e87 	callf	0x7d0e <_SensorGetState>

00006a8e <.LM298>:
	valve.diag.motorCurrent = get_conv_mot_current();
    6a8e:	5203      	mov	[S-4], A
    6a90:	82db 3c64 	callf	0x78c8 <_get_conv_mot_current>

00006a94 <.LVL107>:
    6a94:	52d8 125a 	mov	0x125a <.LLST3+0x7>, A

00006a98 <.LM299>:

	if ((valve.state != VALVE_CALIBRATION) && (valve.motorMotion == MOTION_RUNNING))
    6a98:	7ed8 11fc 	lod	X, 0x11fc <_valve>
    6a9c:	7a03      	lod	Y, [S-4]
    6a9e:	2c05      	cmp	X, #5
    6aa0:	1d01      	jne	0x6aa4 <.LASF250+0x6>
    6aa2:	0039      	jmp	0x6b16 <.L169>
    6aa4:	7ed8 1208 	lod	X, 0x1208 <.LLST13+0x6>
    6aa8:	2c03      	cmp	X, #3
    6aaa:	1901      	je	0x6aae <.LASF1056+0x2>
    6aac:	0034      	jmp	0x6b16 <.L169>
    6aae:	7ed8 1258 	lod	X, 0x1258 <.LLST3+0x5>

00006ab2 <.LM300>:
	{

		if ((valve.diag.motorCurrent >= 500) && (sensor_f == C_STATUS_STOP))
    6ab2:	aeda 01f3 	cmp	A, #499
    6ab6:	1a2b      	jule	0x6b0e <.L170>
    6ab8:	ec02      	cmp	Y, #2
    6aba:	1d29      	jne	0x6b0e <.L170>

00006abc <.LM301>:
		{

			valve.diag.gmr.count += 1;
    6abc:	2001      	add	X, #1

00006abe <.L549>:
		}
		else
		{
			if (valve.diag.gmr.count > 0)
				valve.diag.gmr.count -= 1;
    6abe:	5ed8 1258 	mov	0x1258 <.LLST3+0x5>, X

00006ac2 <.L171>:
		}

		if (valve.diag.gmr.count > 2000) /*20250715*/
    6ac2:	72d8 1258 	lod	A, 0x1258 <.LLST3+0x5>
    6ac6:	aeda 07d0 	cmp	A, #2000
    6aca:	1a07      	jule	0x6ada <.L172>

00006acc <.LM304>:
		{
			valve.diag.gmr.count = 0;
    6acc:	7000      	lod	A, #0
    6ace:	52d8 1258 	mov	0x1258 <.LLST3+0x5>, A

00006ad2 <.LM305>:
			valve.diag.gmr.state = 1;
    6ad2:	6001      	lod	AL, #1
    6ad4:	0ea7      	lod	C, ML.7
    6ad6:	42d8 1254 	mov	0x1254 <.LLST3+0x1>, AL

00006ada <.L172>:
	}
}
static void valveDiagMcu(void)
{
	static uint16_t LV_filterCnt = 0, HV_filterCnt = 0;
	uint16_t voltage = get_conv_vdda_voltage();
    6ada:	82db 3c53 	callf	0x78a6 <_get_conv_vdda_voltage>
    6ade:	7ee2      	lod	X, A

00006ae0 <.LM307>:
	if (valve.diag.McuFault == 0)
    6ae0:	62d8 125e 	lod	AL, 0x125e <.LLST3+0xb>

00006ae4 <.LVL110>:
    6ae4:	1901      	je	0x6ae8 <.LVL110+0x4>
    6ae6:	0047      	jmp	0x6b76 <.L173>
    6ae8:	66e0      	lod	YL, AL
    6aea:	5cf6      	usex	Y

00006aec <.LM308>:
	{
		HV_filterCnt = 0;
    6aec:	5ad8 10b0 	mov	0x10b0 <___HV_filterCnt_5226>, Y
    6af0:	72d8 10ae 	lod	A, 0x10ae <___LV_filterCnt_5225>

00006af4 <.LM309>:
		if (voltage <= 300) /*scale: 10mV*/
    6af4:	2eda 012c 	cmp	X, #300
    6af8:	1e12      	jug	0x6b1e <.L174>

00006afa <.LM310>:
		{
			LV_filterCnt += 1;
    6afa:	a001      	add	A, #1
    6afc:	52d8 10ae 	mov	0x10ae <___LV_filterCnt_5225>, A

00006b00 <.LM311>:
			if (LV_filterCnt >= 500)
    6b00:	aeda 01f3 	cmp	A, #499
    6b04:	1a11      	jule	0x6b28 <.L176>

00006b06 <.LM312>:
			{
				valve.diag.McuFault = 1;
    6b06:	6001      	lod	AL, #1

00006b08 <.L550>:
		if (voltage >= 320) /*scale: 10mV*/
		{
			HV_filterCnt += 1;
			if (HV_filterCnt >= 500)
			{
				valve.diag.McuFault = 0;
    6b08:	42d8 125e 	mov	0x125e <.LLST3+0xb>, AL
    6b0c:	000d      	jmp	0x6b28 <.L176>

00006b0e <.L170>:

			valve.diag.gmr.count += 1;
		}
		else
		{
			if (valve.diag.gmr.count > 0)
    6b0e:	2c00      	cmp	X, #0
    6b10:	1958      	je	0x6ac2 <.L171>

00006b12 <.LM315>:
				valve.diag.gmr.count -= 1;
    6b12:	20ff      	add	X, #-1
    6b14:	07d4      	jmp	0x6abe <.L549>

00006b16 <.L169>:
			valve.diag.gmr.state = 1;
		}
	}
	else
	{
		valve.diag.gmr.count = 0;
    6b16:	7000      	lod	A, #0
    6b18:	52d8 1258 	mov	0x1258 <.LLST3+0x5>, A
    6b1c:	07de      	jmp	0x6ada <.L172>

00006b1e <.L174>:
				valve.diag.McuFault = 1;
			}
		}
		else
		{
			if (LV_filterCnt > 0)
    6b1e:	ac00      	cmp	A, #0
    6b20:	1903      	je	0x6b28 <.L176>

00006b22 <.LM318>:
				LV_filterCnt -= 1;
    6b22:	a0ff      	add	A, #-1
    6b24:	52d8 10ae 	mov	0x10ae <___LV_filterCnt_5225>, A

00006b28 <.L176>:
	valve.diag.motorFault = MotGetFaultState();
	valve.diag.stallFault = MotGetStallState();
	valveDiagSensor();
	valveDiagMcu();

	fault_err = check_fault_mode();
    6b28:	14b1      	call	0x648c <_check_fault_mode>
    6b2a:	5205      	mov	[S-6], A

00006b2c <.LM320>:
	protect_mode = check_protect_mode();
    6b2c:	1452      	call	0x63d2 <_check_protect_mode>

00006b2e <.LVL116>:
    6b2e:	5207      	mov	[S-8], A

00006b30 <.LM321>:
	if ((valve.state != VALVE_FAULT) && (fault_err != 0))
    6b30:	7ada 11fc 	lod	Y, #4604
    6b34:	7ef0      	lod	X, [Y]
    6b36:	2c06      	cmp	X, #6
    6b38:	1d01      	jne	0x6b3c <.LM322>
    6b3a:	0033      	jmp	0x6ba2 <.L179>

00006b3c <.LM322>:
    6b3c:	7205      	lod	A, [S-6]

00006b3e <.LVL118>:
    6b3e:	1931      	je	0x6ba2 <.L179>

00006b40 <.LM323>:
	{

		valve.initStatus = 1;
    6b40:	6001      	lod	AL, #1
    6b42:	42d8 1207 	mov	0x1207 <.LLST13+0x5>, AL

00006b46 <.LM324>:
		valve.elapsedTime = 0;
    6b46:	7000      	lod	A, #0
    6b48:	0ea7      	lod	C, ML.7
    6b4a:	52d8 1202 	mov	0x1202 <.LLST13>, A

00006b4e <.LM325>:
		valve.lastState = valve.state;
    6b4e:	5ed8 11fe 	mov	0x11fe <_valve+0x2>, X

00006b52 <.LM326>:
		valve.state = VALVE_FAULT;
    6b52:	7006      	lod	A, #6
    6b54:	52f0      	mov	[Y], A

00006b56 <.L180>:
	}
	else
	{
	}

	valve.pos.currentAngle = MotGetCurrentPosition();
    6b56:	82db 3e47 	callf	0x7c8e <_MotGetCurrentPosition>
    6b5a:	7ee2      	lod	X, A
    6b5c:	52d8 120c 	mov	0x120c <.LASF1440>, A

00006b60 <.LBB311>:

static void calc_PosToLinData(int16_t currentAngle)
{
// #define CAL_POS_ANGLE_THD	(50* C_GMR_ANGLE_SCALE_FACTOR)
#define CAL_POS_ANGLE_THD (1 * C_GMR_ANGLE_SCALE_FACTOR)
	switch (valve.comm.actualMode)
    6b60:	62d8 1229 	lod	AL, 0x1229 <.Lframe0+0x1>

00006b64 <.LVL121>:
    6b64:	1d01      	jne	0x6b68 <.LASF1002+0x1>
    6b66:	0031      	jmp	0x6bca <.L182>
    6b68:	66e0      	lod	YL, AL
    6b6a:	5cf6      	usex	Y
    6b6c:	ec01      	cmp	Y, #1
    6b6e:	1d01      	jne	0x6b72 <.L537>
    6b70:	0045      	jmp	0x6bfc <.L183>

00006b72 <.L537>:
		else
		{
		}
		break;
	default:
		valve.comm.actualMode = C_MODE_B;
    6b72:	6001      	lod	AL, #1
    6b74:	0049      	jmp	0x6c08 <.L551>

00006b76 <.L173>:
				LV_filterCnt -= 1;
		}
	}
	else
	{
		LV_filterCnt = 0;
    6b76:	7000      	lod	A, #0
    6b78:	52d8 10ae 	mov	0x10ae <___LV_filterCnt_5225>, A
    6b7c:	7ad8 10b0 	lod	Y, 0x10b0 <___HV_filterCnt_5226>

00006b80 <.LM331>:
		if (voltage >= 320) /*scale: 10mV*/
    6b80:	0ea7      	lod	C, ML.7
    6b82:	2eda 013f 	cmp	X, #319
    6b86:	1a07      	jule	0x6b96 <.L178>

00006b88 <.LM332>:
		{
			HV_filterCnt += 1;
    6b88:	e001      	add	Y, #1
    6b8a:	5ad8 10b0 	mov	0x10b0 <___HV_filterCnt_5226>, Y

00006b8e <.LM333>:
			if (HV_filterCnt >= 500)
    6b8e:	eeda 01f3 	cmp	Y, #499
    6b92:	1a4a      	jule	0x6b28 <.L176>
    6b94:	07b9      	jmp	0x6b08 <.L550>

00006b96 <.L178>:
				valve.diag.McuFault = 0;
			}
		}
		else
		{
			if (HV_filterCnt > 0)
    6b96:	ec00      	cmp	Y, #0
    6b98:	1947      	je	0x6b28 <.L176>

00006b9a <.LM335>:
				HV_filterCnt -= 1;
    6b9a:	e0ff      	add	Y, #-1
    6b9c:	5ad8 10b0 	mov	0x10b0 <___HV_filterCnt_5226>, Y
    6ba0:	07c3      	jmp	0x6b28 <.L176>

00006ba2 <.L179>:
		valve.initStatus = 1;
		valve.elapsedTime = 0;
		valve.lastState = valve.state;
		valve.state = VALVE_FAULT;
	}
	else if ((valve.state != VALVE_FAULT) && (valve.state != VALVE_PROTECTION) && (protect_mode != 0))
    6ba2:	7aee      	lod	Y, X
    6ba4:	e0fa      	add	Y, #-6
    6ba6:	ec01      	cmp	Y, #1
    6ba8:	1a56      	jule	0x6b56 <.L180>

00006baa <.LM337>:
    6baa:	7207      	lod	A, [S-8]
    6bac:	1954      	je	0x6b56 <.L180>

00006bae <.LM338>:
	{
		valve.initStatus = 1;
    6bae:	6001      	lod	AL, #1
    6bb0:	42d8 1207 	mov	0x1207 <.LLST13+0x5>, AL

00006bb4 <.LM339>:
		valve.elapsedTime = 0;
    6bb4:	7000      	lod	A, #0
    6bb6:	0ea7      	lod	C, ML.7
    6bb8:	52d8 1202 	mov	0x1202 <.LLST13>, A

00006bbc <.LM340>:
		valve.lastState = valve.state;
    6bbc:	5ed8 11fe 	mov	0x11fe <_valve+0x2>, X

00006bc0 <.LM341>:
		valve.state = VALVE_PROTECTION;
    6bc0:	7007      	lod	A, #7
    6bc2:	0ea7      	lod	C, ML.7
    6bc4:	52d8 11fc 	mov	0x11fc <_valve>, A
    6bc8:	07c6      	jmp	0x6b56 <.L180>

00006bca <.L182>:
// #define CAL_POS_ANGLE_THD	(50* C_GMR_ANGLE_SCALE_FACTOR)
#define CAL_POS_ANGLE_THD (1 * C_GMR_ANGLE_SCALE_FACTOR)
	switch (valve.comm.actualMode)
	{
	case C_MODE_A:
		if (currentAngle <= (valve.pos.modeAngle[C_MODE_B] + (int16_t)CAL_POS_ANGLE_THD))
    6bca:	72d8 1210 	lod	A, 0x1210 <.LASF1440+0x4>
    6bce:	a00a      	add	A, #10
    6bd0:	2ee2      	cmp	X, A
    6bd2:	1b4f      	jsle	0x6b72 <.L537>

00006bd4 <.L184>:
	{
	}

	valve.pos.currentAngle = MotGetCurrentPosition();
	calc_PosToLinData(valve.pos.currentAngle);
	if ((valve.motorMotion >= MOTION_ACC) && (valve.motorMotion <= MOTION_DEC))
    6bd4:	7ad8 1208 	lod	Y, 0x1208 <.LLST13+0x6>
    6bd8:	5a01      	mov	[S-2], Y
    6bda:	72e6      	lod	A, Y
    6bdc:	a0fe      	add	A, #-2
    6bde:	ac02      	cmp	A, #2
    6be0:	1e16      	jug	0x6c0e <.L185>

00006be2 <.LM344>:
	{
		valve.comm.moving = 1;
    6be2:	6001      	lod	AL, #1

00006be4 <.L552>:
	}
	else
	{
		valve.comm.moving = 0;
    6be4:	42d8 122a 	mov	0x122a <.Lframe0+0x2>, AL

00006be8 <.LM346>:
	}
	switch (valve.state)
    6be8:	72d8 11fc 	lod	A, 0x11fc <_valve>
    6bec:	ac0a      	cmp	A, #10
    6bee:	1a01      	jule	0x6bf2 <.LASF58+0x2>
    6bf0:	00ec      	jmp	0x6dca <.L203>
    6bf2:	4422      	asl	A
    6bf4:	a2da 5cc2 	add	A, #23746
    6bf8:	7ae2      	lod	Y, A
    6bfa:	76f0      	jmp	[Y]

00006bfc <.L183>:
		else
		{
		}
		break;
	case C_MODE_B:
		if (currentAngle >= (valve.pos.modeAngle[C_MODE_A] - (int16_t)CAL_POS_ANGLE_THD))
    6bfc:	72d8 120e 	lod	A, 0x120e <.LASF1440+0x2>
    6c00:	a0f6      	add	A, #-10
    6c02:	2ee2      	cmp	X, A
    6c04:	1ae7      	jsl	0x6bd4 <.L184>

00006c06 <.LM348>:
		{
			valve.comm.actualMode = C_MODE_A;
    6c06:	6000      	lod	AL, #0

00006c08 <.L551>:
		else
		{
		}
		break;
	default:
		valve.comm.actualMode = C_MODE_B;
    6c08:	42d8 1229 	mov	0x1229 <.Lframe0+0x1>, AL
    6c0c:	07e3      	jmp	0x6bd4 <.L184>

00006c0e <.L185>:
	{
		valve.comm.moving = 1;
	}
	else
	{
		valve.comm.moving = 0;
    6c0e:	6000      	lod	AL, #0
    6c10:	07e9      	jmp	0x6be4 <.L552>

00006c12 <.L188>:

#endif
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    6c12:	5ed8 120a 	mov	0x120a <.LLST13+0x8>, X

00006c16 <.LBE320>:
{
	tValveState nextState = VALVE_INIT;
	int16_t diff = 0;

	ValveTargetAngleUpdate(valve.pos.currentAngle);
	MotSetTargetPosition(valve.pos.targetAngle);
    6c16:	72ee      	lod	A, X
    6c18:	82db 3e30 	callf	0x7c60 <_MotSetTargetPosition>

00006c1c <.LM353>:
	if ((valve.diag.ign.state == IGN_NORMAL) && (valve.elapsedTime >= 5u))
    6c1c:	72d8 124e 	lod	A, 0x124e <.LASF1845+0x1>
    6c20:	1902      	je	0x6c26 <.LASF217+0x4>
    6c22:	76da 3a92 	jmpf	0x7524 <.L326>
    6c26:	7ed8 1202 	lod	X, 0x1202 <.LLST13>
    6c2a:	2c04      	cmp	X, #4
    6c2c:	1a18      	jule	0x6c5e <.L562>

00006c2e <.LM354>:
	{
		if (u16EventState == VALVE_CAL_FAULT)
    6c2e:	72d8 10b6 	lod	A, 0x10b6 <_u16EventState>
    6c32:	ac09      	cmp	A, #9
    6c34:	1d03      	jne	0x6c3c <.L201>

00006c36 <.LM355>:
		{
			valve.calibration.req2Cal = 1;
    6c36:	6001      	lod	AL, #1
    6c38:	42d8 1216 	mov	0x1216 <.LASF1440+0xa>, AL

00006c3c <.L201>:
		}
		if (valve.memory.lastAngle != 0)
    6c3c:	7ed8 1236 	lod	X, 0x1236 <.LLST15+0xa>
    6c40:	72d8 120c 	lod	A, 0x120c <.LASF1440>
    6c44:	2c00      	cmp	X, #0
    6c46:	190d      	je	0x6c62 <.L202>

00006c48 <.L568>:
		{
			diff = valve.pos.currentAngle - valve.memory.lastAngle;
    6c48:	aaee      	sub	A, X

00006c4a <.L553>:
			if (diff < 0)
			{
				diff = -diff;
			}
			if (diff > (int16_t)C_VALVE_ACCURACY_ANGLE)
    6c4a:	ac00      	cmp	A, #0
    6c4c:	1d81      	jnn	0x6c50 <.L578>
    6c4e:	5cc2      	neg	A

00006c50 <.L578>:
    6c50:	ac14      	cmp	A, #20
    6c52:	1f01      	jsg	0x6c56 <.LM359>
    6c54:	00ba      	jmp	0x6dca <.L203>

00006c56 <.LM359>:
			{

				valve.calibration.req2Cal = 1;
    6c56:	6001      	lod	AL, #1

00006c58 <.LVL133>:
    6c58:	42d8 1216 	mov	0x1216 <.LASF1440+0xa>, AL

00006c5c <.LM360>:
			{

				valve.calibration.req2Cal = 1;
			}
		}
		nextState = VALVE_STANDBY;
    6c5c:	7001      	lod	A, #1

00006c5e <.L562>:
	MotRequestHardStop();

	if ((valve.calibration.req2Cal == 1) || (valve.calibration.req1Cal == 1))
	{

		nextState = VALVE_CALIBRATION;
    6c5e:	5205      	mov	[S-6], A
    6c60:	003a      	jmp	0x6cd6 <.L200>

00006c62 <.L202>:
			}
		}
		else
		{

			if (valve.pos.currentAngle <= (valve.pos.modeAngle[C_MODE_B] + (int16_t)(45 * C_GMR_ANGLE_SCALE_FACTOR)))
    6c62:	7ed8 1210 	lod	X, 0x1210 <.LASF1440+0x4>
    6c66:	7aee      	lod	Y, X
    6c68:	e2da 01c2 	add	Y, #450
    6c6c:	eee2      	cmp	Y, A
    6c6e:	1eec      	jsge	0x6c48 <.L568>

00006c70 <.LM363>:
			{
				diff = valve.pos.currentAngle - valve.pos.modeAngle[C_MODE_B];
			}
			else
			{
				diff = valve.pos.currentAngle - valve.pos.modeAngle[C_MODE_A];
    6c70:	aad8 120e 	sub	A, 0x120e <.LASF1440+0x2>
    6c74:	07ea      	jmp	0x6c4a <.L553>

00006c76 <.L190>:
{

	tValveState nextState = VALVE_STANDBY;
	int16_t diffPos;

	if (valve.initStatus != 0)
    6c76:	62d8 1207 	lod	AL, 0x1207 <.LLST13+0x5>
    6c7a:	1903      	je	0x6c82 <.L207>

00006c7c <.LM365>:
	{
		valve.initStatus = 0;
    6c7c:	6000      	lod	AL, #0
    6c7e:	42d8 1207 	mov	0x1207 <.LLST13+0x5>, AL

00006c82 <.L207>:
	}

	MotRequestHardStop();
    6c82:	82db 3e28 	callf	0x7c50 <_MotRequestHardStop>

00006c86 <.LM367>:

	if ((valve.calibration.req2Cal == 1) || (valve.calibration.req1Cal == 1))
    6c86:	62d8 1216 	lod	AL, 0x1216 <.LASF1440+0xa>
    6c8a:	8c01      	cmp	AL, #1
    6c8c:	1d01      	jne	0x6c90 <.LM367+0xa>
    6c8e:	0155      	jmp	0x6f3a <.L328>
    6c90:	62d8 1217 	lod	AL, 0x1217 <.LASF1440+0xb>
    6c94:	8c01      	cmp	AL, #1
    6c96:	1d01      	jne	0x6c9a <.LM368>
    6c98:	012f      	jmp	0x6ef8 <.L572>

00006c9a <.LM368>:
	{

		nextState = VALVE_CALIBRATION;
	}
	else if (valve.comm.ForcedDiag != 0)
    6c9a:	62d8 1227 	lod	AL, 0x1227 <.LLST14+0xe>
    6c9e:	1902      	je	0x6ca4 <.L208>

00006ca0 <.L571>:
}

static tValveState ValveDiagRunTask(void)
{

	tValveState nextState = VALVE_DIAGRUN;
    6ca0:	7804      	lod	Y, #4
    6ca2:	005e      	jmp	0x6d60 <.L563>

00006ca4 <.L208>:
	else if (valve.comm.ForcedDiag != 0)
	{

		nextState = VALVE_DIAGRUN;
	}
	else if (valve.comm.Enable != 0)
    6ca4:	62d8 1225 	lod	AL, 0x1225 <.LLST14+0xc>
    6ca8:	1d01      	jne	0x6cac <.LM371>
    6caa:	008f      	jmp	0x6dca <.L203>

00006cac <.LM371>:
	{

		if (valve.pos.targetAngle > valve.pos.currentAngle)
    6cac:	7ed8 120a 	lod	X, 0x120a <.LLST13+0x8>
    6cb0:	72d8 120c 	lod	A, 0x120c <.LASF1440>
    6cb4:	2ee2      	cmp	X, A
    6cb6:	1f01      	jsg	0x6cba <.LM372>
    6cb8:	0040      	jmp	0x6d3a <.L209>

00006cba <.LM372>:
		{
			diffPos = valve.pos.targetAngle - valve.pos.currentAngle;
    6cba:	2ae2      	sub	X, A

00006cbc <.L210>:
		{

			nextState = VALVE_READY;
		}
#else
		if ((valve.comm.lastMode != valve.comm.targetMode) && (diffPos >= (int16_t)C_VALVE_ACCURACY_ANGLE))
    6cbc:	66d8 1224 	lod	YL, 0x1224 <.LLST14+0xb>
    6cc0:	62d8 1228 	lod	AL, 0x1228 <.Lframe0>
    6cc4:	8ee8      	cmp	AL, YL
    6cc6:	1d01      	jne	0x6cca <.LM374>
    6cc8:	003b      	jmp	0x6d40 <.L330>

00006cca <.LM374>:
		{

			nextState = VALVE_READY;
    6cca:	2c13      	cmp	X, #19
    6ccc:	5cb2      	ssg	A
    6cce:	a001      	add	A, #1
    6cd0:	5205      	mov	[S-6], A

00006cd2 <.L211>:
		}
#endif
		valve.comm.lastMode = valve.comm.targetMode;
    6cd2:	46d8 1228 	mov	0x1228 <.Lframe0>, YL

00006cd6 <.L200>:
		nextState = VALVE_STANDBY;
		break;
	}

	/* state changed */
	if (valve.state != nextState)
    6cd6:	72d8 11fc 	lod	A, 0x11fc <_valve>
    6cda:	ae05      	cmp	A, [S-6]
    6cdc:	1d01      	jne	0x6ce0 <.LM377>
    6cde:	01be      	jmp	0x705c <.L318>

00006ce0 <.LM377>:
	{

		valve.initStatus = 1;
    6ce0:	6401      	lod	YL, #1
    6ce2:	46d8 1207 	mov	0x1207 <.LLST13+0x5>, YL

00006ce6 <.LM378>:
		valve.elapsedTime = 0;
    6ce6:	7c00      	lod	X, #0
    6ce8:	0ea7      	lod	C, ML.7
    6cea:	5ed8 1202 	mov	0x1202 <.LLST13>, X

00006cee <.LM379>:
		if (valve.state != VALVE_LOWPOWER)
    6cee:	ac09      	cmp	A, #9
    6cf0:	1902      	je	0x6cf6 <.L319>

00006cf2 <.LM380>:
		{
			valve.lastState = valve.state;
    6cf2:	52d8 11fe 	mov	0x11fe <_valve+0x2>, A

00006cf6 <.L319>:
		}
		valve.state = nextState;
    6cf6:	7205      	lod	A, [S-6]
    6cf8:	52d8 11fc 	mov	0x11fc <_valve>, A

00006cfc <.L320>:
	{
		if (valve.elapsedTime < 0xffffu)
			valve.elapsedTime += 1;
	}

	if (valve.linLiveTimeOut > 0)
    6cfc:	72d8 1200 	lod	A, 0x1200 <_valve+0x4>
    6d00:	1d02      	jne	0x6d06 <.LM383>
    6d02:	76da 3a9a 	jmpf	0x7534 <.L321>

00006d06 <.LM383>:
	{
		valve.linLiveTimeOut -= 1;
    6d06:	a0ff      	add	A, #-1
    6d08:	52d8 1200 	mov	0x1200 <_valve+0x4>, A

00006d0c <.L322>:
	else
	{
		valve.diag.linError = 1;
	}
	//	valve.comm.actualMode
	if (Fwv_Request_Event != 0)
    6d0c:	62d8 10ab 	lod	AL, 0x10ab <_Fwv_Request_Event>
    6d10:	1908      	je	0x6d22 <.L323>

00006d12 <.LM385>:
	{
		Fwv_Request_Event = 0;
    6d12:	6000      	lod	AL, #0
    6d14:	42d8 10ab 	mov	0x10ab <_Fwv_Request_Event>, AL

00006d18 <.LM386>:
		//		ValveLinGetCommand();
		valve.linLiveTimeOut = 4000;
    6d18:	72da 0fa0 	lod	A, #4000
    6d1c:	0ea7      	lod	C, ML.7
    6d1e:	52d8 1200 	mov	0x1200 <_valve+0x4>, A

00006d22 <.L323>:
	}
	if (Fwv_Response_Event != 0)
    6d22:	62d8 10aa 	lod	AL, 0x10aa <__data_end>
    6d26:	1908      	je	0x6d38 <.L118>

00006d28 <.LM388>:
	{
		Fwv_Response_Event = 0;
    6d28:	6000      	lod	AL, #0
    6d2a:	42d8 10aa 	mov	0x10aa <__data_end>, AL

00006d2e <.LM389>:
		//		ValveLinUpdateSignals();
		valve.linLiveTimeOut = 4000;
    6d2e:	72da 0fa0 	lod	A, #4000
    6d32:	0ea7      	lod	C, ML.7
    6d34:	52d8 1200 	mov	0x1200 <_valve+0x4>, A

00006d38 <.L118>:
	}
}
    6d38:	5409      	ret	#10

00006d3a <.L209>:
		{
			diffPos = valve.pos.targetAngle - valve.pos.currentAngle;
		}
		else
		{
			diffPos = valve.pos.currentAngle - valve.pos.targetAngle;
    6d3a:	aaee      	sub	A, X
    6d3c:	7ee2      	lod	X, A

00006d3e <.LVL146>:
    6d3e:	07be      	jmp	0x6cbc <.L210>

00006d40 <.L330>:
}

static tValveState ValveStandbyTask(void)
{

	tValveState nextState = VALVE_STANDBY;
    6d40:	7c01      	lod	X, #1

00006d42 <.LVL148>:
    6d42:	5e05      	mov	[S-6], X

00006d44 <.LVL149>:
    6d44:	07c6      	jmp	0x6cd2 <.L211>

00006d46 <.L191>:
static tValveState ValveReadyTask(void)
{

	tValveState nextState = VALVE_READY;

	if (valve.initStatus != 0)
    6d46:	62d8 1207 	lod	AL, 0x1207 <.LLST13+0x5>
    6d4a:	1905      	je	0x6d56 <.L212>

00006d4c <.LM394>:
	{
		valve.initStatus = 0;
    6d4c:	6000      	lod	AL, #0
    6d4e:	42d8 1207 	mov	0x1207 <.LLST13+0x5>, AL

00006d52 <.LM395>:
		MotClearHardStop();
    6d52:	82db 3e2c 	callf	0x7c58 <_MotClearHardStop>

00006d56 <.L212>:
	}

	MotSetTargetPosition(valve.pos.targetAngle);
    6d56:	72d8 120a 	lod	A, 0x120a <.LLST13+0x8>
    6d5a:	82db 3e30 	callf	0x7c60 <_MotSetTargetPosition>

00006d5e <.LBE343>:
		break;
	case VALVE_STANDBY:
		nextState = ValveStandbyTask();
		break;
	case VALVE_READY:
		nextState = ValveReadyTask();
    6d5e:	7803      	lod	Y, #3

00006d60 <.L563>:
	}
	return nextState;
}
static tValveState ValvePowerLatchTask(void)
{
	tValveState nextState = VALVE_POWERLATCH;
    6d60:	5a05      	mov	[S-6], Y
    6d62:	07b9      	jmp	0x6cd6 <.L200>

00006d64 <.L192>:
{

	tValveState nextState = VALVE_OPERATION;
	int16_t actualPos;

	if (valve.initStatus != 0)
    6d64:	62d8 1207 	lod	AL, 0x1207 <.LLST13+0x5>
    6d68:	1905      	je	0x6d74 <.L213>

00006d6a <.LM400>:
	{
		valve.initStatus = 0;
    6d6a:	6000      	lod	AL, #0
    6d6c:	42d8 1207 	mov	0x1207 <.LLST13+0x5>, AL

00006d70 <.LM401>:

		MotClearHardStop();
    6d70:	82db 3e2c 	callf	0x7c58 <_MotClearHardStop>

00006d74 <.L213>:
	}

	if (valve.elapsedTime >= valve.comm.timeOut)
    6d74:	72d8 1202 	lod	A, 0x1202 <.LLST13>
    6d78:	aed8 1222 	cmp	A, 0x1222 <.LLST14+0x9>
    6d7c:	1805      	jc	0x6d88 <.L214>

00006d7e <.LM403>:
	{

		valve.pos.fault = 1;
    6d7e:	6001      	lod	AL, #1
    6d80:	42d8 1212 	mov	0x1212 <.LASF1440+0x6>, AL

00006d84 <.L314>:
				valve.pos.fault = 1;
			}
#endif
			if (valve.pos.fault != 0)
			{
				nextState = VALVE_PROTECTION;
    6d84:	7807      	lod	Y, #7
    6d86:	07ec      	jmp	0x6d60 <.L563>

00006d88 <.L214>:
		else
		{
			nextState = VALVE_STANDBY;
		}
#else
		if ((valve.motorMotion >= MOTION_ACC) && (valve.motorMotion <= MOTION_DEC))
    6d88:	72d8 1208 	lod	A, 0x1208 <.LLST13+0x6>
    6d8c:	a0fe      	add	A, #-2
    6d8e:	ac02      	cmp	A, #2
    6d90:	1e01      	jug	0x6d94 <.LM406>
    6d92:	03ca      	jmp	0x7528 <.L332>

00006d94 <.LM406>:
		{
		}
		else
		{

			actualPos = valve.pos.currentAngle;
    6d94:	7ed8 120c 	lod	X, 0x120c <.LASF1440>

00006d98 <.LM407>:
				
				}
			}
			else {}
#else
			if ((actualPos >= (valve.pos.modeAngle[C_MODE_A] - (int16_t)C_VALVE_ACCURACY_ANGLE)) && (actualPos <= (valve.pos.modeAngle[C_MODE_A] + (int16_t)C_VALVE_ACCURACY_ANGLE)))
    6d98:	72d8 120e 	lod	A, 0x120e <.LASF1440+0x2>
    6d9c:	7ae2      	lod	Y, A
    6d9e:	e0ec      	add	Y, #-20
    6da0:	2ee6      	cmp	X, Y
    6da2:	1a83      	jsl	0x6daa <.L215>
    6da4:	a014      	add	A, #20
    6da6:	2ee2      	cmp	X, A
    6da8:	1b0c      	jsle	0x6dc2 <.L216>

00006daa <.L215>:
			{
			}
			else if ((actualPos >= (valve.pos.modeAngle[C_MODE_B] - (int16_t)C_VALVE_ACCURACY_ANGLE)) && (actualPos <= (valve.pos.modeAngle[C_MODE_B] + (int16_t)C_VALVE_ACCURACY_ANGLE)))
    6daa:	72d8 1210 	lod	A, 0x1210 <.LASF1440+0x4>
    6dae:	7ae2      	lod	Y, A
    6db0:	e0ec      	add	Y, #-20
    6db2:	2ee6      	cmp	X, Y
    6db4:	1a83      	jsl	0x6dbc <.L217>
    6db6:	a014      	add	A, #20
    6db8:	2ee2      	cmp	X, A
    6dba:	1b03      	jsle	0x6dc2 <.L216>

00006dbc <.L217>:
			{
			}
			else
			{
				valve.pos.fault = 1;
    6dbc:	6001      	lod	AL, #1
    6dbe:	42d8 1212 	mov	0x1212 <.LASF1440+0x6>, AL

00006dc2 <.L216>:
			}
#endif
			if (valve.pos.fault != 0)
    6dc2:	62d8 1212 	lod	AL, 0x1212 <.LASF1440+0x6>

00006dc6 <.L555>:
    6dc6:	8c00      	cmp	AL, #0
    6dc8:	1d5d      	jne	0x6d84 <.L314>

00006dca <.L203>:
			{
				nextState = VALVE_PROTECTION;
			}
			else
			{
				nextState = VALVE_STANDBY;
    6dca:	7c01      	lod	X, #1

00006dcc <.L561>:
		break;
	case VALVE_LOWPOWER:
		nextState = ValveLowPowerTask();
		break;
	case VALVE_UNDEF:
		nextState = ValveUndefTask();
    6dcc:	5e05      	mov	[S-6], X
    6dce:	0783      	jmp	0x6cd6 <.L200>

00006dd0 <.L193>:
static tValveState ValveDiagRunTask(void)
{

	tValveState nextState = VALVE_DIAGRUN;

	if (valve.initStatus != 0)
    6dd0:	62d8 1207 	lod	AL, 0x1207 <.LLST13+0x5>
    6dd4:	1909      	je	0x6de8 <.L218>

00006dd6 <.LM414>:
	{
		valve.initStatus = 0;
    6dd6:	6000      	lod	AL, #0
    6dd8:	42d8 1207 	mov	0x1207 <.LLST13+0x5>, AL

00006ddc <.LM415>:
		valve.test.step = 0;
    6ddc:	7000      	lod	A, #0
    6dde:	0ea7      	lod	C, ML.7
    6de0:	52d8 122c 	mov	0x122c <.LLST15>, A

00006de4 <.LM416>:
		MotClearHardStop();
    6de4:	82db 3e2c 	callf	0x7c58 <_MotClearHardStop>

00006de8 <.L218>:
	}
	valve.comm.lastMode = 0xff;
    6de8:	60ff      	lod	AL, #-1
    6dea:	42d8 1228 	mov	0x1228 <.Lframe0>, AL

00006dee <.LM418>:
	if (valve.comm.ForcedDiag == 0)
    6dee:	62d8 1227 	lod	AL, 0x1227 <.LLST14+0xe>
    6df2:	1d04      	jne	0x6dfc <.L219>

00006df4 <.LM419>:
	{
		if (valve.comm.moving == 0)
    6df4:	62d8 122a 	lod	AL, 0x122a <.Lframe0+0x2>
    6df8:	1968      	je	0x6dca <.L203>
    6dfa:	0752      	jmp	0x6ca0 <.L571>

00006dfc <.L219>:
		}
	}
	else
	{
		/* B->A->B*/
		if ((valve.motorMotion >= MOTION_ACC) && (valve.motorMotion <= MOTION_DEC))
    6dfc:	72d8 1208 	lod	A, 0x1208 <.LLST13+0x6>
    6e00:	a0fe      	add	A, #-2
    6e02:	ac02      	cmp	A, #2
    6e04:	1e04      	jug	0x6e0e <.L221>

00006e06 <.LM421>:
		{
			valve.elapsedTime = 0;
    6e06:	7000      	lod	A, #0
    6e08:	52d8 1202 	mov	0x1202 <.LLST13>, A
    6e0c:	0749      	jmp	0x6ca0 <.L571>

00006e0e <.L221>:
		}
		else
		{

			if (valve.elapsedTime >= 2000u)
    6e0e:	72d8 1202 	lod	A, 0x1202 <.LLST13>
    6e12:	aeda 07cf 	cmp	A, #1999
    6e16:	1e01      	jug	0x6e1a <.LM423>
    6e18:	0743      	jmp	0x6ca0 <.L571>

00006e1a <.LM423>:
			{
				if (valve.test.step == 0)
    6e1a:	72d8 122c 	lod	A, 0x122c <.LLST15>
    6e1e:	1d0c      	jne	0x6e38 <.L222>

00006e20 <.LM424>:
				{
					valve.test.step = 1;
    6e20:	7001      	lod	A, #1
    6e22:	52d8 122c 	mov	0x122c <.LLST15>, A

00006e26 <.LM425>:
					ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]);
    6e26:	72d8 1210 	lod	A, 0x1210 <.LASF1440+0x4>

00006e2a <.LBB334>:

#endif
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    6e2a:	0ea7      	lod	C, ML.7
    6e2c:	52d8 120a 	mov	0x120a <.LLST13+0x8>, A

00006e30 <.LBE334>:
			{
				if (valve.test.step == 0)
				{
					valve.test.step = 1;
					ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]);
					MotSetTargetPosition(valve.pos.targetAngle);
    6e30:	82db 3e30 	callf	0x7c60 <_MotSetTargetPosition>

00006e34 <.LM428>:
}

static tValveState ValveDiagRunTask(void)
{

	tValveState nextState = VALVE_DIAGRUN;
    6e34:	7c04      	lod	X, #4
    6e36:	07ca      	jmp	0x6dcc <.L561>

00006e38 <.L222>:
				{
					valve.test.step = 1;
					ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]);
					MotSetTargetPosition(valve.pos.targetAngle);
				}
				else if (valve.test.step == 1)
    6e38:	ac01      	cmp	A, #1
    6e3a:	1d0c      	jne	0x6e54 <.L223>

00006e3c <.LM430>:
				{
#if 0
					valve.test.step=0;
#else
					valve.test.step = 2;
    6e3c:	7002      	lod	A, #2
    6e3e:	52d8 122c 	mov	0x122c <.LLST15>, A

00006e42 <.LM431>:
#endif
					ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_A]);
    6e42:	72d8 120e 	lod	A, 0x120e <.LASF1440+0x2>

00006e46 <.LBB336>:

#endif
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    6e46:	0ea7      	lod	C, ML.7
    6e48:	52d8 120a 	mov	0x120a <.LLST13+0x8>, A

00006e4c <.LBE336>:
					valve.test.step=0;
#else
					valve.test.step = 2;
#endif
					ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_A]);
					MotSetTargetPosition(valve.pos.targetAngle);
    6e4c:	82db 3e30 	callf	0x7c60 <_MotSetTargetPosition>

00006e50 <.LM434>:
}

static tValveState ValveDiagRunTask(void)
{

	tValveState nextState = VALVE_DIAGRUN;
    6e50:	7004      	lod	A, #4
    6e52:	0705      	jmp	0x6c5e <.L562>

00006e54 <.L223>:
					valve.test.step = 2;
#endif
					ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_A]);
					MotSetTargetPosition(valve.pos.targetAngle);
				}
				else if (valve.test.step == 2) /*20250714*/
    6e54:	ac02      	cmp	A, #2
    6e56:	1901      	je	0x6e5a <.LM436>
    6e58:	0723      	jmp	0x6ca0 <.L571>

00006e5a <.LM436>:
				{
					valve.test.step = 3;
    6e5a:	7003      	lod	A, #3
    6e5c:	52d8 122c 	mov	0x122c <.LLST15>, A

00006e60 <.LM437>:
					ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]);
    6e60:	72d8 1210 	lod	A, 0x1210 <.LASF1440+0x4>

00006e64 <.LBB338>:

#endif
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    6e64:	0ea7      	lod	C, ML.7
    6e66:	52d8 120a 	mov	0x120a <.LLST13+0x8>, A

00006e6a <.LBE338>:
				}
				else if (valve.test.step == 2) /*20250714*/
				{
					valve.test.step = 3;
					ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]);
					MotSetTargetPosition(valve.pos.targetAngle);
    6e6a:	82db 3e30 	callf	0x7c60 <_MotSetTargetPosition>
    6e6e:	0718      	jmp	0x6ca0 <.L571>

00006e70 <.L194>:
{
	tValveState nextState = VALVE_CALIBRATION;
	int16_t diff;
	uint16_t timeOut;

	if (valve.calibration.req2Cal)
    6e70:	62d8 1216 	lod	AL, 0x1216 <.LASF1440+0xa>
    6e74:	66e0      	lod	YL, AL
    6e76:	5cf6      	usex	Y
    6e78:	5a07      	mov	[S-8], Y

00006e7a <.LVL174>:
    6e7a:	8c00      	cmp	AL, #0
    6e7c:	191c      	je	0x6eb6 <.L333>

00006e7e <.LM441>:
	{
		timeOut = 20000;
    6e7e:	7ada 4e20 	lod	Y, #20000

00006e82 <.L556>:
	}
	else
	{
		timeOut = 6000;
    6e82:	5a05      	mov	[S-6], Y

00006e84 <.LM443>:
	}
	// uint16_t state,value;
	if (valve.initStatus != 0)
    6e84:	62d8 1207 	lod	AL, 0x1207 <.LLST13+0x5>
    6e88:	1908      	je	0x6e9a <.L225>

00006e8a <.LM444>:
	{
		valve.initStatus = 0;
    6e8a:	6000      	lod	AL, #0
    6e8c:	42d8 1207 	mov	0x1207 <.LLST13+0x5>, AL

00006e90 <.LM445>:
		valve.calibration.state = CALSTEP_RESET;
    6e90:	42d8 1214 	mov	0x1214 <.LASF1440+0x8>, AL

00006e94 <.LM446>:
		valve.diag.calFault = 0;
    6e94:	0ea7      	lod	C, ML.7
    6e96:	42d8 1264 	mov	0x1264 <.LASF1020+0x5>, AL

00006e9a <.L225>:
	}
	valve.comm.lastMode = 0xff;
    6e9a:	60ff      	lod	AL, #-1
    6e9c:	42d8 1228 	mov	0x1228 <.Lframe0>, AL

00006ea0 <.LM448>:
	switch (valve.calibration.state)
    6ea0:	62d8 1214 	lod	AL, 0x1214 <.LASF1440+0x8>
    6ea4:	5cf2      	usex	A
    6ea6:	ac09      	cmp	A, #9
    6ea8:	1a01      	jule	0x6eac <.LASF1640+0x9>
    6eaa:	078f      	jmp	0x6dca <.L203>
    6eac:	4422      	asl	A
    6eae:	a2da 5cd8 	add	A, #23768
    6eb2:	7ae2      	lod	Y, A

00006eb4 <.LVL176>:
    6eb4:	76f0      	jmp	[Y]

00006eb6 <.L333>:
	{
		timeOut = 20000;
	}
	else
	{
		timeOut = 6000;
    6eb6:	7ada 1770 	lod	Y, #6000
    6eba:	07e3      	jmp	0x6e82 <.L556>

00006ebc <.L226>:
	}
	valve.comm.lastMode = 0xff;
	switch (valve.calibration.state)
	{
	case CALSTEP_RESET:
		MotClearStallFlag(0); /* clear stall flag if set */
    6ebc:	7000      	lod	A, #0
    6ebe:	82db 3e4a 	callf	0x7c94 <_MotClearStallFlag>

00006ec2 <.LM451>:
		MotRequestHardStop();
    6ec2:	82db 3e28 	callf	0x7c50 <_MotRequestHardStop>

00006ec6 <.LM452>:
		valve.calibration.state = CALSTEP_START;
    6ec6:	6001      	lod	AL, #1

00006ec8 <.L573>:
				valve.pos.modeAngle[C_MODE_A] = valve.calibration.d360Angle;
#endif
				ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]); /* move to init position */
				MotSetTargetPosition(valve.pos.targetAngle);
				valve.calibration.delay = 3;
				valve.calibration.state = CALSTEP_INIT_POS;
    6ec8:	42d8 1214 	mov	0x1214 <.LASF1440+0x8>, AL

00006ecc <.L574>:

	set_gmr_sensor_offset(offset);
}
static tValveState ValveCalibrationTask(void)
{
	tValveState nextState = VALVE_CALIBRATION;
    6ecc:	7c05      	lod	X, #5
    6ece:	077e      	jmp	0x6dcc <.L561>

00006ed0 <.L228>:
		MotClearStallFlag(0); /* clear stall flag if set */
		MotRequestHardStop();
		valve.calibration.state = CALSTEP_START;
		break;
	case CALSTEP_START:
		MotClearHardStop();
    6ed0:	82db 3e2c 	callf	0x7c58 <_MotClearHardStop>

00006ed4 <.LM456>:
		valve.calibration.delay = 3;
    6ed4:	7003      	lod	A, #3
    6ed6:	52d8 121e 	mov	0x121e <.LLST14+0x5>, A

00006eda <.LM457>:
		valve.calibration.timer = 0;
    6eda:	7000      	lod	A, #0
    6edc:	0ea7      	lod	C, ML.7
    6ede:	52d8 1220 	mov	0x1220 <.LLST14+0x7>, A

00006ee2 <.LM458>:
		if (valve.calibration.req2Cal != 0)
    6ee2:	62d8 1216 	lod	AL, 0x1216 <.LASF1440+0xa>
    6ee6:	190a      	je	0x6efc <.L235>

00006ee8 <.L236>:

#endif
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    6ee8:	709c      	lod	A, #-100
    6eea:	52d8 120a 	mov	0x120a <.LLST13+0x8>, A

00006eee <.LBE355>:
		valve.calibration.delay = 3;
		valve.calibration.timer = 0;
		if (valve.calibration.req2Cal != 0)
		{
			ValveTargetAngleUpdate(-10 * C_GMR_ANGLE_SCALE_FACTOR); /* move to 0% position */
			MotSetTargetPosition(valve.pos.targetAngle);
    6eee:	82db 3e30 	callf	0x7c60 <_MotSetTargetPosition>

00006ef2 <.LM461>:
			valve.calibration.state = CALSTEP_0d_POS;
    6ef2:	6002      	lod	AL, #2

00006ef4 <.L575>:
			}
			else
			{
				ValveTargetAngleUpdate(370 * C_GMR_ANGLE_SCALE_FACTOR); /* move to 360% position */
				MotSetTargetPosition(valve.pos.targetAngle);
				valve.calibration.state = CALSTEP_360d_POS;
    6ef4:	42d8 1214 	mov	0x1214 <.LASF1440+0x8>, AL

00006ef8 <.L572>:

	set_gmr_sensor_offset(offset);
}
static tValveState ValveCalibrationTask(void)
{
	tValveState nextState = VALVE_CALIBRATION;
    6ef8:	7805      	lod	Y, #5
    6efa:	0732      	jmp	0x6d60 <.L563>

00006efc <.L235>:
			MotSetTargetPosition(valve.pos.targetAngle);
			valve.calibration.state = CALSTEP_0d_POS;
		}
		else
		{
			if (valve.pos.currentAngle <= (valve.pos.modeAngle[C_MODE_B] + (int16_t)(45 * C_GMR_ANGLE_SCALE_FACTOR)))
    6efc:	72d8 1210 	lod	A, 0x1210 <.LASF1440+0x4>
    6f00:	a2da 01c2 	add	A, #450
    6f04:	aed8 120c 	cmp	A, 0x120c <.LASF1440>
    6f08:	1eef      	jsge	0x6ee8 <.L236>

00006f0a <.LBB357>:

#endif
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    6f0a:	72da 0e74 	lod	A, #3700
    6f0e:	52d8 120a 	mov	0x120a <.LLST13+0x8>, A

00006f12 <.LBE357>:
				valve.calibration.state = CALSTEP_0d_POS;
			}
			else
			{
				ValveTargetAngleUpdate(370 * C_GMR_ANGLE_SCALE_FACTOR); /* move to 360% position */
				MotSetTargetPosition(valve.pos.targetAngle);
    6f12:	82db 3e30 	callf	0x7c60 <_MotSetTargetPosition>

00006f16 <.LM467>:
				valve.calibration.state = CALSTEP_360d_POS;
    6f16:	6003      	lod	AL, #3
    6f18:	0ea7      	lod	C, ML.7
    6f1a:	07ec      	jmp	0x6ef4 <.L575>

00006f1c <.L229>:
			}
		}
		break;
	case CALSTEP_0d_POS:
		valve.calibration.timer += 1;
    6f1c:	72d8 1220 	lod	A, 0x1220 <.LLST14+0x7>
    6f20:	a001      	add	A, #1
    6f22:	52d8 1220 	mov	0x1220 <.LLST14+0x7>, A

00006f26 <.LM469>:
		if (valve.calibration.timer >= timeOut)
    6f26:	ae05      	cmp	A, [S-6]
    6f28:	1802      	jc	0x6f2e <.L237>

00006f2a <.L576>:
			{

				MotClearStallFlag(0); /* clear stall flag if set */
				MotRequestHardStop();

				valve.calibration.state = CALSTEP_FAULT;
    6f2a:	6008      	lod	AL, #8
    6f2c:	07cd      	jmp	0x6ec8 <.L573>

00006f2e <.L237>:
		if (valve.calibration.timer >= timeOut)
		{

			valve.calibration.state = CALSTEP_FAULT;
		}
		else if (valve.calibration.delay > 0)
    6f2e:	72d8 121e 	lod	A, 0x121e <.LLST14+0x5>
    6f32:	1905      	je	0x6f3e <.L238>

00006f34 <.L570>:
		}
		break;
	case CALSTEP_INIT_POS:
		if (valve.calibration.delay > 0)
		{
			valve.calibration.delay -= 1;
    6f34:	a0ff      	add	A, #-1
    6f36:	52d8 121e 	mov	0x121e <.LLST14+0x5>, A

00006f3a <.L328>:
	MotRequestHardStop();

	if ((valve.calibration.req2Cal == 1) || (valve.calibration.req1Cal == 1))
	{

		nextState = VALVE_CALIBRATION;
    6f3a:	7005      	lod	A, #5
    6f3c:	0690      	jmp	0x6c5e <.L562>

00006f3e <.L238>:
			valve.calibration.delay -= 1;
		}
		else
		{

			if (valve.motorMotion == MOTION_STALL)
    6f3e:	7a01      	lod	Y, [S-2]
    6f40:	ec06      	cmp	Y, #6
    6f42:	1901      	je	0x6f46 <.LM475>
    6f44:	0087      	jmp	0x7054 <.L249>

00006f46 <.LM475>:
			{
				MotClearStallFlag(0); /* clear stall flag if set */
    6f46:	82db 3e4a 	callf	0x7c94 <_MotClearStallFlag>

00006f4a <.LM476>:
				MotRequestHardStop();
    6f4a:	82db 3e28 	callf	0x7c50 <_MotRequestHardStop>

00006f4e <.LM477>:
				if (valve.calibration.offsetDone == 0)
    6f4e:	62d8 1215 	lod	AL, 0x1215 <.LASF1440+0x9>
    6f52:	1d32      	jne	0x6fb8 <.L241>

00006f54 <.LM478>:
				{
					calcSensorOffset(valve.pos.currentAngle);
    6f54:	7ad8 120c 	lod	Y, 0x120c <.LASF1440>

00006f58 <.LBB359>:

	return nextState;
}
static void calcSensorOffset(int16_t currDegree)
{
	int16_t offset = get_gmr_sensor_offset();
    6f58:	5a03      	mov	[S-4], Y
    6f5a:	82db 3bfb 	callf	0x77f6 <_get_gmr_sensor_offset>

00006f5e <.LM480>:
	if (offset >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
	{
		offset -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
	}
#else
	offset += (int16_t)((int16_t)(C_GMR_SENSOR_OFFSET * C_GMR_ANGLE_SCALE_FACTOR) - currDegree);
    6f5e:	7a03      	lod	Y, [S-4]
    6f60:	aae6      	sub	A, Y

00006f62 <.LVL196>:
    6f62:	a2da 0708 	add	A, #1800

00006f66 <.LM481>:
	if (offset >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
    6f66:	aeda 0e0f 	cmp	A, #3599
    6f6a:	1b33      	jsle	0x6fd2 <.L242>

00006f6c <.LM482>:
	{
		offset -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    6f6c:	a2da f1f0 	add	A, #61936

00006f70 <.L243>:
	else
	{
	}
#endif

	set_gmr_sensor_offset(offset);
    6f70:	82db 3bf8 	callf	0x77f0 <_set_gmr_sensor_offset>

00006f74 <.LBE359>:
				MotClearStallFlag(0); /* clear stall flag if set */
				MotRequestHardStop();
				if (valve.calibration.offsetDone == 0)
				{
					calcSensorOffset(valve.pos.currentAngle);
					diff = valve.memory.offset - get_gmr_sensor_offset();
    6f74:	7ad8 1234 	lod	Y, 0x1234 <.LLST15+0x8>
    6f78:	5a03      	mov	[S-4], Y
    6f7a:	82db 3bfb 	callf	0x77f6 <_get_gmr_sensor_offset>
    6f7e:	7a03      	lod	Y, [S-4]
    6f80:	eae2      	sub	Y, A
    6f82:	72e6      	lod	A, Y

00006f84 <.LM485>:
					if (diff < 0)
					{
						diff = -diff;
					}
					if (diff > C_VALVE_CAL_HYSTERISYS)
    6f84:	1d81      	jnn	0x6f88 <.L579>
    6f86:	5cc2      	neg	A

00006f88 <.L579>:
    6f88:	4cf6      	ssex	YA
    6f8a:	82db 2fe8 	callf	0x5fd0 <___floatsisf>

00006f8e <.LVL203>:
    6f8e:	54ca 0000 	pushw	#0
    6f92:	54ca 4120 	pushw	#16672

00006f96 <.LCFI8>:
    6f96:	82db 2fc6 	callf	0x5f8c <___gtsf2>
    6f9a:	5c03      	dec	S, #4

00006f9c <.LCFI9>:
    6f9c:	ac00      	cmp	A, #0
    6f9e:	1b0c      	jsle	0x6fb8 <.L241>

00006fa0 <.LM486>:
					{
						valve_gmr_write((uint16_t)get_gmr_sensor_offset(), (uint16_t)valve.pos.currentAngle, 0x5555);
    6fa0:	7ad8 120c 	lod	Y, 0x120c <.LASF1440>
    6fa4:	5a03      	mov	[S-4], Y
    6fa6:	82db 3bfb 	callf	0x77f6 <_get_gmr_sensor_offset>
    6faa:	54ca 5555 	pushw	#21845

00006fae <.LCFI10>:
    6fae:	7a05      	lod	Y, [S-6]
    6fb0:	5adf      	push	Y

00006fb2 <.LCFI11>:
    6fb2:	82db 43be 	callf	0x877c <_valve_gmr_write>
    6fb6:	5c03      	dec	S, #4

00006fb8 <.L241>:
					}
				}
				valve.calibration.offsetDone = 1;
				valve.calibration.delay = 3;
    6fb8:	7003      	lod	A, #3
    6fba:	52d8 121e 	mov	0x121e <.LLST14+0x5>, A

00006fbe <.LM488>:
				valve.calibration.timer = 0;
    6fbe:	7000      	lod	A, #0
    6fc0:	0ea7      	lod	C, ML.7
    6fc2:	52d8 1220 	mov	0x1220 <.LLST14+0x7>, A

00006fc6 <.LM489>:
				valve.calibration.state = CALSTEP_CALC;
    6fc6:	72da 0105 	lod	A, #261
    6fca:	52d8 1214 	mov	0x1214 <.LASF1440+0x8>, A
    6fce:	0ea7      	lod	C, ML.7
    6fd0:	0793      	jmp	0x6ef8 <.L572>

00006fd2 <.L242>:
	offset += (int16_t)((int16_t)(C_GMR_SENSOR_OFFSET * C_GMR_ANGLE_SCALE_FACTOR) - currDegree);
	if (offset >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
	{
		offset -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
	}
	else if (offset < 0)
    6fd2:	ac00      	cmp	A, #0
    6fd4:	1ecd      	jsge	0x6f70 <.L243>

00006fd6 <.LM491>:
	{
		offset = (-offset);
		offset = (int16_t)C_GMR_SENSOR_ANGLE_LIMIT - offset;
    6fd6:	a2da 0e10 	add	A, #3600

00006fda <.LVL214>:
    6fda:	07ca      	jmp	0x6f70 <.L243>

00006fdc <.L230>:
			}
		}
		break;

	case CALSTEP_360d_POS:
		valve.calibration.timer += 1;
    6fdc:	72d8 1220 	lod	A, 0x1220 <.LLST14+0x7>
    6fe0:	a001      	add	A, #1
    6fe2:	52d8 1220 	mov	0x1220 <.LLST14+0x7>, A

00006fe6 <.LM493>:
		if (valve.calibration.timer >= timeOut)
    6fe6:	7e05      	lod	X, [S-6]
    6fe8:	2ee2      	cmp	X, A
    6fea:	1e01      	jug	0x6fee <.LM494>
    6fec:	079e      	jmp	0x6f2a <.L576>

00006fee <.LM494>:
		{

			valve.calibration.state = CALSTEP_FAULT;
		}
		else if (valve.calibration.delay > 0)
    6fee:	72d8 121e 	lod	A, 0x121e <.LLST14+0x5>
    6ff2:	1901      	je	0x6ff6 <.LM495>
    6ff4:	079f      	jmp	0x6f34 <.L570>

00006ff6 <.LM495>:
		{
			valve.calibration.delay -= 1;
		}
		else
		{
			if (valve.motorMotion == MOTION_STALL)
    6ff6:	7a01      	lod	Y, [S-2]
    6ff8:	ec06      	cmp	Y, #6
    6ffa:	1d2c      	jne	0x7054 <.L249>

00006ffc <.LM496>:
			{
				MotClearStallFlag(0);																	/* clear stall flag if set */
    6ffc:	82db 3e4a 	callf	0x7c94 <_MotClearStallFlag>

00007000 <.LM497>:
				valve.calibration.d360Angle = (valve.pos.currentAngle - (int16_t)C_STOPPER_360D_ANGLE); // C_STOPPER_360D_ANGLE
    7000:	72d8 120c 	lod	A, 0x120c <.LASF1440>
    7004:	7ee2      	lod	X, A
    7006:	22da ff47 	add	X, #65351

0000700a <.LM498>:
				if (valve.calibration.d360Angle < 0)
    700a:	2c00      	cmp	X, #0
    700c:	1e85      	jsge	0x7018 <.L250>

0000700e <.LM499>:
				{
					valve.calibration.d360Angle += (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    700e:	a2da 0d57 	add	A, #3415

00007012 <.L558>:
				}
				else if (valve.calibration.d360Angle >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
				{
					valve.calibration.d360Angle -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    7012:	52d8 121c 	mov	0x121c <.LLST14+0x3>, A
    7016:	0005      	jmp	0x7022 <.L251>

00007018 <.L250>:
				valve.calibration.d360Angle = (valve.pos.currentAngle - (int16_t)C_STOPPER_360D_ANGLE); // C_STOPPER_360D_ANGLE
				if (valve.calibration.d360Angle < 0)
				{
					valve.calibration.d360Angle += (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
				}
				else if (valve.calibration.d360Angle >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
    7018:	2eda 0e0f 	cmp	X, #3599
    701c:	1f18      	jsg	0x704e <.L252>

0000701e <.LM502>:
		else
		{
			if (valve.motorMotion == MOTION_STALL)
			{
				MotClearStallFlag(0);																	/* clear stall flag if set */
				valve.calibration.d360Angle = (valve.pos.currentAngle - (int16_t)C_STOPPER_360D_ANGLE); // C_STOPPER_360D_ANGLE
    701e:	5ed8 121c 	mov	0x121c <.LLST14+0x3>, X

00007022 <.L251>:
					valve.calibration.d360Angle -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
				}
				else
				{
				}
				valve.calibration.travel = valve.calibration.d360Angle - valve.calibration.d0Angle;
    7022:	72d8 121c 	lod	A, 0x121c <.LLST14+0x3>
    7026:	7ee2      	lod	X, A
    7028:	2ad8 121a 	sub	X, 0x121a <.LLST14+0x1>
    702c:	5ed8 1218 	mov	0x1218 <.LASF1440+0xc>, X

00007030 <.LM504>:
#if 1
				valve.pos.modeAngle[C_MODE_A] = valve.calibration.d360Angle;
    7030:	52d8 120e 	mov	0x120e <.LASF1440+0x2>, A

00007034 <.LM505>:
#endif
				ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]); /* move to init position */
    7034:	0ea7      	lod	C, ML.7
    7036:	72d8 1210 	lod	A, 0x1210 <.LASF1440+0x4>

0000703a <.LBB363>:

#endif
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    703a:	52d8 120a 	mov	0x120a <.LLST13+0x8>, A

0000703e <.LBE363>:
				valve.calibration.travel = valve.calibration.d360Angle - valve.calibration.d0Angle;
#if 1
				valve.pos.modeAngle[C_MODE_A] = valve.calibration.d360Angle;
#endif
				ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]); /* move to init position */
				MotSetTargetPosition(valve.pos.targetAngle);
    703e:	82db 3e30 	callf	0x7c60 <_MotSetTargetPosition>

00007042 <.LM508>:
				valve.calibration.delay = 3;
    7042:	7003      	lod	A, #3
    7044:	0ea7      	lod	C, ML.7
    7046:	52d8 121e 	mov	0x121e <.LLST14+0x5>, A

0000704a <.LM509>:
				valve.calibration.state = CALSTEP_INIT_POS;
    704a:	6007      	lod	AL, #7
    704c:	073d      	jmp	0x6ec8 <.L573>

0000704e <.L252>:
				{
					valve.calibration.d360Angle += (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
				}
				else if (valve.calibration.d360Angle >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
				{
					valve.calibration.d360Angle -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    704e:	a2da f137 	add	A, #61751
    7052:	07df      	jmp	0x7012 <.L558>

00007054 <.L249>:
				ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]); /* move to init position */
				MotSetTargetPosition(valve.pos.targetAngle);
				valve.calibration.delay = 3;
				valve.calibration.state = CALSTEP_INIT_POS;
			}
			else if (valve.motorMotion == MOTION_STOPPED)
    7054:	7a01      	lod	Y, [S-2]
    7056:	ec01      	cmp	Y, #1
    7058:	1d01      	jne	0x705c <.L318>
    705a:	0767      	jmp	0x6f2a <.L576>

0000705c <.L318>:
		}
		valve.state = nextState;
	}
	else
	{
		if (valve.elapsedTime < 0xffffu)
    705c:	72d8 1202 	lod	A, 0x1202 <.LLST13>
    7060:	acff      	cmp	A, #-1
    7062:	1d01      	jne	0x7066 <.LM513>
    7064:	064b      	jmp	0x6cfc <.L320>

00007066 <.LM513>:
			valve.elapsedTime += 1;
    7066:	a001      	add	A, #1
    7068:	52d8 1202 	mov	0x1202 <.LLST13>, A
    706c:	0647      	jmp	0x6cfc <.L320>

0000706e <.L231>:
				valve.calibration.state = CALSTEP_FAULT;
			}
		}
		break;
	case CALSTEP_CALC:
		if (valve.calibration.delay > 0)
    706e:	72d8 121e 	lod	A, 0x121e <.LLST14+0x5>
    7072:	1904      	je	0x707c <.L253>

00007074 <.LM515>:
		{
			valve.calibration.delay -= 1;
    7074:	a0ff      	add	A, #-1
    7076:	52d8 121e 	mov	0x121e <.LLST14+0x5>, A
    707a:	0728      	jmp	0x6ecc <.L574>

0000707c <.L253>:
		}
		else
		{
			valve.calibration.d0Angle = (valve.pos.currentAngle + (int16_t)C_STOPPER_0D_ANGLE); // C_STOPPER_0D_ANGLE
    707c:	72ee      	lod	A, X
    707e:	a2da 00b9 	add	A, #185

00007082 <.LM517>:
			if (valve.calibration.d0Angle >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
    7082:	aeda 0e0f 	cmp	A, #3599
    7086:	1b05      	jsle	0x7092 <.L254>

00007088 <.LM518>:
			{
				valve.calibration.d0Angle -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    7088:	22da f2a9 	add	X, #62121

0000708c <.L559>:
			}
			else if (valve.calibration.d0Angle < 0)
			{
				valve.calibration.d0Angle += (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    708c:	5ed8 121a 	mov	0x121a <.LLST14+0x1>, X
    7090:	0004      	jmp	0x709a <.L255>

00007092 <.L254>:
			valve.calibration.d0Angle = (valve.pos.currentAngle + (int16_t)C_STOPPER_0D_ANGLE); // C_STOPPER_0D_ANGLE
			if (valve.calibration.d0Angle >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
			{
				valve.calibration.d0Angle -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
			}
			else if (valve.calibration.d0Angle < 0)
    7092:	ac00      	cmp	A, #0
    7094:	1a96      	jsl	0x70c2 <.L256>

00007096 <.LM521>:
		{
			valve.calibration.delay -= 1;
		}
		else
		{
			valve.calibration.d0Angle = (valve.pos.currentAngle + (int16_t)C_STOPPER_0D_ANGLE); // C_STOPPER_0D_ANGLE
    7096:	52d8 121a 	mov	0x121a <.LLST14+0x1>, A

0000709a <.L255>:
			}
			else
			{
			}
#if 1
			valve.pos.modeAngle[C_MODE_B] = valve.calibration.d0Angle;
    709a:	72d8 121a 	lod	A, 0x121a <.LLST14+0x1>
    709e:	52d8 1210 	mov	0x1210 <.LASF1440+0x4>, A

000070a2 <.LM523>:
#endif
			if (valve.calibration.req2Cal != 0)
    70a2:	7a07      	lod	Y, [S-8]
    70a4:	1911      	je	0x70c8 <.L257>

000070a6 <.LBB365>:

#endif
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    70a6:	72da 0e74 	lod	A, #3700
    70aa:	52d8 120a 	mov	0x120a <.LLST13+0x8>, A

000070ae <.LBE365>:
			valve.pos.modeAngle[C_MODE_B] = valve.calibration.d0Angle;
#endif
			if (valve.calibration.req2Cal != 0)
			{
				ValveTargetAngleUpdate(370 * C_GMR_ANGLE_SCALE_FACTOR); /* move to 360% position */
				valve.calibration.state = CALSTEP_360d_POS;
    70ae:	6003      	lod	AL, #3

000070b0 <.L560>:
			}
			else
			{
				ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]); /* move to init position */
				valve.calibration.state = CALSTEP_INIT_POS;
    70b0:	42d8 1214 	mov	0x1214 <.LASF1440+0x8>, AL

000070b4 <.LM527>:
			}
			MotClearHardStop();
    70b4:	82db 3e2c 	callf	0x7c58 <_MotClearHardStop>

000070b8 <.LM528>:
			MotSetTargetPosition(valve.pos.targetAngle);
    70b8:	72d8 120a 	lod	A, 0x120a <.LLST13+0x8>
    70bc:	82db 3e30 	callf	0x7c60 <_MotSetTargetPosition>
    70c0:	0705      	jmp	0x6ecc <.L574>

000070c2 <.L256>:
			{
				valve.calibration.d0Angle -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
			}
			else if (valve.calibration.d0Angle < 0)
			{
				valve.calibration.d0Angle += (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    70c2:	22da 0ec9 	add	X, #3785
    70c6:	07e2      	jmp	0x708c <.L559>

000070c8 <.L257>:

#endif
}
void ValveTargetAngleUpdate(int16_t angle)
{
	valve.pos.targetAngle = angle;
    70c8:	52d8 120a 	mov	0x120a <.LLST13+0x8>, A

000070cc <.LBE367>:
				valve.calibration.state = CALSTEP_360d_POS;
			}
			else
			{
				ValveTargetAngleUpdate(valve.pos.modeAngle[C_MODE_B]); /* move to init position */
				valve.calibration.state = CALSTEP_INIT_POS;
    70cc:	6007      	lod	AL, #7
    70ce:	07f0      	jmp	0x70b0 <.L560>

000070d0 <.L232>:
			MotClearHardStop();
			MotSetTargetPosition(valve.pos.targetAngle);
		}
		break;
	case CALSTEP_INIT_POS:
		if (valve.calibration.delay > 0)
    70d0:	72d8 121e 	lod	A, 0x121e <.LLST14+0x5>
    70d4:	1901      	je	0x70d8 <.LM533>
    70d6:	072e      	jmp	0x6f34 <.L570>

000070d8 <.LM533>:
		{
			valve.calibration.delay -= 1;
		}
		else
		{
			if (valve.motorMotion == MOTION_STALL)
    70d8:	7a01      	lod	Y, [S-2]
    70da:	ec06      	cmp	Y, #6
    70dc:	1d05      	jne	0x70e8 <.L260>

000070de <.LM534>:
			{

				MotClearStallFlag(0); /* clear stall flag if set */
    70de:	82db 3e4a 	callf	0x7c94 <_MotClearStallFlag>

000070e2 <.LM535>:
				MotRequestHardStop();
    70e2:	82db 3e28 	callf	0x7c50 <_MotRequestHardStop>
    70e6:	0721      	jmp	0x6f2a <.L576>

000070e8 <.L260>:

				valve.calibration.state = CALSTEP_FAULT;
			}
			else if (valve.motorMotion == MOTION_STOPPED)
    70e8:	7a01      	lod	Y, [S-2]
    70ea:	ec01      	cmp	Y, #1
    70ec:	1901      	je	0x70f0 <.LM537>
    70ee:	07b6      	jmp	0x705c <.L318>

000070f0 <.LM537>:
			{

				valve.calibration.state = CALSTEP_COMPLETED;
    70f0:	6009      	lod	AL, #9
    70f2:	06ea      	jmp	0x6ec8 <.L573>

000070f4 <.L233>:
		}
		break;

	case CALSTEP_FAULT:

		valve.calibration.req2Cal = 0;
    70f4:	7000      	lod	A, #0
    70f6:	52d8 1216 	mov	0x1216 <.LASF1440+0xa>, A

000070fa <.LM539>:
		valve.calibration.req1Cal = 0;
		valve.diag.calFault = 1;
    70fa:	6001      	lod	AL, #1
    70fc:	0ea7      	lod	C, ML.7
    70fe:	42d8 1264 	mov	0x1264 <.LASF1020+0x5>, AL

00007102 <.LM540>:
		u16EventState = VALVE_CAL_FAULT;
    7102:	7009      	lod	A, #9
    7104:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

00007108 <.LM541>:
		u16EventValue = valve.pos.currentAngle;
    7108:	0ea7      	lod	C, ML.7
    710a:	5ed8 10b4 	mov	0x10b4 <_u16EventValue>, X

0000710e <.L334>:
	}
	return nextState;
}
static tValveState ValveFaultTask(void)
{
	tValveState nextState = VALVE_FAULT;
    710e:	7006      	lod	A, #6
    7110:	05a6      	jmp	0x6c5e <.L562>

00007112 <.L234>:

		nextState = VALVE_FAULT;
		break;
	case CALSTEP_COMPLETED:

		valve.calibration.req2Cal = 0;
    7112:	7000      	lod	A, #0
    7114:	52d8 1216 	mov	0x1216 <.LASF1440+0xa>, A

00007118 <.LM544>:
		valve.calibration.req1Cal = 0;
		nextState = VALVE_STANDBY;
    7118:	7801      	lod	Y, #1
    711a:	0ea7      	lod	C, ML.7
    711c:	0621      	jmp	0x6d60 <.L563>

0000711e <.L195>:
}
static tValveState ValveFaultTask(void)
{
	tValveState nextState = VALVE_FAULT;
	uint16_t status = 1;
	MotRequestHardStop();
    711e:	82db 3e28 	callf	0x7c50 <_MotRequestHardStop>

00007122 <.LM546>:
	valve.comm.lastMode = 0xff;
    7122:	60ff      	lod	AL, #-1
    7124:	42d8 1228 	mov	0x1228 <.Lframe0>, AL

00007128 <.LM547>:
	if (valve.initStatus != 0)
    7128:	62d8 1207 	lod	AL, 0x1207 <.LLST13+0x5>
    712c:	1926      	je	0x717a <.L262>

0000712e <.LM548>:
	{
		valve.initStatus = 0;
    712e:	6000      	lod	AL, #0
    7130:	42d8 1207 	mov	0x1207 <.LLST13+0x5>, AL

00007134 <.LM549>:
		if (valve.diag.calFault != 0)
    7134:	62d8 1264 	lod	AL, 0x1264 <.LASF1020+0x5>
    7138:	1905      	je	0x7144 <.L263>

0000713a <.LM550>:
		{
			valve.diag.calRetryCnt += 1;
    713a:	62d8 1268 	lod	AL, 0x1268 <.LLST4+0x2>
    713e:	8001      	add	AL, #1
    7140:	42d8 1268 	mov	0x1268 <.LLST4+0x2>, AL

00007144 <.L263>:
		}
		if ((valve.diag.stallFault & STALL_MASK_PERMENT) != 0)
    7144:	62d8 1266 	lod	AL, 0x1266 <.LLST4>
    7148:	9402      	and	AL, #2
    714a:	1905      	je	0x7156 <.L264>

0000714c <.LM552>:
		{
			valve.diag.stallRetryCnt += 1;
    714c:	62d8 1267 	lod	AL, 0x1267 <.LLST4+0x1>
    7150:	8001      	add	AL, #1
    7152:	42d8 1267 	mov	0x1267 <.LLST4+0x1>, AL

00007156 <.L264>:
		}
		if ((valve.diag.motorFault & FAULT_MASK_PHASE_A_OPEN) != 0)
    7156:	66d8 1265 	lod	YL, 0x1265 <.LASF1020+0x6>
    715a:	62e8      	lod	AL, YL
    715c:	9401      	and	AL, #1
    715e:	1905      	je	0x716a <.L265>

00007160 <.LM554>:
		{
			valve.diag.motOpenRetryCnt += 1;
    7160:	62d8 126a 	lod	AL, 0x126a <.LLST4+0x4>
    7164:	8001      	add	AL, #1
    7166:	42d8 126a 	mov	0x126a <.LLST4+0x4>, AL

0000716a <.L265>:
		}
		if ((valve.diag.motorFault & FAULT_MASK_PHASE_A_SHORT) != 0)
    716a:	62e8      	lod	AL, YL
    716c:	9410      	and	AL, #16
    716e:	1905      	je	0x717a <.L262>

00007170 <.LM556>:
		{
			valve.diag.motShortRetryCnt += 1;
    7170:	62d8 126b 	lod	AL, 0x126b <.LLST4+0x5>
    7174:	8001      	add	AL, #1
    7176:	42d8 126b 	mov	0x126b <.LLST4+0x5>, AL

0000717a <.L262>:
		}
	}

	if (valve.elapsedTime >= 5000u)
    717a:	72d8 1202 	lod	A, 0x1202 <.LLST13>
    717e:	aeda 1387 	cmp	A, #4999
    7182:	1a45      	jule	0x710e <.L334>

00007184 <.LM558>:
	{
		if (valve.diag.calRetryCnt <= 3)
    7184:	62d8 1268 	lod	AL, 0x1268 <.LLST4+0x2>
    7188:	8c03      	cmp	AL, #3
    718a:	1e03      	jug	0x7192 <.L267>

0000718c <.LM559>:
		{
			valve.diag.calFault = 0;
    718c:	6000      	lod	AL, #0
    718e:	42d8 1264 	mov	0x1264 <.LASF1020+0x5>, AL

00007192 <.L267>:
		}
		if (valve.diag.stallRetryCnt <= 3)
    7192:	62d8 1267 	lod	AL, 0x1267 <.LLST4+0x1>
    7196:	8c03      	cmp	AL, #3
    7198:	1e03      	jug	0x71a0 <.L268>

0000719a <.LM561>:
		{
			MotClearStallFlag(0);
    719a:	7000      	lod	A, #0
    719c:	82db 3e4a 	callf	0x7c94 <_MotClearStallFlag>

000071a0 <.L268>:
		}
		if (valve.diag.motOpenRetryCnt <= 3)
    71a0:	62d8 126a 	lod	AL, 0x126a <.LLST4+0x4>
    71a4:	8c03      	cmp	AL, #3
    71a6:	1e03      	jug	0x71ae <.L269>

000071a8 <.LM563>:
		{
			MotClearFaultFlag(1);
    71a8:	7001      	lod	A, #1
    71aa:	82db 3e59 	callf	0x7cb2 <_MotClearFaultFlag>

000071ae <.L269>:
		}
		if (valve.diag.motShortRetryCnt <= 3)
    71ae:	62d8 126b 	lod	AL, 0x126b <.LLST4+0x5>
    71b2:	8c03      	cmp	AL, #3
    71b4:	1e03      	jug	0x71bc <.L270>

000071b6 <.LM565>:
		{
			MotClearFaultFlag(2);
    71b6:	7002      	lod	A, #2
    71b8:	82db 3e59 	callf	0x7cb2 <_MotClearFaultFlag>

000071bc <.L270>:
		}

		if (valve.diag.calFault != 0)
    71bc:	66d8 1264 	lod	YL, 0x1264 <.LASF1020+0x5>

000071c0 <.LM567>:
		{
			status = 0;
		}
		if (MotGetStallState() != 0)
    71c0:	5a03      	mov	[S-4], Y
    71c2:	82db 3e7f 	callf	0x7cfe <_MotGetStallState>
    71c6:	7a03      	lod	Y, [S-4]
    71c8:	ac00      	cmp	A, #0
    71ca:	1d11      	jne	0x71ee <.L335>

000071cc <.LM568>:
	return nextState;
}
static tValveState ValveFaultTask(void)
{
	tValveState nextState = VALVE_FAULT;
	uint16_t status = 1;
    71cc:	62e8      	lod	AL, YL
    71ce:	5c86      	se	Y

000071d0 <.L271>:
		}
		if (MotGetStallState() != 0)
		{
			status = 0;
		}
		if (MotGetFaultState() != 0)
    71d0:	5a03      	mov	[S-4], Y
    71d2:	82db 3e83 	callf	0x7d06 <_MotGetFaultState>

000071d6 <.LVL241>:
    71d6:	7a03      	lod	Y, [S-4]
    71d8:	ac00      	cmp	A, #0
    71da:	1d03      	jne	0x71e2 <.L272>

000071dc <.LM570>:
		{
			status = 0;
		}

		if (status != 0)
    71dc:	ec00      	cmp	Y, #0
    71de:	1901      	je	0x71e2 <.L272>
    71e0:	05f4      	jmp	0x6dca <.L203>

000071e2 <.L272>:
			//			nextState=valve.lastState;
			nextState = VALVE_STANDBY;
		}
		else
		{
			valve.comm.faultMode = 1;
    71e2:	6001      	lod	AL, #1
    71e4:	42d8 122b 	mov	0x122b <.Lframe0+0x3>, AL

000071e8 <.LM572>:
	}
	return nextState;
}
static tValveState ValveFaultTask(void)
{
	tValveState nextState = VALVE_FAULT;
    71e8:	7806      	lod	Y, #6
    71ea:	0ea7      	lod	C, ML.7
    71ec:	05b9      	jmp	0x6d60 <.L563>

000071ee <.L335>:
		{
			status = 0;
		}
		if (MotGetStallState() != 0)
		{
			status = 0;
    71ee:	7800      	lod	Y, #0
    71f0:	07ef      	jmp	0x71d0 <.L271>

000071f2 <.L196>:
static tValveState ValveProtectionTask(void)
{
	tValveState nextState = VALVE_PROTECTION;
	uint16_t status = 1;

	MotRequestHardStop();
    71f2:	82db 3e28 	callf	0x7c50 <_MotRequestHardStop>

000071f6 <.LM575>:
	valve.comm.lastMode = 0xff;
    71f6:	60ff      	lod	AL, #-1
    71f8:	42d8 1228 	mov	0x1228 <.Lframe0>, AL

000071fc <.LM576>:
	if (valve.initStatus != 0)
    71fc:	62d8 1207 	lod	AL, 0x1207 <.LLST13+0x5>
    7200:	1d01      	jne	0x7204 <.LM577>
    7202:	00df      	jmp	0x73c2 <.L274>

00007204 <.LM577>:
	{
		valve.initStatus = 0;
    7204:	6000      	lod	AL, #0
    7206:	42d8 1207 	mov	0x1207 <.LLST13+0x5>, AL

0000720a <.LM578>:

		if (valve.diag.vs.state == VS_UNDERVOLTAGE)
    720a:	72d8 123c 	lod	A, 0x123c <.LASF2154+0x3>
    720e:	ac01      	cmp	A, #1
    7210:	1d1a      	jne	0x7246 <.L275>

00007212 <.LM579>:
		{
			if (valve.diag.protType != VS_LOW_ERROR)
    7212:	72d8 1262 	lod	A, 0x1262 <.LASF1020+0x3>
    7216:	ac01      	cmp	A, #1
    7218:	1902      	je	0x721e <.L276>

0000721a <.LM580>:
			{
				ValveErrorReset();
    721a:	82db 322f 	callf	0x645e <_ValveErrorReset>

0000721e <.L276>:
			}
			if (valve.diag.vs.UVretryCnt < 0xffu)
    721e:	62d8 1244 	lod	AL, 0x1244 <.LLST1+0x4>
    7222:	66e0      	lod	YL, AL
    7224:	5cf6      	usex	Y
    7226:	eeda 00ff 	cmp	Y, #255
    722a:	1903      	je	0x7232 <.L277>

0000722c <.LM582>:
			{
				valve.diag.vs.UVretryCnt += 1;
    722c:	8001      	add	AL, #1
    722e:	42d8 1244 	mov	0x1244 <.LLST1+0x4>, AL

00007232 <.L277>:
			}
			valve.diag.protType = VS_LOW_ERROR;
    7232:	7001      	lod	A, #1
    7234:	52d8 1262 	mov	0x1262 <.LASF1020+0x3>, A

00007238 <.LM584>:
			u16EventState = VS_LOW_ERROR;
    7238:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

0000723c <.LM585>:
			u16EventValue = valve.diag.vs.state;
    723c:	0ea7      	lod	C, ML.7
    723e:	72d8 123c 	lod	A, 0x123c <.LASF2154+0x3>
    7242:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

00007246 <.L275>:
		}
		if (valve.diag.vs.state == VS_OVERVOLTAGE)
    7246:	72d8 123c 	lod	A, 0x123c <.LASF2154+0x3>
    724a:	ac02      	cmp	A, #2
    724c:	1d1a      	jne	0x7282 <.L278>

0000724e <.LM587>:
		{
			if (valve.diag.protType != VS_HIGH_ERROR)
    724e:	72d8 1262 	lod	A, 0x1262 <.LASF1020+0x3>
    7252:	ac02      	cmp	A, #2
    7254:	1902      	je	0x725a <.L279>

00007256 <.LM588>:
			{
				ValveErrorReset();
    7256:	82db 322f 	callf	0x645e <_ValveErrorReset>

0000725a <.L279>:
			}
			if (valve.diag.vs.OVretryCnt < 0xffu)
    725a:	62d8 1245 	lod	AL, 0x1245 <.LLST1+0x5>
    725e:	66e0      	lod	YL, AL
    7260:	5cf6      	usex	Y
    7262:	eeda 00ff 	cmp	Y, #255
    7266:	1903      	je	0x726e <.L280>

00007268 <.LM590>:
			{
				valve.diag.vs.OVretryCnt += 1;
    7268:	8001      	add	AL, #1
    726a:	42d8 1245 	mov	0x1245 <.LLST1+0x5>, AL

0000726e <.L280>:
			}
			valve.diag.protType = VS_HIGH_ERROR;
    726e:	7002      	lod	A, #2
    7270:	52d8 1262 	mov	0x1262 <.LASF1020+0x3>, A

00007274 <.LM592>:
			u16EventState = VS_HIGH_ERROR;
    7274:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

00007278 <.LM593>:
			u16EventValue = valve.diag.vs.state;
    7278:	0ea7      	lod	C, ML.7
    727a:	72d8 123c 	lod	A, 0x123c <.LASF2154+0x3>
    727e:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

00007282 <.L278>:
		}
		if (valve.diag.temp.state != TEMPERATURE_NORMAL)
    7282:	72d8 1246 	lod	A, 0x1246 <.LLST1+0x6>
    7286:	1918      	je	0x72b8 <.L281>

00007288 <.LM595>:
		{
			if (valve.diag.protType != TEMP_HIGH_ERROR)
    7288:	72d8 1262 	lod	A, 0x1262 <.LASF1020+0x3>
    728c:	ac03      	cmp	A, #3
    728e:	1902      	je	0x7294 <.L282>

00007290 <.LM596>:
			{
				ValveErrorReset();
    7290:	82db 322f 	callf	0x645e <_ValveErrorReset>

00007294 <.L282>:
			}
			if (valve.diag.temp.retryCnt < 0xffu)
    7294:	72d8 1248 	lod	A, 0x1248 <.LLST1+0x8>
    7298:	aeda 00fe 	cmp	A, #254
    729c:	1e03      	jug	0x72a4 <.L283>

0000729e <.LM598>:
			{
				valve.diag.temp.retryCnt += 1;
    729e:	a001      	add	A, #1
    72a0:	52d8 1248 	mov	0x1248 <.LLST1+0x8>, A

000072a4 <.L283>:
			}
			valve.diag.protType = TEMP_HIGH_ERROR;
    72a4:	7003      	lod	A, #3
    72a6:	52d8 1262 	mov	0x1262 <.LASF1020+0x3>, A

000072aa <.LM600>:
			u16EventState = TEMP_HIGH_ERROR;
    72aa:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

000072ae <.LM601>:
			u16EventValue = valve.diag.temp.deg;
    72ae:	0ea7      	lod	C, ML.7
    72b0:	72d8 124a 	lod	A, 0x124a <.LLST1+0xa>
    72b4:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

000072b8 <.L281>:
		}
		if ((valve.diag.motorFault & FAULT_MASK_OVER_CURRENT) != 0)
    72b8:	62d8 1265 	lod	AL, 0x1265 <.LASF1020+0x6>
    72bc:	9440      	and	AL, #64
    72be:	1913      	je	0x72e6 <.L284>

000072c0 <.LM603>:
		{
			if (valve.diag.protType != MOT_OC_ERROR)
    72c0:	72d8 1262 	lod	A, 0x1262 <.LASF1020+0x3>
    72c4:	ac04      	cmp	A, #4
    72c6:	1902      	je	0x72cc <.L285>

000072c8 <.LM604>:
			{
				ValveErrorReset();
    72c8:	82db 322f 	callf	0x645e <_ValveErrorReset>

000072cc <.L285>:
			}
			if (valve.diag.motOcRetryCnt < 0xffu)
    72cc:	62d8 1269 	lod	AL, 0x1269 <.LLST4+0x3>
    72d0:	66e0      	lod	YL, AL
    72d2:	5cf6      	usex	Y
    72d4:	eeda 00ff 	cmp	Y, #255
    72d8:	1903      	je	0x72e0 <.L286>

000072da <.LM606>:
			{
				valve.diag.motOcRetryCnt += 1;
    72da:	8001      	add	AL, #1
    72dc:	42d8 1269 	mov	0x1269 <.LLST4+0x3>, AL

000072e0 <.L286>:
			}
			valve.diag.protType = MOT_OC_ERROR;
    72e0:	7004      	lod	A, #4
    72e2:	52d8 1262 	mov	0x1262 <.LASF1020+0x3>, A

000072e6 <.L284>:
		}
		if ((valve.diag.stallFault & STALL_MASK_TEMPORARY) != 0)
    72e6:	62d8 1266 	lod	AL, 0x1266 <.LLST4>
    72ea:	9401      	and	AL, #1
    72ec:	1913      	je	0x7314 <.L287>

000072ee <.LM609>:
		{
			if (valve.diag.protType != MOT_ABSTALL_ERROR)
    72ee:	72d8 1262 	lod	A, 0x1262 <.LASF1020+0x3>
    72f2:	ac05      	cmp	A, #5
    72f4:	1902      	je	0x72fa <.L288>

000072f6 <.LM610>:
			{
				ValveErrorReset();
    72f6:	82db 322f 	callf	0x645e <_ValveErrorReset>

000072fa <.L288>:
			}
			if (valve.diag.ObstructionRetryCnt < 0xffu)
    72fa:	62d8 1260 	lod	AL, 0x1260 <.LASF1020+0x1>
    72fe:	66e0      	lod	YL, AL
    7300:	5cf6      	usex	Y
    7302:	eeda 00ff 	cmp	Y, #255
    7306:	1903      	je	0x730e <.L289>

00007308 <.LM612>:
			{
				valve.diag.ObstructionRetryCnt += 1;
    7308:	8001      	add	AL, #1
    730a:	42d8 1260 	mov	0x1260 <.LASF1020+0x1>, AL

0000730e <.L289>:
			}
			valve.diag.protType = MOT_ABSTALL_ERROR;
    730e:	7005      	lod	A, #5
    7310:	52d8 1262 	mov	0x1262 <.LASF1020+0x3>, A

00007314 <.L287>:
		}
		if (valve.pos.fault != 0)
    7314:	62d8 1212 	lod	AL, 0x1212 <.LASF1440+0x6>
    7318:	191a      	je	0x734e <.L290>

0000731a <.LM615>:
		{
			if (valve.diag.protType != SENSOR_POS_ERROR)
    731a:	72d8 1262 	lod	A, 0x1262 <.LASF1020+0x3>
    731e:	ac06      	cmp	A, #6
    7320:	1902      	je	0x7326 <.L291>

00007322 <.LM616>:
			{
				ValveErrorReset();
    7322:	82db 322f 	callf	0x645e <_ValveErrorReset>

00007326 <.L291>:
			}
			if (valve.pos.retryCnt < 0xffu)
    7326:	62d8 1213 	lod	AL, 0x1213 <.LASF1440+0x7>
    732a:	66e0      	lod	YL, AL
    732c:	5cf6      	usex	Y
    732e:	eeda 00ff 	cmp	Y, #255
    7332:	1903      	je	0x733a <.L292>

00007334 <.LM618>:
			{
				valve.pos.retryCnt += 1;
    7334:	8001      	add	AL, #1
    7336:	42d8 1213 	mov	0x1213 <.LASF1440+0x7>, AL

0000733a <.L292>:
			}
			valve.diag.protType = SENSOR_POS_ERROR;
    733a:	7006      	lod	A, #6
    733c:	52d8 1262 	mov	0x1262 <.LASF1020+0x3>, A

00007340 <.LM620>:
			u16EventState = SENSOR_POS_ERROR;
    7340:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

00007344 <.LM621>:
			u16EventValue = valve.pos.currentAngle;
    7344:	0ea7      	lod	C, ML.7
    7346:	72d8 120c 	lod	A, 0x120c <.LASF1440>
    734a:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

0000734e <.L290>:
		}
		if (valve.diag.gmr.state != 0)
    734e:	62d8 1254 	lod	AL, 0x1254 <.LLST3+0x1>
    7352:	191a      	je	0x7388 <.L293>

00007354 <.LM623>:
		{
			if (valve.diag.protType != SENSOR_OUT_ERROR)
    7354:	72d8 1262 	lod	A, 0x1262 <.LASF1020+0x3>
    7358:	ac07      	cmp	A, #7
    735a:	1902      	je	0x7360 <.L294>

0000735c <.LM624>:
			{
				ValveErrorReset();
    735c:	82db 322f 	callf	0x645e <_ValveErrorReset>

00007360 <.L294>:
			}
			if (valve.diag.gmr.retryCnt < 0xffu)
    7360:	62d8 1255 	lod	AL, 0x1255 <.LLST3+0x2>
    7364:	66e0      	lod	YL, AL
    7366:	5cf6      	usex	Y
    7368:	eeda 00ff 	cmp	Y, #255
    736c:	1903      	je	0x7374 <.L295>

0000736e <.LM626>:
			{
				valve.diag.gmr.retryCnt += 1;
    736e:	8001      	add	AL, #1
    7370:	42d8 1255 	mov	0x1255 <.LLST3+0x2>, AL

00007374 <.L295>:
			}
			valve.diag.protType = SENSOR_OUT_ERROR;
    7374:	7007      	lod	A, #7
    7376:	52d8 1262 	mov	0x1262 <.LASF1020+0x3>, A

0000737a <.LM628>:
			u16EventState = SENSOR_OUT_ERROR;
    737a:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

0000737e <.LM629>:
			u16EventValue = valve.pos.currentAngle;
    737e:	0ea7      	lod	C, ML.7
    7380:	72d8 120c 	lod	A, 0x120c <.LASF1440>
    7384:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

00007388 <.L293>:
		}

		if (valve.diag.McuFault != 0)
    7388:	62d8 125e 	lod	AL, 0x125e <.LLST3+0xb>
    738c:	191a      	je	0x73c2 <.L274>

0000738e <.LM631>:
		{
			if (valve.diag.protType != MCU_ERROR)
    738e:	72d8 1262 	lod	A, 0x1262 <.LASF1020+0x3>
    7392:	ac08      	cmp	A, #8
    7394:	1902      	je	0x739a <.L297>

00007396 <.LM632>:
			{
				ValveErrorReset();
    7396:	82db 322f 	callf	0x645e <_ValveErrorReset>

0000739a <.L297>:
			}
			if (valve.diag.mcuRetryCnt < 0xffu)
    739a:	62d8 125f 	lod	AL, 0x125f <.LASF1020>
    739e:	66e0      	lod	YL, AL
    73a0:	5cf6      	usex	Y
    73a2:	eeda 00ff 	cmp	Y, #255
    73a6:	1903      	je	0x73ae <.L298>

000073a8 <.LM634>:
			{
				valve.diag.mcuRetryCnt += 1;
    73a8:	8001      	add	AL, #1
    73aa:	42d8 125f 	mov	0x125f <.LASF1020>, AL

000073ae <.L298>:
			}
			valve.diag.protType = MCU_ERROR;
    73ae:	7008      	lod	A, #8
    73b0:	52d8 1262 	mov	0x1262 <.LASF1020+0x3>, A

000073b4 <.LM636>:
			u16EventState = MCU_ERROR;
    73b4:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

000073b8 <.LM637>:
			u16EventValue = valve.diag.vs.state;
    73b8:	0ea7      	lod	C, ML.7
    73ba:	72d8 123c 	lod	A, 0x123c <.LASF2154+0x3>
    73be:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

000073c2 <.L274>:
		}
	}

	if (valve.elapsedTime >= 3000u)
    73c2:	72d8 1202 	lod	A, 0x1202 <.LLST13>
    73c6:	aeda 0bb7 	cmp	A, #2999
    73ca:	1a20      	jule	0x740c <.L299>

000073cc <.LM639>:
	{
		if (valve.diag.ObstructionRetryCnt < 10)
    73cc:	62d8 1260 	lod	AL, 0x1260 <.LASF1020+0x1>
    73d0:	8c09      	cmp	AL, #9
    73d2:	1a01      	jule	0x73d6 <.LM640>
    73d4:	0060      	jmp	0x7496 <.L300>

000073d6 <.LM640>:
		{
			MotClearStallFlag(1);
    73d6:	7001      	lod	A, #1
    73d8:	82db 3e4a 	callf	0x7c94 <_MotClearStallFlag>

000073dc <.L301>:
		}
		else
		{
			valve.comm.faultMode = 1;
		}
		if (valve.diag.motOcRetryCnt < 10)
    73dc:	62d8 1269 	lod	AL, 0x1269 <.LLST4+0x3>
    73e0:	8c09      	cmp	AL, #9
    73e2:	1a01      	jule	0x73e6 <.LM642>
    73e4:	005c      	jmp	0x749e <.L302>

000073e6 <.LM642>:
		{
			MotClearFaultFlag(3);
    73e6:	7003      	lod	A, #3
    73e8:	82db 3e59 	callf	0x7cb2 <_MotClearFaultFlag>

000073ec <.L303>:
		}
		else
		{
			valve.comm.faultMode = 1;
		}
		if (valve.pos.retryCnt < 10)
    73ec:	62d8 1213 	lod	AL, 0x1213 <.LASF1440+0x7>
    73f0:	8c09      	cmp	AL, #9
    73f2:	1a01      	jule	0x73f6 <.LM644>
    73f4:	0058      	jmp	0x74a6 <.L304>

000073f6 <.LM644>:
		{
			valve.pos.fault = 0;
    73f6:	6000      	lod	AL, #0
    73f8:	42d8 1212 	mov	0x1212 <.LASF1440+0x6>, AL

000073fc <.L305>:
		}
		else
		{
			valve.comm.faultMode = 1;
		}
		if (valve.diag.gmr.retryCnt < 10)
    73fc:	62d8 1255 	lod	AL, 0x1255 <.LLST3+0x2>
    7400:	8c09      	cmp	AL, #9
    7402:	1a01      	jule	0x7406 <.LM646>
    7404:	0054      	jmp	0x74ae <.L306>

00007406 <.LM646>:
		{
			valve.diag.gmr.state = 0;
    7406:	6000      	lod	AL, #0
    7408:	42d8 1254 	mov	0x1254 <.LLST3+0x1>, AL

0000740c <.L299>:
		{
			valve.comm.faultMode = 1;
		}
	}

	if (valve.diag.vs.state != VS_NORMAL)
    740c:	7ed8 123c 	lod	X, 0x123c <.LASF2154+0x3>
    7410:	1d0f      	jne	0x7430 <.L336>

00007412 <.LM648>:
	{
		status = 0;
	}
	else
	{
		if (valve.diag.vs.UVretryCnt >= 30)
    7412:	62d8 1244 	lod	AL, 0x1244 <.LLST1+0x4>
    7416:	8c1d      	cmp	AL, #29
    7418:	1e01      	jug	0x741c <.LM649>
    741a:	004d      	jmp	0x74b6 <.L337>

0000741c <.LM649>:
		{
			status = 0;
			valve.comm.faultMode = 1;
    741c:	6001      	lod	AL, #1
    741e:	42d8 122b 	mov	0x122b <.Lframe0+0x3>, AL

00007422 <.L308>:
		}
		if (valve.diag.vs.OVretryCnt >= 30)
    7422:	62d8 1245 	lod	AL, 0x1245 <.LLST1+0x5>
    7426:	8c1d      	cmp	AL, #29
    7428:	1a04      	jule	0x7432 <.L307>

0000742a <.LM651>:
		{
			status = 0;
			valve.comm.faultMode = 1;
    742a:	6001      	lod	AL, #1
    742c:	42d8 122b 	mov	0x122b <.Lframe0+0x3>, AL

00007430 <.L336>:
		}
	}

	if (valve.diag.vs.state != VS_NORMAL)
	{
		status = 0;
    7430:	7c00      	lod	X, #0

00007432 <.L307>:
		{
			status = 0;
			valve.comm.faultMode = 1;
		}
	}
	if (valve.diag.temp.state != TEMPERATURE_NORMAL)
    7432:	72d8 1246 	lod	A, 0x1246 <.LLST1+0x6>
    7436:	1d07      	jne	0x7446 <.L338>

00007438 <.LM654>:
	{
		status = 0;
	}
	else
	{
		if (valve.diag.temp.retryCnt >= 10)
    7438:	7ad8 1248 	lod	Y, 0x1248 <.LLST1+0x8>
    743c:	ec09      	cmp	Y, #9
    743e:	1a04      	jule	0x7448 <.L309>

00007440 <.LM655>:
		{
			status = 0;
			valve.comm.faultMode = 1;
    7440:	6401      	lod	YL, #1
    7442:	46d8 122b 	mov	0x122b <.Lframe0+0x3>, YL

00007446 <.L338>:
			valve.comm.faultMode = 1;
		}
	}
	if (valve.diag.temp.state != TEMPERATURE_NORMAL)
	{
		status = 0;
    7446:	7c00      	lod	X, #0

00007448 <.L309>:
		{
			status = 0;
			valve.comm.faultMode = 1;
		}
	}
	if (valve.diag.McuFault != 0)
    7448:	62d8 125e 	lod	AL, 0x125e <.LLST3+0xb>
    744c:	1d07      	jne	0x745c <.L339>

0000744e <.LM658>:
	{
		status = 0;
	}
	else
	{
		if (valve.diag.mcuRetryCnt >= 10)
    744e:	62d8 125f 	lod	AL, 0x125f <.LASF1020>
    7452:	8c09      	cmp	AL, #9
    7454:	1a04      	jule	0x745e <.L310>

00007456 <.LM659>:
		{
			status = 0;
			valve.comm.faultMode = 1;
    7456:	6001      	lod	AL, #1
    7458:	42d8 122b 	mov	0x122b <.Lframe0+0x3>, AL

0000745c <.L339>:
			valve.comm.faultMode = 1;
		}
	}
	if (valve.diag.McuFault != 0)
	{
		status = 0;
    745c:	7c00      	lod	X, #0

0000745e <.L310>:
		{
			status = 0;
			valve.comm.faultMode = 1;
		}
	}
	if ((valve.diag.stallFault & STALL_MASK_TEMPORARY) != 0)
    745e:	62d8 1266 	lod	AL, 0x1266 <.LLST4>
    7462:	9401      	and	AL, #1
    7464:	1901      	je	0x7468 <.L311>

00007466 <.LM662>:
	{
		status = 0;
    7466:	7c00      	lod	X, #0

00007468 <.L311>:
	}
	if ((valve.diag.motorFault & FAULT_MASK_OVER_CURRENT) != 0)
    7468:	62d8 1265 	lod	AL, 0x1265 <.LASF1020+0x6>
    746c:	9440      	and	AL, #64
    746e:	1901      	je	0x7472 <.L312>

00007470 <.LM664>:
	{
		status = 0;
    7470:	7c00      	lod	X, #0

00007472 <.L312>:
	}

	if ((valve.diag.gmr.state != 0) || (valve.pos.fault != 0))
    7472:	62d8 1254 	lod	AL, 0x1254 <.LLST3+0x1>
    7476:	1d21      	jne	0x74ba <.L342>
    7478:	66e0      	lod	YL, AL
    747a:	5cf6      	usex	Y
    747c:	62d8 1212 	lod	AL, 0x1212 <.LASF1440+0x6>
    7480:	1d1e      	jne	0x74be <.L343>

00007482 <.L313>:
	{
		status = 0;
	}
	if (valve.linLiveTimeOut == 0)
    7482:	72d8 1200 	lod	A, 0x1200 <_valve+0x4>
    7486:	1d01      	jne	0x748a <.LM667>
    7488:	047d      	jmp	0x6d84 <.L314>

0000748a <.LM667>:
	{
		status = 0;
	}
	if ((status != 0) && (valve.comm.faultMode == 0))
    748a:	2c00      	cmp	X, #0
    748c:	1d01      	jne	0x7490 <.LASF1025+0x5>
    748e:	047a      	jmp	0x6d84 <.L314>
    7490:	62d8 122b 	lod	AL, 0x122b <.Lframe0+0x3>
    7494:	0498      	jmp	0x6dc6 <.L555>

00007496 <.L300>:
		{
			MotClearStallFlag(1);
		}
		else
		{
			valve.comm.faultMode = 1;
    7496:	6001      	lod	AL, #1
    7498:	42d8 122b 	mov	0x122b <.Lframe0+0x3>, AL
    749c:	079f      	jmp	0x73dc <.L301>

0000749e <.L302>:
		{
			MotClearFaultFlag(3);
		}
		else
		{
			valve.comm.faultMode = 1;
    749e:	6001      	lod	AL, #1
    74a0:	42d8 122b 	mov	0x122b <.Lframe0+0x3>, AL
    74a4:	07a3      	jmp	0x73ec <.L303>

000074a6 <.L304>:
		{
			valve.pos.fault = 0;
		}
		else
		{
			valve.comm.faultMode = 1;
    74a6:	6001      	lod	AL, #1
    74a8:	42d8 122b 	mov	0x122b <.Lframe0+0x3>, AL
    74ac:	07a7      	jmp	0x73fc <.L305>

000074ae <.L306>:
		{
			valve.diag.gmr.state = 0;
		}
		else
		{
			valve.comm.faultMode = 1;
    74ae:	6001      	lod	AL, #1
    74b0:	42d8 122b 	mov	0x122b <.Lframe0+0x3>, AL
    74b4:	07ab      	jmp	0x740c <.L299>

000074b6 <.L337>:
}

static tValveState ValveProtectionTask(void)
{
	tValveState nextState = VALVE_PROTECTION;
	uint16_t status = 1;
    74b6:	7c01      	lod	X, #1
    74b8:	07b4      	jmp	0x7422 <.L308>

000074ba <.L342>:
		status = 0;
	}

	if ((valve.diag.gmr.state != 0) || (valve.pos.fault != 0))
	{
		status = 0;
    74ba:	7c00      	lod	X, #0

000074bc <.LVL272>:
    74bc:	07e2      	jmp	0x7482 <.L313>

000074be <.L343>:
    74be:	7ee6      	lod	X, Y

000074c0 <.LVL274>:
    74c0:	07e0      	jmp	0x7482 <.L313>

000074c2 <.L197>:
}
static tValveState ValvePowerLatchTask(void)
{
	tValveState nextState = VALVE_POWERLATCH;

	MotRequestHardStop();
    74c2:	13c6      	call	0x7c50 <_MotRequestHardStop>

000074c4 <.LM675>:
	if (valve.initStatus != 0)
    74c4:	62d8 1207 	lod	AL, 0x1207 <.LLST13+0x5>
    74c8:	1903      	je	0x74d0 <.L315>

000074ca <.LM676>:
	{
		valve.initStatus = 0;
    74ca:	6000      	lod	AL, #0
    74cc:	42d8 1207 	mov	0x1207 <.LLST13+0x5>, AL

000074d0 <.L315>:
	}
	if (valve.diag.ign.state != IGN_OFF)
    74d0:	72d8 124e 	lod	A, 0x124e <.LASF1845+0x1>
    74d4:	ac01      	cmp	A, #1
    74d6:	192a      	je	0x752c <.L344>

000074d8 <.LM678>:
	{

		nextState = valve.lastState;
    74d8:	7ad8 11fe 	lod	Y, 0x11fe <_valve+0x2>
    74dc:	0441      	jmp	0x6d60 <.L563>

000074de <.L198>:
}
static tValveState ValveLowPowerTask(void)
{
	tValveState nextState = VALVE_LOWPOWER;

	if (valve.initStatus != 0)
    74de:	62d8 1207 	lod	AL, 0x1207 <.LLST13+0x5>
    74e2:	1903      	je	0x74ea <.L316>

000074e4 <.LM680>:
	{
		valve.initStatus = 0;
    74e4:	6000      	lod	AL, #0
    74e6:	42d8 1207 	mov	0x1207 <.LLST13+0x5>, AL

000074ea <.L316>:
	}
	if (valve.diag.ign.state != IGN_OFF)
    74ea:	72d8 124e 	lod	A, 0x124e <.LASF1845+0x1>
    74ee:	ac01      	cmp	A, #1
    74f0:	1d0d      	jne	0x750c <.L345>

000074f2 <.LM682>:

	return nextState;
}
static tValveState ValveLowPowerTask(void)
{
	tValveState nextState = VALVE_LOWPOWER;
    74f2:	7809      	lod	Y, #9
    74f4:	5a05      	mov	[S-6], Y

000074f6 <.L317>:
	{

		nextState = VALVE_STANDBY;
	}

	if (valve.elapsedTime >= 60000u) /*60sec*/
    74f6:	72d8 1202 	lod	A, 0x1202 <.LLST13>
    74fa:	aeda ea5f 	cmp	A, #59999
    74fe:	1e02      	jug	0x7504 <.LM684>
    7500:	76da 366b 	jmpf	0x6cd6 <.L200>

00007504 <.LM684>:
	{
		AppLinSleepEnter();
    7504:	82db 31e4 	callf	0x63c8 <_AppLinSleepEnter>
    7508:	76da 366b 	jmpf	0x6cd6 <.L200>

0000750c <.L345>:
		valve.initStatus = 0;
	}
	if (valve.diag.ign.state != IGN_OFF)
	{

		nextState = VALVE_STANDBY;
    750c:	7c01      	lod	X, #1
    750e:	5e05      	mov	[S-6], X

00007510 <.LVL281>:
    7510:	07f2      	jmp	0x74f6 <.L317>

00007512 <.L199>:
static tValveState ValveUndefTask(void)
{

	tValveState nextState = VALVE_UNDEF;

	if (valve.initStatus != 0)
    7512:	62d8 1207 	lod	AL, 0x1207 <.LLST13+0x5>
    7516:	190c      	je	0x7530 <.L346>

00007518 <.LM687>:
	{
		valve.initStatus = 0;
    7518:	6000      	lod	AL, #0
    751a:	42d8 1207 	mov	0x1207 <.LLST13+0x5>, AL

0000751e <.LBE385>:
		break;
	case VALVE_LOWPOWER:
		nextState = ValveLowPowerTask();
		break;
	case VALVE_UNDEF:
		nextState = ValveUndefTask();
    751e:	780a      	lod	Y, #10
    7520:	0ea7      	lod	C, ML.7
    7522:	041e      	jmp	0x6d60 <.L563>

00007524 <.L326>:
	valve.diag.temp.retryCnt = 0;
}

static tValveState ValveInitTask(void)
{
	tValveState nextState = VALVE_INIT;
    7524:	7c00      	lod	X, #0
    7526:	0452      	jmp	0x6dcc <.L561>

00007528 <.L332>:
}

static tValveState ValveOperationTask(void)
{

	tValveState nextState = VALVE_OPERATION;
    7528:	7c03      	lod	X, #3
    752a:	0450      	jmp	0x6dcc <.L561>

0000752c <.L344>:
	}
	return nextState;
}
static tValveState ValvePowerLatchTask(void)
{
	tValveState nextState = VALVE_POWERLATCH;
    752c:	7808      	lod	Y, #8
    752e:	0418      	jmp	0x6d60 <.L563>

00007530 <.L346>:
		break;
	case VALVE_LOWPOWER:
		nextState = ValveLowPowerTask();
		break;
	case VALVE_UNDEF:
		nextState = ValveUndefTask();
    7530:	7c0a      	lod	X, #10
    7532:	044c      	jmp	0x6dcc <.L561>

00007534 <.L321>:
	{
		valve.linLiveTimeOut -= 1;
	}
	else
	{
		valve.diag.linError = 1;
    7534:	6001      	lod	AL, #1
    7536:	42d8 125c 	mov	0x125c <.LLST3+0x9>, AL
    753a:	76da 3686 	jmpf	0x6d0c <.L322>

0000753e <_adc_DoSoftwareTrigger>:
    753e:	5801      	inc	S, #2

00007540 <.LCFI0>:
    7540:	5201      	mov	[S-2], A

00007542 <.LM2>:
    7542:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>

00007546 <.LVL2>:
    7546:	9401      	and	AL, #1
    7548:	1d0a      	jne	0x755e <.L2>

0000754a <.LBB540>:
    754a:	601f      	lod	AL, #31
    754c:	42d8 016b 	mov	0x16b <.LASF1902>, AL

00007550 <.LBB542>:
    7550:	7002      	lod	A, #2
    7552:	0ea7      	lod	C, ML.7
    7554:	52d8 016a 	mov	0x16a <.LLST14>, A

00007558 <.LBB544>:
    7558:	7001      	lod	A, #1
    755a:	52d8 0166 	mov	0x166 <_ADC_SAR>, A

0000755e <.L2>:
    755e:	7028      	lod	A, #40
    7560:	82db 1128 	callf	0x2250 <_delay_cycles>

00007564 <.LBB549>:
    7564:	6004      	lod	AL, #4
    7566:	42d8 016a 	mov	0x16a <.LLST14>, AL

0000756a <.L3>:
    756a:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>
    756e:	b402      	and	A, #2
    7570:	1902      	je	0x7576 <.L5>

00007572 <.LM9>:
    7572:	7000      	lod	A, #0
    7574:	5403      	ret	#4

00007576 <.L5>:
    7576:	7ad8 016a 	lod	Y, 0x16a <.LLST14>
    757a:	44c8      	rl	YL, #2
    757c:	f403      	and	Y, #3
    757e:	ee01      	cmp	Y, [S-2]
    7580:	1906      	je	0x758e <.L6>

00007582 <.LM11>:
    7582:	7ed8 016a 	lod	X, 0x16a <.LLST14>
    7586:	36da 1000 	and	X, #4096
    758a:	196f      	je	0x756a <.L3>

0000758c <.L4>:
    758c:	5403      	ret	#4

0000758e <.L6>:
    758e:	7001      	lod	A, #1
    7590:	07fd      	jmp	0x758c <.L4>

00007592 <_adc_Init>:
    7592:	128d      	call	0x7aae <_conv_high_voltage_init>

00007594 <.LM16>:
    7594:	12dc      	call	0x7b4e <_conv_low_voltage_init>

00007596 <.LM17>:
    7596:	12f4      	call	0x7b80 <_conv_motor_voltage_init>

00007598 <.LM18>:
    7598:	1329      	call	0x7bec <_conv_shunt_current_init>

0000759a <.LBB551>:
    759a:	7000      	lod	A, #0
    759c:	52d8 12c2 	mov	0x12c2 <_calib_current>, A

000075a0 <.LBE551>:
    75a0:	62d8 01f5 	lod	AL, 0x1f5 <_PORT_MISC2_OUT+0x1>
    75a4:	8404      	or	AL, #4
    75a6:	42d8 01f5 	mov	0x1f5 <_PORT_MISC2_OUT+0x1>, AL

000075aa <.LBB553>:
    75aa:	72da 2710 	lod	A, #10000
    75ae:	82db 1128 	callf	0x2250 <_delay_cycles>

000075b2 <.LBE553>:
    75b2:	62d8 020e 	lod	AL, 0x20e <_PORT_DRV_OUT>
    75b6:	8440      	or	AL, #64
    75b8:	42d8 020e 	mov	0x20e <_PORT_DRV_OUT>, AL

000075bc <.LM23>:
    75bc:	62b4      	lod	AL, io:0x34 <_PORT_ADC_CTRL>
    75be:	8402      	or	AL, #2
    75c0:	42b4      	mov	io:0x34 <_PORT_ADC_CTRL>, AL

000075c2 <.LBB556>:
    75c2:	7ee3      	lod	X, M

000075c4 <.LBB559>:
    75c4:	5049      	call	fp2:0x48

000075c6 <.LBE559>:
    75c6:	62d8 008c 	lod	AL, 0x8c <.LASF1526>
    75ca:	94f3      	and	AL, #-13
    75cc:	8404      	or	AL, #4
    75ce:	42d8 008c 	mov	0x8c <.LASF1526>, AL

000075d2 <.LM27>:
    75d2:	62d8 0070 	lod	AL, 0x70 <__mlx4_cst_tables_ram_size+0x12>
    75d6:	8420      	or	AL, #32
    75d8:	42d8 0070 	mov	0x70 <__mlx4_cst_tables_ram_size+0x12>, AL

000075dc <.LBB561>:
    75dc:	5ee3      	mov	M, X

000075de <.LBE556>:
    75de:	5401      	ret

000075e0 <_adc_Start>:
    75e0:	7ee2      	lod	X, A

000075e2 <.LBB565>:
    75e2:	601f      	lod	AL, #31

000075e4 <.LVL18>:
    75e4:	42d8 016b 	mov	0x16b <.LASF1902>, AL

000075e8 <.LBB567>:
    75e8:	7002      	lod	A, #2
    75ea:	0ea7      	lod	C, ML.7
    75ec:	52d8 016a 	mov	0x16a <.LLST14>, A

000075f0 <.LBB569>:
    75f0:	62b4      	lod	AL, io:0x34 <_PORT_ADC_CTRL>
    75f2:	8402      	or	AL, #2
    75f4:	42b4      	mov	io:0x34 <_PORT_ADC_CTRL>, AL

000075f6 <.LM38>:
    75f6:	62d8 0166 	lod	AL, 0x166 <_ADC_SAR>
    75fa:	94fc      	and	AL, #-4
    75fc:	8402      	or	AL, #2
    75fe:	42d8 0166 	mov	0x166 <_ADC_SAR>, AL

00007602 <.LM39>:
    7602:	6007      	lod	AL, #7
    7604:	42d8 016c 	mov	0x16c <.LASF1902+0x1>, AL

00007608 <.LM40>:
    7608:	0ea7      	lod	C, ML.7
    760a:	72da 101a 	lod	A, #4122
    760e:	52d8 0168 	mov	0x168 <_ADC_SAR+0x2>, A

00007612 <.LM41>:
    7612:	72da 0ac4 	lod	A, #2756
    7616:	0ea7      	lod	C, ML.7
    7618:	52d8 0166 	mov	0x166 <_ADC_SAR>, A

0000761c <.LBB571>:
    761c:	7ae3      	lod	Y, M

0000761e <.LBB574>:
    761e:	5049      	call	fp2:0x48

00007620 <.LBE574>:
    7620:	6020      	lod	AL, #32
    7622:	42d8 0054 	mov	0x54 <.Lframe0>, AL

00007626 <.LBB576>:
    7626:	5ae3      	mov	M, Y

00007628 <.LBB580>:
    7628:	7001      	lod	A, #1
    762a:	0ea7      	lod	C, ML.7
    762c:	52d8 0166 	mov	0x166 <_ADC_SAR>, A

00007630 <.LBE580>:
    7630:	2c00      	cmp	X, #0
    7632:	1904      	je	0x763c <.L10>

00007634 <.L12>:
    7634:	72d8 0054 	lod	A, 0x54 <.Lframe0>
    7638:	9420      	and	AL, #32
    763a:	197c      	je	0x7634 <.L12>

0000763c <.L10>:
    763c:	5401      	ret

0000763e <_adc_Stop>:
    763e:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>
    7642:	9402      	and	AL, #2
    7644:	1d1c      	jne	0x767e <.L18>

00007646 <.L39>:
    7646:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>
    764a:	9402      	and	AL, #2
    764c:	1d14      	jne	0x7676 <.L22>

0000764e <.LBB593>:
    764e:	7002      	lod	A, #2
    7650:	52d8 0166 	mov	0x166 <_ADC_SAR>, A
    7654:	07f8      	jmp	0x7646 <.L39>

00007656 <.L23>:
    7656:	7001      	lod	A, #1
    7658:	52d8 0166 	mov	0x166 <_ADC_SAR>, A

0000765c <.L40>:
    765c:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>
    7660:	9401      	and	AL, #1
    7662:	1979      	je	0x7656 <.L23>

00007664 <.LBB597>:
    7664:	0000      	nop

00007666 <.L41>:
    7666:	72d8 0166 	lod	A, 0x166 <_ADC_SAR>
    766a:	9402      	and	AL, #2
    766c:	1d04      	jne	0x7676 <.L22>

0000766e <.LBB599>:
    766e:	7002      	lod	A, #2
    7670:	52d8 0166 	mov	0x166 <_ADC_SAR>, A
    7674:	07f8      	jmp	0x7666 <.L41>

00007676 <.L22>:
    7676:	72d8 016a 	lod	A, 0x16a <.LLST14>
    767a:	94c0      	and	AL, #-64
    767c:	1d6f      	jne	0x765c <.L40>

0000767e <.L18>:
    767e:	5401      	ret

00007680 <_adc_Shunt_OffsetCalib>:
    7680:	581b      	inc	S, #28

00007682 <.LCFI1>:
    7682:	7eef      	lod	X, S
    7684:	20f2      	add	X, #-14
    7686:	7000      	lod	A, #0
    7688:	52de      	mov	[X++], A
    768a:	52de      	mov	[X++], A
    768c:	52de      	mov	[X++], A
    768e:	720d      	lod	A, [S-14]
    7690:	5205      	mov	[S-6], A
    7692:	720b      	lod	A, [S-12]
    7694:	5203      	mov	[S-4], A
    7696:	7209      	lod	A, [S-10]
    7698:	5201      	mov	[S-2], A
    769a:	72ef      	lod	A, S
    769c:	a0ec      	add	A, #-20
    769e:	5207      	mov	[S-8], A
    76a0:	7205      	lod	A, [S-6]
    76a2:	b483      	and	A, #-125
    76a4:	a440      	or	A, #64
    76a6:	b6da fc7f 	and	A, #64639
    76aa:	a6da 0180 	or	A, #384
    76ae:	5205      	mov	[S-6], A
    76b0:	7203      	lod	A, [S-4]
    76b2:	b483      	and	A, #-125
    76b4:	a440      	or	A, #64
    76b6:	b6da fc7f 	and	A, #64639
    76ba:	a6da 0180 	or	A, #384
    76be:	5203      	mov	[S-4], A
    76c0:	7201      	lod	A, [S-2]
    76c2:	8403      	or	AL, #3
    76c4:	5201      	mov	[S-2], A
    76c6:	7207      	lod	A, [S-8]
    76c8:	521b      	mov	[S-28], A
    76ca:	7205      	lod	A, [S-6]
    76cc:	5219      	mov	[S-26], A
    76ce:	7203      	lod	A, [S-4]
    76d0:	5217      	mov	[S-24], A
    76d2:	7201      	lod	A, [S-2]
    76d4:	5215      	mov	[S-22], A

000076d6 <.LM63>:
    76d6:	17b3      	call	0x763e <_adc_Stop>

000076d8 <.LM64>:
    76d8:	62d8 020e 	lod	AL, 0x20e <_PORT_DRV_OUT>
    76dc:	8440      	or	AL, #64
    76de:	42d8 020e 	mov	0x20e <_PORT_DRV_OUT>, AL

000076e2 <.LM65>:
    76e2:	62b4      	lod	AL, io:0x34 <_PORT_ADC_CTRL>
    76e4:	8402      	or	AL, #2
    76e6:	42b4      	mov	io:0x34 <_PORT_ADC_CTRL>, AL

000076e8 <.LBB601>:
    76e8:	62b4      	lod	AL, io:0x34 <_PORT_ADC_CTRL>
    76ea:	8402      	or	AL, #2
    76ec:	42b4      	mov	io:0x34 <_PORT_ADC_CTRL>, AL

000076ee <.LM67>:
    76ee:	62d8 0166 	lod	AL, 0x166 <_ADC_SAR>
    76f2:	94fc      	and	AL, #-4
    76f4:	8402      	or	AL, #2
    76f6:	42d8 0166 	mov	0x166 <_ADC_SAR>, AL

000076fa <.LM68>:
    76fa:	6007      	lod	AL, #7
    76fc:	42d8 016c 	mov	0x16c <.LASF1902+0x1>, AL

00007700 <.LM69>:
    7700:	72ef      	lod	A, S
    7702:	a0e4      	add	A, #-28

00007704 <.LVL26>:
    7704:	52d8 0168 	mov	0x168 <_ADC_SAR+0x2>, A

00007708 <.LM70>:
    7708:	72da 08d8 	lod	A, #2264

0000770c <.LVL27>:
    770c:	52d8 0166 	mov	0x166 <_ADC_SAR>, A

00007710 <.LBE601>:
    7710:	0ea7      	lod	C, ML.7
    7712:	7003      	lod	A, #3
    7714:	1714      	call	0x753e <_adc_DoSoftwareTrigger>

00007716 <.LM72>:
    7716:	7000      	lod	A, #0
    7718:	1712      	call	0x753e <_adc_DoSoftwareTrigger>

0000771a <.LM73>:
    771a:	7213      	lod	A, [S-20]
    771c:	7e11      	lod	X, [S-18]
    771e:	a2ee      	add	A, X
    7720:	a001      	add	A, #1
    7722:	4432      	lsr	A
    7724:	52d8 10ba 	mov	0x10ba <_i16MotorCurrentZeroOffset>, A

00007728 <.LM74>:
    7728:	541d      	ret	#30

0000772a <_adc_ConvertToCurrent>:
int16_t adc_ConvertToCurrent(uint16_t u16AdcVal)
{
    int16_t current;

    /* the current sensor current in mA units */
    current = conv_shunt_current(u16AdcVal); // Option-A
    772a:	0275      	jmp	0x7c16 <_conv_shunt_current>

0000772c <_adc_ConvertToTchip>:
 * @param[in]  u16AdcVal  Raw adc measurement.
 * @return  the temperature in 1 degC.
 */
int16_t adc_ConvertToTchip(uint16_t u16AdcVal)
{
    return CalculateTemperature3pLinearize(u16AdcVal);
    772c:	76da 503b 	jmpf	0xa076 <_CalculateTemperature3pLinearize>

00007730 <_adc_ConvertToVsupply>:
 * @param[in]  u16AdcVal  Raw adc measurement.
 * @return  the supply voltage in 10 mV.
 */
int16_t adc_ConvertToVsupply(uint16_t u16AdcVal)
{
    return conv_high_voltage_with_tcorrection(u16AdcVal, dBase[ADC_SAMPLE_TEMP]);
    7730:	7ed8 126e 	lod	X, 0x126e <_dBase+0x2>
    7734:	5edf      	push	X

00007736 <.LCFI5>:
    7736:	11e5      	call	0x7b02 <_conv_high_voltage_with_tcorrection>

00007738 <.LCFI6>:
}
    7738:	5403      	ret	#4

0000773a <_adc_ConvertToVoltage>:
 */
MATHLIB_INLINE_STATIC __inline__ uint32_t mulU32_U16byU16(uint16_t multiplicand, uint16_t multiplier)
{
    uint32_t result;

    __asm__ __volatile__ (
    773a:	4822 0294 	mulu	YA, A, #660

0000773e <.LBE605>:
 */
int16_t adc_ConvertToVoltage(uint16_t u16AdcVal)
{
    int16_t i16Volt;

    i16Volt = (int16_t)(mulU32_U16byU16(u16AdcVal, 660u) / 1024u);
    773e:	48a9      	lsr	YA, #10

00007740 <.LM106>:

    return (i16Volt);
}
    7740:	5401      	ret

00007742 <__ADC_SAR_INT>:
/**
 * @brief ADC Interrupt Service Routine
 * In case no ADC_ISR action required, this ISR has 4us overhead
 */
__attribute__((interrupt)) void _ADC_SAR_INT(void)
{
    7742:	5edf      	push	X

00007744 <.LCFI9>:
    7744:	5adf      	push	Y

00007746 <.LCFI10>:
    7746:	52df      	push	A

00007748 <.LCFI11>:
    7748:	4c83      	push	D

0000774a <.LCFI12>:
    if (p16AdcIrq != NULL)
    774a:	72d8 10b8 	lod	A, 0x10b8 <_p16AdcIrq>
    774e:	1903      	je	0x7756 <.L51>

00007750 <.LM109>:
    {
        p16AdcIrq();
    7750:	0001      	jmp	0x7754 <.L57>

00007752 <.L56>:
    7752:	76e2      	jmp	A

00007754 <.L57>:
    7754:	17fe      	call	0x7752 <.L56>

00007756 <.L51>:
    if (p16AdcIrq2 != NULL)
    {
        p16AdcIrq2();
    }
#endif
}
    7756:	4cc3      	pop	D

00007758 <.LCFI13>:
    7758:	72cf      	pop	A

0000775a <.LCFI14>:
    775a:	7acf      	pop	Y

0000775c <.LCFI15>:
    775c:	7ecf      	pop	X

0000775e <.LCFI16>:
    775e:	72cb      	pop	M
    7760:	5401      	ret

00007762 <_gmr_calibration_setup>:
	l16_SetGmrSensorOffset = (DEFAULT_GMR_OFFSET * C_GMR_ANGLE_SCALE_FACTOR);
	l_au16MotorOffsetCurrent = 0;
}
void gmr_calibration_setup(void)
{
	l16_GmrCalEnable = 1;
    7762:	7801      	lod	Y, #1
    7764:	5ad8 10be 	mov	0x10be <_l16_GmrCalEnable>, Y

00007768 <.LM3>:
	l16_SinPosMaxPeak = 0;
    7768:	7c00      	lod	X, #0
    776a:	0ea7      	lod	C, ML.7
    776c:	5ed8 1296 	mov	0x1296 <_l16_SinPosMaxPeak>, X

00007770 <.LM4>:
	l16_SinPosMinPeak = 0x7fff;
    7770:	72da 7fff 	lod	A, #32767
    7774:	52d8 1290 	mov	0x1290 <_l16_SinPosMinPeak>, A

00007778 <.LM5>:
	l16_SinNegMaxPeak = 0;
    7778:	0ea7      	lod	C, ML.7
    777a:	5ed8 128e 	mov	0x128e <_l16_SinNegMaxPeak>, X

0000777e <.LM6>:
	l16_SinNegMinPeak = 0x7fff;
    777e:	52d8 129a 	mov	0x129a <_l16_SinNegMinPeak>, A

00007782 <.LM7>:
	l16_CosinPosMaxPeak = 0;
    7782:	5ed8 1294 	mov	0x1294 <_l16_CosinPosMaxPeak>, X

00007786 <.LM8>:
	l16_CosinPosMinPeak = 0x7fff;
    7786:	0ea7      	lod	C, ML.7
    7788:	52d8 1292 	mov	0x1292 <_l16_CosinPosMinPeak>, A

0000778c <.LM9>:
	l16_CosinNegMaxPeak = 0;
    778c:	5ed8 129c 	mov	0x129c <_l16_CosinNegMaxPeak>, X

00007790 <.LM10>:
	l16_CosinNegMinPeak = 0x7fff;
    7790:	52d8 1298 	mov	0x1298 <_l16_CosinNegMinPeak>, A

00007794 <.LM11>:
	l16_SinOutputOffset = 0xFFFF;
    7794:	0ea7      	lod	C, ML.7
    7796:	70ff      	lod	A, #-1
    7798:	52d8 129e 	mov	0x129e <_l16_SinOutputOffset>, A

0000779c <.LM12>:
	l16_CosinOutputOffset = 1;
    779c:	5ad8 12a0 	mov	0x12a0 <_l16_CosinOutputOffset>, Y

000077a0 <.LM13>:
}
    77a0:	5401      	ret

000077a2 <_sensor_init>:
int16_t l16_CosinNegMinPeak;
int16_t l16_SinOutputOffset;
int16_t l16_CosinOutputOffset;
int16_t l16_SetGmrSensorOffset = 0;
void sensor_init(void)
{
    77a2:	5803      	inc	S, #4

000077a4 <.LCFI0>:
    77a4:	7eda 103a 	lod	X, #4154
    77a8:	5e03      	mov	[S-4], X

000077aa <.LM15>:
	uint16_t num = 0, index = 0, initValue;

	for (num = 0; num < C_ADC_END_ITEM; num++)
    77aa:	7000      	lod	A, #0
    77ac:	5201      	mov	[S-2], A

000077ae <.LM16>:
	{
		if (num == C_ADC_VS_)
			initValue = 0xFF;
    77ae:	72da 00ff 	lod	A, #255

000077b2 <.L3>:
    77b2:	7e03      	lod	X, [S-4]
    77b4:	7afc      	lod	Y, [X+4]
    77b6:	7c08      	lod	X, #8

000077b8 <.L5>:
		else
			initValue = 0;
		l_sAdcAvgObject[num].u32MovAvgxN = 0;
		for (index = 0; index < 8; index++)
		{
			l_sAdcAvgObject[num].pu16Raw[index] = initValue;
    77b8:	52d6      	mov	[Y++], A

000077ba <.LM18>:
		else if (num == C_ADC_TEMP_)
			initValue = 0x260;
		else
			initValue = 0;
		l_sAdcAvgObject[num].u32MovAvgxN = 0;
		for (index = 0; index < 8; index++)
    77ba:	1bfe      	djnz	X, 0x77b8 <.L5>
    77bc:	4cf2      	usex	YA

000077be <.LVL3>:
    77be:	48e2      	asl	YA, #3
    77c0:	7e03      	lod	X, [S-4]
    77c2:	4ca7      	mov	[X], YA

000077c4 <.LM19>:
int16_t l16_SetGmrSensorOffset = 0;
void sensor_init(void)
{
	uint16_t num = 0, index = 0, initValue;

	for (num = 0; num < C_ADC_END_ITEM; num++)
    77c4:	7201      	lod	A, [S-2]
    77c6:	a001      	add	A, #1

000077c8 <.LVL5>:
    77c8:	5201      	mov	[S-2], A
    77ca:	ac09      	cmp	A, #9
    77cc:	1d06      	jne	0x77da <.L6>

000077ce <.LM20>:
		{
			l_sAdcAvgObject[num].pu16Raw[index] = initValue;
			l_sAdcAvgObject[num].u32MovAvgxN += initValue;
		}
	}
	gmr_calibration_setup();
    77ce:	17c9      	call	0x7762 <_gmr_calibration_setup>

000077d0 <.LM21>:
	//	l16_SetGmrSensorOffset=C_GMR_SENSOR_OFFSET*C_GMR_ANGLE_SCALE_FACTOR;
	l16_SetGmrSensorOffset = (DEFAULT_GMR_OFFSET * C_GMR_ANGLE_SCALE_FACTOR);
    77d0:	72da 0456 	lod	A, #1110
    77d4:	52d8 10bc 	mov	0x10bc <_l16_SetGmrSensorOffset>, A

000077d8 <.LM22>:
	l_au16MotorOffsetCurrent = 0;
}
    77d8:	5405      	ret	#6

000077da <.L6>:

	for (num = 0; num < C_ADC_END_ITEM; num++)
	{
		if (num == C_ADC_VS_)
			initValue = 0xFF;
		else if (num == C_ADC_TEMP_)
    77da:	7e01      	lod	X, [S-2]
    77dc:	2c01      	cmp	X, #1
    77de:	1d06      	jne	0x77ec <.L7>

000077e0 <.LM24>:
			initValue = 0x260;
    77e0:	72da 0260 	lod	A, #608

000077e4 <.L4>:
    77e4:	7e03      	lod	X, [S-4]
    77e6:	200c      	add	X, #12
    77e8:	5e03      	mov	[S-4], X
    77ea:	07e3      	jmp	0x77b2 <.L3>

000077ec <.L7>:
		else
			initValue = 0;
    77ec:	7000      	lod	A, #0
    77ee:	07fa      	jmp	0x77e4 <.L4>

000077f0 <_set_gmr_sensor_offset>:
void gmr_calibration_end(void)
{
}
void set_gmr_sensor_offset(int16_t offset)
{
	l16_SetGmrSensorOffset = offset;
    77f0:	52d8 10bc 	mov	0x10bc <_l16_SetGmrSensorOffset>, A

000077f4 <.LM30>:
}
    77f4:	5401      	ret

000077f6 <_get_gmr_sensor_offset>:
int16_t get_gmr_sensor_offset(void)
{
	return l16_SetGmrSensorOffset;
}
    77f6:	72d8 10bc 	lod	A, 0x10bc <_l16_SetGmrSensorOffset>
    77fa:	5401      	ret

000077fc <_adc_raw_update>:
void adc_raw_update(void)
{
    77fc:	5801      	inc	S, #2

000077fe <.LCFI1>:
	uint16_t index = 0;

	for (index = 0; index < C_ADC_END_ITEM; index++)
    77fe:	7000      	lod	A, #0
    7800:	5201      	mov	[S-2], A

00007802 <.L25>:
	{
		switch (index)
    7802:	7201      	lod	A, [S-2]
    7804:	a0ff      	add	A, #-1
    7806:	ac07      	cmp	A, #7
    7808:	1e05      	jug	0x7814 <.L13>
    780a:	4422      	asl	A
    780c:	7ee2      	lod	X, A
    780e:	22da 5cec 	add	X, #23788
    7812:	76f8      	jmp	[X]

00007814 <.L13>:
 * @returns  raw Vs adc sample.
 */
static INLINE uint16_t adc_GetRawVs(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_VS];
    7814:	72d8 1276 	lod	A, 0x1276 <.LASF2063>

00007818 <.LBE38>:
		{
		case C_ADC_VS_:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_VS_], adc_GetRawVs());
    7818:	52df      	push	A

0000781a <.LCFI2>:
    781a:	72da 1038 	lod	A, #4152

0000781e <.L28>:
		case C_ADC_SENSOR_3:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_SENSOR_3], adc_Get_GMR_pCosine());
			//						temp = l_sAdcAvgObject[C_ADC_SENSOR_].u16MovAvg;
			break;
		case C_ADC_SENSOR_4:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_SENSOR_4], adc_Get_GMR_pSine());
    781e:	82db 43da 	callf	0x87b4 <_FILTER_AVG_CalcMovAvg>

00007822 <.LM39>:
}
void adc_raw_update(void)
{
	uint16_t index = 0;

	for (index = 0; index < C_ADC_END_ITEM; index++)
    7822:	7203      	lod	A, [S-4]
    7824:	5c01      	dec	S, #2

00007826 <.LCFI3>:
    7826:	a001      	add	A, #1
    7828:	5201      	mov	[S-2], A
    782a:	ac09      	cmp	A, #9
    782c:	1d6a      	jne	0x7802 <.L25>

0000782e <.LM40>:
			break;
		default:
			break;
		}
	}
}
    782e:	5403      	ret	#4

00007830 <.L14>:
 * @returns  raw temperature adc sample.
 */
static INLINE uint16_t adc_GetRawTemperature(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_TEMP];
    7830:	72d8 126e 	lod	A, 0x126e <_dBase+0x2>

00007834 <.LBE40>:
		case C_ADC_VS_:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_VS_], adc_GetRawVs());
			//						temp = l_sAdcAvgObject[C_ADC_VS_].u16MovAvg;
			break;
		case C_ADC_TEMP_:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_TEMP_], adc_GetRawTemperature());
    7834:	52df      	push	A

00007836 <.LCFI4>:
    7836:	72da 1044 	lod	A, #4164
    783a:	07f1      	jmp	0x781e <.L28>

0000783c <.L16>:
 */
static INLINE uint16_t adc_GetRawCurrent(void)
{
    extern volatile uint16_t dBase[];
    extern int16_t i16MotorCurrentZeroOffset;
    int16_t i16MotorCurrent = ((dBase[ADC_SAMPLE_CURR] + dBase[ADC_SAMPLE_CURR_2]) >> 1);
    783c:	72d8 1270 	lod	A, 0x1270 <.LASF2051>
    7840:	7ed8 127c 	lod	X, 0x127c <.LASF1636>
    7844:	a2ee      	add	A, X
    7846:	4432      	lsr	A

00007848 <.LM44>:
    if (i16MotorCurrent >= i16MotorCurrentZeroOffset)
    7848:	7ed8 10ba 	lod	X, 0x10ba <_i16MotorCurrentZeroOffset>
    784c:	aeee      	cmp	A, X
    784e:	1a85      	jsl	0x785a <.L26>

00007850 <.LM45>:
    {
        i16MotorCurrent -= i16MotorCurrentZeroOffset;
    7850:	aaee      	sub	A, X

00007852 <.L24>:
			//						temp = l_sAdcAvgObject[C_ADC_TEMP_].u16MovAvg;
			break;
		case C_ADC_CURRENT_:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_CURRENT_], adc_GetRawCurrent());
    7852:	52df      	push	A

00007854 <.LCFI6>:
    7854:	72da 1050 	lod	A, #4176
    7858:	07e2      	jmp	0x781e <.L28>

0000785a <.L26>:
    }
    else
    {
        i16MotorCurrent = 0;
    785a:	7000      	lod	A, #0

0000785c <.LVL22>:
    785c:	07fa      	jmp	0x7852 <.L24>

0000785e <.L17>:
 * @returns  raw VDDA voltage sample.
 */
static INLINE uint16_t adc_GetRawVdda(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_VDDA];
    785e:	72d8 1272 	lod	A, 0x1272 <.LASF2051+0x2>

00007862 <.LBE46>:
			//						temp = l_sAdcAvgObject[C_ADC_CURRENT_].u16MovAvg;
			break;
		case C_ADC_VDDA:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_VDDA], adc_GetRawVdda());
    7862:	52df      	push	A

00007864 <.LCFI8>:
    7864:	72da 105c 	lod	A, #4188
    7868:	07da      	jmp	0x781e <.L28>

0000786a <.L18>:
 * @returns  raw IO voltage sample.
 */
static INLINE uint16_t adc_GetRawIGN(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_IGN];
    786a:	72d8 1274 	lod	A, 0x1274 <.LASF2051+0x4>

0000786e <.LBE48>:
			//						temp = l_sAdcAvgObject[C_ADC_VDDA].u16MovAvg;
			break;
		case C_ADC_IGN:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_IGN], adc_GetRawIGN());
    786e:	52df      	push	A

00007870 <.LCFI10>:
    7870:	72da 1068 	lod	A, #4200
    7874:	07d4      	jmp	0x781e <.L28>

00007876 <.L19>:
 * @returns  raw IO voltage sample.
 */
static INLINE uint16_t adc_Get_GMR_nCosine(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_GMR_IO1];
    7876:	72d8 1278 	lod	A, 0x1278 <.Ldebug_abbrev0>

0000787a <.LBE50>:
			//						temp = l_sAdcAvgObject[C_ADC_VREF_].u16MovAvg;
			break;
		case C_ADC_SENSOR_1:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_SENSOR_1], adc_Get_GMR_nCosine());
    787a:	52df      	push	A

0000787c <.LCFI12>:
    787c:	72da 1074 	lod	A, #4212
    7880:	07ce      	jmp	0x781e <.L28>

00007882 <.L20>:
 * @returns  raw IO voltage sample.
 */
static INLINE uint16_t adc_Get_GMR_nSine(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_GMR_IO2];
    7882:	72d8 127a 	lod	A, 0x127a <.Ldebug_abbrev0+0x2>

00007886 <.LBE52>:
			//						temp = l_sAdcAvgObject[C_ADC_SENSOR_].u16MovAvg;
			break;
		case C_ADC_SENSOR_2:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_SENSOR_2], adc_Get_GMR_nSine());
    7886:	52df      	push	A

00007888 <.LCFI14>:
    7888:	72da 1080 	lod	A, #4224
    788c:	07c8      	jmp	0x781e <.L28>

0000788e <.L21>:
 * @returns  raw IO voltage sample.
 */
static INLINE uint16_t adc_Get_GMR_pCosine(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_GMR_IO3];
    788e:	72d8 127e 	lod	A, 0x127e <.LLST6+0x1>

00007892 <.LBE54>:
			//						temp = l_sAdcAvgObject[C_ADC_SENSOR_].u16MovAvg;
			break;
		case C_ADC_SENSOR_3:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_SENSOR_3], adc_Get_GMR_pCosine());
    7892:	52df      	push	A

00007894 <.LCFI16>:
    7894:	72da 108c 	lod	A, #4236
    7898:	07c2      	jmp	0x781e <.L28>

0000789a <.L22>:
 * @returns  raw IO voltage sample.
 */
static INLINE uint16_t adc_Get_GMR_pSine(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_GMR_IO4];
    789a:	72d8 1280 	lod	A, 0x1280 <.LLST6+0x3>

0000789e <.LBE56>:
			//						temp = l_sAdcAvgObject[C_ADC_SENSOR_].u16MovAvg;
			break;
		case C_ADC_SENSOR_4:
			FILTER_AVG_CalcMovAvg(&l_sAdcAvgObject[C_ADC_SENSOR_4], adc_Get_GMR_pSine());
    789e:	52df      	push	A

000078a0 <.LCFI18>:
    78a0:	72da 1098 	lod	A, #4248
    78a4:	07bc      	jmp	0x781e <.L28>

000078a6 <_get_conv_vdda_voltage>:
{
	return (l_sAdcAvgObject[num].u16MovAvg);
}
uint16_t get_conv_vdda_voltage(void)
{
	return adc_ConvertToVoltage(get_sensor_raw_data(C_ADC_VDDA));
    78a6:	72d8 105c 	lod	A, 0x105c <.LASF1903+0x7>
    78aa:	0747      	jmp	0x773a <_adc_ConvertToVoltage>

000078ac <_get_conv_supply_voltage>:
}
uint16_t get_conv_supply_voltage(void)
{
	return adc_ConvertToVsupply(get_sensor_raw_data(C_ADC_VS_));
    78ac:	72d8 1038 	lod	A, 0x1038 <_l_sAdcAvgObject>
    78b0:	073f      	jmp	0x7730 <_adc_ConvertToVsupply>

000078b2 <_get_conv_ic_temperature>:
int16_t get_conv_ic_temperature(void)
{
#if 0
	return adc_ConvertToTchip(get_sensor_raw_data(C_ADC_TEMP_));
#else
	int16_t temperature = adc_ConvertToTchip(get_sensor_raw_data(C_ADC_TEMP_));
    78b2:	72d8 1044 	lod	A, 0x1044 <_l_sAdcAvgObject+0xc>
    78b6:	173a      	call	0x772c <_adc_ConvertToTchip>

000078b8 <.LM71>:
	if (temperature >= 0)
    78b8:	ac00      	cmp	A, #0
    78ba:	1a82      	jsl	0x78c0 <.L33>

000078bc <.L36>:
		{
			temperature = 0;
		}
		else
		{
			temperature = (C_TEMP_CONV_OFFSET + temperature);
    78bc:	a028      	add	A, #40
    78be:	5401      	ret

000078c0 <.L33>:
	{
		temperature += C_TEMP_CONV_OFFSET;
	}
	else
	{
		if (temperature < (-40))
    78c0:	acd8      	cmp	A, #-40
    78c2:	1efc      	jsge	0x78bc <.L36>

000078c4 <.LM74>:
		{
			temperature = 0;
    78c4:	7000      	lod	A, #0

000078c6 <.LM75>:
		}
	}

	return temperature;
#endif
}
    78c6:	5401      	ret

000078c8 <_get_conv_mot_current>:
uint16_t get_conv_mot_current(void)
{
	return adc_ConvertToCurrent(get_sensor_raw_data(C_ADC_CURRENT_));
    78c8:	72d8 1050 	lod	A, 0x1050 <.LLST32+0x9>
    78cc:	072e      	jmp	0x772a <_adc_ConvertToCurrent>

000078ce <_get_gmr_sine_output>:
	int16_t cal, offset = C_GMR_OUTPUT_OFFSET;
	int16_t pSin, nSin;
	pSin = get_sensor_raw_data(C_ADC_SENSOR_4) - offset;
	nSin = get_sensor_raw_data(C_ADC_SENSOR_2) - offset;

	cal = pSin - nSin;
    78ce:	72d8 1098 	lod	A, 0x1098 <.LLST34+0x6>
    78d2:	aad8 1080 	sub	A, 0x1080 <.LLST33+0x5>

000078d6 <.LM81>:
if (cal<l16_SinNegMaxPeak)
{
l16_SinNegMaxPeak=cal;
}
#endif
	cal = cal - l16_SinOutputOffset;
    78d6:	aad8 129e 	sub	A, 0x129e <_l16_SinOutputOffset>

000078da <.LVL44>:
    78da:	0ea7      	lod	C, ML.7
    78dc:	aeda c001 	cmp	A, #49153
    78e0:	1e82      	jsge	0x78e6 <.L39>
    78e2:	72da c001 	lod	A, #49153

000078e6 <.L39>:
		cal = C_GMR_NEGAITIVE_MAX;
	}
	else
	{
	}
	return (cal);
    78e6:	aeda 3fff 	cmp	A, #16383
    78ea:	1b02      	jsle	0x78f0 <.L40>
    78ec:	72da 3fff 	lod	A, #16383

000078f0 <.L40>:
}
    78f0:	5401      	ret

000078f2 <_get_gmr_cosine_output>:
	int16_t cal, offset = C_GMR_OUTPUT_OFFSET;
	int16_t pCosin, nCosin;
	pCosin = get_sensor_raw_data(C_ADC_SENSOR_3) - offset;
	nCosin = get_sensor_raw_data(C_ADC_SENSOR_1) - offset;

	cal = pCosin - nCosin;
    78f2:	72d8 108c 	lod	A, 0x108c <.LLST33+0x11>
    78f6:	aad8 1074 	sub	A, 0x1074 <.Lframe0+0xc>

000078fa <.LM86>:
if (cal<l16_CosinNegMaxPeak)
{
l16_CosinNegMaxPeak=cal;
}
#endif
	cal = cal - l16_CosinOutputOffset;
    78fa:	aad8 12a0 	sub	A, 0x12a0 <_l16_CosinOutputOffset>

000078fe <.LVL49>:
    78fe:	0ea7      	lod	C, ML.7
    7900:	aeda c001 	cmp	A, #49153
    7904:	1e82      	jsge	0x790a <.L42>
    7906:	72da c001 	lod	A, #49153

0000790a <.L42>:
		cal = C_GMR_NEGAITIVE_MAX;
	}
	else
	{
	}
	return (cal);
    790a:	aeda 3fff 	cmp	A, #16383
    790e:	1b02      	jsle	0x7914 <.L43>
    7910:	72da 3fff 	lod	A, #16383

00007914 <.L43>:
}
    7914:	5401      	ret

00007916 <_calculate_gmr_angle>:
/* ELMOS
u16 loc_rotor_angle_estimated = math_get_angle_unsafe( loc_e_beta_filtered, loc_e_alpha_filtered );
*/

int16_t calculate_gmr_angle(void)
{
    7916:	5801      	inc	S, #2

00007918 <.LCFI19>:
	int16_t ang_result;

	ang_result = (int16_t)atan2I16(get_gmr_cosine_output(), get_gmr_sine_output());
    7918:	17da      	call	0x78ce <_get_gmr_sine_output>
    791a:	5201      	mov	[S-2], A
    791c:	17ea      	call	0x78f2 <_get_gmr_cosine_output>
    791e:	7a01      	lod	Y, [S-2]
    7920:	5adf      	push	Y

00007922 <.LCFI20>:
    7922:	82db 513d 	callf	0xa27a <_atan2I16>

00007926 <.LBB60>:
}
/* 0~0xFFFF -> 0~360*10*/
static uint16_t MLX_to_GMR_conv(uint16_t angle)
{
	uint16_t cal, offset;
	if (angle < 0x2000) /* 45*/
    7926:	5c01      	dec	S, #2

00007928 <.LCFI21>:
    7928:	aeda 1fff 	cmp	A, #8191
    792c:	1e01      	jug	0x7930 <.LM92>
    792e:	0049      	jmp	0x79c2 <.L54>

00007930 <.LM92>:
	{
		offset = 0;
	}
	else if (angle < 0x4000) /* 90*/
    7930:	aeda 3fff 	cmp	A, #16383
    7934:	1e1a      	jug	0x796a <.L46>

00007936 <.LM93>:
	{
		angle -= 0x2000;
    7936:	a2da e000 	add	A, #57344

0000793a <.LM94>:
		offset = 450;
    793a:	7eda 01c2 	lod	X, #450

0000793e <.L45>:
	else /* 360*/
	{
		angle -= 0xE000;
		offset = 3150;
	}
	angle = (angle >> 6); /* div 64 */
    793e:	44b2      	lsr	A, #2
    7940:	44b2      	lsr	A, #2
    7942:	44b2      	lsr	A, #2

00007944 <.LM96>:
	cal = (450 * angle) >> 7;
    7944:	4872 01c2 	muls	A, A, #450

00007948 <.LVL58>:
    7948:	4442      	rl	A
    794a:	9401      	and	AL, #1
    794c:	72e4      	swap	A

0000794e <.LM97>:
	cal += offset;
    794e:	a2ee      	add	A, X

00007950 <.LM98>:
	if (cal >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
    7950:	aeda 0e0f 	cmp	A, #3599
    7954:	1a02      	jule	0x795a <.L52>

00007956 <.LM99>:
	{
		cal -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    7956:	a2da f1f0 	add	A, #61936

0000795a <.L52>:
	}

	cal += l16_SetGmrSensorOffset;
    795a:	a2d8 10bc 	add	A, 0x10bc <_l16_SetGmrSensorOffset>

0000795e <.LM101>:
	if (cal >= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT)
    795e:	aeda 0e0f 	cmp	A, #3599
    7962:	1a02      	jule	0x7968 <.L53>

00007964 <.LM102>:
	{
		cal -= (int16_t)C_GMR_SENSOR_ANGLE_LIMIT;
    7964:	a2da f1f0 	add	A, #61936

00007968 <.L53>:

	/* output angle(0~0xFFFF) -> 0~360 degree */
	ang_result = MLX_to_GMR_conv(ang_result);

	return ang_result;
}
    7968:	5403      	ret	#4

0000796a <.L46>:
	else if (angle < 0x4000) /* 90*/
	{
		angle -= 0x2000;
		offset = 450;
	}
	else if (angle < 0x6000) /* 135*/
    796a:	aeda 5fff 	cmp	A, #24575
    796e:	1e05      	jug	0x797a <.L47>

00007970 <.LM105>:
	{
		angle -= 0x4000;
    7970:	a2da c000 	add	A, #49152

00007974 <.LM106>:
		offset = 900;
    7974:	7eda 0384 	lod	X, #900
    7978:	07e2      	jmp	0x793e <.L45>

0000797a <.L47>:
	}
	else if (angle < 0x8000) /* 180*/
    797a:	ac00      	cmp	A, #0
    797c:	1a85      	jsl	0x7988 <.L48>

0000797e <.LM108>:
	{
		angle -= 0x6000;
    797e:	a2da a000 	add	A, #40960

00007982 <.LM109>:
		offset = 1350;
    7982:	7eda 0546 	lod	X, #1350
    7986:	07db      	jmp	0x793e <.L45>

00007988 <.L48>:
	}
	else if (angle < 0xA000) /* 225*/
    7988:	aeda 9fff 	cmp	A, #40959
    798c:	1e05      	jug	0x7998 <.L49>

0000798e <.LM111>:
	{
		angle -= 0x8000;
    798e:	a2da 8000 	add	A, #32768

00007992 <.LM112>:
		offset = 1800;
    7992:	7eda 0708 	lod	X, #1800
    7996:	07d3      	jmp	0x793e <.L45>

00007998 <.L49>:
	}
	else if (angle < 0xC000) /* 270*/
    7998:	aeda bfff 	cmp	A, #49151
    799c:	1e05      	jug	0x79a8 <.L50>

0000799e <.LM114>:
	{
		angle -= 0xA000;
    799e:	a2da 6000 	add	A, #24576

000079a2 <.LM115>:
		offset = 2250;
    79a2:	7eda 08ca 	lod	X, #2250
    79a6:	07cb      	jmp	0x793e <.L45>

000079a8 <.L50>:
	}
	else if (angle < 0xE000) /* 315*/
    79a8:	aeda dfff 	cmp	A, #57343
    79ac:	1e05      	jug	0x79b8 <.L51>

000079ae <.LM117>:
	{
		angle -= 0xC000;
    79ae:	a2da 4000 	add	A, #16384

000079b2 <.LM118>:
		offset = 2700;
    79b2:	7eda 0a8c 	lod	X, #2700
    79b6:	07c3      	jmp	0x793e <.L45>

000079b8 <.L51>:
	}
	else /* 360*/
	{
		angle -= 0xE000;
    79b8:	a2da 2000 	add	A, #8192

000079bc <.LM120>:
		offset = 3150;
    79bc:	7eda 0c4e 	lod	X, #3150
    79c0:	07be      	jmp	0x793e <.L45>

000079c2 <.L54>:
static uint16_t MLX_to_GMR_conv(uint16_t angle)
{
	uint16_t cal, offset;
	if (angle < 0x2000) /* 45*/
	{
		offset = 0;
    79c2:	7c00      	lod	X, #0
    79c4:	07bc      	jmp	0x793e <.L45>

000079c6 <_forward_linear_Interpolation>:

	return ang_result;
}

int16_t forward_linear_Interpolation(int16_t x, int16_t x0, int16_t x1, int16_t y0, int16_t y1)
{
    79c6:	7ae2      	lod	Y, A

000079c8 <.LM123>:
    79c8:	7e07      	lod	X, [S-8]
    79ca:	7209      	lod	A, [S-10]

000079cc <.LM124>:
	int16_t tmp = 0;
	int16_t retVal = 0;

	tmp = (int16_t)(y1 - y0) * (int16_t)(x - x0);
    79cc:	aaee      	sub	A, X

000079ce <.LM125>:

	return ang_result;
}

int16_t forward_linear_Interpolation(int16_t x, int16_t x0, int16_t x1, int16_t y0, int16_t y1)
{
    79ce:	7e03      	lod	X, [S-4]

000079d0 <.LM126>:
	int16_t tmp = 0;
	int16_t retVal = 0;

	tmp = (int16_t)(y1 - y0) * (int16_t)(x - x0);
    79d0:	eaee      	sub	Y, X

000079d2 <.LVL80>:
    79d2:	4871      	muls	A, A, Y

000079d4 <.LM127>:

	if ((x1 - x0) != 0)
    79d4:	2e05      	cmp	X, [S-6]
    79d6:	1906      	je	0x79e4 <.L56>

000079d8 <.LM128>:
	{
		tmp /= (int16_t)(x1 - x0);
    79d8:	7e05      	lod	X, [S-6]
    79da:	2a03      	sub	X, [S-4]
    79dc:	4cf8      	movs	YA, A
    79de:	4c73      	divs	YA, X
    79e0:	4c73      	divs	YA, X
    79e2:	4c7b      	dadjs	YA, X

000079e4 <.L56>:
    79e4:	7e07      	lod	X, [S-8]

000079e6 <.LM129>:
	}

	tmp += (int16_t)y0;
    79e6:	a2ee      	add	A, X

000079e8 <.LM130>:

	retVal = tmp;

	return retVal;
}
    79e8:	5401      	ret

000079ea <_get_conv_ignition_voltage>:
	{0x15B, 900u},	// 1
	{0x178, 1200u}, // 2
	{0x19B, 1800u}	// 3
};
uint16_t get_conv_ignition_voltage(void)
{
    79ea:	5803      	inc	S, #4

000079ec <.LBB64>:
	}
}

int16_t get_sensor_raw_data(uint16_t num)
{
	return (l_sAdcAvgObject[num].u16MovAvg);
    79ec:	7ad8 1068 	lod	Y, 0x1068 <.Lframe0>

000079f0 <.LBE64>:
uint16_t get_conv_ignition_voltage(void)
{
	uint16_t volt = get_sensor_raw_data(C_ADC_IGN);
	uint16_t cal_result = 0, index;

	if (volt < IGNconversionMap[0].actual)
    79f0:	eeda 0131 	cmp	Y, #305
    79f4:	1a27      	jule	0x7a44 <.L60>

000079f6 <.LM134>:
	{
		cal_result = 0;
	}
	else if (volt > IGNconversionMap[3].actual)
    79f6:	eeda 019b 	cmp	Y, #411
    79fa:	1e26      	jug	0x7a48 <.L61>

000079fc <.LM135>:
	}
	else
	{
		for (index = 0U; index < (IGN_CONV_MAP_SIZE - 1U); index++)
		{
			if (volt <= IGNconversionMap[index + 1U].actual)
    79fc:	eeda 015b 	cmp	Y, #347
    7a00:	1a1f      	jule	0x7a40 <.L62>
    7a02:	eeda 0178 	cmp	Y, #376
    7a06:	5cb0      	sug	A
    7a08:	a001      	add	A, #1

00007a0a <.L64>:
	{
		cal_result = 1800u;
	}
	else
	{
		for (index = 0U; index < (IGN_CONV_MAP_SIZE - 1U); index++)
    7a0a:	5203      	mov	[S-4], A

00007a0c <.LM137>:
				break;
			}
		}
		cal_result = forward_linear_Interpolation(volt,
												  IGNconversionMap[index].actual, IGNconversionMap[index + 1U].actual,
												  IGNconversionMap[index].correction, IGNconversionMap[index + 1U].correction);
    7a0c:	44a2      	asl	A, #2
    7a0e:	4422      	asl	A
    7a10:	7ee2      	lod	X, A
    7a12:	22da 5d04 	add	X, #23812
    7a16:	5e01      	mov	[S-2], X

00007a18 <.LM138>:
			if (volt <= IGNconversionMap[index + 1U].actual)
			{
				break;
			}
		}
		cal_result = forward_linear_Interpolation(volt,
    7a18:	72fc      	lod	A, [X+4]
    7a1a:	52df      	push	A

00007a1c <.LCFI23>:
												  IGNconversionMap[index].actual, IGNconversionMap[index + 1U].actual,
												  IGNconversionMap[index].correction, IGNconversionMap[index + 1U].correction);
    7a1c:	7205      	lod	A, [S-6]
    7a1e:	44a2      	asl	A, #2
    7a20:	4422      	asl	A
    7a22:	a2da 5cfc 	add	A, #23804
    7a26:	5205      	mov	[S-6], A

00007a28 <.LM140>:
			if (volt <= IGNconversionMap[index + 1U].actual)
			{
				break;
			}
		}
		cal_result = forward_linear_Interpolation(volt,
    7a28:	7ee2      	lod	X, A
    7a2a:	72fc      	lod	A, [X+4]
    7a2c:	52df      	push	A

00007a2e <.LCFI24>:
    7a2e:	7e05      	lod	X, [S-6]
    7a30:	72f8      	lod	A, [X]
    7a32:	52df      	push	A

00007a34 <.LCFI25>:
    7a34:	7e09      	lod	X, [S-10]
    7a36:	72f8      	lod	A, [X]
    7a38:	52df      	push	A

00007a3a <.LCFI26>:
    7a3a:	72e6      	lod	A, Y
    7a3c:	17c4      	call	0x79c6 <_forward_linear_Interpolation>

00007a3e <.LCFI27>:
    7a3e:	540d      	ret	#14

00007a40 <.L62>:
	{
		cal_result = 1800u;
	}
	else
	{
		for (index = 0U; index < (IGN_CONV_MAP_SIZE - 1U); index++)
    7a40:	7000      	lod	A, #0
    7a42:	07e3      	jmp	0x7a0a <.L64>

00007a44 <.L60>:
	uint16_t volt = get_sensor_raw_data(C_ADC_IGN);
	uint16_t cal_result = 0, index;

	if (volt < IGNconversionMap[0].actual)
	{
		cal_result = 0;
    7a44:	7000      	lod	A, #0
    7a46:	5405      	ret	#6

00007a48 <.L61>:
	}
	else if (volt > IGNconversionMap[3].actual)
	{
		cal_result = 1800u;
    7a48:	72da 0708 	lod	A, #1800

00007a4c <.LM144>:
												  IGNconversionMap[index].actual, IGNconversionMap[index + 1U].actual,
												  IGNconversionMap[index].correction, IGNconversionMap[index + 1U].correction);
	}

	return (cal_result);
}
    7a4c:	5405      	ret	#6

00007a4e <_conv_clock_error_init>:
int16_t clock_error_SClockHighCal;  /**< CPU clock gain for high temperature range */
int16_t clock_error_OClockCal;  /**< CPU clock offset */

void conv_clock_error_init(void)
{
    clock_error_OTempCal = EE_GET(OTEMPCAL);
    7a4e:	72d8 09b4 	lod	A, 0x9b4 <.LASF1021>
    7a52:	52d8 12a2 	mov	0x12a2 <_clock_error_OTempCal>, A

00007a56 <.LM3>:

    #if (FPLL == 32000) || (FPLL == 16000)
    clock_error_SClockLowCal = EE_GET(SCLOCK32LOWCAL);
    7a56:	72d8 09c4 	lod	A, 0x9c4 <.LASF1598+0x3>
    7a5a:	66e0      	lod	YL, AL
    7a5c:	5ce6      	ssex	Y
    7a5e:	5ad8 12a6 	mov	0x12a6 <_clock_error_SClockLowCal>, Y

00007a62 <.LM4>:
    clock_error_SClockHighCal = EE_GET(SCLOCK32HIGHCAL);
    7a62:	62e4      	lod	AL, AH
    7a64:	5ce2      	ssex	A
    7a66:	52d8 12a8 	mov	0x12a8 <_clock_error_SClockHighCal>, A

00007a6a <.LM5>:
    clock_error_OClockCal = EE_GET(OCLOCK32CAL);
    7a6a:	62d8 09c6 	lod	AL, 0x9c6 <.LASF1598+0x5>
    7a6e:	5ce2      	ssex	A
    7a70:	52d8 12a4 	mov	0x12a4 <_clock_error_OClockCal>, A

00007a74 <.LM6>:
    #else
    clock_error_SClockLowCal = 0;
    clock_error_SClockHighCal = 0;
    clock_error_OClockCal = 0;
    #endif
}
    7a74:	5401      	ret

00007a76 <_conv_clock_error_speed>:
int16_t conv_clock_error_speed(uint16_t raw_temperature)
{
    int16_t temp;
    int16_t gain;

    temp = (int16_t)raw_temperature - clock_error_OTempCal;
    7a76:	aad8 12a2 	sub	A, 0x12a2 <_clock_error_OTempCal>

00007a7a <.LM9>:

    if (temp > 0)
    7a7a:	ac00      	cmp	A, #0
    7a7c:	1b0f      	jsle	0x7a9c <.L3>

00007a7e <.LM10>:
    {
        gain = clock_error_SClockLowCal;
    7a7e:	7ed8 12a6 	lod	X, 0x12a6 <_clock_error_SClockLowCal>

00007a82 <.L4>:
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI32_I16byI16(int16_t multiplicand, int16_t multiplier)
{
    int32_t result;

    __asm__ __volatile__ (
    7a82:	4833      	muls	YA, A, X

00007a84 <.LBE6>:
    else
    {
        gain = clock_error_SClockHighCal;
    }

    return clock_error_OClockCal + (int16_t)(mulI32_I16byI16(temp, gain) / 64);
    7a84:	4cb2 0000 	cmp	YA, #0
    7a88:	0000 
    7a8a:	1e84      	jsge	0x7a94 <.L5>
    7a8c:	4cc0      	mov	D, YA
    7a8e:	4c0a 003f 	addu	D, #63
    7a92:	4c80      	mov	YA, D

00007a94 <.L5>:
    7a94:	48b5      	asr	YA, #6
    7a96:	a2d8 12a4 	add	A, 0x12a4 <_clock_error_OClockCal>

00007a9a <.LM13>:
}
    7a9a:	5401      	ret

00007a9c <.L3>:
    {
        gain = clock_error_SClockLowCal;
    }
    else
    {
        gain = clock_error_SClockHighCal;
    7a9c:	7ed8 12a8 	lod	X, 0x12a8 <_clock_error_SClockHighCal>

00007aa0 <.LVL5>:
    7aa0:	07f0      	jmp	0x7a82 <.L4>

00007aa2 <_conv_clock_error_correct_period>:
    return clock_error_OClockCal + (int16_t)(mulI32_I16byI16(temp, gain) / 64);
}

uint16_t conv_clock_error_correct_period(uint16_t period, int16_t clock_error)
{
    int16_t temp = 2048 + clock_error;
    7aa2:	7e03      	lod	X, [S-4]
    7aa4:	22da 0800 	add	X, #2048

00007aa8 <.LBB8>:
 */
MATHLIB_INLINE_STATIC __inline__ uint32_t mulU32_U16byU16(uint16_t multiplicand, uint16_t multiplier)
{
    uint32_t result;

    __asm__ __volatile__ (
    7aa8:	4823      	mulu	YA, A, X

00007aaa <.LBE8>:
    return (uint16_t)(mulU32_U16byU16(period, (uint16_t)temp) / 2048u);
    7aaa:	48aa      	lsr	YA, #11

00007aac <.LM19>:
}
    7aac:	5401      	ret

00007aae <_conv_high_voltage_init>:
calib_data_t calib_hvi;

void conv_high_voltage_init(void)
{
#if defined(EE_O_HVI_GET)
    calib_hvi.simple.offset = EE_GET(O_HVI);
    7aae:	72d8 09d4 	lod	A, 0x9d4 <.LLST8+0x2>
    7ab2:	62e4      	lod	AL, AH
    7ab4:	5ce2      	ssex	A
    7ab6:	52d8 12aa 	mov	0x12aa <_calib_hvi>, A
    7aba:	72d8 09d8 	lod	A, 0x9d8 <.LLST8+0x6>
    7abe:	d400      	and	AH, #0

00007ac0 <.LM3>:
    calib_hvi.simple.gain = EE_GET(GAIN_HVI);
    7ac0:	52d8 12ac 	mov	0x12ac <.LASF2140+0x1>, A

00007ac4 <.LM4>:
    calib_hvi.gain_low_t = EE_GET(GAINLO_VSMF);
    7ac4:	7ad8 09e2 	lod	Y, 0x9e2 <.Ldebug_abbrev0+0x2>
    7ac8:	46d8 12ae 	mov	0x12ae <.LASF2140+0x3>, YL

00007acc <.LM5>:
    calib_hvi.gain_high_t = EE_GET(GAINHI_VSMF);
    7acc:	0ea7      	lod	C, ML.7
    7ace:	4ed8 af12 	mov	0x12af <.LASF2140+0x4>, YH

00007ad2 <.LM6>:
    calib_hvi.simple.gain = EE_GET(VS_GAIN);
    calib_hvi.gain_low_t = 0;
    calib_hvi.gain_high_t = 0;
#endif

    if (calib_hvi.simple.gain == 0u)
    7ad2:	ac00      	cmp	A, #0
    7ad4:	1d04      	jne	0x7ade <.L1>

00007ad6 <.LM7>:
    {
        /* gain 0 is not allowed, use the default value */
        calib_hvi.simple.gain = 164u;               /* 2.5V * 21 * 100 * HVI_GAIN_DIV / 1023 */
    7ad6:	72da 00a4 	lod	A, #164
    7ada:	52d8 12ac 	mov	0x12ac <.LASF2140+0x1>, A

00007ade <.L1>:
    }
}
    7ade:	5401      	ret

00007ae0 <_conv_high_voltage>:
 * @return  updated measurement.
 */
STATIC INLINE int16_t apply_offset_gain(uint16_t u16ADC_Value, simple_calib_data_t * cal_data, uint8_t divider)
{
    int16_t measurement = (int16_t)u16ADC_Value;
    measurement -= cal_data->offset;
    7ae0:	aad8 12aa 	sub	A, 0x12aa <_calib_hvi>

00007ae4 <.LBB24>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byU8(int16_t multiplicand, uint8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    7ae4:	7ed8 12ac 	lod	X, 0x12ac <.LASF2140+0x1>
    7ae8:	36da 00ff 	and	X, #255

00007aec <.LM12>:

    __asm__ __volatile__ (
    7aec:	4833      	muls	YA, A, X

00007aee <.LBE24>:
    measurement = (int16_t)(mulI24_I16byU8(measurement, cal_data->gain) / divider);
    7aee:	4cb2 0000 	cmp	YA, #0
    7af2:	0000 
    7af4:	1e84      	jsge	0x7afe <.L4>
    7af6:	4cc0      	mov	D, YA
    7af8:	4c0a 001f 	addu	D, #31
    7afc:	4c80      	mov	YA, D

00007afe <.L4>:
    7afe:	48b4      	asr	YA, #5

00007b00 <.LBE22>:

int16_t conv_high_voltage(uint16_t u16ADC_Value)
{
    /* cHVI = (mHVI - O_HVI_EE) * Gain_HVI_EE / 2^5 */
    return apply_offset_gain(u16ADC_Value, &calib_hvi.simple, HVI_GAIN_DIV);
}
    7b00:	5401      	ret

00007b02 <_conv_high_voltage_with_tcorrection>:

int16_t conv_high_voltage_with_tcorrection(uint16_t u16ADC_Value, uint16_t u16ADC_Temp)
{
    7b02:	5805      	inc	S, #6

00007b04 <.LCFI0>:
     * }else{
     *     tempGain = ((GainHi_VSMF_EE / 2^11) * mTempDiff)/2^7;
     * }
     * cHVIcorr = cHVI * (1 + tempGain)
     */
    return apply_temp_gain(conv_high_voltage(u16ADC_Value), u16ADC_Temp, &calib_hvi);
    7b04:	17ed      	call	0x7ae0 <_conv_high_voltage>

00007b06 <.LVL5>:
    7b06:	5205      	mov	[S-6], A

00007b08 <.LBB26>:
 * @return  updated measurement.
 */
STATIC INLINE int16_t apply_temp_gain(uint16_t u16ADC_Value, uint16_t u16ADC_Temp, calib_data_t * cal_data)
{
    int16_t gain;
    int16_t temp_diff = (int16_t)(u16ADC_Temp - EE_GET(OTEMPCAL));
    7b08:	7e09      	lod	X, [S-10]
    7b0a:	2ad8 09b4 	sub	X, 0x9b4 <.LASF1021>

00007b0e <.LM18>:

    if (temp_diff > 0)
    7b0e:	2c00      	cmp	X, #0
    7b10:	1b1b      	jsle	0x7b48 <.L6>

00007b12 <.LBB28>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byI8(int16_t multiplicand, int8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    7b12:	66d8 12ae 	lod	YL, 0x12ae <.LASF2140+0x3>

00007b16 <.L12>:
    7b16:	5ce6      	ssex	Y

00007b18 <.LM20>:

    __asm__ __volatile__ (
    7b18:	72ee      	lod	A, X

00007b1a <.LVL10>:
    7b1a:	4811      	muls	D, A, Y
    7b1c:	5880      	mov	[S-4], D

00007b1e <.LBE30>:
    {
        gain = (int16_t)(mulI24_I16byI8(temp_diff, cal_data->gain_low_t) / 128);
    }
    else
    {
        gain = (int16_t)(mulI24_I16byI8(temp_diff, cal_data->gain_high_t) / 128);
    7b1e:	4caa 0000 	cmpu	D, #0
    7b22:	1e83      	jsge	0x7b2a <.L9>

00007b24 <.LVL11>:
    7b24:	4c0a 007f 	addu	D, #127
    7b28:	5880      	mov	[S-4], D

00007b2a <.L9>:
    7b2a:	58e0      	mov	YA, [S-4]

00007b2c <.LVL12>:
    7b2c:	48b6      	asr	YA, #7

00007b2e <.LBB33>:
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI32_I16byI16(int16_t multiplicand, int16_t multiplier)
{
    int32_t result;

    __asm__ __volatile__ (
    7b2e:	7e05      	lod	X, [S-6]

00007b30 <.LVL14>:
    7b30:	4833      	muls	YA, A, X

00007b32 <.LBE33>:
    }

    return (u16ADC_Value + (mulI32_I16byI16(gain, u16ADC_Value) / 2048));
    7b32:	4cb2 0000 	cmp	YA, #0
    7b36:	0000 
    7b38:	1e84      	jsge	0x7b42 <.L10>
    7b3a:	4cc0      	mov	D, YA
    7b3c:	4c0a 07ff 	addu	D, #2047
    7b40:	4c80      	mov	YA, D

00007b42 <.L10>:
    7b42:	48ba      	asr	YA, #11
    7b44:	a205      	add	A, [S-6]

00007b46 <.LBE26>:
}
    7b46:	5407      	ret	#8

00007b48 <.L6>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byI8(int16_t multiplicand, int8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    7b48:	66d8 12af 	lod	YL, 0x12af <.LASF2140+0x4>
    7b4c:	07e4      	jmp	0x7b16 <.L12>

00007b4e <_conv_low_voltage_init>:
calib_data_t calib_lvi;

void conv_low_voltage_init(void)
{
#if defined(EE_O_LVI_GET)
    calib_lvi.simple.offset = EE_GET(O_LVI);
    7b4e:	72d8 09d6 	lod	A, 0x9d6 <.LLST8+0x4>
    7b52:	7ee2      	lod	X, A
    7b54:	54e4      	mov	Cx, #4
    7b56:	44fe      	asr	X, #2
    7b58:	1ffe      	djnz	Cx, 0x7b56 <.LASF1130+0x3>
    7b5a:	5ed8 12b0 	mov	0x12b0 <_calib_lvi>, X
    7b5e:	d400      	and	AH, #0

00007b60 <.LM3>:
    calib_lvi.simple.gain = EE_GET(GAIN_LVI);
    7b60:	52d8 12b2 	mov	0x12b2 <_calib_lvi+0x2>, A

00007b64 <.LM4>:
    calib_lvi.gain_low_t = EE_GET(GAINLO_LVI);
    7b64:	7ad8 09da 	lod	Y, 0x9da <.LLST8+0x8>
    7b68:	46d8 12b4 	mov	0x12b4 <_calib_lvi+0x4>, YL

00007b6c <.LM5>:
    calib_lvi.gain_high_t = EE_GET(GAINHI_LVI);
    7b6c:	0ea7      	lod	C, ML.7
    7b6e:	4ed8 b512 	mov	0x12b5 <_calib_lvi+0x5>, YH

00007b72 <.LM6>:
    calib_lvi.simple.gain = 213u;                   /* 2.5V * 1.36 * 1000 * LVI_GAIN_DIV / 1023 */
    calib_lvi.gain_low_t = 0;
    calib_lvi.gain_high_t = 0;
#endif

    if (calib_lvi.simple.gain == 0u)
    7b72:	ac00      	cmp	A, #0
    7b74:	1d04      	jne	0x7b7e <.L1>

00007b76 <.LM7>:
    {
        /* gain 0 is not allowed, use the default value */
        calib_lvi.simple.gain = 213u;               /* 2.5V * 1.36 * 1000 * LVI_GAIN_DIV / 1023 */
    7b76:	72da 00d5 	lod	A, #213
    7b7a:	52d8 12b2 	mov	0x12b2 <_calib_lvi+0x2>, A

00007b7e <.L1>:
    }
}
    7b7e:	5401      	ret

00007b80 <_conv_motor_voltage_init>:
calib_data_t calib_vsm;
/** VSM filtered calibration data */
calib_data_t calib_vsmf;

void conv_motor_voltage_init(void)
{
    7b80:	5805      	inc	S, #6

00007b82 <.LCFI0>:
#if defined(EE_O_HVI_GET)
    calib_vsm.simple.offset = EE_GET(O_HVI);
    7b82:	72d8 09d4 	lod	A, 0x9d4 <.LLST8+0x2>
    7b86:	7ae2      	lod	Y, A
    7b88:	66ec      	lod	YL, YH
    7b8a:	5ce6      	ssex	Y
    7b8c:	5a03      	mov	[S-4], Y
    7b8e:	5ad8 12bc 	mov	0x12bc <_calib_vsm>, Y
    7b92:	d400      	and	AH, #0

00007b94 <.LM3>:
    calib_vsm.simple.gain = EE_GET(GAIN_VSMF);
    7b94:	52d8 12be 	mov	0x12be <_calib_vsm+0x2>, A

00007b98 <.LM4>:
    calib_vsm.gain_low_t = EE_GET(GAINLO_VSMF);
    7b98:	66d8 09e2 	lod	YL, 0x9e2 <.Ldebug_abbrev0+0x2>
    7b9c:	5ce6      	ssex	Y
    7b9e:	5a05      	mov	[S-6], Y
    7ba0:	46d8 12c0 	mov	0x12c0 <_calib_vsm+0x4>, YL

00007ba4 <.LM5>:
    calib_vsm.gain_high_t = EE_GET(GAINHI_VSMF);
    7ba4:	7ad8 09e2 	lod	Y, 0x9e2 <.Ldebug_abbrev0+0x2>
    7ba8:	66ec      	lod	YL, YH
    7baa:	5ce6      	ssex	Y
    7bac:	5a01      	mov	[S-2], Y
    7bae:	46d8 12c1 	mov	0x12c1 <_calib_vsm+0x5>, YL

00007bb2 <.LM6>:
    calib_vsm.simple.gain = EE_GET(VSM_GAIN);
    calib_vsm.gain_low_t = 0;
    calib_vsm.gain_high_t = 0;
#endif

    if (calib_vsm.simple.gain == 0u)
    7bb2:	ac00      	cmp	A, #0
    7bb4:	1d04      	jne	0x7bbe <.L2>

00007bb6 <.LM7>:
    {
        /* gain 0 is not allowed, use the default value */
        calib_vsm.simple.gain = 164u;               /* 2.5V * 21 * 100 * HVI_GAIN_DIV / 1023 */
    7bb6:	7eda 00a4 	lod	X, #164
    7bba:	5ed8 12be 	mov	0x12be <_calib_vsm+0x2>, X

00007bbe <.L2>:
    }

#if defined(EE_O_HVI_GET)
    calib_vsmf.simple.offset = EE_GET(O_HVI) + EE_GET(O_VSMF);
    7bbe:	7ed8 09d8 	lod	X, 0x9d8 <.LLST8+0x6>
    7bc2:	54e4      	mov	Cx, #4
    7bc4:	44fe      	asr	X, #2
    7bc6:	1ffe      	djnz	Cx, 0x7bc4 <.LASF1371+0x3>
    7bc8:	2203      	add	X, [S-4]
    7bca:	5ed8 12b6 	mov	0x12b6 <_calib_vsmf>, X

00007bce <.LM9>:
    calib_vsmf.simple.gain = EE_GET(GAIN_VSMF);
    7bce:	52d8 12b8 	mov	0x12b8 <_calib_vsmf+0x2>, A

00007bd2 <.LM10>:
    calib_vsmf.gain_low_t = EE_GET(GAINLO_VSMF);
    7bd2:	6605      	lod	YL, [S-6]
    7bd4:	46d8 12ba 	mov	0x12ba <_calib_vsmf+0x4>, YL

00007bd8 <.LM11>:
    calib_vsmf.gain_high_t = EE_GET(GAINHI_VSMF);
    7bd8:	6601      	lod	YL, [S-2]
    7bda:	46d8 12bb 	mov	0x12bb <_calib_vsmf+0x5>, YL

00007bde <.LM12>:
    calib_vsmf.simple.gain = EE_GET(VSM_FILT_GAIN);
    calib_vsmf.gain_low_t = 0;
    calib_vsmf.gain_high_t = 0;
#endif

    if (calib_vsmf.simple.gain == 0u)
    7bde:	ac00      	cmp	A, #0
    7be0:	1d04      	jne	0x7bea <.L1>

00007be2 <.LM13>:
    {
        /* gain 0 is not allowed, use the default value */
        calib_vsmf.simple.gain = 164u;              /* 2.5V * 21 * 100 * HVI_GAIN_DIV / 1023 */
    7be2:	72da 00a4 	lod	A, #164
    7be6:	52d8 12b8 	mov	0x12b8 <_calib_vsmf+0x2>, A

00007bea <.L1>:
    }
}
    7bea:	5407      	ret	#8

00007bec <_conv_shunt_current_init>:
calib_data_t calib_current;

void conv_shunt_current_init(void)
{
#if defined(EE_O_CURR_GET)
    calib_current.simple.offset = EE_GET(O_CURR) + 512;
    7bec:	72d8 09dc 	lod	A, 0x9dc <.LLST8+0xa>
    7bf0:	7ee2      	lod	X, A
    7bf2:	54e4      	mov	Cx, #4
    7bf4:	44fe      	asr	X, #2
    7bf6:	1ffe      	djnz	Cx, 0x7bf4 <.LASF1503+0x2>
    7bf8:	22da 0200 	add	X, #512
    7bfc:	5ed8 12c2 	mov	0x12c2 <_calib_current>, X

00007c00 <.LM3>:
    calib_current.simple.gain = EE_GET(GAIN_CURR);
    7c00:	d400      	and	AH, #0
    7c02:	52d8 12c4 	mov	0x12c4 <.LASF1434>, A

00007c06 <.LM4>:
    calib_current.gain_low_t = EE_GET(GAINLO_CURR);
    7c06:	72d8 09e0 	lod	A, 0x9e0 <.Ldebug_abbrev0>
    7c0a:	42d8 12c6 	mov	0x12c6 <.LASF1434+0x2>, AL

00007c0e <.LM5>:
    calib_current.gain_high_t = EE_GET(GAINHI_CURR);
    7c0e:	0ea7      	lod	C, ML.7
    7c10:	4ad8 c712 	mov	0x12c7 <.LASF1434+0x3>, AH

00007c14 <.LM6>:
    calib_current.simple.offset = EE_GET(CURR_OFFS) + 512;
    calib_current.simple.gain = EE_GET(CURR_GAIN);
    calib_current.gain_low_t = 0;
    calib_current.gain_high_t = 0;
#endif
}
    7c14:	5401      	ret

00007c16 <_conv_shunt_current>:
 * @return  updated measurement.
 */
STATIC INLINE int16_t apply_offset_gain(uint16_t u16ADC_Value, simple_calib_data_t * cal_data, uint8_t divider)
{
    int16_t measurement = (int16_t)u16ADC_Value;
    measurement -= cal_data->offset;
    7c16:	aad8 12c2 	sub	A, 0x12c2 <_calib_current>

00007c1a <.LBB16>:
 *  @ingroup     math_multiplication_group
 */
MATHLIB_INLINE_STATIC __inline__ int32_t mulI24_I16byU8(int16_t multiplicand, uint8_t multiplier)
{
    int32_t result;
    int16_t b_16 = (int16_t) multiplier; /* cast to Word */
    7c1a:	7ed8 12c4 	lod	X, 0x12c4 <.LASF1434>
    7c1e:	36da 00ff 	and	X, #255

00007c22 <.LM10>:

    __asm__ __volatile__ (
    7c22:	4833      	muls	YA, A, X

00007c24 <.LBE16>:
    measurement = (int16_t)(mulI24_I16byU8(measurement, cal_data->gain) / divider);
    7c24:	4cb2 0000 	cmp	YA, #0
    7c28:	0000 
    7c2a:	1e84      	jsge	0x7c34 <.L4>
    7c2c:	4cc0      	mov	D, YA
    7c2e:	4c0a 001f 	addu	D, #31
    7c32:	4c80      	mov	YA, D

00007c34 <.L4>:
    7c34:	48b4      	asr	YA, #5

00007c36 <.LBE14>:
{
    /* MLX81330: cCur = (mCur - (O_Curr_EE + 512)) * Gain_Curr_EE / 2^6
     * MLX81332: cCur = (mCur - (O_Curr_EE + 512)) * Gain_Curr_EE / 2^5
     */
    return apply_offset_gain(u16ADC_Value, &calib_current.simple, CURR_GAIN_DIV);
}
    7c36:	5401      	ret

00007c38 <_Mot_dirChange_check>:
int16_t SensorGetDelta(void)
{
	return sensor.delta;
}
static uint16_t Mot_dirChange_check(void)
{
    7c38:	72d8 12ee 	lod	A, 0x12ee <.LLST8+0xb>

00007c3c <.LM2>:
	uint16_t flag=0;
#if C_MOT_POLE_POLAR==0
	if (motor.direction==C_DIR_CW)
#else
	if (motor.direction==C_DIR_CCW)
    7c3c:	7ed8 12e0 	lod	X, 0x12e0 <_motor+0xc>
    7c40:	2c02      	cmp	X, #2
    7c42:	1d03      	jne	0x7c4a <.L2>

00007c44 <.LBB4>:
#endif		
	{
		if (motor.pos.Delta < 0) flag=1;
    7c44:	4442      	rl	A
    7c46:	b401      	and	A, #1
    7c48:	5401      	ret

00007c4a <.L2>:
    7c4a:	ac00      	cmp	A, #0
    7c4c:	5cb2      	ssg	A

00007c4e <.LBE4>:
		if (motor.pos.Delta > 0) flag=1;

	}
	return (flag);

}
    7c4e:	5401      	ret

00007c50 <_MotRequestHardStop>:
    int16_t lastDeg;		
} sensor;	

void MotRequestHardStop(void)
{
	motor.requestStop = 1;
    7c50:	7001      	lod	A, #1
    7c52:	52d8 12dc 	mov	0x12dc <_motor+0x8>, A

00007c56 <.LM7>:
}
    7c56:	5401      	ret

00007c58 <_MotClearHardStop>:
void MotClearHardStop(void)
{
	motor.requestStop = 0;
    7c58:	7000      	lod	A, #0
    7c5a:	52d8 12dc 	mov	0x12dc <_motor+0x8>, A

00007c5e <.LM10>:
}
    7c5e:	5401      	ret

00007c60 <_MotSetTargetPosition>:
	if (targetPos > (360 * C_GMR_ANGLE_SCALE_FACTOR))
	{
		targetPos -= (360 * C_GMR_ANGLE_SCALE_FACTOR);
	}
#endif	
	motor.pos.target = targetPos;
    7c60:	52d8 12ea 	mov	0x12ea <.LLST8+0x7>, A

00007c64 <.LM13>:
	if (motor.pos.target >= motor.pos.current)
    7c64:	7ed8 12e8 	lod	X, 0x12e8 <.LLST8+0x5>
    7c68:	2ee2      	cmp	X, A
    7c6a:	1f0f      	jsg	0x7c8a <.L7>

00007c6c <.LM14>:
	{
		diff=motor.pos.target-motor.pos.current;
    7c6c:	7ae2      	lod	Y, A
    7c6e:	eaee      	sub	Y, X
    7c70:	7ee6      	lod	X, Y

00007c72 <.L8>:
	}
	else 
	{
		diff=motor.pos.current-motor.pos.target;
	}
	if ((motor.pos.target != motor.pos.lastTarget) || (diff > (int16_t)C_MOT_ON_HYSTERISYS))
    7c72:	7ad8 12ec 	lod	Y, 0x12ec <.LLST8+0x9>
    7c76:	eee2      	cmp	Y, A
    7c78:	1d02      	jne	0x7c7e <.L9>

00007c7a <.LM16>:
    7c7a:	2c0a      	cmp	X, #10
    7c7c:	1b05      	jsle	0x7c88 <.L6>

00007c7e <.L9>:
	{
		motor.pos.newTarget=1;
    7c7e:	6401      	lod	YL, #1
    7c80:	46d8 12f0 	mov	0x12f0 <.LASF1850>, YL

00007c84 <.LM18>:
		motor.pos.lastTarget = motor.pos.target;
    7c84:	52d8 12ec 	mov	0x12ec <.LLST8+0x9>, A

00007c88 <.L6>:
	}
}
    7c88:	5401      	ret

00007c8a <.L7>:
	{
		diff=motor.pos.target-motor.pos.current;
	}
	else 
	{
		diff=motor.pos.current-motor.pos.target;
    7c8a:	2ae2      	sub	X, A

00007c8c <.LVL5>:
    7c8c:	07f2      	jmp	0x7c72 <.L8>

00007c8e <_MotGetCurrentPosition>:
}
int16_t MotGetCurrentPosition(void)
{
	return motor.pos.current;

}
    7c8e:	72d8 12e8 	lod	A, 0x12e8 <.LLST8+0x5>
    7c92:	5401      	ret

00007c94 <_MotClearStallFlag>:
}
/*
type 0 : all clear
*/
void MotClearStallFlag(uint16_t type)
{
    7c94:	7ae2      	lod	Y, A

00007c96 <.LM40>:
	if (type==0)
    7c96:	1d03      	jne	0x7c9e <.L18>

00007c98 <.LM41>:
	{
		motor.stall.flag=0;
    7c98:	42d8 130a 	mov	0x130a <.LASF1535+0x4>, AL
    7c9c:	5401      	ret

00007c9e <.L18>:
    7c9e:	62d8 130a 	lod	AL, 0x130a <.LASF1535+0x4>

00007ca2 <.LM42>:
	}
	else if (type==1)
    7ca2:	ec01      	cmp	Y, #1
    7ca4:	1d04      	jne	0x7cae <.L20>

00007ca6 <.LM43>:
	{
		motor.stall.flag &= (~STALL_MASK_TEMPORARY);
    7ca6:	94fe      	and	AL, #-2

00007ca8 <.L21>:
	}
	else
	{
		motor.stall.flag &= (~STALL_MASK_PERMENT);	
    7ca8:	42d8 130a 	mov	0x130a <.LASF1535+0x4>, AL

00007cac <.LM45>:
	}
}
    7cac:	5401      	ret

00007cae <.L20>:
	{
		motor.stall.flag &= (~STALL_MASK_TEMPORARY);
	}
	else
	{
		motor.stall.flag &= (~STALL_MASK_PERMENT);	
    7cae:	94fd      	and	AL, #-3
    7cb0:	07fb      	jmp	0x7ca8 <.L21>

00007cb2 <_MotClearFaultFlag>:
/*
type 0 : all clear
*/
void MotClearFaultFlag(uint16_t type)
{
	if (type==0)
    7cb2:	ac00      	cmp	A, #0
    7cb4:	1d07      	jne	0x7cc4 <.L23>

00007cb6 <.LM49>:
	{
		motor.fault.flag=0;
    7cb6:	42d8 1316 	mov	0x1316 <.LLST9+0x9>, AL

00007cba <.LM50>:
		g_e8OverCurrent=0;
    7cba:	42d8 11af 	mov	0x11af <_g_e8OverCurrent>, AL

00007cbe <.LM51>:
		g_e8ShortOcc=0;	
    7cbe:	52d8 11b0 	mov	0x11b0 <_g_e8ShortOcc>, A
    7cc2:	5401      	ret

00007cc4 <.L23>:
	}
	else if (type==1)
    7cc4:	ac01      	cmp	A, #1
    7cc6:	1d06      	jne	0x7cd4 <.L25>

00007cc8 <.LM53>:
	{
		motor.fault.flag &= (~FAULT_MASK_PHASE_A_OPEN);
    7cc8:	62d8 1316 	lod	AL, 0x1316 <.LLST9+0x9>

00007ccc <.LVL14>:
    7ccc:	94fe      	and	AL, #-2

00007cce <.L27>:
		motor.fault.flag &= (~FAULT_MASK_PHASE_A_SHORT);
	}	
	else if (type==3)
	{
		g_e8OverCurrent=0;		
		motor.fault.flag &= (~FAULT_MASK_OVER_CURRENT);
    7cce:	42d8 1316 	mov	0x1316 <.LLST9+0x9>, AL

00007cd2 <.L22>:
	}		
	else
	{

	}		
}
    7cd2:	5401      	ret

00007cd4 <.L25>:
	}
	else if (type==1)
	{
		motor.fault.flag &= (~FAULT_MASK_PHASE_A_OPEN);
	}
	else if (type==2)
    7cd4:	ac02      	cmp	A, #2
    7cd6:	1d07      	jne	0x7ce6 <.L26>

00007cd8 <.LM57>:
	{
		g_e8ShortOcc=0;		
    7cd8:	7000      	lod	A, #0

00007cda <.LVL16>:
    7cda:	52d8 11b0 	mov	0x11b0 <_g_e8ShortOcc>, A

00007cde <.LM58>:
		motor.fault.flag &= (~FAULT_MASK_PHASE_A_SHORT);
    7cde:	62d8 1316 	lod	AL, 0x1316 <.LLST9+0x9>
    7ce2:	94ef      	and	AL, #-17
    7ce4:	07f4      	jmp	0x7cce <.L27>

00007ce6 <.L26>:
	}	
	else if (type==3)
    7ce6:	ac03      	cmp	A, #3
    7ce8:	1d74      	jne	0x7cd2 <.L22>

00007cea <.LM60>:
	{
		g_e8OverCurrent=0;		
    7cea:	6000      	lod	AL, #0

00007cec <.LVL18>:
    7cec:	42d8 11af 	mov	0x11af <_g_e8OverCurrent>, AL

00007cf0 <.LM61>:
		motor.fault.flag &= (~FAULT_MASK_OVER_CURRENT);
    7cf0:	62d8 1316 	lod	AL, 0x1316 <.LLST9+0x9>
    7cf4:	94bf      	and	AL, #-65
    7cf6:	07eb      	jmp	0x7cce <.L27>

00007cf8 <_MotGetState>:
	}		
}
tMotState MotGetState(void)
{
	return motor.state;
}
    7cf8:	72d8 12d4 	lod	A, 0x12d4 <_motor>
    7cfc:	5401      	ret

00007cfe <_MotGetStallState>:
uint8_t MotGetStallState(void)
{
	return motor.stall.flag;
    7cfe:	62d8 130a 	lod	AL, 0x130a <.LASF1535+0x4>
    7d02:	5cf2      	usex	A

00007d04 <.LM66>:
}
    7d04:	5401      	ret

00007d06 <_MotGetFaultState>:

uint8_t MotGetFaultState(void)
{
	return motor.fault.flag;
    7d06:	62d8 1316 	lod	AL, 0x1316 <.LLST9+0x9>
    7d0a:	5cf2      	usex	A

00007d0c <.LM69>:
}
    7d0c:	5401      	ret

00007d0e <_SensorGetState>:
uint8_t SensorGetState(void)
{
	return sensor.moving;
    7d0e:	72d8 12c8 	lod	A, 0x12c8 <_sensor>
    7d12:	5cf2      	usex	A

00007d14 <.LM72>:
}
    7d14:	5401      	ret

00007d16 <_app_mot_init>:
}

void app_mot_init(void)
{

	motor.state=MOTION_STOPPED;
    7d16:	7801      	lod	Y, #1
    7d18:	5ad8 12d4 	mov	0x12d4 <_motor>, Y

00007d1c <.LM77>:
	motor.lastState=MOTION_STOPPED;
    7d1c:	5ad8 12d6 	mov	0x12d6 <_motor+0x2>, Y

00007d20 <.LM78>:
	motor.initStatus=1;
    7d20:	0ea7      	lod	C, ML.7
    7d22:	5ad8 12d8 	mov	0x12d8 <_motor+0x4>, Y

00007d26 <.LM79>:
	motor.elapsedTime=0;
    7d26:	7000      	lod	A, #0
    7d28:	52d8 12da 	mov	0x12da <_motor+0x6>, A

00007d2c <.LM80>:
	motor.direction=C_DIR_NONE;
    7d2c:	0ea7      	lod	C, ML.7
    7d2e:	52d8 12e0 	mov	0x12e0 <_motor+0xc>, A

00007d32 <.LM81>:
	motor.lastDirection=C_DIR_NONE;	
    7d32:	52d8 12e2 	mov	0x12e2 <_motor+0xe>, A

00007d36 <.LM82>:
	motor.runTimeOut=(5*1000);	
    7d36:	7eda 1388 	lod	X, #5000
    7d3a:	0ea7      	lod	C, ML.7
    7d3c:	5ed8 12e4 	mov	0x12e4 <.LLST8+0x1>, X

00007d40 <.LM83>:
	motor.pos.target=0;
    7d40:	52d8 12ea 	mov	0x12ea <.LLST8+0x7>, A

00007d44 <.LM84>:
	motor.pos.lastTarget=0;
    7d44:	52d8 12ec 	mov	0x12ec <.LLST8+0x9>, A

00007d48 <.LM85>:
	motor.pos.current=0;
    7d48:	0ea7      	lod	C, ML.7
    7d4a:	52d8 12e8 	mov	0x12e8 <.LLST8+0x5>, A

00007d4e <.LM86>:
	motor.pos.newTarget=0;
    7d4e:	52d8 12f0 	mov	0x12f0 <.LASF1850>, A

00007d52 <.LM87>:
	motor.pos.posReached=0;
    7d52:	5ad8 12f2 	mov	0x12f2 <.LASF1850+0x2>, Y

00007d56 <.LM88>:
	motor.out.enable=0;
	motor.out.duty=0;
	motor.out.maxDuty=C_MOT_MAXDUTY_SET;
	motor.out.minDuty=C_MOT_MINDUTY_SET;
	motor.softStart.enable=1u;
    7d56:	0ea7      	lod	C, ML.7
    7d58:	7eda 0733 	lod	X, #1843
    7d5c:	5ed8 12f4 	mov	0x12f4 <.LASF1850+0x4>, X

00007d60 <.LM89>:
	motor.softStart.outThreshold=(C_MOT_MAXDUTY_SET * 0.9f);	
    7d60:	7c66      	lod	X, #102
    7d62:	0ea7      	lod	C, ML.7
    7d64:	5ed8 12f6 	mov	0x12f6 <.LASF1850+0x6>, X

00007d68 <.LM90>:
//	motor.softStart.accDuty=(C_MOT_MAXDUTY_SET * 0.0027f);/*300ms=6*/
//	motor.softStart.accDuty=(C_MOT_MAXDUTY_SET * 0.002f);/*400ms=4*/
//	motor.softStart.accDuty=(C_MOT_MAXDUTY_SET * 0.0016f);/*500ms=3*/
//	motor.softStart.accDuty=(C_MOT_MAXDUTY_SET * 0.0015f);/*533ms*/
#else
	motor.softStart.accDuty=(C_MOT_MAXDUTY_SET * 0.05f);
    7d68:	5ad8 12f8 	mov	0x12f8 <.LASF1850+0x8>, Y

00007d6c <.LM91>:
#endif	
	motor.softStop.enable=1u;
	motor.softStop.completed=0;
    7d6c:	7c28      	lod	X, #40
    7d6e:	0ea7      	lod	C, ML.7
    7d70:	5ed8 12fa 	mov	0x12fa <.LASF1850+0xa>, X

00007d74 <.LM92>:
	motor.softStop.inThreshold=(4*C_GMR_ANGLE_SCALE_FACTOR);
    7d74:	7c14      	lod	X, #20
    7d76:	5ed8 12fc 	mov	0x12fc <.LASF1850+0xc>, X

00007d7a <.LM93>:
	motor.softStop.dccDuty=(C_MOT_MAXDUTY_SET * 0.01f);
    7d7a:	0ea7      	lod	C, ML.7
    7d7c:	52d8 12fe 	mov	0x12fe <.LASF1850+0xe>, A

00007d80 <.LM94>:
	motor.pos.target=0;
	motor.pos.lastTarget=0;
	motor.pos.current=0;
	motor.pos.newTarget=0;
	motor.pos.posReached=0;
	motor.out.enable=0;
    7d80:	52d8 1300 	mov	0x1300 <.LASF1888>, A

00007d84 <.LM95>:
	motor.out.duty=0;
    7d84:	7eda 0800 	lod	X, #2048
    7d88:	0ea7      	lod	C, ML.7
    7d8a:	5ed8 1302 	mov	0x1302 <.LASF1888+0x2>, X

00007d8e <.LM96>:
	motor.out.maxDuty=C_MOT_MAXDUTY_SET;
    7d8e:	7eda 0200 	lod	X, #512
    7d92:	5ed8 1304 	mov	0x1304 <.LASF1888+0x4>, X

00007d96 <.LM97>:
	motor.softStop.enable=1u;
	motor.softStop.completed=0;
	motor.softStop.inThreshold=(4*C_GMR_ANGLE_SCALE_FACTOR);
	motor.softStop.dccDuty=(C_MOT_MAXDUTY_SET * 0.01f);

	motor.stall.flag=0;
    7d96:	0ea7      	lod	C, ML.7
    7d98:	7eda 0100 	lod	X, #256
    7d9c:	5ed8 130a 	mov	0x130a <.LASF1535+0x4>, X

00007da0 <.LM98>:
	motor.stall.enable=1;	
    7da0:	52d8 130c 	mov	0x130c <.LASF1535+0x6>, A

00007da4 <.LM99>:
	motor.stall.maskTimer=0;	
	motor.stall.threshold=800;	/* 1000mA -> 800mA */
    7da4:	0ea7      	lod	C, ML.7
    7da6:	7eda 0320 	lod	X, #800
    7daa:	5ed8 1312 	mov	0x1312 <.LLST9+0x5>, X

00007dae <.LM100>:

	motor.fault.flag=0;
    7dae:	7eda 0100 	lod	X, #256
    7db2:	0ea7      	lod	C, ML.7
    7db4:	5ed8 1316 	mov	0x1316 <.LLST9+0x9>, X

00007db8 <.LM101>:
	motor.fault.openEnable=1;
	motor.fault.ocEnable=1;
    7db8:	46d8 1318 	mov	0x1318 <.LLST9+0xb>, YL

00007dbc <.LM102>:
	motor.fault.ocDetectCnt=0;		
    7dbc:	52d8 131a 	mov	0x131a <.LLST9+0xd>, A

00007dc0 <.LM103>:
	motor.fault.openDetectCnt=0;
    7dc0:	0ea7      	lod	C, ML.7
    7dc2:	52d8 131c 	mov	0x131c <.LLST9+0xf>, A

00007dc6 <.LM104>:

	sensor.delay=0;
    7dc6:	42d8 12ca 	mov	0x12ca <_sensor+0x2>, AL

00007dca <.LM105>:
	sensor.delta=0;
    7dca:	52d8 12ce 	mov	0x12ce <_sensor+0x6>, A

00007dce <.LM106>:
	sensor.moving=C_STATUS_OFF_;
    7dce:	0ea7      	lod	C, ML.7
    7dd0:	52d8 12c8 	mov	0x12c8 <_sensor>, A

00007dd4 <.LM107>:
	sensor.lastDeg=0;
    7dd4:	52d8 12d2 	mov	0x12d2 <.LLST7+0x2>, A

00007dd8 <.LM108>:
}
    7dd8:	5401      	ret

00007dda <_app_motor_task>:

/* called by every 1ms */
void app_motor_task(void)
{
    7dda:	5803      	inc	S, #4

00007ddc <.LCFI0>:
	tMotState next_state = motor.state;
	uint16_t voltage = get_valve_voltage();
    7ddc:	82db 334f 	callf	0x669e <_get_valve_voltage>

00007de0 <.LVL20>:
    7de0:	5203      	mov	[S-4], A

00007de2 <.LM111>:

/*** state machine control ***/
	switch( motor.state )
    7de2:	7eda 12d4 	lod	X, #4820
    7de6:	72f8      	lod	A, [X]

00007de8 <.LVL22>:
    7de8:	ac07      	cmp	A, #7
    7dea:	1e0d      	jug	0x7e06 <.L88>
    7dec:	4422      	asl	A
    7dee:	7ae2      	lod	Y, A
    7df0:	e2da 5d1c 	add	Y, #23836
    7df4:	7ed8 12d8 	lod	X, 0x12d8 <_motor+0x4>
    7df8:	76f0      	jmp	[Y]

00007dfa <.L36>:
}

static tMotState motor_state_INIT (void)
{
	tMotState next_state = MOTION_INIT;
	if(motor.initStatus)
    7dfa:	2c00      	cmp	X, #0
    7dfc:	1d01      	jne	0x7e00 <.LM113>
    7dfe:	0151      	jmp	0x80a2 <.L45>

00007e00 <.LM113>:
	{
		motor.initStatus=0;
    7e00:	7000      	lod	A, #0
    7e02:	52d8 12d8 	mov	0x12d8 <_motor+0x4>, A

00007e06 <.L88>:
		case MOTION_DEC:	{next_state = motor_state_DCC(); break; }
		case MOTION_PAUSE:	{next_state = motor_state_PAUSE(); break; }
		case MOTION_STALL:	{next_state = motor_state_STALLED(); break; }
		case MOTION_FAULT:	{next_state = motor_state_FAULT(); break; }
		default: 			
			next_state = MOTION_STOPPED; 
    7e06:	7001      	lod	A, #1
    7e08:	0024      	jmp	0x7e52 <.L35>

00007e0a <.L38>:
    7e0a:	7000      	lod	A, #0

00007e0c <.LBB23>:

static tMotState motor_state_STOPPED(void)
{
	tMotState next_state = MOTION_STOPPED;
	uint16_t rState=0;
	if(motor.initStatus)
    7e0c:	2c00      	cmp	X, #0
    7e0e:	1902      	je	0x7e14 <.L46>

00007e10 <.LM116>:
	{
		motor.initStatus=0;
    7e10:	52d8 12d8 	mov	0x12d8 <_motor+0x4>, A

00007e14 <.L46>:

	}

	motor.out.enable=0;
    7e14:	52d8 12fe 	mov	0x12fe <.LASF1850+0xe>, A

00007e18 <.LM118>:
	motor.out.duty=0;
    7e18:	52d8 1300 	mov	0x1300 <.LASF1888>, A

00007e1c <.LM119>:
	motor.pos.posReached = 0;
    7e1c:	42d8 12f1 	mov	0x12f1 <.LASF1850+0x1>, AL

00007e20 <.LM120>:
	if (motor.requestStop != 0)
    7e20:	0ea7      	lod	C, ML.7
    7e22:	7ad8 12dc 	lod	Y, 0x12dc <_motor+0x8>
    7e26:	1901      	je	0x7e2a <.LM121>
    7e28:	00e5      	jmp	0x7ff4 <.L47>

00007e2a <.LM121>:
	{

	}
	else if (motor.pos.newTarget)
    7e2a:	62d8 12f0 	lod	AL, 0x12f0 <.LASF1850>
    7e2e:	1d01      	jne	0x7e32 <.LM122>
    7e30:	00e1      	jmp	0x7ff4 <.L47>

00007e32 <.LM122>:
	{
		motor.pos.newTarget=0;
    7e32:	46d8 12f0 	mov	0x12f0 <.LASF1850>, YL

00007e36 <.LM123>:
#if C_MOT_POLE_POLAR==0		
		if (motor.pos.Delta > 0)
#else
		if (motor.pos.Delta < 0)
    7e36:	72d8 12ee 	lod	A, 0x12ee <.LLST8+0xb>
    7e3a:	1981      	jn	0x7e3e <.LM124>
    7e3c:	0072      	jmp	0x7f22 <.L48>

00007e3e <.LM124>:
#endif
		{
			motor.direction=C_DIR_CW;
    7e3e:	7001      	lod	A, #1

00007e40 <.L131>:
		}
		else
		{
			motor.direction=C_DIR_CCW;
    7e40:	52d8 12e0 	mov	0x12e0 <_motor+0xc>, A

00007e44 <.LM126>:

	}

	if (rState != 0)
	{
		pwm_Start(motor.direction,0u);		
    7e44:	5cf2      	usex	A
    7e46:	54ca 0000 	pushw	#0

00007e4a <.LCFI1>:
    7e4a:	82db 4cf3 	callf	0x99e6 <_pwm_Start>
    7e4e:	5c01      	dec	S, #2

00007e50 <.L56>:
motor.softStart.outThreshold = 90%
ACC duration = (90-10)/5/1ms = 16ms
*/
static tMotState motor_state_ACC (void)/*20250714*/
{
	tMotState next_state = MOTION_ACC;
    7e50:	7002      	lod	A, #2

00007e52 <.L35>:
		case MOTION_FAULT:	{next_state = motor_state_FAULT(); break; }
		default: 			
			next_state = MOTION_STOPPED; 
			break; 
	}
	if( next_state != motor.state )
    7e52:	7ed8 12d4 	lod	X, 0x12d4 <_motor>
    7e56:	2ee2      	cmp	X, A
    7e58:	1d01      	jne	0x7e5c <.L87>
    7e5a:	00cc      	jmp	0x7ff4 <.L47>

00007e5c <.L87>:
	{
		motor.lastState = motor.state;
    7e5c:	5ed8 12d6 	mov	0x12d6 <_motor+0x2>, X

00007e60 <.LM130>:
		motor.state = next_state;
    7e60:	52d8 12d4 	mov	0x12d4 <_motor>, A

00007e64 <.LM131>:
		motor.initStatus=1u;
    7e64:	7001      	lod	A, #1

00007e66 <.LVL32>:
    7e66:	0ea7      	lod	C, ML.7
    7e68:	52d8 12d8 	mov	0x12d8 <_motor+0x4>, A

00007e6c <.LM132>:
		motor.elapsedTime = 0;
    7e6c:	7000      	lod	A, #0

00007e6e <.L132>:
	}
	else
	{
		if (motor.elapsedTime < 0xFFFFu) motor.elapsedTime += 1u;
    7e6e:	52d8 12da 	mov	0x12da <_motor+0x6>, A

00007e72 <.L69>:
	}
	if (motor.out.enable != 0)
    7e72:	72d8 12fe 	lod	A, 0x12fe <.LASF1850+0xe>
    7e76:	1d01      	jne	0x7e7a <.LM135>
    7e78:	0199      	jmp	0x81ac <.L70>

00007e7a <.LM135>:
	{
		if (sensor.delay > 0) 
    7e7a:	62d8 12ca 	lod	AL, 0x12ca <_sensor+0x2>
    7e7e:	1903      	je	0x7e86 <.L71>

00007e80 <.LM136>:
		{
			sensor.delay -= 1;
    7e80:	80ff      	add	AL, #-1
    7e82:	42d8 12ca 	mov	0x12ca <_sensor+0x2>, AL

00007e86 <.L71>:
		}
		if (sensor.delay == 0)
    7e86:	62d8 12ca 	lod	AL, 0x12ca <_sensor+0x2>
    7e8a:	1d05      	jne	0x7e96 <.L72>

00007e8c <.LM138>:
		{
			sensor.filterPeriod += 1;
    7e8c:	62d8 12cb 	lod	AL, 0x12cb <_sensor+0x3>
    7e90:	8001      	add	AL, #1
    7e92:	42d8 12cb 	mov	0x12cb <_sensor+0x3>, AL

00007e96 <.L72>:
		}
		
		if (voltage <= 950)
    7e96:	7203      	lod	A, [S-4]
    7e98:	aeda 03b6 	cmp	A, #950
    7e9c:	1a01      	jule	0x7ea0 <.LM140>
    7e9e:	0126      	jmp	0x80ec <.L73>

00007ea0 <.LM140>:
		{
			sensor.thd=10;
    7ea0:	700a      	lod	A, #10
    7ea2:	52d8 12d0 	mov	0x12d0 <.LLST7>, A

00007ea6 <.LM141>:
			motor.stall.halfThd=550;
    7ea6:	72da 0226 	lod	A, #550
    7eaa:	0ea7      	lod	C, ML.7
    7eac:	52d8 1310 	mov	0x1310 <.LLST9+0x3>, A

00007eb0 <.LM142>:
			motor.stall.threshold=650;
    7eb0:	72da 028a 	lod	A, #650
    7eb4:	52d8 1312 	mov	0x1312 <.LLST9+0x5>, A

00007eb8 <.LM143>:
			motor.out.minDuty=(C_MOT_MAXDUTY_SET * 0.35);
    7eb8:	0ea7      	lod	C, ML.7
    7eba:	72da 02cc 	lod	A, #716

00007ebe <.L133>:
		else if (voltage <= 1050)
		{
			sensor.thd=11;
			motor.stall.halfThd=600;
			motor.stall.threshold=700;
			motor.out.minDuty=(C_MOT_MAXDUTY_SET * 0.32);
    7ebe:	52d8 1304 	mov	0x1304 <.LASF1888+0x4>, A

00007ec2 <.L74>:
		sensor.delta=0;
		sensor.moving=C_STATUS_OFF_;
		sensor.lastDeg = motor.pos.current;
	}
	
	if (sensor.filterPeriod >= 20)/*20msec*/
    7ec2:	62d8 12cb 	lod	AL, 0x12cb <_sensor+0x3>
    7ec6:	8c13      	cmp	AL, #19
    7ec8:	1f01      	jsg	0x7ecc <.LM146>
    7eca:	0196      	jmp	0x81f8 <.L34>

00007ecc <.LM146>:
	{

		sensor.filterPeriod= 0;
    7ecc:	6000      	lod	AL, #0
    7ece:	42d8 12cb 	mov	0x12cb <_sensor+0x3>, AL

00007ed2 <.LM147>:
		if (motor.pos.current > sensor.lastDeg)
    7ed2:	7ed8 12e8 	lod	X, 0x12e8 <.LLST8+0x5>
    7ed6:	0ea7      	lod	C, ML.7
    7ed8:	72d8 12d2 	lod	A, 0x12d2 <.LLST7+0x2>
    7edc:	2ee2      	cmp	X, A
    7ede:	1f01      	jsg	0x7ee2 <.LM148>
    7ee0:	0176      	jmp	0x81ce <.L81>

00007ee2 <.LM148>:
		{
			sensor.delta = motor.pos.current-sensor.lastDeg;
    7ee2:	7aee      	lod	Y, X
    7ee4:	eae2      	sub	Y, A
    7ee6:	72e6      	lod	A, Y

00007ee8 <.L134>:
		}
		else
		{
			sensor.delta = sensor.lastDeg-motor.pos.current;
    7ee8:	52d8 12ce 	mov	0x12ce <_sensor+0x6>, A

00007eec <.LM150>:
		}
		
		sensor.lastDeg = motor.pos.current;
    7eec:	5ed8 12d2 	mov	0x12d2 <.LLST7+0x2>, X
    7ef0:	62d8 12cc 	lod	AL, 0x12cc <_sensor+0x4>
    7ef4:	5ce2      	ssex	A

00007ef6 <.LM151>:

		if (sensor.delta >= sensor.thd) 
    7ef6:	7ed8 12ce 	lod	X, 0x12ce <_sensor+0x6>
    7efa:	2ed8 12d0 	cmp	X, 0x12d0 <.LLST7>
    7efe:	1e81      	jsge	0x7f02 <.LM152>
    7f00:	0168      	jmp	0x81d2 <.L83>

00007f02 <.LM152>:
		{
			if (sensor.filterCnt < 3) sensor.filterCnt++;
    7f02:	ac02      	cmp	A, #2
    7f04:	1f03      	jsg	0x7f0c <.L84>

00007f06 <.LM153>:
    7f06:	8001      	add	AL, #1

00007f08 <.L135>:
		}
		else
		{
			if (sensor.filterCnt > -3) sensor.filterCnt--;	
    7f08:	42d8 12cc 	mov	0x12cc <_sensor+0x4>, AL

00007f0c <.L84>:
		
		}
		if (sensor.filterCnt >= 2)
    7f0c:	7eda 12c8 	lod	X, #4808
    7f10:	62d8 12cc 	lod	AL, 0x12cc <_sensor+0x4>
    7f14:	5ce2      	ssex	A
    7f16:	ac01      	cmp	A, #1
    7f18:	1f01      	jsg	0x7f1c <.LM156>
    7f1a:	0160      	jmp	0x81dc <.L85>

00007f1c <.LM156>:
		{
		sensor.moving=C_STATUS_RUN;
    7f1c:	7001      	lod	A, #1

00007f1e <.L136>:
		}
		else if (sensor.filterCnt <= -2)
		{
	
		sensor.moving=C_STATUS_STOP;
    7f1e:	52f8      	mov	[X], A

00007f20 <.LM158>:
		}
		else {}
	}
}
    7f20:	5405      	ret	#6

00007f22 <.L48>:
		{
			motor.direction=C_DIR_CW;
		}
		else
		{
			motor.direction=C_DIR_CCW;
    7f22:	7002      	lod	A, #2
    7f24:	078d      	jmp	0x7e40 <.L131>

00007f26 <.L39>:
*/
static tMotState motor_state_ACC (void)/*20250714*/
{
	tMotState next_state = MOTION_ACC;
	uint16_t u16diff;
	if(motor.initStatus)
    7f26:	2c00      	cmp	X, #0
    7f28:	190b      	je	0x7f40 <.L50>

00007f2a <.LM161>:
	{
		motor.initStatus=0;
    7f2a:	7000      	lod	A, #0
    7f2c:	52d8 12d8 	mov	0x12d8 <_motor+0x4>, A

00007f30 <.LM162>:
		motor.out.enable=1;
    7f30:	7001      	lod	A, #1
    7f32:	0ea7      	lod	C, ML.7
    7f34:	52d8 12fe 	mov	0x12fe <.LASF1850+0xe>, A

00007f38 <.LM163>:
		motor.out.duty=C_MOT_STARTDUTY_SET;
    7f38:	72da 00cc 	lod	A, #204
    7f3c:	52d8 1300 	mov	0x1300 <.LASF1888>, A

00007f40 <.L50>:
	}

	if ((motor.requestStop != 0) || (motor.pos.posReached != 0))
    7f40:	72d8 12dc 	lod	A, 0x12dc <_motor+0x8>
    7f44:	1901      	je	0x7f48 <.L50+0x8>
    7f46:	00ad      	jmp	0x80a2 <.L45>
    7f48:	62d8 12f1 	lod	AL, 0x12f1 <.LASF1850+0x1>
    7f4c:	1901      	je	0x7f50 <.LM165>
    7f4e:	00a9      	jmp	0x80a2 <.L45>

00007f50 <.LM165>:
	{
		next_state = MOTION_STOPPED;
	}
	else 
	{
		if (motor.pos.Delta >= 0)
    7f50:	72d8 12ee 	lod	A, 0x12ee <.LLST8+0xb>

00007f54 <.LM166>:
		{
			u16diff = motor.pos.Delta;
    7f54:	1d81      	jnn	0x7f58 <.L137>
    7f56:	5cc2      	neg	A

00007f58 <.L137>:
    7f58:	7ed8 12fa 	lod	X, 0x12fa <.LASF1850+0xa>

00007f5c <.LM167>:
		}
		else
		{
			u16diff = -motor.pos.Delta;
		}		
		if (motor.softStart.enable)
    7f5c:	7ad8 12f2 	lod	Y, 0x12f2 <.LASF1850+0x2>
    7f60:	1918      	je	0x7f92 <.L53>
    7f62:	7ad8 12f6 	lod	Y, 0x12f6 <.LASF1850+0x6>
    7f66:	e2d8 1300 	add	Y, 0x1300 <.LASF1888>

00007f6a <.LM168>:
		{
			if (u16diff <= motor.softStop.inThreshold)
			{
				motor.out.duty += motor.softStart.accDuty;
    7f6a:	5ad8 1300 	mov	0x1300 <.LASF1888>, Y

00007f6e <.LM169>:
		{
			u16diff = -motor.pos.Delta;
		}		
		if (motor.softStart.enable)
		{
			if (u16diff <= motor.softStop.inThreshold)
    7f6e:	aeee      	cmp	A, X
    7f70:	1e09      	jug	0x7f84 <.L54>

00007f72 <.LM170>:
			{
				motor.out.duty += motor.softStart.accDuty;
				if (motor.out.duty >= motor.out.minDuty)
    7f72:	72d8 1304 	lod	A, 0x1304 <.LASF1888+0x4>

00007f76 <.LVL37>:
    7f76:	aee6      	cmp	A, Y
    7f78:	1a01      	jule	0x7f7c <.L55>
    7f7a:	076a      	jmp	0x7e50 <.L56>

00007f7c <.L55>:
		case MOTION_FAULT:	{next_state = motor_state_FAULT(); break; }
		default: 			
			next_state = MOTION_STOPPED; 
			break; 
	}
	if( next_state != motor.state )
    7f7c:	7ed8 12d4 	lod	X, 0x12d4 <_motor>

00007f80 <.LM172>:
			if (u16diff <= motor.softStop.inThreshold)
			{
				motor.out.duty += motor.softStart.accDuty;
				if (motor.out.duty >= motor.out.minDuty)
				{
				next_state = MOTION_DEC;
    7f80:	7004      	lod	A, #4
    7f82:	076c      	jmp	0x7e5c <.L87>

00007f84 <.L54>:
				}
			}	
			else
			{
				motor.out.duty += motor.softStart.accDuty;
				if (motor.out.duty >= motor.softStart.outThreshold)
    7f84:	72d8 12f4 	lod	A, 0x12f4 <.LASF1850+0x4>

00007f88 <.LVL40>:
    7f88:	aee6      	cmp	A, Y
    7f8a:	1a01      	jule	0x7f8e <.LM174>
    7f8c:	0761      	jmp	0x7e50 <.L56>

00007f8e <.LM174>:
				{
				next_state = MOTION_RUNNING;
    7f8e:	7003      	lod	A, #3
    7f90:	0760      	jmp	0x7e52 <.L35>

00007f92 <.L53>:
			}
		}
		else
		{

			if (u16diff <= motor.softStop.inThreshold)
    7f92:	aeee      	cmp	A, X
    7f94:	1a01      	jule	0x7f98 <.LM176>
    7f96:	0126      	jmp	0x81e4 <.L57>

00007f98 <.LM176>:
			{
				motor.out.duty += motor.softStart.accDuty;
    7f98:	72d8 1300 	lod	A, 0x1300 <.LASF1888>

00007f9c <.LVL42>:
    7f9c:	a2d8 12f6 	add	A, 0x12f6 <.LASF1850+0x6>
    7fa0:	52d8 1300 	mov	0x1300 <.LASF1888>, A

00007fa4 <.LM177>:
				if (motor.out.duty >= motor.softStart.outThreshold)
    7fa4:	0ea7      	lod	C, ML.7
    7fa6:	aed8 12f4 	cmp	A, 0x12f4 <.LASF1850+0x4>
    7faa:	1c68      	jnc	0x7f7c <.L55>
    7fac:	0751      	jmp	0x7e50 <.L56>

00007fae <.L40>:
}
static tMotState motor_state_RUNNING (void)
{
	tMotState next_state = MOTION_RUNNING;
	uint16_t u16diff;
	if(motor.initStatus)
    7fae:	2c00      	cmp	X, #0
    7fb0:	1907      	je	0x7fc0 <.L58>

00007fb2 <.LM179>:
	{
		motor.initStatus=0;
    7fb2:	7000      	lod	A, #0
    7fb4:	52d8 12d8 	mov	0x12d8 <_motor+0x4>, A

00007fb8 <.LM180>:
		motor.out.enable=1;
    7fb8:	7001      	lod	A, #1
    7fba:	0ea7      	lod	C, ML.7
    7fbc:	52d8 12fe 	mov	0x12fe <.LASF1850+0xe>, A

00007fc0 <.L58>:
	
	}
#if DUTY_ADJUST_ENABLE == 0
	motor.out.duty=C_MOT_MAXDUTY_SET;
    7fc0:	72da 0800 	lod	A, #2048
    7fc4:	52d8 1300 	mov	0x1300 <.LASF1888>, A

00007fc8 <.LM182>:
#else
	motor.out.duty=motor.out.maxDuty;
#endif	
	if ((motor.requestStop != 0) || (motor.pos.posReached != 0))
    7fc8:	72d8 12dc 	lod	A, 0x12dc <_motor+0x8>
    7fcc:	1901      	je	0x7fd0 <.LASF1315>
    7fce:	0069      	jmp	0x80a2 <.L45>
    7fd0:	62d8 12f1 	lod	AL, 0x12f1 <.LASF1850+0x1>
    7fd4:	1901      	je	0x7fd8 <.LM183>
    7fd6:	0065      	jmp	0x80a2 <.L45>

00007fd8 <.LM183>:
	{

		next_state = MOTION_STOPPED;
	}
	else if (Mot_dirChange_check() != 0)
    7fd8:	162f      	call	0x7c38 <_Mot_dirChange_check>
    7fda:	ac00      	cmp	A, #0
    7fdc:	1901      	je	0x7fe0 <.LM184>
    7fde:	0107      	jmp	0x81ee <.L59>

00007fe0 <.LM184>:
	}
#endif	
	else
	{
		
		if (motor.softStop.enable)
    7fe0:	62d8 12f8 	lod	AL, 0x12f8 <.LASF1850+0x8>
    7fe4:	1907      	je	0x7ff4 <.L47>

00007fe6 <.LM185>:
			}
			else
			{
				u16diff = -motor.pos.Delta;
			}			
			if (u16diff <= motor.softStop.inThreshold)
    7fe6:	72d8 12ee 	lod	A, 0x12ee <.LLST8+0xb>
    7fea:	1d81      	jnn	0x7fee <.L138>
    7fec:	5cc2      	neg	A

00007fee <.L138>:
    7fee:	aed8 12fa 	cmp	A, 0x12fa <.LASF1850+0xa>
    7ff2:	1a44      	jule	0x7f7c <.L55>

00007ff4 <.L47>:
		motor.initStatus=1u;
		motor.elapsedTime = 0;
	}
	else
	{
		if (motor.elapsedTime < 0xFFFFu) motor.elapsedTime += 1u;
    7ff4:	72d8 12da 	lod	A, 0x12da <_motor+0x6>
    7ff8:	acff      	cmp	A, #-1
    7ffa:	1d01      	jne	0x7ffe <.LM187>
    7ffc:	073a      	jmp	0x7e72 <.L69>

00007ffe <.LM187>:
    7ffe:	a001      	add	A, #1
    8000:	0736      	jmp	0x7e6e <.L132>

00008002 <.L41>:
}
static tMotState motor_state_DCC (void)
{
	tMotState next_state = MOTION_DEC;
	uint16_t u16diff=0;
	if(motor.initStatus)
    8002:	2c00      	cmp	X, #0
    8004:	1909      	je	0x8018 <.L62>

00008006 <.LM189>:
	{
		motor.initStatus=0;
    8006:	7000      	lod	A, #0
    8008:	52d8 12d8 	mov	0x12d8 <_motor+0x4>, A

0000800c <.LM190>:
		motor.out.enable=1;
    800c:	7c01      	lod	X, #1
    800e:	0ea7      	lod	C, ML.7
    8010:	5ed8 12fe 	mov	0x12fe <.LASF1850+0xe>, X

00008014 <.LM191>:
		motor.softStop.completed=0;
    8014:	42d8 12f9 	mov	0x12f9 <.LASF1850+0x9>, AL

00008018 <.L62>:
	}
	
	if ((motor.requestStop != 0) || (motor.pos.posReached != 0))
    8018:	72d8 12dc 	lod	A, 0x12dc <_motor+0x8>
    801c:	1901      	je	0x8020 <.LASF1015+0x1>
    801e:	0041      	jmp	0x80a2 <.L45>
    8020:	62d8 12f1 	lod	AL, 0x12f1 <.LASF1850+0x1>
    8024:	1901      	je	0x8028 <.LM193>
    8026:	003d      	jmp	0x80a2 <.L45>

00008028 <.LM193>:
	{

		next_state = MOTION_STOPPED;
	}
	else if (Mot_dirChange_check() != 0)
    8028:	1607      	call	0x7c38 <_Mot_dirChange_check>
    802a:	7ae2      	lod	Y, A
    802c:	1901      	je	0x8030 <.LM194>
    802e:	00df      	jmp	0x81ee <.L59>

00008030 <.LM194>:
		next_state = MOTION_PAUSE;
		
	}
	else
	{
		if (motor.softStop.completed==0)
    8030:	62d8 12f9 	lod	AL, 0x12f9 <.LASF1850+0x9>
    8034:	1d16      	jne	0x8062 <.L63>

00008036 <.LM195>:
			{
				motor.out.duty = motor.out.minDuty;

			}	
#else
			if (motor.pos.Delta >= 0)
    8036:	7ad8 12ee 	lod	Y, 0x12ee <.LLST8+0xb>

0000803a <.LM196>:
			{
				u16diff = motor.pos.Delta;
    803a:	1d81      	jnn	0x803e <.L139>
    803c:	5cc6      	neg	Y

0000803e <.L139>:
			}
			else
			{
				u16diff = -motor.pos.Delta;
			}		
			motor.out.duty -= ((u16diff>>1)+motor.softStop.dccDuty);
    803e:	72d8 1300 	lod	A, 0x1300 <.LASF1888>
    8042:	aad8 12fc 	sub	A, 0x12fc <.LASF1850+0xc>
    8046:	5201      	mov	[S-2], A
    8048:	72e6      	lod	A, Y
    804a:	4432      	lsr	A
    804c:	7ee2      	lod	X, A
    804e:	7201      	lod	A, [S-2]
    8050:	aaee      	sub	A, X
    8052:	52d8 1300 	mov	0x1300 <.LASF1888>, A

00008056 <.LM198>:
			if (motor.out.duty < motor.out.minDuty)
    8056:	7ed8 1304 	lod	X, 0x1304 <.LASF1888+0x4>
    805a:	aeee      	cmp	A, X
    805c:	1c02      	jnc	0x8062 <.L63>

0000805e <.LM199>:
			{
				motor.out.duty = motor.out.minDuty;
    805e:	5ed8 1300 	mov	0x1300 <.LASF1888>, X

00008062 <.L63>:

			}				
#endif
		}
		if (sensor.moving==C_STATUS_STOP)
    8062:	72d8 12c8 	lod	A, 0x12c8 <_sensor>
    8066:	ac02      	cmp	A, #2
    8068:	1d0c      	jne	0x8082 <.L90>

0000806a <.LM201>:
		{
		
			motor.softStop.completed=1;
    806a:	6001      	lod	AL, #1
    806c:	42d8 12f9 	mov	0x12f9 <.LASF1850+0x9>, AL

00008070 <.LM202>:
			motor.out.duty += ((u16diff>>1)+motor.softStop.dccDuty);
    8070:	72d8 1300 	lod	A, 0x1300 <.LASF1888>
    8074:	0ea7      	lod	C, ML.7
    8076:	a2d8 12fc 	add	A, 0x12fc <.LASF1850+0xc>
    807a:	4436      	lsr	Y

0000807c <.LVL52>:
    807c:	e2e2      	add	Y, A
    807e:	5ad8 1300 	mov	0x1300 <.LASF1888>, Y

00008082 <.L90>:

	return next_state;
}
static tMotState motor_state_DCC (void)
{
	tMotState next_state = MOTION_DEC;
    8082:	7004      	lod	A, #4
    8084:	06e6      	jmp	0x7e52 <.L35>

00008086 <.L42>:
    8086:	7000      	lod	A, #0

00008088 <.LBB39>:
}
static tMotState motor_state_PAUSE (void)
{
	tMotState next_state = MOTION_PAUSE;

	if(motor.initStatus)
    8088:	2c00      	cmp	X, #0
    808a:	1904      	je	0x8094 <.L66>

0000808c <.LM205>:
	{
		motor.initStatus=0;
    808c:	52d8 12d8 	mov	0x12d8 <_motor+0x4>, A

00008090 <.LM206>:
		motor.out.enable=0;
    8090:	52d8 12fe 	mov	0x12fe <.LASF1850+0xe>, A

00008094 <.L66>:

	}
	motor.out.duty = 0;
    8094:	52d8 1300 	mov	0x1300 <.LASF1888>, A

00008098 <.LM208>:
	if (motor.elapsedTime > 100u)
    8098:	72d8 12da 	lod	A, 0x12da <_motor+0x6>
    809c:	ac64      	cmp	A, #100
    809e:	1e01      	jug	0x80a2 <.L45>
    80a0:	07a9      	jmp	0x7ff4 <.L47>

000080a2 <.L45>:
		case MOTION_FAULT:	{next_state = motor_state_FAULT(); break; }
		default: 			
			next_state = MOTION_STOPPED; 
			break; 
	}
	if( next_state != motor.state )
    80a2:	7ada 12d4 	lod	Y, #4820
    80a6:	7ef0      	lod	X, [Y]

000080a8 <.LM210>:

	}
	motor.out.duty = 0;
	if (motor.elapsedTime > 100u)
	{
		next_state = MOTION_STOPPED;
    80a8:	7001      	lod	A, #1
    80aa:	06d8      	jmp	0x7e5c <.L87>

000080ac <.L43>:
    80ac:	7000      	lod	A, #0

000080ae <.LBB43>:

static tMotState motor_state_STALLED (void)
{
	tMotState next_state = MOTION_STALL;

	if(motor.initStatus)
    80ae:	2c00      	cmp	X, #0
    80b0:	1904      	je	0x80ba <.L67>

000080b2 <.LM212>:
	{
		motor.initStatus=0;
    80b2:	52d8 12d8 	mov	0x12d8 <_motor+0x4>, A

000080b6 <.LM213>:
		motor.out.enable=0;
    80b6:	52d8 12fe 	mov	0x12fe <.LASF1850+0xe>, A

000080ba <.L67>:

	}
	motor.holdTime=0;
    80ba:	52d8 12e6 	mov	0x12e6 <.LLST8+0x3>, A

000080be <.LM215>:
	motor.out.duty=0;
    80be:	52d8 1300 	mov	0x1300 <.LASF1888>, A

000080c2 <.LM216>:
	if(motor.stall.flag == 0u)
    80c2:	62d8 130a 	lod	AL, 0x130a <.LASF1535+0x4>
    80c6:	196d      	je	0x80a2 <.L45>

000080c8 <.LM217>:
	return next_state;
}

static tMotState motor_state_STALLED (void)
{
	tMotState next_state = MOTION_STALL;
    80c8:	7006      	lod	A, #6
    80ca:	06c3      	jmp	0x7e52 <.L35>

000080cc <.L44>:
    80cc:	7000      	lod	A, #0

000080ce <.LBB45>:
}
static tMotState motor_state_FAULT (void)
{
	tMotState next_state = MOTION_FAULT;

	if(motor.initStatus)
    80ce:	2c00      	cmp	X, #0
    80d0:	1904      	je	0x80da <.L68>

000080d2 <.LM219>:
	{
		motor.initStatus=0;
    80d2:	52d8 12d8 	mov	0x12d8 <_motor+0x4>, A

000080d6 <.LM220>:
		motor.out.enable=0;
    80d6:	52d8 12fe 	mov	0x12fe <.LASF1850+0xe>, A

000080da <.L68>:

	}
	motor.out.duty=0;
    80da:	52d8 1300 	mov	0x1300 <.LASF1888>, A

000080de <.LM222>:
	if(motor.fault.flag == 0u)
    80de:	62d8 1316 	lod	AL, 0x1316 <.LLST9+0x9>
    80e2:	1d02      	jne	0x80e8 <.L91>

000080e4 <.LM223>:
	{
DIAGNOSTIC_Reset();	
    80e4:	1251      	call	0x8588 <_DIAGNOSTIC_Reset>
    80e6:	068f      	jmp	0x7e06 <.L88>

000080e8 <.L91>:

	return next_state;
}
static tMotState motor_state_FAULT (void)
{
	tMotState next_state = MOTION_FAULT;
    80e8:	7007      	lod	A, #7
    80ea:	06b3      	jmp	0x7e52 <.L35>

000080ec <.L73>:
			sensor.thd=10;
			motor.stall.halfThd=550;
			motor.stall.threshold=650;
			motor.out.minDuty=(C_MOT_MAXDUTY_SET * 0.35);
		}			
		else if (voltage <= 1050)
    80ec:	7203      	lod	A, [S-4]
    80ee:	aeda 041a 	cmp	A, #1050
    80f2:	1e10      	jug	0x8114 <.L75>

000080f4 <.LM226>:
		{
			sensor.thd=11;
    80f4:	700b      	lod	A, #11
    80f6:	52d8 12d0 	mov	0x12d0 <.LLST7>, A

000080fa <.LM227>:
			motor.stall.halfThd=600;
    80fa:	72da 0258 	lod	A, #600
    80fe:	0ea7      	lod	C, ML.7
    8100:	52d8 1310 	mov	0x1310 <.LLST9+0x3>, A

00008104 <.LM228>:
			motor.stall.threshold=700;
    8104:	72da 02bc 	lod	A, #700
    8108:	52d8 1312 	mov	0x1312 <.LLST9+0x5>, A

0000810c <.LM229>:
			motor.out.minDuty=(C_MOT_MAXDUTY_SET * 0.32);
    810c:	0ea7      	lod	C, ML.7
    810e:	72da 028f 	lod	A, #655
    8112:	06d5      	jmp	0x7ebe <.L133>

00008114 <.L75>:
		}
		else if (voltage <= 1150)
    8114:	7203      	lod	A, [S-4]
    8116:	aeda 047e 	cmp	A, #1150
    811a:	1e10      	jug	0x813c <.L76>

0000811c <.LM231>:
		{
			sensor.thd=12;
    811c:	700c      	lod	A, #12
    811e:	52d8 12d0 	mov	0x12d0 <.LLST7>, A

00008122 <.LM232>:
			motor.stall.halfThd=650;
    8122:	72da 028a 	lod	A, #650
    8126:	0ea7      	lod	C, ML.7
    8128:	52d8 1310 	mov	0x1310 <.LLST9+0x3>, A

0000812c <.LM233>:
			motor.stall.threshold=750;
    812c:	72da 02ee 	lod	A, #750
    8130:	52d8 1312 	mov	0x1312 <.LLST9+0x5>, A

00008134 <.LM234>:
			motor.out.minDuty=(C_MOT_MAXDUTY_SET * 0.29);
    8134:	0ea7      	lod	C, ML.7
    8136:	72da 0251 	lod	A, #593
    813a:	06c1      	jmp	0x7ebe <.L133>

0000813c <.L76>:
		}
		else if (voltage <= 1250)
    813c:	7203      	lod	A, [S-4]
    813e:	aeda 04e2 	cmp	A, #1250
    8142:	1e10      	jug	0x8164 <.L77>

00008144 <.LM236>:
		{
			sensor.thd=14;
    8144:	700e      	lod	A, #14
    8146:	52d8 12d0 	mov	0x12d0 <.LLST7>, A

0000814a <.LM237>:
			motor.stall.halfThd=700;
    814a:	72da 02bc 	lod	A, #700
    814e:	0ea7      	lod	C, ML.7
    8150:	52d8 1310 	mov	0x1310 <.LLST9+0x3>, A

00008154 <.LM238>:
			motor.stall.threshold=800;
    8154:	72da 0320 	lod	A, #800
    8158:	52d8 1312 	mov	0x1312 <.LLST9+0x5>, A

0000815c <.LM239>:
			motor.out.minDuty=(C_MOT_MAXDUTY_SET * 0.25);
    815c:	0ea7      	lod	C, ML.7
    815e:	72da 0200 	lod	A, #512
    8162:	06ad      	jmp	0x7ebe <.L133>

00008164 <.L77>:
		}
		else if (voltage <= 1450)
    8164:	7203      	lod	A, [S-4]
    8166:	aeda 05aa 	cmp	A, #1450
    816a:	1e10      	jug	0x818c <.L78>

0000816c <.LM241>:
		{
			sensor.thd=16;
    816c:	7010      	lod	A, #16
    816e:	52d8 12d0 	mov	0x12d0 <.LLST7>, A

00008172 <.LM242>:
			motor.stall.halfThd=800;
    8172:	72da 0320 	lod	A, #800
    8176:	0ea7      	lod	C, ML.7
    8178:	52d8 1310 	mov	0x1310 <.LLST9+0x3>, A

0000817c <.LM243>:
			motor.stall.threshold=900;
    817c:	72da 0384 	lod	A, #900
    8180:	52d8 1312 	mov	0x1312 <.LLST9+0x5>, A

00008184 <.LM244>:
			motor.out.minDuty=(C_MOT_MAXDUTY_SET * 0.21);
    8184:	0ea7      	lod	C, ML.7
    8186:	72da 01ae 	lod	A, #430
    818a:	0699      	jmp	0x7ebe <.L133>

0000818c <.L78>:
		}		
		else
		{
			sensor.thd=17;
    818c:	7011      	lod	A, #17
    818e:	52d8 12d0 	mov	0x12d0 <.LLST7>, A

00008192 <.LM246>:
			motor.stall.halfThd=900;
    8192:	72da 0384 	lod	A, #900
    8196:	0ea7      	lod	C, ML.7
    8198:	52d8 1310 	mov	0x1310 <.LLST9+0x3>, A

0000819c <.LM247>:
			motor.stall.threshold=1000;
    819c:	72da 03e8 	lod	A, #1000
    81a0:	52d8 1312 	mov	0x1312 <.LLST9+0x5>, A

000081a4 <.LM248>:
			motor.out.minDuty=(C_MOT_MAXDUTY_SET * 0.18);
    81a4:	0ea7      	lod	C, ML.7
    81a6:	72da 0170 	lod	A, #368
    81aa:	0689      	jmp	0x7ebe <.L133>

000081ac <.L70>:
		}					
	}
	else
	{
		sensor.delay=50;
    81ac:	7eda 0a32 	lod	X, #2610
    81b0:	5ed8 12ca 	mov	0x12ca <_sensor+0x2>, X

000081b4 <.LM250>:
		sensor.filterPeriod= 10;
    81b4:	42d8 12cc 	mov	0x12cc <_sensor+0x4>, AL

000081b8 <.LM251>:
		sensor.filterCnt=0;
		sensor.delta=0;
    81b8:	0ea7      	lod	C, ML.7
    81ba:	52d8 12ce 	mov	0x12ce <_sensor+0x6>, A

000081be <.LM252>:
		sensor.moving=C_STATUS_OFF_;
    81be:	52d8 12c8 	mov	0x12c8 <_sensor>, A

000081c2 <.LM253>:
		sensor.lastDeg = motor.pos.current;
    81c2:	72d8 12e8 	lod	A, 0x12e8 <.LLST8+0x5>
    81c6:	0ea7      	lod	C, ML.7
    81c8:	52d8 12d2 	mov	0x12d2 <.LLST7+0x2>, A
    81cc:	067a      	jmp	0x7ec2 <.L74>

000081ce <.L81>:
		{
			sensor.delta = motor.pos.current-sensor.lastDeg;
		}
		else
		{
			sensor.delta = sensor.lastDeg-motor.pos.current;
    81ce:	aaee      	sub	A, X
    81d0:	068b      	jmp	0x7ee8 <.L134>

000081d2 <.L83>:
		{
			if (sensor.filterCnt < 3) sensor.filterCnt++;
		}
		else
		{
			if (sensor.filterCnt > -3) sensor.filterCnt--;	
    81d2:	acfe      	cmp	A, #-2
    81d4:	1e81      	jsge	0x81d8 <.LM256>
    81d6:	069a      	jmp	0x7f0c <.L84>

000081d8 <.LM256>:
    81d8:	80ff      	add	AL, #-1
    81da:	0696      	jmp	0x7f08 <.L135>

000081dc <.L85>:
		}
		if (sensor.filterCnt >= 2)
		{
		sensor.moving=C_STATUS_RUN;
		}
		else if (sensor.filterCnt <= -2)
    81dc:	acff      	cmp	A, #-1
    81de:	1e8c      	jsge	0x81f8 <.L34>

000081e0 <.LM258>:
		{
	
		sensor.moving=C_STATUS_STOP;
    81e0:	7002      	lod	A, #2
    81e2:	069d      	jmp	0x7f1e <.L136>

000081e4 <.L57>:
		case MOTION_FAULT:	{next_state = motor_state_FAULT(); break; }
		default: 			
			next_state = MOTION_STOPPED; 
			break; 
	}
	if( next_state != motor.state )
    81e4:	7ada 12d4 	lod	Y, #4820
    81e8:	7ef0      	lod	X, [Y]

000081ea <.LM260>:
				next_state = MOTION_DEC;
				}
			}	
			else
			{
				next_state = MOTION_RUNNING;
    81ea:	7003      	lod	A, #3

000081ec <.LVL61>:
    81ec:	0637      	jmp	0x7e5c <.L87>

000081ee <.L59>:
		case MOTION_FAULT:	{next_state = motor_state_FAULT(); break; }
		default: 			
			next_state = MOTION_STOPPED; 
			break; 
	}
	if( next_state != motor.state )
    81ee:	7ada 12d4 	lod	Y, #4820
    81f2:	7ef0      	lod	X, [Y]

000081f4 <.LM262>:

		next_state = MOTION_STOPPED;
	}
	else if (Mot_dirChange_check() != 0)
	{
		next_state = MOTION_PAUSE;
    81f4:	7005      	lod	A, #5
    81f6:	0632      	jmp	0x7e5c <.L87>

000081f8 <.L34>:
	
		sensor.moving=C_STATUS_STOP;
		}
		else {}
	}
}
    81f8:	5405      	ret	#6

000081fa <_motor_ctrl_handler>:

/* called by every 100us */
void motor_ctrl_handler(void)
{
    81fa:	5803      	inc	S, #4

000081fc <.LCFI3>:
	g_u16DebugData[1] = motor.pos.current;
	g_u16DebugData[2] = (uint16_t)motor.direction;
	g_u16DebugData[3] = motor.out.duty;
	#endif

	adc_raw_update();
    81fc:	82db 3bfe 	callf	0x77fc <_adc_raw_update>

00008200 <.LM266>:
	motor.pos.current = calculate_gmr_angle();
    8200:	82db 3c8b 	callf	0x7916 <_calculate_gmr_angle>
    8204:	52d8 12e8 	mov	0x12e8 <.LLST8+0x5>, A

00008208 <.LM267>:

	motor.pos.Delta = (int16_t)(motor.pos.target-motor.pos.current);
    8208:	7ed8 12ea 	lod	X, 0x12ea <.LLST8+0x7>
    820c:	2ae2      	sub	X, A
    820e:	72ee      	lod	A, X
    8210:	5ed8 12ee 	mov	0x12ee <.LLST8+0xb>, X

00008214 <.LM268>:
	if (motor.pos.Delta >= 0)
	{
		diff = motor.pos.Delta;
    8214:	ac00      	cmp	A, #0
    8216:	1d81      	jnn	0x821a <.L221>
    8218:	5cc2      	neg	A

0000821a <.L221>:
	else
	{
		diff = -motor.pos.Delta;
	}
	
	if (diff <= (int16_t)C_MOT_OFF_HYSTERISYS)
    821a:	ac03      	cmp	A, #3
    821c:	1e08      	jug	0x822e <.L143>

0000821e <.LM270>:
	{
		motor.out.enable=0;
    821e:	7000      	lod	A, #0

00008220 <.LVL67>:
    8220:	52d8 12fe 	mov	0x12fe <.LASF1850+0xe>, A

00008224 <.LM271>:
		motor.pos.posReached = 1;
		motor.pos.newTarget=0;
    8224:	72da 0100 	lod	A, #256
    8228:	0ea7      	lod	C, ML.7
    822a:	52d8 12f0 	mov	0x12f0 <.LASF1850>, A

0000822e <.L143>:
	}
	else
	{
	}
    /* motor stall diagnostics */
	if (motor.out.enable)
    822e:	72d8 12fe 	lod	A, 0x12fe <.LASF1850+0xe>
    8232:	1d01      	jne	0x8236 <.LBB53>
    8234:	0128      	jmp	0x8486 <.L144>

00008236 <.LBB53>:
 *
 * \return fault flag
 */
static void MotorStallDiag(void)/*100usec */
{
	uint16_t current = get_valve_motCurrent();		
    8236:	82db 3355 	callf	0x66aa <_get_valve_motCurrent>
    823a:	7ae2      	lod	Y, A

0000823c <.LM274>:

	if (motor.stall.maskTimer < 0xffffu)
    823c:	72d8 130c 	lod	A, 0x130c <.LASF1535+0x6>

00008240 <.LVL70>:
    8240:	acff      	cmp	A, #-1
    8242:	1903      	je	0x824a <.L145>

00008244 <.LM275>:
	{
		motor.stall.maskTimer += 1;
    8244:	a001      	add	A, #1
    8246:	52d8 130c 	mov	0x130c <.LASF1535+0x6>, A

0000824a <.L145>:
	}
	if (motor.stall.maskTimer>=1000u)/*100msec*/
    824a:	72d8 130c 	lod	A, 0x130c <.LASF1535+0x6>
    824e:	aeda 03e7 	cmp	A, #999
    8252:	1e01      	jug	0x8256 <.LASF1984+0x9>
    8254:	0111      	jmp	0x8478 <.L146>
    8256:	72d8 1314 	lod	A, 0x1314 <.LLST9+0x7>

0000825a <.LM277>:
	{
		if ((current >= motor.stall.halfThd) && (sensor.delta<sensor.thd) && (sensor.delta>3))		
    825a:	eed8 1310 	cmp	Y, 0x1310 <.LLST9+0x3>
    825e:	1c01      	jnc	0x8262 <.LASF1985+0x6>
    8260:	0101      	jmp	0x8464 <.L147>
    8262:	7ed8 12ce 	lod	X, 0x12ce <_sensor+0x6>
    8266:	2ed8 12d0 	cmp	X, 0x12d0 <.LLST7>
    826a:	1a81      	jsl	0x826e <.LASF1986+0x3>
    826c:	00fb      	jmp	0x8464 <.L147>
    826e:	2c03      	cmp	X, #3
    8270:	1f01      	jsg	0x8274 <.LM278>
    8272:	00f8      	jmp	0x8464 <.L147>

00008274 <.LM278>:
		{
	
			motor.stall.obstrCnt += 1;
    8274:	a001      	add	A, #1

00008276 <.L217>:
		}
		else
		{
	
			if (motor.stall.obstrCnt > 0) motor.stall.obstrCnt -= 1;
    8276:	52d8 1314 	mov	0x1314 <.LLST9+0x7>, A

0000827a <.L148>:
		}
		if (motor.stall.obstrCnt >= 3000u)
    827a:	72d8 1314 	lod	A, 0x1314 <.LLST9+0x7>
    827e:	aeda 0bb7 	cmp	A, #2999
    8282:	1a1f      	jule	0x82c2 <.L150>

00008284 <.LM281>:
		{
if ((motor.stall.enable) && (get_valve_mode() != VALVE_CALIBRATION))
    8284:	62d8 130b 	lod	AL, 0x130b <.LASF1535+0x5>
    8288:	191c      	je	0x82c2 <.L150>
    828a:	5a03      	mov	[S-4], Y
    828c:	82db 334c 	callf	0x6698 <_get_valve_mode>

00008290 <.LVL71>:
    8290:	7a03      	lod	Y, [S-4]
    8292:	ac05      	cmp	A, #5
    8294:	1916      	je	0x82c2 <.L150>

00008296 <.LM282>:
{
			motor.stall.flag |= STALL_MASK_TEMPORARY;
    8296:	62d8 130a 	lod	AL, 0x130a <.LASF1535+0x4>
    829a:	8401      	or	AL, #1
    829c:	42d8 130a 	mov	0x130a <.LASF1535+0x4>, AL

000082a0 <.LM283>:
	
u16EventState=MOT_ABSTALL_ERROR;		
    82a0:	7005      	lod	A, #5
    82a2:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

000082a6 <.LM284>:
u16EventValue=(uint16_t)(current>>3);
u16EventValue|=(uint16_t)((motor.elapsedTime>>8)<<8);
    82a6:	0ea7      	lod	C, ML.7
    82a8:	7ed8 12da 	lod	X, 0x12da <_motor+0x6>
    82ac:	36da ff00 	and	X, #65280
    82b0:	5e01      	mov	[S-2], X

000082b2 <.LM285>:
if ((motor.stall.enable) && (get_valve_mode() != VALVE_CALIBRATION))
{
			motor.stall.flag |= STALL_MASK_TEMPORARY;
	
u16EventState=MOT_ABSTALL_ERROR;		
u16EventValue=(uint16_t)(current>>3);
    82b2:	72e6      	lod	A, Y
    82b4:	44b2      	lsr	A, #2
    82b6:	4432      	lsr	A
    82b8:	7ee2      	lod	X, A

000082ba <.LM286>:
u16EventValue|=(uint16_t)((motor.elapsedTime>>8)<<8);
    82ba:	7201      	lod	A, [S-2]
    82bc:	a6ee      	or	A, X
    82be:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

000082c2 <.L150>:
    82c2:	72d8 130e 	lod	A, 0x130e <.LLST9+0x1>

000082c6 <.LM287>:
	
}			
		}
		
		if ((current >= motor.stall.threshold) && (sensor.moving==C_STATUS_STOP))	
    82c6:	eed8 1312 	cmp	Y, 0x1312 <.LLST9+0x5>
    82ca:	1c01      	jnc	0x82ce <.LASF1340+0x7>
    82cc:	00d0      	jmp	0x846e <.L152>
    82ce:	7ed8 12c8 	lod	X, 0x12c8 <_sensor>
    82d2:	2c02      	cmp	X, #2
    82d4:	1901      	je	0x82d8 <.LM288>
    82d6:	00cb      	jmp	0x846e <.L152>

000082d8 <.LM288>:
		{

			motor.stall.stallCnt += 1;
    82d8:	a001      	add	A, #1

000082da <.L218>:
		}
		else
		{

			if (motor.stall.stallCnt > 0) motor.stall.stallCnt -= 1;
    82da:	52d8 130e 	mov	0x130e <.LLST9+0x1>, A

000082de <.L153>:
		}
		if (motor.stall.stallCnt >= 5000u)
    82de:	72d8 130e 	lod	A, 0x130e <.LLST9+0x1>
    82e2:	aeda 1387 	cmp	A, #4999
    82e6:	1a14      	jule	0x8310 <.L154>

000082e8 <.LM291>:
		{
if (motor.stall.enable)	
    82e8:	62d8 130b 	lod	AL, 0x130b <.LASF1535+0x5>
    82ec:	1911      	je	0x8310 <.L154>

000082ee <.LM292>:
{
			motor.stall.flag |= STALL_MASK_PERMENT;
    82ee:	62d8 130a 	lod	AL, 0x130a <.LASF1535+0x4>
    82f2:	8402      	or	AL, #2
    82f4:	42d8 130a 	mov	0x130a <.LASF1535+0x4>, AL

000082f8 <.LM293>:

u16EventState=MOT_STALL_FAULT;		
    82f8:	700a      	lod	A, #10
    82fa:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

000082fe <.LM294>:
u16EventValue=(uint16_t)(current>>3);
u16EventValue|=(uint16_t)((motor.elapsedTime>>8)<<8);				
    82fe:	0ea7      	lod	C, ML.7
    8300:	72d8 12da 	lod	A, 0x12da <_motor+0x6>
    8304:	9400      	and	AL, #0

00008306 <.LM295>:
if (motor.stall.enable)	
{
			motor.stall.flag |= STALL_MASK_PERMENT;

u16EventState=MOT_STALL_FAULT;		
u16EventValue=(uint16_t)(current>>3);
    8306:	44b6      	lsr	Y, #2
    8308:	4436      	lsr	Y

0000830a <.LM296>:
u16EventValue|=(uint16_t)((motor.elapsedTime>>8)<<8);				
    830a:	e6e2      	or	Y, A
    830c:	5ad8 10b4 	mov	0x10b4 <_u16EventValue>, Y

00008310 <.L154>:
	}
	else
	{
		motor.stall.maskTimer=0;	
	}
	if (motor.stall.flag != 0u) 
    8310:	7ada 12d4 	lod	Y, #4820
    8314:	62d8 130a 	lod	AL, 0x130a <.LASF1535+0x4>
    8318:	1911      	je	0x833c <.L156>

0000831a <.LM298>:
	{

		motor.out.enable=0;
    831a:	7c00      	lod	X, #0
    831c:	5ed8 12fe 	mov	0x12fe <.LASF1850+0xe>, X

00008320 <.LM299>:
		if (motor.state != MOTION_STALL)
    8320:	72f0      	lod	A, [Y]
    8322:	5201      	mov	[S-2], A
    8324:	ac06      	cmp	A, #6
    8326:	190a      	je	0x833c <.L156>

00008328 <.LM300>:
		{
			motor.initStatus=1u;
    8328:	7001      	lod	A, #1
    832a:	52d8 12d8 	mov	0x12d8 <_motor+0x4>, A

0000832e <.LM301>:
			motor.elapsedTime = 0;	
    832e:	5ed8 12da 	mov	0x12da <_motor+0x6>, X

00008332 <.LM302>:
			motor.lastState = motor.state;		
    8332:	7201      	lod	A, [S-2]
    8334:	52d8 12d6 	mov	0x12d6 <_motor+0x2>, A

00008338 <.LM303>:
			motor.state = MOTION_STALL;
    8338:	7006      	lod	A, #6
    833a:	52f0      	mov	[Y], A

0000833c <.L156>:
 *
 * \return fault flag
 */
static void MotorFaultDiag(void)
{
    uint16_t current = get_valve_motCurrent();		
    833c:	82db 3355 	callf	0x66aa <_get_valve_motCurrent>
    8340:	7ee2      	lod	X, A

00008342 <.LM305>:

/* open check */
	if (motor.state == MOTION_RUNNING)
    8342:	72d8 12d4 	lod	A, 0x12d4 <_motor>

00008346 <.LVL74>:
    8346:	ac03      	cmp	A, #3
    8348:	1901      	je	0x834c <.LVL74+0x6>
    834a:	00a5      	jmp	0x8496 <.L158>
    834c:	72d8 131c 	lod	A, 0x131c <.LLST9+0xf>

00008350 <.LM306>:
	{
		if ((current <= 5) && (sensor.moving==C_STATUS_STOP))	
    8350:	2c05      	cmp	X, #5
    8352:	1a01      	jule	0x8356 <.LASF210+0x2>
    8354:	009b      	jmp	0x848c <.L159>
    8356:	7ad8 12c8 	lod	Y, 0x12c8 <_sensor>
    835a:	ec02      	cmp	Y, #2
    835c:	1901      	je	0x8360 <.LM307>
    835e:	0096      	jmp	0x848c <.L159>

00008360 <.LM307>:
		{
			motor.fault.openDetectCnt += 1;
    8360:	a001      	add	A, #1

00008362 <.L219>:
		}
		else
		{
			if (motor.fault.openDetectCnt > 0) motor.fault.openDetectCnt -= 1;
    8362:	52d8 131c 	mov	0x131c <.LLST9+0xf>, A

00008366 <.L160>:
		}
		if (motor.fault.openDetectCnt >= 5000u)
    8366:	72d8 131c 	lod	A, 0x131c <.LLST9+0xf>
    836a:	aeda 1387 	cmp	A, #4999
    836e:	1a15      	jule	0x839a <.L161>

00008370 <.LM310>:
		{
if (motor.fault.openEnable)
    8370:	62d8 1318 	lod	AL, 0x1318 <.LLST9+0xb>
    8374:	1912      	je	0x839a <.L161>

00008376 <.LM311>:
{
			motor.fault.flag |= FAULT_MASK_PHASE_A_OPEN;
    8376:	62d8 1316 	lod	AL, 0x1316 <.LLST9+0x9>
    837a:	8401      	or	AL, #1
    837c:	42d8 1316 	mov	0x1316 <.LLST9+0x9>, AL

00008380 <.LM312>:

u16EventState=MOT_OPEN_FAULT;		
    8380:	700c      	lod	A, #12
    8382:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

00008386 <.LM313>:
u16EventValue=(uint16_t)(current>>3);
u16EventValue|=(uint16_t)((motor.elapsedTime>>8)<<8);					
    8386:	0ea7      	lod	C, ML.7
    8388:	72d8 12da 	lod	A, 0x12da <_motor+0x6>
    838c:	9400      	and	AL, #0

0000838e <.LM314>:
if (motor.fault.openEnable)
{
			motor.fault.flag |= FAULT_MASK_PHASE_A_OPEN;

u16EventState=MOT_OPEN_FAULT;		
u16EventValue=(uint16_t)(current>>3);
    838e:	7aee      	lod	Y, X
    8390:	44b6      	lsr	Y, #2
    8392:	4436      	lsr	Y

00008394 <.LM315>:
u16EventValue|=(uint16_t)((motor.elapsedTime>>8)<<8);					
    8394:	a6e6      	or	A, Y
    8396:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

0000839a <.L161>:
	else
	{
		motor.fault.openDetectCnt=0;
	}
/* overcurrent check */	
	if (motor.out.enable)
    839a:	72d8 12fe 	lod	A, 0x12fe <.LASF1850+0xe>
    839e:	1d01      	jne	0x83a2 <.L161+0x8>
    83a0:	0083      	jmp	0x84a8 <.L162>
    83a2:	72d8 131a 	lod	A, 0x131a <.LLST9+0xd>

000083a6 <.LM317>:
	{
		if (current >= 1500) 
    83a6:	2eda 05db 	cmp	X, #1499
    83aa:	1e01      	jug	0x83ae <.LM318>
    83ac:	0078      	jmp	0x849e <.L163>

000083ae <.LM318>:
		{
			motor.fault.ocDetectCnt += 1;
    83ae:	a001      	add	A, #1

000083b0 <.L220>:
		}
		else
		{
			if (motor.fault.ocDetectCnt > 0) motor.fault.ocDetectCnt -= 1;
    83b0:	52d8 131a 	mov	0x131a <.LLST9+0xd>, A

000083b4 <.L164>:
		}
		if (motor.fault.ocDetectCnt >= 5000u)
    83b4:	72d8 131a 	lod	A, 0x131a <.LLST9+0xd>
    83b8:	aeda 1387 	cmp	A, #4999
    83bc:	1a15      	jule	0x83e8 <.L165>

000083be <.LM321>:
		{
if (motor.fault.ocEnable)
    83be:	62d8 1317 	lod	AL, 0x1317 <.LLST9+0xa>
    83c2:	1912      	je	0x83e8 <.L165>

000083c4 <.LM322>:
{
			motor.fault.flag |= FAULT_MASK_OVER_CURRENT;
    83c4:	62d8 1316 	lod	AL, 0x1316 <.LLST9+0x9>
    83c8:	8440      	or	AL, #64
    83ca:	42d8 1316 	mov	0x1316 <.LLST9+0x9>, AL

000083ce <.LM323>:

u16EventState=MOT_OC_ERROR;		
    83ce:	7004      	lod	A, #4
    83d0:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

000083d4 <.LM324>:
u16EventValue=(uint16_t)(current>>3);
u16EventValue|=(uint16_t)((motor.elapsedTime>>8)<<8);				
    83d4:	0ea7      	lod	C, ML.7
    83d6:	72d8 12da 	lod	A, 0x12da <_motor+0x6>
    83da:	9400      	and	AL, #0

000083dc <.LM325>:
if (motor.fault.ocEnable)
{
			motor.fault.flag |= FAULT_MASK_OVER_CURRENT;

u16EventState=MOT_OC_ERROR;		
u16EventValue=(uint16_t)(current>>3);
    83dc:	7aee      	lod	Y, X
    83de:	44b6      	lsr	Y, #2
    83e0:	4436      	lsr	Y

000083e2 <.LM326>:
u16EventValue|=(uint16_t)((motor.elapsedTime>>8)<<8);				
    83e2:	a6e6      	or	A, Y
    83e4:	52d8 10b4 	mov	0x10b4 <_u16EventValue>, A

000083e8 <.L165>:
    83e8:	66d8 1316 	lod	YL, 0x1316 <.LLST9+0x9>

000083ec <.LM327>:
	else
	{
		motor.fault.ocDetectCnt=0;
	}
/* short/oc check */	
	if (g_e8ShortOcc == C_ERR_SHORT_VDS)
    83ec:	72d8 11b0 	lod	A, 0x11b0 <_g_e8ShortOcc>
    83f0:	ac02      	cmp	A, #2
    83f2:	1901      	je	0x83f6 <.LM328>
    83f4:	005c      	jmp	0x84ae <.L166>

000083f6 <.LM328>:
	{
		motor.fault.flag |= FAULT_MASK_PHASE_A_SHORT;
    83f6:	62e8      	lod	AL, YL
    83f8:	8410      	or	AL, #16
    83fa:	42d8 1316 	mov	0x1316 <.LLST9+0x9>, AL

000083fe <.LM329>:

u16EventState=MOT_SHORT_FAULT;		
    83fe:	700b      	lod	A, #11
    8400:	52d8 10b6 	mov	0x10b6 <_u16EventState>, A

00008404 <.LM330>:
u16EventValue=(uint16_t)(current>>3);
u16EventValue|=(uint16_t)((motor.elapsedTime>>8)<<8);				
    8404:	0ea7      	lod	C, ML.7
    8406:	7ad8 12da 	lod	Y, 0x12da <_motor+0x6>
    840a:	f6da ff00 	and	Y, #65280

0000840e <.LM331>:
	if (g_e8ShortOcc == C_ERR_SHORT_VDS)
	{
		motor.fault.flag |= FAULT_MASK_PHASE_A_SHORT;

u16EventState=MOT_SHORT_FAULT;		
u16EventValue=(uint16_t)(current>>3);
    840e:	44be      	lsr	X, #2
    8410:	443e      	lsr	X

00008412 <.LM332>:
u16EventValue|=(uint16_t)((motor.elapsedTime>>8)<<8);				
    8412:	26e6      	or	X, Y
    8414:	5ed8 10b4 	mov	0x10b4 <_u16EventValue>, X

00008418 <.L167>:
			motor.state = MOTION_STALL;
		}
	}	
    /* motor fault diagnostics */
	MotorFaultDiag();
	if (motor.fault.flag != 0)
    8418:	7ada 12d4 	lod	Y, #4820
    841c:	62d8 1316 	lod	AL, 0x1316 <.LLST9+0x9>
    8420:	1914      	je	0x844a <.L168>

00008422 <.LM334>:
	{
		motor.holdTime=0;
    8422:	7000      	lod	A, #0
    8424:	52d8 12e6 	mov	0x12e6 <.LLST8+0x3>, A

00008428 <.LM335>:
		motor.out.enable=0;
    8428:	52d8 12fe 	mov	0x12fe <.LASF1850+0xe>, A

0000842c <.LM336>:
		if (motor.state != MOTION_FAULT)
    842c:	7ef0      	lod	X, [Y]
    842e:	5e01      	mov	[S-2], X
    8430:	2c07      	cmp	X, #7
    8432:	1d01      	jne	0x8436 <.LM337>
    8434:	0045      	jmp	0x84c0 <.L169>

00008436 <.LM337>:
		{		
			motor.initStatus=1u;
    8436:	7c01      	lod	X, #1
    8438:	5ed8 12d8 	mov	0x12d8 <_motor+0x4>, X

0000843c <.LM338>:
			motor.elapsedTime = 0;	
    843c:	52d8 12da 	mov	0x12da <_motor+0x6>, A

00008440 <.LM339>:
			motor.lastState = motor.state;
    8440:	7201      	lod	A, [S-2]
    8442:	52d8 12d6 	mov	0x12d6 <_motor+0x2>, A

00008446 <.LM340>:
			motor.state = MOTION_FAULT;
    8446:	7007      	lod	A, #7
    8448:	52f0      	mov	[Y], A

0000844a <.L168>:
		}
	}

	if (motor.out.enable)
    844a:	72d8 12fe 	lod	A, 0x12fe <.LASF1850+0xe>
    844e:	1d01      	jne	0x8452 <.LM342>
    8450:	0037      	jmp	0x84c0 <.L169>

00008452 <.LM342>:
	{
	/* 16384 = 0% */
		pwm_SetDutyCycle(motor.direction,motor.out.duty); 
    8452:	72d8 12e0 	lod	A, 0x12e0 <_motor+0xc>
    8456:	5cf2      	usex	A
    8458:	7ed8 1300 	lod	X, 0x1300 <.LASF1888>
    845c:	5edf      	push	X

0000845e <.LCFI4>:
    845e:	82db 4cd2 	callf	0x99a4 <_pwm_SetDutyCycle>

00008462 <.LCFI5>:
    8462:	5407      	ret	#8

00008464 <.L147>:
			motor.stall.obstrCnt += 1;
		}
		else
		{
	
			if (motor.stall.obstrCnt > 0) motor.stall.obstrCnt -= 1;
    8464:	ac00      	cmp	A, #0
    8466:	1d01      	jne	0x846a <.L147+0x6>
    8468:	0708      	jmp	0x827a <.L148>
    846a:	a0ff      	add	A, #-1
    846c:	0704      	jmp	0x8276 <.L217>

0000846e <.L152>:
			motor.stall.stallCnt += 1;
		}
		else
		{

			if (motor.stall.stallCnt > 0) motor.stall.stallCnt -= 1;
    846e:	ac00      	cmp	A, #0
    8470:	1d01      	jne	0x8474 <.LASF1092+0x2>
    8472:	0735      	jmp	0x82de <.L153>
    8474:	a0ff      	add	A, #-1
    8476:	0731      	jmp	0x82da <.L218>

00008478 <.L146>:
}			
		}
	}
	else
	{
		motor.stall.stallCnt=0;
    8478:	7000      	lod	A, #0
    847a:	52d8 130e 	mov	0x130e <.LLST9+0x1>, A

0000847e <.LM346>:
		motor.stall.obstrCnt=0;
    847e:	52d8 1314 	mov	0x1314 <.LLST9+0x7>, A
    8482:	0ea7      	lod	C, ML.7
    8484:	0745      	jmp	0x8310 <.L154>

00008486 <.L144>:
	{
		MotorStallDiag();	
	}
	else
	{
		motor.stall.maskTimer=0;	
    8486:	52d8 130c 	mov	0x130c <.LASF1535+0x6>, A
    848a:	0742      	jmp	0x8310 <.L154>

0000848c <.L159>:
		{
			motor.fault.openDetectCnt += 1;
		}
		else
		{
			if (motor.fault.openDetectCnt > 0) motor.fault.openDetectCnt -= 1;
    848c:	ac00      	cmp	A, #0
    848e:	1d01      	jne	0x8492 <.L159+0x6>
    8490:	076a      	jmp	0x8366 <.L160>
    8492:	a0ff      	add	A, #-1
    8494:	0766      	jmp	0x8362 <.L219>

00008496 <.L158>:
}
		}
	}
	else
	{
		motor.fault.openDetectCnt=0;
    8496:	7000      	lod	A, #0
    8498:	52d8 131c 	mov	0x131c <.LLST9+0xf>, A
    849c:	077e      	jmp	0x839a <.L161>

0000849e <.L163>:
		{
			motor.fault.ocDetectCnt += 1;
		}
		else
		{
			if (motor.fault.ocDetectCnt > 0) motor.fault.ocDetectCnt -= 1;
    849e:	ac00      	cmp	A, #0
    84a0:	1d01      	jne	0x84a4 <.L163+0x6>
    84a2:	0788      	jmp	0x83b4 <.L164>
    84a4:	a0ff      	add	A, #-1
    84a6:	0784      	jmp	0x83b0 <.L220>

000084a8 <.L162>:
}
		}
	}
	else
	{
		motor.fault.ocDetectCnt=0;
    84a8:	52d8 131a 	mov	0x131a <.LLST9+0xd>, A
    84ac:	079d      	jmp	0x83e8 <.L165>

000084ae <.L166>:

u16EventState=MOT_SHORT_FAULT;		
u16EventValue=(uint16_t)(current>>3);
u16EventValue|=(uint16_t)((motor.elapsedTime>>8)<<8);				
	}
	else if (g_e8OverCurrent != 0)
    84ae:	62d8 11af 	lod	AL, 0x11af <_g_e8OverCurrent>
    84b2:	1d01      	jne	0x84b6 <.LM353>
    84b4:	07b1      	jmp	0x8418 <.L167>

000084b6 <.LM353>:
	{
		motor.fault.flag |= FAULT_MASK_OVER_CURRENT;
    84b6:	62e8      	lod	AL, YL
    84b8:	8440      	or	AL, #64
    84ba:	42d8 1316 	mov	0x1316 <.LLST9+0x9>, AL
    84be:	07ac      	jmp	0x8418 <.L167>

000084c0 <.L169>:
		pwm_SetDutyCycle(motor.direction,motor.out.duty); 

	}
	else
	{
		if (motor.elapsedTime >= 1000u)
    84c0:	72d8 12da 	lod	A, 0x12da <_motor+0x6>
    84c4:	aeda 03e7 	cmp	A, #999
    84c8:	1a03      	jule	0x84d0 <.L171>

000084ca <.LM355>:
		{
			pwm_Off();
    84ca:	82db 4d0c 	callf	0x9a18 <_pwm_Off>
    84ce:	5405      	ret	#6

000084d0 <.L171>:
		}
		else
		{
			pwm_Stop();
    84d0:	82db 4cfc 	callf	0x99f8 <_pwm_Stop>

000084d4 <.LM357>:
		}

	}

}
    84d4:	5405      	ret	#6

000084d6 <_diagnostic_Init>:
void diagnostic_Init(void)
{
    /* Disable hardware protection for over-temperature, under-voltage
     * Hardware protection is enabled in case of OC, VDS(LS), VDS(HS), OV_VS, OVT
     */
    IO_SET(PORT_DRV1_PROT, DIS_UV_VDDA, 1u, DIS_UV_VDDAF, 1u, DIS_UV_VS, 1u);
    84d6:	72d8 0218 	lod	A, 0x218 <_PORT_DRV1_PROT>
    84da:	a6da 02a0 	or	A, #672
    84de:	52d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, A

000084e2 <.LM5>:

    /*
     * Connect the phase to GND in case of VDS(HS),
     */
    IO_SET(PORT_DRV1_PROT,
    84e2:	0ea7      	lod	C, ML.7
    84e4:	72d8 0218 	lod	A, 0x218 <_PORT_DRV1_PROT>
    84e8:	b6da abfa 	and	A, #44026
    84ec:	c404      	or	AH, #4
    84ee:	52d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, A

000084f2 <.LM6>:
           0, /* high */
           OC_PM,
           PROTECTION_MODE_TRISTATE);

    /* Set/enable UV & OV debounce circuitry */
    IO_SET(PORT_SUPP_CFG, UV_VS_FILT_SEL, 1u); /* 0 : 1-2us filtering, 1 : 100-110us filtering */
    84f2:	62d8 01e4 	lod	AL, 0x1e4 <_PORT_SUPP_CFG>
    84f6:	8408      	or	AL, #8
    84f8:	42d8 01e4 	mov	0x1e4 <_PORT_SUPP_CFG>, AL

000084fc <.LM7>:
    IO_SET(PORT_SUPP_CFG, OV_VS_FILT_SEL, 1u); /* 0 : 1-2us filtering, 1 : 100-110us filtering */
    84fc:	62d8 01e4 	lod	AL, 0x1e4 <_PORT_SUPP_CFG>
    8500:	8410      	or	AL, #16
    8502:	42d8 01e4 	mov	0x1e4 <_PORT_SUPP_CFG>, AL

00008506 <.LM8>:

    /* Under/Over voltage detection levels */
    IO_SET(PORT_MISC_OUT, PRUV_VS, vsuv6V);
    8506:	72d8 01f2 	lod	A, 0x1f2 <_PORT_MISC_OUT>
    850a:	b6da fe3f 	and	A, #65087
    850e:	8480      	or	AL, #-128
    8510:	52d8 01f2 	mov	0x1f2 <_PORT_MISC_OUT>, A

00008514 <.LM9>:
    //    IO_SET(PORT_MISC_OUT, PRUV_VS, vsuv9V);
    //    IO_SET(PORT_MISC_OUT, PROV_VS, vsov22V);
    IO_SET(PORT_MISC_OUT, PROV_VS, vsov24V);
    8514:	62d8 01f3 	lod	AL, 0x1f3 <_PORT_MISC_OUT+0x1>
    8518:	94f9      	and	AL, #-7
    851a:	8402      	or	AL, #2
    851c:	42d8 01f3 	mov	0x1f3 <_PORT_MISC_OUT+0x1>, AL

00008520 <.LM10>:

    uint16_t u16trim_high = EE_GET(TRIM_CSA_CL_HIGH); // 2A Threshold from calibration data
    uint16_t u16trim_low = EE_GET(TRIM_CSA_CL_LOW);   // 1.5A Trheshold from calibration data

    IO_SET(TRIM3_DRV, TRIM_CSA_CL, u16trim_high); // HW OC threshold ,2A
    8520:	62d8 09f0 	lod	AL, 0x9f0 <.LASF1601+0x5>
    8524:	42d8 020c 	mov	0x20c <_TRIM3_DRV>, AL

00008528 <.LM11>:
			STEP2_INC , 1U) ; 	/* STEP_INC = 1 */
    IO_SET (PORT_SSCM2_CONF , SSCM2_EN , 1u ) ; /* Enable the spread spectrum modulation */
#endif
    // VDDA output voltage level
    // Default : 3.3V output
    IO_SET(PORT_MISC_OUT, SWITCH_VDDA_TO_5V, VDDA_OUTPUT_LEVEL); /* 5V output*/
    8528:	0ea7      	lod	C, ML.7
    852a:	62d8 01f2 	lod	AL, 0x1f2 <_PORT_MISC_OUT>
    852e:	94df      	and	AL, #-33
    8530:	42d8 01f2 	mov	0x1f2 <_PORT_MISC_OUT>, AL

00008534 <.LM12>:
    Itc_Enable(UV_VS);		//Under Voltage_ISR Enable
    Itc_Enable(OV_VS);		//Over Voltage Enable
    Itc_Enable(OVC);		//Over Current_ISR Enable
    Itc_Enable(OVT);		//Over Temperature_ISR Enable
#endif
}
    8534:	5401      	ret

00008536 <_diagnostic_Start>:
/**
 * Clear over current, VDS and OV pending flag(s)
 */
void diagnostic_Start(void)
{
    IO_SET(PORT_DRV1_PROT, DIS_OC, 1u); /* clear MEM flag */
    8536:	62d8 0219 	lod	AL, 0x219 <_PORT_DRV1_PROT+0x1>
    853a:	8408      	or	AL, #8
    853c:	42d8 0219 	mov	0x219 <_PORT_DRV1_PROT+0x1>, AL

00008540 <.LM22>:
    IO_SET(PORT_DRV1_PROT, DIS_OC, 0u); /* re-enable hardware protection */
    8540:	62d8 0219 	lod	AL, 0x219 <_PORT_DRV1_PROT+0x1>
    8544:	94f7      	and	AL, #-9
    8546:	42d8 0219 	mov	0x219 <_PORT_DRV1_PROT+0x1>, AL

0000854a <.LM23>:

    IO_SET(PORT_DRV1_PROT, DIS_UV_VS, 1u); /* clear MEM flag */
    854a:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    854e:	8420      	or	AL, #32
    8550:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

00008554 <.LM24>:
    IO_SET(PORT_DRV1_PROT, DIS_UV_VS, 0u); /* re-enable hardware protection */
    8554:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    8558:	94df      	and	AL, #-33
    855a:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

0000855e <.LM25>:

    IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 1u); /* clear MEM flag */
    855e:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    8562:	8408      	or	AL, #8
    8564:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

00008568 <.LM26>:
    IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 0u); /* re-enable hardware protection */
    8568:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    856c:	94f7      	and	AL, #-9
    856e:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

00008572 <.LM27>:

    IO_SET(PORT_DRV1_PROT, DIS_OVT, 1u); /* clear MEM flag */
    8572:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    8576:	8402      	or	AL, #2
    8578:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

0000857c <.LM28>:
    IO_SET(PORT_DRV1_PROT, DIS_OVT, 0u); /* re-enable hardware protection */
    857c:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    8580:	94fd      	and	AL, #-3
    8582:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

00008586 <.LM29>:
}
    8586:	5401      	ret

00008588 <_DIAGNOSTIC_Reset>:
/**
 * Clear over current, VDS and OC pending flag(s)
 */
void DIAGNOSTIC_Reset(void)
{
    IO_SET(PORT_DRV1_PROT, DIS_OC, 1u); /* clear OVC_MEM flag */
    8588:	62d8 0219 	lod	AL, 0x219 <_PORT_DRV1_PROT+0x1>
    858c:	8408      	or	AL, #8
    858e:	42d8 0219 	mov	0x219 <_PORT_DRV1_PROT+0x1>, AL

00008592 <.LM32>:
    IO_SET(PORT_DRV1_PROT, DIS_OC, 0u); /* re-enable OVC hardware protection */
    8592:	62d8 0219 	lod	AL, 0x219 <_PORT_DRV1_PROT+0x1>
    8596:	94f7      	and	AL, #-9
    8598:	42d8 0219 	mov	0x219 <_PORT_DRV1_PROT+0x1>, AL

0000859c <.LM33>:

    IO_SET(PORT_DRV1_PROT, DIS_OV_HS_VDS, 1u); /* clear OV_HS_VDS_MEM flag */
    859c:	62d8 0219 	lod	AL, 0x219 <_PORT_DRV1_PROT+0x1>
    85a0:	8420      	or	AL, #32
    85a2:	42d8 0219 	mov	0x219 <_PORT_DRV1_PROT+0x1>, AL

000085a6 <.LM34>:
    IO_SET(PORT_DRV1_PROT, DIS_OV_HS_VDS, 0u); /* re-enable HS-VDS hardware protection */
    85a6:	62d8 0219 	lod	AL, 0x219 <_PORT_DRV1_PROT+0x1>
    85aa:	94df      	and	AL, #-33
    85ac:	42d8 0219 	mov	0x219 <_PORT_DRV1_PROT+0x1>, AL

000085b0 <.LM35>:
}
    85b0:	5401      	ret

000085b2 <_diagnostic_IsUVPending>:
 */
bool diagnostic_IsUVPending(void)
{
    bool bRetVal;

    bRetVal = IO_GET(PORT_SUPP_IN, UV_VS_IT) ? true : false;
    85b2:	72d8 01e0 	lod	A, 0x1e0 <_PORT_SUPP_IN>

000085b6 <.LM38>:
        ENTER_SECTION(ATOMIC_SYSTEM_MODE);
        Itc_Enable(UV_VS);
        EXIT_SECTION();
    }
#endif
    return bRetVal;
    85b6:	9404      	and	AL, #4
    85b8:	5ca2      	sne	A

000085ba <.LM39>:
}
    85ba:	5401      	ret

000085bc <_diagnostic_IsOVPending>:
 */
bool diagnostic_IsOVPending(void)
{
    bool bRetVal;

    bRetVal = IO_GET(PORT_DIAG_IN, OV_VS_MEM) ? true : false;
    85bc:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>

000085c0 <.LM42>:
    {
        IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 1u);  /* clear MEM flag */
        IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 0u);  /* re-enable hardware protection */
    }
#endif
    return bRetVal;
    85c0:	9402      	and	AL, #2
    85c2:	5ca2      	sne	A

000085c4 <.LM43>:
}
    85c4:	5401      	ret

000085c6 <_diagnostic_IsOVTPending>:
 */
bool diagnostic_IsOVTPending(void)
{
    bool bRetVal;

    bRetVal = IO_GET(PORT_DIAG_IN, OVT_MEM) ? true : false;
    85c6:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>

000085ca <.LM46>:
    {
        IO_SET(PORT_DRV1_PROT, DIS_OVT, 1u);  /* clear MEM flag */
        IO_SET(PORT_DRV1_PROT, DIS_OVT, 0u);  /* re-enable hardware protection */
    }
#endif
    return bRetVal;
    85ca:	b401      	and	A, #1

000085cc <.LM47>:
}
    85cc:	5401      	ret

000085ce <_diagnostic_IsOVCPending>:
 */
bool diagnostic_IsOVCPending(void)
{
    bool bRetVal;

    bRetVal = IO_GET(PORT_DIAG_IN, OVC_MEM) ? true : false;
    85ce:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>

000085d2 <.LM50>:

    return bRetVal;
    85d2:	9420      	and	AL, #32
    85d4:	5ca2      	sne	A

000085d6 <.LM51>:
}
    85d6:	5401      	ret

000085d8 <_diagnostic_IsVDSPending>:
 */
bool diagnostic_IsVDSPending(void)
{
    bool bRetVal;

    bRetVal = (IO_GET(PORT_DIAG_IN, OV_HS_VDS_MEM) || IO_GET(PORT_DIAG_IN, OV_LS_VDS_MEM)) ? true : false;
    85d8:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>
    85dc:	b6da 03c0 	and	A, #960
    85e0:	1d06      	jne	0x85ee <.L12>

000085e2 <.LM54>:
    85e2:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>
    85e6:	b6da 3c00 	and	A, #15360
    85ea:	5ca2      	sne	A
    85ec:	5401      	ret

000085ee <.L12>:
    85ee:	7001      	lod	A, #1

000085f0 <.LM56>:

    return bRetVal;
}
    85f0:	5401      	ret

000085f2 <__UV_VS_INT>:

/**
 * Under voltage interrupt
 */
INTERRUPT void _UV_VS_INT(void)
{
    85f2:	5edf      	push	X

000085f4 <.LCFI0>:
    85f4:	5adf      	push	Y

000085f6 <.LCFI1>:
    85f6:	52df      	push	A

000085f8 <.LCFI2>:
    85f8:	4c83      	push	D

000085fa <.LCFI3>:
    /* Disable the interrupt, otherwise the interrupt will be called continuously */
    Itc_Disable(UV_VS);
    85fa:	62d8 006c 	lod	AL, 0x6c <__mlx4_cst_tables_ram_size+0xe>
    85fe:	947f      	and	AL, #127
    8600:	42d8 006c 	mov	0x6c <__mlx4_cst_tables_ram_size+0xe>, AL

00008604 <.LM59>:

    /* Call application callback (save data to EEPROM, log error, etc) */
    EVENT_UnderVoltage();
    8604:	82db 4bb3 	callf	0x9766 <_EVENT_UnderVoltage>

00008608 <.LM60>:
}
    8608:	4cc3      	pop	D

0000860a <.LCFI4>:
    860a:	72cf      	pop	A

0000860c <.LCFI5>:
    860c:	7acf      	pop	Y

0000860e <.LCFI6>:
    860e:	7ecf      	pop	X

00008610 <.LCFI7>:
    8610:	72cb      	pop	M
    8612:	5401      	ret

00008614 <__OV_VS_INT>:

/**
 * Over voltage interrupt
 */
INTERRUPT void _OV_VS_INT(void)
{
    8614:	52df      	push	A

00008616 <.LCFI8>:

    /* Disable the interrupt, otherwise the interrupt will be called continuously */
    Itc_Disable(OV_VS);
    8616:	62d8 0071 	lod	AL, 0x71 <__mlx4_cst_tables_ram_size+0x13>
    861a:	94fb      	and	AL, #-5
    861c:	42d8 0071 	mov	0x71 <__mlx4_cst_tables_ram_size+0x13>, AL

00008620 <.LM63>:

    /* Call application callback (save data to EEPROM, log error, etc) */
    //    EVENT_OverVoltage();
}
    8620:	72cf      	pop	A

00008622 <.LCFI9>:
    8622:	72cb      	pop	M
    8624:	5401      	ret

00008626 <__OVT_INT>:

/**
 * Over Temperature interrupt
 */
INTERRUPT void _OVT_INT(void)
{
    8626:	52df      	push	A

00008628 <.LCFI10>:

    /* Disable the interrupt, otherwise the interrupt will be called continuously */
    Itc_Disable(OVT);
    8628:	62d8 006d 	lod	AL, 0x6d <__mlx4_cst_tables_ram_size+0xf>
    862c:	94fb      	and	AL, #-5
    862e:	42d8 006d 	mov	0x6d <__mlx4_cst_tables_ram_size+0xf>, AL

00008632 <.LM66>:
}
    8632:	72cf      	pop	A

00008634 <.LCFI11>:
    8634:	72cb      	pop	M
    8636:	5401      	ret

00008638 <__OVC_INT>:

/**
 * Over Current interrupt
 */
INTERRUPT void _OVC_INT(void)
{
    8638:	52df      	push	A

0000863a <.LCFI12>:

    /* Disable the interrupt, otherwise the interrupt will be called continuously */
    Itc_Disable(OVC);
    863a:	62d8 006d 	lod	AL, 0x6d <__mlx4_cst_tables_ram_size+0xf>
    863e:	94f7      	and	AL, #-9
    8640:	42d8 006d 	mov	0x6d <__mlx4_cst_tables_ram_size+0xf>, AL

00008644 <.LM69>:
}
    8644:	72cf      	pop	A

00008646 <.LCFI13>:
    8646:	72cb      	pop	M
    8648:	5401      	ret

0000864a <_eeprom_Init>:

/**
 * Module initialization
 */
bool eeprom_Init(void)
{
    864a:	5801      	inc	S, #2

0000864c <.LCFI0>:
    bool retval = true;

    unirom_Init();
    864c:	82db 4f46 	callf	0x9e8c <_unirom_Init>

00008650 <.LM3>:

    if (!unirom_LoadUserConfig())
    8650:	82db 4f47 	callf	0x9e8e <_unirom_LoadUserConfig>
    8654:	7ae2      	lod	Y, A
    8656:	1d06      	jne	0x8664 <.L2>

00008658 <.LM4>:
    {
        (void)unirom_ResetUserConfig(&eeprom_defaults);
    8658:	72da 5d2c 	lod	A, #23852
    865c:	5a01      	mov	[S-2], Y
    865e:	82db 4fa1 	callf	0x9f42 <_unirom_ResetUserConfig>
    8662:	7a01      	lod	Y, [S-2]

00008664 <.L2>:

        retval = false;
    }

    return retval;
}
    8664:	72e6      	lod	A, Y
    8666:	5403      	ret	#4

00008668 <_eeprom_ReadLINconfig>:
 * @param[in]  length  the number of configuration words to read
 * @retval  true  valid configuration found in eeprom.
 * @retval  false  otherwise.
 */
bool eeprom_ReadLINconfig(uint8_t *config, uint8_t length)
{
    8668:	6603      	lod	YL, [S-4]
    866a:	5cf6      	usex	Y

0000866c <.LM7>:
    bool retval = false;
    retval = unirom_ReadPage(0u, config, length);
    866c:	5adf      	push	Y

0000866e <.LCFI1>:
    866e:	52df      	push	A

00008670 <.LCFI2>:
    8670:	7000      	lod	A, #0

00008672 <.LVL7>:
    8672:	82db 5014 	callf	0xa028 <_unirom_ReadPage>

00008676 <.LCFI3>:

    return retval;
}
    8676:	5405      	ret	#6

00008678 <_eeprom_ReadValveConfig>:
 * @param[out]  position  the position
 * @retval  true  valid position found in eeprom.
 * @retval  false  otherwise.
 */
bool eeprom_ReadValveConfig(valve_config_t *config)
{
    8678:	5809      	inc	S, #10

0000867a <.LCFI7>:
    867a:	7ae2      	lod	Y, A

0000867c <.LM18>:
    bool retval = false;
    uint8_t bytes[sizeof(valve_config_t)];
    (void)unirom_ReadPage(1u, &bytes[0], sizeof(valve_config_t));
    867c:	54ca 0006 	pushw	#6

00008680 <.LCFI8>:
    8680:	72ef      	lod	A, S

00008682 <.LVL18>:
    8682:	a0f4      	add	A, #-12
    8684:	52df      	push	A

00008686 <.LCFI9>:
    8686:	7001      	lod	A, #1
    8688:	5a07      	mov	[S-8], Y
    868a:	82db 5014 	callf	0xa028 <_unirom_ReadPage>

0000868e <.LM19>:

    config->E1DATA0 = (uint16_t)(bytes[0] + ((uint16_t)bytes[1] << 8));
    868e:	620c      	lod	AL, [S-13]
    8690:	6800      	lod	AH, #0
    8692:	72e4      	swap	A
    8694:	5205      	mov	[S-6], A
    8696:	620d      	lod	AL, [S-14]
    8698:	5cf2      	usex	A
    869a:	7ee2      	lod	X, A
    869c:	7205      	lod	A, [S-6]
    869e:	a2ee      	add	A, X
    86a0:	7a07      	lod	Y, [S-8]
    86a2:	52f0      	mov	[Y], A

000086a4 <.LM20>:
    config->E1DATA1 = (uint16_t)(bytes[2] + ((uint16_t)bytes[3] << 8));
    86a4:	620a      	lod	AL, [S-11]
    86a6:	6800      	lod	AH, #0
    86a8:	72e4      	swap	A
    86aa:	5205      	mov	[S-6], A
    86ac:	620b      	lod	AL, [S-12]
    86ae:	5cf2      	usex	A
    86b0:	7ee2      	lod	X, A
    86b2:	7205      	lod	A, [S-6]
    86b4:	a2ee      	add	A, X
    86b6:	52f2      	mov	[Y+2], A

000086b8 <.LM21>:
    config->E1DATA2 = (uint16_t)(bytes[4] + ((uint16_t)bytes[5] << 8));
    86b8:	6208      	lod	AL, [S-9]
    86ba:	6800      	lod	AH, #0
    86bc:	72e4      	swap	A
    86be:	5205      	mov	[S-6], A
    86c0:	6209      	lod	AL, [S-10]
    86c2:	5cf2      	usex	A
    86c4:	7ee2      	lod	X, A
    86c6:	7205      	lod	A, [S-6]
    86c8:	a2ee      	add	A, X
    86ca:	52f4      	mov	[Y+4], A

000086cc <.LM22>:

    retval = true;

    return retval;
}
    86cc:	7001      	lod	A, #1

000086ce <.LCFI10>:
    86ce:	540f      	ret	#16

000086d0 <_eeprom_WriteValveConfig>:
 * @param[out]  config  the configuration array to be stored
 * @retval  true  the configuration is correctly stored
 * @retval  false  otherwise
 */
bool eeprom_WriteValveConfig(valve_config_t *config)
{
    86d0:	5805      	inc	S, #6

000086d2 <.LCFI11>:
    86d2:	7ee2      	lod	X, A

000086d4 <.LM24>:
    bool retval = true;
    uint8_t bytes[sizeof(valve_config_t)];

    bytes[0] = (uint8_t)((uint16_t)config->E1DATA0 & 0xFF);
    86d4:	7af8      	lod	Y, [X]
    86d6:	4605      	mov	[S-6], YL

000086d8 <.LM25>:
    bytes[1] = (uint8_t)(((uint16_t)config->E1DATA0 >> 8) & 0xFF);
    86d8:	4e04      	mov	[S-5], YH

000086da <.LM26>:
    bytes[2] = (uint8_t)((uint16_t)config->E1DATA1 & 0xFF);
    86da:	7afa      	lod	Y, [X+2]
    86dc:	4603      	mov	[S-4], YL

000086de <.LM27>:
    bytes[3] = (uint8_t)(((uint16_t)config->E1DATA1 >> 8) & 0xFF);
    86de:	4e02      	mov	[S-3], YH

000086e0 <.LM28>:
    bytes[4] = (uint8_t)((uint16_t)config->E1DATA2 & 0xFF);
    86e0:	72fc      	lod	A, [X+4]

000086e2 <.LVL23>:
    86e2:	4201      	mov	[S-2], AL

000086e4 <.LM29>:
    bytes[5] = (uint8_t)(((uint16_t)config->E1DATA2 >> 8) & 0xFF);
    86e4:	4a00      	mov	[S-1], AH

000086e6 <.LM30>:

    (void)unirom_WritePage(1u, &bytes[0], sizeof(valve_config_t));
    86e6:	54ca 0006 	pushw	#6

000086ea <.LCFI12>:
    86ea:	72ef      	lod	A, S
    86ec:	a0f8      	add	A, #-8
    86ee:	52df      	push	A

000086f0 <.LCFI13>:
    86f0:	7001      	lod	A, #1
    86f2:	82db 4fda 	callf	0x9fb4 <_unirom_WritePage>

000086f6 <.LM31>:
    return retval;
}
    86f6:	7001      	lod	A, #1

000086f8 <.LCFI14>:
    86f8:	540b      	ret	#12

000086fa <_eeprom_ReadDiagConfig>:
 *
 * @retval  true  valid position found in eeprom.
 * @retval  false  otherwise.
 */
bool eeprom_ReadDiagConfig(valve_config_t *config)
{
    86fa:	5809      	inc	S, #10

000086fc <.LCFI15>:
    86fc:	7ae2      	lod	Y, A

000086fe <.LM33>:
    bool retval = false;
    uint8_t bytes[sizeof(valve_config_t)];
    (void)unirom_ReadPage(2u, &bytes[0], sizeof(valve_config_t));
    86fe:	54ca 0006 	pushw	#6

00008702 <.LCFI16>:
    8702:	72ef      	lod	A, S

00008704 <.LVL27>:
    8704:	a0f4      	add	A, #-12
    8706:	52df      	push	A

00008708 <.LCFI17>:
    8708:	7002      	lod	A, #2
    870a:	5a07      	mov	[S-8], Y
    870c:	82db 5014 	callf	0xa028 <_unirom_ReadPage>

00008710 <.LM34>:

    config->E1DATA0 = (uint16_t)(bytes[0] + ((uint16_t)bytes[1] << 8));
    8710:	620c      	lod	AL, [S-13]
    8712:	6800      	lod	AH, #0
    8714:	72e4      	swap	A
    8716:	5205      	mov	[S-6], A
    8718:	620d      	lod	AL, [S-14]
    871a:	5cf2      	usex	A
    871c:	7ee2      	lod	X, A
    871e:	7205      	lod	A, [S-6]
    8720:	a2ee      	add	A, X
    8722:	7a07      	lod	Y, [S-8]
    8724:	52f0      	mov	[Y], A

00008726 <.LM35>:
    config->E1DATA1 = (uint16_t)(bytes[2] + ((uint16_t)bytes[3] << 8));
    8726:	620a      	lod	AL, [S-11]
    8728:	6800      	lod	AH, #0
    872a:	72e4      	swap	A
    872c:	5205      	mov	[S-6], A
    872e:	620b      	lod	AL, [S-12]
    8730:	5cf2      	usex	A
    8732:	7ee2      	lod	X, A
    8734:	7205      	lod	A, [S-6]
    8736:	a2ee      	add	A, X
    8738:	52f2      	mov	[Y+2], A

0000873a <.LM36>:
    config->E1DATA2 = (uint16_t)(bytes[4] + ((uint16_t)bytes[5] << 8));
    873a:	6208      	lod	AL, [S-9]
    873c:	6800      	lod	AH, #0
    873e:	72e4      	swap	A
    8740:	5205      	mov	[S-6], A
    8742:	6209      	lod	AL, [S-10]
    8744:	5cf2      	usex	A
    8746:	7ee2      	lod	X, A
    8748:	7205      	lod	A, [S-6]
    874a:	a2ee      	add	A, X
    874c:	52f4      	mov	[Y+4], A

0000874e <.LM37>:

    retval = true;

    return retval;
}
    874e:	7001      	lod	A, #1

00008750 <.LCFI18>:
    8750:	540f      	ret	#16

00008752 <_eeprom_WriteDiagConfig>:
bool eeprom_WriteDiagConfig(valve_config_t *config)
{
    8752:	5805      	inc	S, #6

00008754 <.LCFI19>:
    8754:	7ee2      	lod	X, A

00008756 <.LM39>:
    bool retval = true;
    uint8_t bytes[sizeof(valve_config_t)];

    bytes[0] = (uint8_t)((uint16_t)config->E1DATA0 & 0xFF);
    8756:	7af8      	lod	Y, [X]
    8758:	4605      	mov	[S-6], YL

0000875a <.LM40>:
    bytes[1] = (uint8_t)(((uint16_t)config->E1DATA0 >> 8) & 0xFF);
    875a:	4e04      	mov	[S-5], YH

0000875c <.LM41>:
    bytes[2] = (uint8_t)((uint16_t)config->E1DATA1 & 0xFF);
    875c:	7afa      	lod	Y, [X+2]
    875e:	4603      	mov	[S-4], YL

00008760 <.LM42>:
    bytes[3] = (uint8_t)(((uint16_t)config->E1DATA1 >> 8) & 0xFF);
    8760:	4e02      	mov	[S-3], YH

00008762 <.LM43>:
    bytes[4] = (uint8_t)((uint16_t)config->E1DATA2 & 0xFF);
    8762:	72fc      	lod	A, [X+4]

00008764 <.LVL32>:
    8764:	4201      	mov	[S-2], AL

00008766 <.LM44>:
    bytes[5] = (uint8_t)(((uint16_t)config->E1DATA2 >> 8) & 0xFF);
    8766:	4a00      	mov	[S-1], AH

00008768 <.LM45>:

    (void)unirom_WritePage(2u, &bytes[0], sizeof(valve_config_t));
    8768:	54ca 0006 	pushw	#6

0000876c <.LCFI20>:
    876c:	72ef      	lod	A, S
    876e:	a0f8      	add	A, #-8
    8770:	52df      	push	A

00008772 <.LCFI21>:
    8772:	7002      	lod	A, #2
    8774:	82db 4fda 	callf	0x9fb4 <_unirom_WritePage>

00008778 <.LM46>:
    return retval;
}
    8778:	7001      	lod	A, #1

0000877a <.LCFI22>:
    877a:	540b      	ret	#12

0000877c <_valve_gmr_write>:
    {
    }
}
void valve_gmr_write(uint16_t data1, uint16_t data2, uint16_t data3)
{
    valve_gmr_data.E1DATA0 = data1;
    877c:	7eda 1324 	lod	X, #4900
    8780:	52f8      	mov	[X], A

00008782 <.LM55>:
    else
    {
    }
}
void valve_gmr_write(uint16_t data1, uint16_t data2, uint16_t data3)
{
    8782:	7203      	lod	A, [S-4]

00008784 <.LM56>:
    valve_gmr_data.E1DATA0 = data1;
    valve_gmr_data.E1DATA1 = data2;
    8784:	52d8 1326 	mov	0x1326 <_valve_gmr_data+0x2>, A

00008788 <.LM57>:
    else
    {
    }
}
void valve_gmr_write(uint16_t data1, uint16_t data2, uint16_t data3)
{
    8788:	7205      	lod	A, [S-6]

0000878a <.LM58>:
    valve_gmr_data.E1DATA0 = data1;
    valve_gmr_data.E1DATA1 = data2;
    valve_gmr_data.E1DATA2 = data3;
    878a:	52d8 1328 	mov	0x1328 <_valve_gmr_data+0x4>, A

0000878e <.LM59>:
    (void)eeprom_WriteValveConfig(&valve_gmr_data);
    878e:	72ee      	lod	A, X
    8790:	179f      	call	0x86d0 <_eeprom_WriteValveConfig>

00008792 <.LBB6>:
}
void eeprom_StoreUserDataConfig(uint16_t index)
{
    if (index == 1)
    {
        (void)unirom_StorePage(1u);
    8792:	7001      	lod	A, #1
    8794:	76da 4fb6 	jmpf	0x9f6c <_unirom_StorePage>

00008798 <_valve_diag_write>:
    (void)eeprom_WriteValveConfig(&valve_gmr_data);
    eeprom_StoreUserDataConfig(1);
}
void valve_diag_write(uint16_t data1, uint16_t data2, uint16_t data3)
{
    valve_diag_data.E1DATA0 = data1;
    8798:	7eda 131e 	lod	X, #4894
    879c:	52f8      	mov	[X], A

0000879e <.LM64>:
    valve_gmr_data.E1DATA2 = data3;
    (void)eeprom_WriteValveConfig(&valve_gmr_data);
    eeprom_StoreUserDataConfig(1);
}
void valve_diag_write(uint16_t data1, uint16_t data2, uint16_t data3)
{
    879e:	7203      	lod	A, [S-4]

000087a0 <.LM65>:
    valve_diag_data.E1DATA0 = data1;
    valve_diag_data.E1DATA1 = data2;
    87a0:	52d8 1320 	mov	0x1320 <.LLST10>, A

000087a4 <.LM66>:
    valve_gmr_data.E1DATA2 = data3;
    (void)eeprom_WriteValveConfig(&valve_gmr_data);
    eeprom_StoreUserDataConfig(1);
}
void valve_diag_write(uint16_t data1, uint16_t data2, uint16_t data3)
{
    87a4:	7205      	lod	A, [S-6]

000087a6 <.LM67>:
    valve_diag_data.E1DATA0 = data1;
    valve_diag_data.E1DATA1 = data2;
    valve_diag_data.E1DATA2 = data3;
    87a6:	52d8 1322 	mov	0x1322 <.LLST10+0x2>, A

000087aa <.LM68>:
    (void)eeprom_WriteDiagConfig(&valve_diag_data);
    87aa:	72ee      	lod	A, X
    87ac:	17d2      	call	0x8752 <_eeprom_WriteDiagConfig>

000087ae <.LBB8>:
    {
        (void)unirom_StorePage(1u);
    }
    else if (index == 2)
    {
        (void)unirom_StorePage(2u);
    87ae:	7002      	lod	A, #2
    87b0:	76da 4fb6 	jmpf	0x9f6c <_unirom_StorePage>

000087b4 <_FILTER_AVG_CalcMovAvg>:
 * @brief add a value in the AVG buffer and calculates the moving average
 * @param a_pHandler The handle (pointer to FILTER_AVG_Object_t structure) to the FILTER_AVG object
 * @param a_u16NewValue A new value to add to the moving-average buffer
 */
void FILTER_AVG_CalcMovAvg(FILTER_AVG_Object_t* const a_pHandler, uint16_t a_u16NewValue)
{
    87b4:	580d      	inc	S, #14

000087b6 <.LCFI1>:
    87b6:	5205      	mov	[S-6], A

000087b8 <.LM13>:
    uint16_t *pu16Element = &a_pHandler->pu16Raw[a_pHandler->u16RawIdx];
    87b8:	7ae2      	lod	Y, A
    87ba:	e00a      	add	Y, #10
    87bc:	72f0      	lod	A, [Y]

000087be <.LVL5>:
    87be:	4422      	asl	A
    87c0:	7e05      	lod	X, [S-6]
    87c2:	7efe      	lod	X, [X+6]
    87c4:	22e2      	add	X, A
    87c6:	5e07      	mov	[S-8], X

000087c8 <.LM14>:
    a_pHandler->u16RawIdx = (a_pHandler->u16RawIdx + 1u) & (a_pHandler->u16Size - 1u);  /* Increment index */
    87c8:	7e05      	lod	X, [S-6]

000087ca <.LVL7>:
    87ca:	2008      	add	X, #8
    87cc:	5e0d      	mov	[S-14], X
    87ce:	72f8      	lod	A, [X]
    87d0:	5201      	mov	[S-2], A
    87d2:	a0ff      	add	A, #-1
    87d4:	7ef0      	lod	X, [Y]
    87d6:	2001      	add	X, #1
    87d8:	b6ee      	and	A, X
    87da:	52f0      	mov	[Y], A

000087dc <.LM15>:
 * @brief add a value in the AVG buffer and calculates the moving average
 * @param a_pHandler The handle (pointer to FILTER_AVG_Object_t structure) to the FILTER_AVG object
 * @param a_u16NewValue A new value to add to the moving-average buffer
 */
void FILTER_AVG_CalcMovAvg(FILTER_AVG_Object_t* const a_pHandler, uint16_t a_u16NewValue)
{
    87dc:	7211      	lod	A, [S-18]

000087de <.LM16>:
    uint16_t *pu16Element = &a_pHandler->pu16Raw[a_pHandler->u16RawIdx];
    a_pHandler->u16RawIdx = (a_pHandler->u16RawIdx + 1u) & (a_pHandler->u16Size - 1u);  /* Increment index */
    uint16_t u16Oldest = *pu16Element;
    a_pHandler->u32MovAvgxN -= u16Oldest;  /* Subtract oldest raw element */
    a_pHandler->u32MovAvgxN += (uint32_t)a_u16NewValue;  /* Add newest raw element */
    87de:	4cc8      	movu	D, A
    87e0:	7a05      	lod	Y, [S-6]
    87e2:	72f2      	lod	A, [Y+2]
    87e4:	7af4      	lod	Y, [Y+4]
    87e6:	4c00      	add	D, YA

000087e8 <.LM17>:
void FILTER_AVG_CalcMovAvg(FILTER_AVG_Object_t* const a_pHandler, uint16_t a_u16NewValue)
{
    uint16_t *pu16Element = &a_pHandler->pu16Raw[a_pHandler->u16RawIdx];
    a_pHandler->u16RawIdx = (a_pHandler->u16RawIdx + 1u) & (a_pHandler->u16Size - 1u);  /* Increment index */
    uint16_t u16Oldest = *pu16Element;
    a_pHandler->u32MovAvgxN -= u16Oldest;  /* Subtract oldest raw element */
    87e8:	7a07      	lod	Y, [S-8]
    87ea:	4ced      	movu	YA, [Y]

000087ec <.LM18>:
    a_pHandler->u32MovAvgxN += (uint32_t)a_u16NewValue;  /* Add newest raw element */
    87ec:	4c10      	sub	D, YA
    87ee:	7e05      	lod	X, [S-6]
    87f0:	2002      	add	X, #2
    87f2:	4c87      	mov	[X], D

000087f4 <.LM19>:
    *pu16Element = (uint16_t)a_u16NewValue;  /* Overwrite oldest with newest element */
    87f4:	7211      	lod	A, [S-18]

000087f6 <.LVL10>:
    87f6:	7a07      	lod	Y, [S-8]

000087f8 <.LVL11>:
    87f8:	52f0      	mov	[Y], A

000087fa <.LBB4>:
MATHLIB_INLINE_STATIC __inline__ uint16_t divU16_U32byU16(uint32_t dividend, uint16_t divisor)
{
    uint16_t result;
    uint16_t result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    87fa:	7e0d      	lod	X, [S-14]
    87fc:	7ef8      	lod	X, [X]
    87fe:	5e07      	mov	[S-8], X
    8800:	4c80      	mov	YA, D
    8802:	4c63      	divu	YA, X
    8804:	4c63      	divu	YA, X

00008806 <.LBE4>:
    a_pHandler->u16MovAvg = divU16_U32byU16(a_pHandler->u32MovAvgxN, a_pHandler->u16Size);
    8806:	7a05      	lod	Y, [S-6]
    8808:	52f0      	mov	[Y], A

0000880a <.LM22>:
}
    880a:	540f      	ret	#16

0000880c <_Generic_INT>:
}

#ifndef HAS_SW_EXPLICIT_FAIL_INFO
/* Generic interrupt handler */
WEAK_INTERRUPT void Generic_INT(void)
{
    880c:	5edf      	push	X

0000880e <.LCFI0>:
    880e:	5adf      	push	Y

00008810 <.LCFI1>:
    8810:	52df      	push	A

00008812 <.LCFI2>:
    8812:	4c83      	push	D

00008814 <.LBB8>:
}

STATIC INLINE void ErrH_FatalInformed(ErrH_Identifier information)
{
    UNUSED(information);
    _fatal();
    8814:	82db 1b23 	callf	0x3646 <__fatal>

00008818 <_fw_mls_ErrorDetected>:

    plinEventTable->ldt_ErrorDetected = fw_mls_ErrorDetected;
}

void fw_mls_ErrorDetected(ml_LinError_t error)
{
    8818:	5803      	inc	S, #4

0000881a <.LCFI0>:
    881a:	5203      	mov	[S-4], A

0000881c <.LBB76>:
    for (uint8_t cnt = 0; cnt < ld_ErrorDetectedMultipleHandler.eventsCount; cnt++) {
    881c:	62d8 13cf 	lod	AL, 0x13cf <.LLST5>

00008820 <.LVL2>:
    8820:	1915      	je	0x884c <.L2>
    8822:	7000      	lod	A, #0
    8824:	5201      	mov	[S-2], A

00008826 <.L3>:
        ld_ErrorDetectedMultipleHandler.eventHandlerBuffer[cnt](error);
    8826:	7201      	lod	A, [S-2]
    8828:	4422      	asl	A
    882a:	7ed8 13cc 	lod	X, 0x13cc <_ld_ErrorDetectedMultipleHandler>
    882e:	22e2      	add	X, A
    8830:	7ef8      	lod	X, [X]
    8832:	7203      	lod	A, [S-4]
    8834:	0001      	jmp	0x8838 <.L13>

00008836 <.L12>:
    8836:	76ee      	jmp	X

00008838 <.L13>:
    8838:	17fe      	call	0x8836 <.L12>

0000883a <.LM4>:
    plinEventTable->ldt_ErrorDetected = fw_mls_ErrorDetected;
}

void fw_mls_ErrorDetected(ml_LinError_t error)
{
    for (uint8_t cnt = 0; cnt < ld_ErrorDetectedMultipleHandler.eventsCount; cnt++) {
    883a:	6201      	lod	AL, [S-2]
    883c:	8001      	add	AL, #1
    883e:	66e0      	lod	YL, AL

00008840 <.LVL5>:
    8840:	5cf2      	usex	A

00008842 <.LVL6>:
    8842:	5201      	mov	[S-2], A
    8844:	62d8 13cf 	lod	AL, 0x13cf <.LLST5>
    8848:	8ee8      	cmp	AL, YL
    884a:	1e6d      	jug	0x8826 <.L3>

0000884c <.L2>:
        ld_ErrorDetectedMultipleHandler.eventHandlerBuffer[cnt](error);
    }
	if (g_u8LinErrorCnt < 0xFFu)
    884c:	62d8 1187 	lod	AL, 0x1187 <_g_u8LinErrorCnt>
    8850:	66e0      	lod	YL, AL
    8852:	5cf6      	usex	Y
    8854:	eeda 00ff 	cmp	Y, #255
    8858:	1903      	je	0x8860 <.L4>

0000885a <.LM6>:
	{
		g_u8LinErrorCnt++;
    885a:	8001      	add	AL, #1
    885c:	42d8 1187 	mov	0x1187 <_g_u8LinErrorCnt>, AL

00008860 <.L4>:
	}
	g_u8LinErrorCode=error;
    8860:	6203      	lod	AL, [S-4]
    8862:	42d8 1186 	mov	0x1186 <_g_u8LinErrorCode>, AL

00008866 <.LM8>:
}
    8866:	5405      	ret	#6

00008868 <_fw_mls_Init>:
#include "io.h"

/** Set the MLX4 clock divider on top of MLX16 clock */
STATIC INLINE void mls_SetMlx4ClockDivider(void)
{
    IO_SET(COLIN, SPEED, (uint16_t)LIN_CLK_DIV);
    8868:	62d8 01bc 	lod	AL, 0x1bc <.LASF1349+0x7>
    886c:	94f8      	and	AL, #-8
    886e:	42d8 01bc 	mov	0x1bc <.LASF1349+0x7>, AL

00008872 <.LBE77>:

void fw_mls_Init(void)
{
    mls_SetMlx4ClockDivider();
#if ML_HAS_LIN_EVENT_TABLE_IN_RAM == 0
    ml_InitLinEventTable(&fwlinEventTable);
    8872:	72da 1168 	lod	A, #4456
    8876:	82db 20b9 	callf	0x4172 <_ml_InitLinEventTable>

0000887a <.LM12>:
#endif /* ML_HAS_LIN_EVENT_TABLE_IN_RAM == 0 */

    /* Initialize LIN TL */
    ld_RequestMultipleHandler.eventHandlerBuffer = ld_RequestMHBuffer;
    887a:	72da 1162 	lod	A, #4450
    887e:	0ea7      	lod	C, ML.7
    8880:	52d8 13c4 	mov	0x13c4 <_ld_RequestMultipleHandler>, A

00008884 <.LM13>:
    ld_RequestMultipleHandler.eventsMaxLength = MLS_TL_MAX_NUMBER_OF_SUBSCRIBERS;
    8884:	7003      	lod	A, #3
    8886:	52d8 13c6 	mov	0x13c6 <_ld_RequestMultipleHandler+0x2>, A

0000888a <.LM14>:
    ld_RequestMultipleHandler.eventsCount = 0u;
    ld_ResponseTransmittedMultipleHandler.eventHandlerBuffer = ld_ResponseTransmittedMHBuffer;
    888a:	0ea7      	lod	C, ML.7
    888c:	7eda 115c 	lod	X, #4444
    8890:	5ed8 13c0 	mov	0x13c0 <_ld_ResponseTransmittedMultipleHandler>, X

00008894 <.LM15>:
    ld_ResponseTransmittedMultipleHandler.eventsMaxLength = MLS_TL_MAX_NUMBER_OF_SUBSCRIBERS;
    8894:	52d8 13c2 	mov	0x13c2 <_ld_ResponseTransmittedMultipleHandler+0x2>, A

00008898 <.LM16>:
    ld_ResponseTransmittedMultipleHandler.eventsCount = 0u;
    ld_FunctionalRequestMultipleHandler.eventHandlerBuffer = ld_FunctionalRequestMHBuffer;
    8898:	0ea7      	lod	C, ML.7
    889a:	7eda 1156 	lod	X, #4438
    889e:	5ed8 13c8 	mov	0x13c8 <_ld_FunctionalRequestMultipleHandler>, X

000088a2 <.LM17>:
    ld_FunctionalRequestMultipleHandler.eventsMaxLength = MLS_TL_MAX_NUMBER_OF_SUBSCRIBERS;
    88a2:	52d8 13ca 	mov	0x13ca <_ld_FunctionalRequestMultipleHandler+0x2>, A

000088a6 <.LM18>:
    ld_FunctionalRequestMultipleHandler.eventsCount = 0u;
    ld_ErrorDetectedMultipleHandler.eventHandlerBuffer = ld_ErrorDetectedMHBuffer;
    88a6:	0ea7      	lod	C, ML.7
    88a8:	7eda 1150 	lod	X, #4432
    88ac:	5ed8 13cc 	mov	0x13cc <_ld_ErrorDetectedMultipleHandler>, X

000088b0 <.LM19>:
    ld_ErrorDetectedMultipleHandler.eventsMaxLength = MLS_TL_MAX_NUMBER_OF_SUBSCRIBERS;
    88b0:	52d8 13ce 	mov	0x13ce <_ld_ErrorDetectedMultipleHandler+0x2>, A

000088b4 <.LM20>:
    ld_ErrorDetectedMultipleHandler.eventsCount = 0u;

    Itc_Clear(COLIN_LIN);
    88b4:	0ea7      	lod	C, ML.7
    88b6:	6002      	lod	AL, #2
    88b8:	42d8 0055 	mov	0x55 <.Lframe0+0x1>, AL

000088bc <.LM21>:
    Itc_SetPrio(COLIN_LIN, MLS_IRQ_PRIO);
    88bc:	62d8 008d 	lod	AL, 0x8d <.LASF1526+0x1>
    88c0:	94f3      	and	AL, #-13
    88c2:	8408      	or	AL, #8
    88c4:	42d8 008d 	mov	0x8d <.LASF1526+0x1>, AL

000088c8 <.LM22>:
    Itc_Enable(COLIN_LIN);
    88c8:	62d8 0071 	lod	AL, 0x71 <__mlx4_cst_tables_ram_size+0x13>
    88cc:	8402      	or	AL, #2
    88ce:	42d8 0071 	mov	0x71 <__mlx4_cst_tables_ram_size+0x13>, AL

000088d2 <.LM23>:
}
    88d2:	5401      	ret

000088d4 <_fw_mls_TransportLayerInit>:

void fw_mls_TransportLayerInit(void)
{
    ldt_Init(&ldt_TL_data,
    88d4:	54ca 13c8 	pushw	#5064

000088d8 <.LCFI1>:
    88d8:	54ca 13c0 	pushw	#5056

000088dc <.LCFI2>:
    88dc:	54ca 13c4 	pushw	#5060

000088e0 <.LCFI3>:
    88e0:	0ea7      	lod	C, ML.7
    88e2:	54ca 0000 	pushw	#0

000088e6 <.LCFI4>:
    88e6:	72da 132a 	lod	A, #4906
    88ea:	82db 1fb0 	callf	0x3f60 <_ldt_Init>

000088ee <.LM26>:

#if FW_LIN_TL_FUNCTIONAL_NAD_FIX == 1
    (void)ldt_SubscribeMultipleHandler(plinEventTable->ldt_ResponseTransmitted, fw_mls_ldt_CustomResponseTransmitted);
#endif

    plinEventTable->ldt_ErrorDetected = fw_mls_ErrorDetected;
    88ee:	7ed8 1002 	lod	X, 0x1002 <_plinEventTable>
    88f2:	2016      	add	X, #22
    88f4:	72da 440c 	lod	A, #17420
    88f8:	52f8      	mov	[X], A

000088fa <.LCFI5>:
}
    88fa:	5409      	ret	#10

000088fc <__COLIN_LIN_INT>:
#endif /* FW_LIN_TL_FUNCTIONAL_NAD_FIX */

/** LIN interrupt handler
 */
__attribute__((interrupt)) void _COLIN_LIN_INT(void)
{
    88fc:	5edf      	push	X

000088fe <.LCFI6>:
    88fe:	5adf      	push	Y

00008900 <.LCFI7>:
    8900:	52df      	push	A

00008902 <.LCFI8>:
    8902:	4c83      	push	D

00008904 <.LCFI9>:
    ml_LinInterruptHandler();
    8904:	82db 20d0 	callf	0x41a0 <_ml_LinInterruptHandler>

00008908 <.LM30>:
}
    8908:	4cc3      	pop	D

0000890a <.LCFI10>:
    890a:	72cf      	pop	A

0000890c <.LCFI11>:
    890c:	7acf      	pop	Y

0000890e <.LCFI12>:
    890e:	7ecf      	pop	X

00008910 <.LCFI13>:
    8910:	72cb      	pop	M
    8912:	5401      	ret

00008914 <_fw_lepm_ResponseTransmitted>:
STATIC bool fw_lepm_ResponseTransmitted(LINDiagTransfer_t* transfer)
{
    (void)transfer;

#if HAS_PPM_EPM == 1
    if (lepmFlag == true) {
    8914:	62d8 1188 	lod	AL, 0x1188 <_lepmFlag>

00008918 <.LVL1>:
    8918:	1904      	je	0x8922 <.L2>

0000891a <.LM3>:
        MLX16_RESET_SIGNED((uint16_t)C_CHIP_STATE_PPM_CMD_EPM);
    891a:	72da b065 	lod	A, #45157
    891e:	82db 1503 	callf	0x2a06 <_MLX16_RESET_SIGNED>

00008922 <.L2>:
    8922:	62d8 1189 	lod	AL, 0x1189 <_isAwaitingResponseTransmitted>
    8926:	5cf2      	usex	A

00008928 <.LM4>:
        return true;
    } else {
        /* The event is intended for the next LIN TL subscribers */
        return false;
    }
}
    8928:	5401      	ret

0000892a <_fw_lepm_Init>:
}

void fw_lepm_Init(void)
{
    /* LIN TL */
    (void)ldt_SubscribeMultipleHandler(&ld_RequestMultipleHandler, fw_lepm_Request);
    892a:	54ca 44a5 	pushw	#17573

0000892e <.LCFI0>:
    892e:	72da 13c4 	lod	A, #5060
    8932:	82db 2005 	callf	0x400a <_ldt_SubscribeMultipleHandler>

00008936 <.LM7>:
    (void)ldt_SubscribeMultipleHandler(&ld_ResponseTransmittedMultipleHandler, fw_lepm_ResponseTransmitted);
    8936:	54ca 448a 	pushw	#17546

0000893a <.LCFI1>:
    893a:	72da 13c0 	lod	A, #5056
    893e:	82db 2005 	callf	0x400a <_ldt_SubscribeMultipleHandler>

00008942 <.LM8>:

    /* LIN EPM specific */
#if HAS_PPM_EPM == 1
    lepmFlag = false;
    8942:	6000      	lod	AL, #0
    8944:	42d8 1188 	mov	0x1188 <_lepmFlag>, AL

00008948 <.LCFI2>:
#endif
}
    8948:	5405      	ret	#6

0000894a <_fw_lepm_Request>:
    /* Always allow enter programming mode by default */
    return true;
}

STATIC bool fw_lepm_Request(LINDiagTransfer_t* transfer)
{
    894a:	5803      	inc	S, #4

0000894c <.LCFI3>:
    894c:	7ae2      	lod	Y, A

0000894e <.LM13>:
     *   returns PLTF_VERSION + TYPE
     *
     * - Read by ID=LE_MLX_PATCH_ID, LE_MLX_SUPPLIER_ID, LE_MLX_FUNCTION_ID_GET_CHIP_VERSION (no broadcasts supported);
     *   returns patch identification
     */
    if (transfer->request.reqSId == LE_READ_BY_ID_SID) {
    894e:	62f0      	lod	AL, [Y]

00008950 <.LVL7>:
    8950:	8cb2      	cmp	AL, #-78
    8952:	1902      	je	0x8958 <.L6>

00008954 <.L25>:
    return true;
}

STATIC bool fw_lepm_Request(LINDiagTransfer_t* transfer)
{
    bool isAnswerExpected = false;
    8954:	7000      	lod	A, #0
    8956:	002e      	jmp	0x89b4 <.L26>

00008958 <.L6>:
     *
     * - Read by ID=LE_MLX_PATCH_ID, LE_MLX_SUPPLIER_ID, LE_MLX_FUNCTION_ID_GET_CHIP_VERSION (no broadcasts supported);
     *   returns patch identification
     */
    if (transfer->request.reqSId == LE_READ_BY_ID_SID) {
        if (transfer->request.dataLen <= LE_MIN_RBI_DATA_LEN) {
    8958:	72f2      	lod	A, [Y+2]
    895a:	ac05      	cmp	A, #5
    895c:	1e7b      	jug	0x8954 <.L25>

0000895e <.LBB20>:

            fw_lepm_ReadByIdProdIdReq_t* pProdIdReq = (fw_lepm_ReadByIdProdIdReq_t*)transfer->request.data;

            if ((pProdIdReq->supp_id == LE_MLX_SUPPLIER_ID)) {
    895e:	7ee6      	lod	X, Y
    8960:	2005      	add	X, #5
    8962:	62f8      	lod	AL, [X]
    8964:	6af9      	lod	AH, [X+1]
    8966:	ac13      	cmp	A, #19
    8968:	1d75      	jne	0x8954 <.L25>

0000896a <.LM17>:
                switch (pProdIdReq->id) {
    896a:	62f4      	lod	AL, [Y+4]
    896c:	4203      	mov	[S-4], AL
    896e:	6203      	lod	AL, [S-4]
    8970:	8c34      	cmp	AL, #52
    8972:	1d01      	jne	0x8976 <.LASF133+0xb>
    8974:	0042      	jmp	0x89fa <.L9>
    8976:	5cf2      	usex	A
    8978:	ac35      	cmp	A, #53
    897a:	1d01      	jne	0x897e <.LASF143+0x7>
    897c:	0052      	jmp	0x8a22 <.L10>
    897e:	ac33      	cmp	A, #51
    8980:	1d69      	jne	0x8954 <.L25>

00008982 <.LM18>:
                    case LE_MLX_SPECIAL_ID:
                        if ((pProdIdReq->func_id == LE_MLX_FUNCTION_ID_GET_CHIP_VERSION)
    8982:	7ee6      	lod	X, Y
    8984:	2007      	add	X, #7
    8986:	62f8      	lod	AL, [X]
    8988:	6af9      	lod	AH, [X+1]
    898a:	94bf      	and	AL, #-65
    898c:	aeda cabc 	cmp	A, #51900
    8990:	1d13      	jne	0x89b8 <.L12>

00008992 <.LBB21>:
}

STATIC void fw_lepm_PrepareProdResponse(LINDiagTransfer_t* transfer)
{
    /* Use Response SID */
    transfer->response.respSId = LE_READ_BY_ID_RSID;
    8992:	60f2      	lod	AL, #-14
    8994:	42f0      	mov	[Y], AL

00008996 <.LM20>:
    transfer->response.dataLen = 5u;
    8996:	7005      	lod	A, #5
    8998:	52f2      	mov	[Y+2], A

0000899a <.LM21>:

    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_ProdIdRes_t* pDeviceVerRev = (fw_lepm_ProdIdRes_t*)transfer->response.data;
    pDeviceVerRev->prod_id_low = (uint16_t)PRODUCT_VERSION_32;
    899a:	72d8 0a36 	lod	A, 0xa36 <.LASF1407+0x9>
    899e:	42f4      	mov	[Y+4], AL
    89a0:	4af5      	mov	[Y+5], AH

000089a2 <.LM22>:
    pDeviceVerRev->prod_id_high = (uint16_t)(PRODUCT_VERSION_32 >> 16);
    89a2:	20ff      	add	X, #-1
    89a4:	6000      	lod	AL, #0
    89a6:	42f8      	mov	[X], AL
    89a8:	42f9      	mov	[X+1], AL

000089aa <.LM23>:
    pDeviceVerRev->reserved = 0xFFu; /* it's reserved */
    89aa:	e008      	add	Y, #8

000089ac <.LVL13>:
    89ac:	72da 00ff 	lod	A, #255

000089b0 <.L28>:
    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_PltfRevRes_t* pPltfRevResp = (fw_lepm_PltfRevRes_t*)transfer->response.data;
    pPltfRevResp->major = RELEASE_MAJOR;
    pPltfRevResp->minor = RELEASE_MINOR;
    pPltfRevResp->patch = RELEASE_REVISION;
    pPltfRevResp->build = 0x00u;
    89b0:	42f0      	mov	[Y], AL

000089b2 <.L27>:
                    case LE_MLX_PATCH_ID:
                        if ((pProdIdReq->func_id == LE_MLX_FUNCTION_ID_GET_CHIP_VERSION)
                            || (pProdIdReq->func_id ==
                                fw_lepm_GetFuncIdAllModes(LE_MLX_FUNCTION_ID_GET_CHIP_VERSION))) {
                            fw_lepm_PreparePatchRevResponse(transfer);
                            isAnswerExpected = true;
    89b2:	7001      	lod	A, #1

000089b4 <.L26>:
    return true;
}

STATIC bool fw_lepm_Request(LINDiagTransfer_t* transfer)
{
    bool isAnswerExpected = false;
    89b4:	5203      	mov	[S-4], A
    89b6:	001c      	jmp	0x89f0 <.L7>

000089b8 <.L12>:
                                fw_lepm_GetFuncIdAllModes(LE_MLX_FUNCTION_ID_GET_CHIP_VERSION))) {
                            /* Prepare response with product identifiers */
                            fw_lepm_PrepareProdResponse(transfer);
                            isAnswerExpected = true;
#if HAS_PPM_EPM == 1
                        } else if ((pProdIdReq->func_id == LE_MLX_FUNCTION_ID_ENTER_PPM_MODE)
    89b8:	aeda cabd 	cmp	A, #51901
    89bc:	1d4b      	jne	0x8954 <.L25>

000089be <.LM28>:
                                   || (pProdIdReq->func_id ==
                                       fw_lepm_GetFuncIdAllModes(LE_MLX_FUNCTION_ID_ENTER_PPM_MODE))) {
                            if (fw_lepm_ApplicationStop()) {
    89be:	5a01      	mov	[S-2], Y
    89c0:	11cf      	call	0x8d60 <_fw_lepm_ApplicationStop>

000089c2 <.LVL17>:
    89c2:	5203      	mov	[S-4], A
    89c4:	7a01      	lod	Y, [S-2]
    89c6:	ac00      	cmp	A, #0
    89c8:	1945      	je	0x8954 <.L25>

000089ca <.LM29>:
                                /* Set PPM mode flag */
                                lepmFlag = true;
    89ca:	6001      	lod	AL, #1
    89cc:	42d8 1188 	mov	0x1188 <_lepmFlag>, AL

000089d0 <.LBB26>:
}

STATIC void fw_lepm_PrepareProdResponse(LINDiagTransfer_t* transfer)
{
    /* Use Response SID */
    transfer->response.respSId = LE_READ_BY_ID_RSID;
    89d0:	60f2      	lod	AL, #-14
    89d2:	42f0      	mov	[Y], AL

000089d4 <.LM31>:
    transfer->response.dataLen = 5u;
    89d4:	7005      	lod	A, #5
    89d6:	52f2      	mov	[Y+2], A

000089d8 <.LM32>:

    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_ProdIdRes_t* pDeviceVerRev = (fw_lepm_ProdIdRes_t*)transfer->response.data;
    pDeviceVerRev->prod_id_low = (uint16_t)PRODUCT_VERSION_32;
    89d8:	72d8 0a36 	lod	A, 0xa36 <.LASF1407+0x9>
    89dc:	42f4      	mov	[Y+4], AL
    89de:	4af5      	mov	[Y+5], AH

000089e0 <.LM33>:
    pDeviceVerRev->prod_id_high = (uint16_t)(PRODUCT_VERSION_32 >> 16);
    89e0:	7ee6      	lod	X, Y
    89e2:	2006      	add	X, #6
    89e4:	6000      	lod	AL, #0
    89e6:	42f8      	mov	[X], AL
    89e8:	42f9      	mov	[X+1], AL

000089ea <.LM34>:
    pDeviceVerRev->reserved = 0xFFu; /* it's reserved */
    89ea:	e008      	add	Y, #8

000089ec <.LVL20>:
    89ec:	60ff      	lod	AL, #-1
    89ee:	42f0      	mov	[Y], AL

000089f0 <.L7>:
        /* ignore other diagnostic messages */
    }

    /* If MLS device ID response is prepared then it's true;
     * in the case of new application specific request after - it's false */
    isAwaitingResponseTransmitted = isAnswerExpected;
    89f0:	6203      	lod	AL, [S-4]
    89f2:	42d8 1189 	mov	0x1189 <_isAwaitingResponseTransmitted>, AL

000089f6 <.LM36>:
    return isAnswerExpected;
}
    89f6:	7203      	lod	A, [S-4]
    89f8:	5405      	ret	#6

000089fa <.L9>:
                            /* ignore unknown Function ID value */
                        }
                        break;

                    case LE_MLX_PLTF_ID:
                        if ((pProdIdReq->func_id == LE_MLX_FUNCTION_ID_GET_CHIP_VERSION)
    89fa:	7ee6      	lod	X, Y
    89fc:	2007      	add	X, #7
    89fe:	62f8      	lod	AL, [X]
    8a00:	6af9      	lod	AH, [X+1]
    8a02:	94bf      	and	AL, #-65
    8a04:	aeda cabc 	cmp	A, #51900
    8a08:	1901      	je	0x8a0c <.LM38>
    8a0a:	07a4      	jmp	0x8954 <.L25>

00008a0c <.LM38>:
}

STATIC void fw_lepm_PreparePltfRevResponse(LINDiagTransfer_t* transfer)
{
    /* Use Response SID */
    transfer->response.respSId = LE_READ_BY_ID_RSID;
    8a0c:	60f2      	lod	AL, #-14
    8a0e:	42f0      	mov	[Y], AL

00008a10 <.LM39>:
    transfer->response.dataLen = LE_PLTF_REV_RES_DATA_LENGTH;
    8a10:	7005      	lod	A, #5
    8a12:	52f2      	mov	[Y+2], A
    8a14:	7eda 0101 	lod	X, #257
    8a18:	5ef4      	mov	[Y+4], X

00008a1a <.LM40>:

    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_PltfRevRes_t* pPltfRevResp = (fw_lepm_PltfRevRes_t*)transfer->response.data;
    pPltfRevResp->major = RELEASE_MAJOR;
    pPltfRevResp->minor = RELEASE_MINOR;
    8a1a:	7c04      	lod	X, #4
    8a1c:	5ef6      	mov	[Y+6], X

00008a1e <.LM41>:
    pPltfRevResp->patch = RELEASE_REVISION;
    pPltfRevResp->build = 0x00u;
    8a1e:	e008      	add	Y, #8

00008a20 <.LVL25>:
    8a20:	07c7      	jmp	0x89b0 <.L28>

00008a22 <.L10>:
                            /* ignore unknown Function ID value */
                        }
                        break;

                    case LE_MLX_PATCH_ID:
                        if ((pProdIdReq->func_id == LE_MLX_FUNCTION_ID_GET_CHIP_VERSION)
    8a22:	7ee6      	lod	X, Y
    8a24:	2007      	add	X, #7
    8a26:	62f8      	lod	AL, [X]
    8a28:	6af9      	lod	AH, [X+1]
    8a2a:	94bf      	and	AL, #-65
    8a2c:	aeda cabc 	cmp	A, #51900
    8a30:	1901      	je	0x8a34 <.LBB29>
    8a32:	0790      	jmp	0x8954 <.L25>

00008a34 <.LBB29>:
}

STATIC void fw_lepm_PreparePatchRevResponse(LINDiagTransfer_t* transfer)
{
    /* Use Response SID */
    transfer->response.respSId = LE_READ_BY_ID_RSID;
    8a34:	60f2      	lod	AL, #-14
    8a36:	42f0      	mov	[Y], AL

00008a38 <.LM44>:
    transfer->response.dataLen = LE_PATCH_REV_RES_DATA_LENGTH;
    8a38:	7002      	lod	A, #2
    8a3a:	52f2      	mov	[Y+2], A

00008a3c <.LM45>:

    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_PatchRevRes_t* pPatchRevResp = (fw_lepm_PatchRevRes_t*)transfer->response.data;

    /* Return patch identifier only when patch is enabled by ROM */
    if (((IO_GET(MLX16, DBG_CONTROL0) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
    8a3c:	72d8 0042 	lod	A, 0x42 <.LLST11+0x6>
    8a40:	d43f      	and	AH, #63
    8a42:	aeda 0410 	cmp	A, #1040
    8a46:	190c      	je	0x8a60 <.L13>

00008a48 <.LM46>:
        ((IO_GET(MLX16, DBG_CONTROL1) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
    8a48:	72d8 0046 	lod	A, 0x46 <.LLST11+0xa>
    8a4c:	d43f      	and	AH, #63

00008a4e <.LM47>:

    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_PatchRevRes_t* pPatchRevResp = (fw_lepm_PatchRevRes_t*)transfer->response.data;

    /* Return patch identifier only when patch is enabled by ROM */
    if (((IO_GET(MLX16, DBG_CONTROL0) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
    8a4e:	aeda 0410 	cmp	A, #1040
    8a52:	1906      	je	0x8a60 <.L13>

00008a54 <.LM48>:
        ((IO_GET(MLX16, DBG_CONTROL1) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
        ((IO_GET(MLX16, DBG_CONTROL2) & 0x3FFFu) == PATCH_CTRL_ENABLE)) {
    8a54:	72d8 004a 	lod	A, 0x4a <.LLST11+0xe>
    8a58:	d43f      	and	AH, #63

00008a5a <.LM49>:
    /* We can't guarantee that transfer->response.data is aligned to the 32-bits address */
    fw_lepm_PatchRevRes_t* pPatchRevResp = (fw_lepm_PatchRevRes_t*)transfer->response.data;

    /* Return patch identifier only when patch is enabled by ROM */
    if (((IO_GET(MLX16, DBG_CONTROL0) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
        ((IO_GET(MLX16, DBG_CONTROL1) & 0x3FFFu) == PATCH_CTRL_ENABLE) ||
    8a5a:	aeda 0410 	cmp	A, #1040
    8a5e:	1d04      	jne	0x8a68 <.L14>

00008a60 <.L13>:
        ((IO_GET(MLX16, DBG_CONTROL2) & 0x3FFFu) == PATCH_CTRL_ENABLE)) {
        pPatchRevResp->identifier = EE_HOST(PATCH_CRC);
    8a60:	7300      	lod	A, ep:0x0 <__bss_dp_size>
    8a62:	42f4      	mov	[Y+4], AL
    8a64:	4af5      	mov	[Y+5], AH
    8a66:	07a5      	jmp	0x89b2 <.L27>

00008a68 <.L14>:
    } else {
        pPatchRevResp->identifier = 0xFFFFu;
    8a68:	e004      	add	Y, #4

00008a6a <.LVL29>:
    8a6a:	60ff      	lod	AL, #-1
    8a6c:	42f0      	mov	[Y], AL
    8a6e:	42f1      	mov	[Y+1], AL
    8a70:	07a0      	jmp	0x89b2 <.L27>

00008a72 <_fw_low_level_init>:
    builtin_mlx16_set_priority(7);  /* system mode, the lowest priority: 7 */
}

void fw_low_level_init(void)
{
    if (nvram_CalcCRC((uint16_t*)EE_APP_TRIM_AREA_START, EE_APP_TRIM_AREA_SIZE >> 1) == NVRAM_CORRECT_CRC) {
    8a72:	54ca 0028 	pushw	#40

00008a76 <.LCFI0>:
    8a76:	72da 09b0 	lod	A, #2480
    8a7a:	82db 1511 	callf	0x2a22 <_nvram_CalcCRC>
    8a7e:	5c01      	dec	S, #2

00008a80 <.LCFI1>:
    8a80:	aeda 00ff 	cmp	A, #255
    8a84:	1901      	je	0x8a88 <.LM3>
    8a86:	004f      	jmp	0x8b26 <.L2>

00008a88 <.LM3>:
        /* load trimming data to io registers */
        IO_SET(TRIM1_DRV,
    8a88:	72d8 0208 	lod	A, 0x208 <_TRIM1_DRV>
    8a8c:	b6da f000 	and	A, #61440
    8a90:	7ed8 09ec 	lod	X, 0x9ec <.LASF1601+0x1>
    8a94:	3403      	and	X, #3
    8a96:	a6ee      	or	A, X
    8a98:	7ed8 09ec 	lod	X, 0x9ec <.LASF1601+0x1>
    8a9c:	36da 0ffc 	and	X, #4092
    8aa0:	a6ee      	or	A, X
    8aa2:	52d8 0208 	mov	0x208 <_TRIM1_DRV>, A

00008aa6 <.LM4>:
               TRIM_DRVSUP, EE_GET(TRIM_DRVSUP),             /* trim output level of driver supply */
               PRE_TRIM_DRVMOD_CPCLK, EE_GET(TRIM_CPCLK));   /* trim frequency of driver clock */
        IO_SET(TRIM2_DRV,
    8aa6:	72d8 020a 	lod	A, 0x20a <_TRIM2_DRV>
    8aaa:	b6da fe00 	and	A, #65024
    8aae:	0ea7      	lod	C, ML.7
    8ab0:	7ed8 09ee 	lod	X, 0x9ee <.LASF1601+0x3>
    8ab4:	340f      	and	X, #15
    8ab6:	a6ee      	or	A, X
    8ab8:	7ed8 09ee 	lod	X, 0x9ee <.LASF1601+0x3>
    8abc:	36da 01f0 	and	X, #496
    8ac0:	a6ee      	or	A, X
    8ac2:	52d8 020a 	mov	0x20a <_TRIM2_DRV>, A

00008ac6 <.LM5>:
               TRIM_SLWRT, EE_GET(TRIM_SLWRT),               /* trim slewrate / slope of drivers */
               TRIM_CSA_GAIN, EE_GET(TRIM_CSA_GAIN));        /* trim gain of current sense amplifier */
        IO_SET(TRIM3_DRV,
    8ac6:	62d8 09f1 	lod	AL, 0x9f1 <.LASF1601+0x6>
    8aca:	42d8 020c 	mov	0x20c <_TRIM3_DRV>, AL

00008ace <.LM6>:
               TRIM_CSA_CL, EE_GET(TRIM_CSA_CL_LOW));        /* trim over-current limit of current sense amplifier */
        IO_SET(TRIM_MISC,
    8ace:	0ea7      	lod	C, ML.7
    8ad0:	72d8 0206 	lod	A, 0x206 <_TRIM_MISC>
    8ad4:	b6da c000 	and	A, #49152
    8ad8:	7ed8 09f2 	lod	X, 0x9f2 <.LASF1601+0x7>
    8adc:	0ea7      	lod	C, ML.7
    8ade:	36da 0fc0 	and	X, #4032
    8ae2:	a6ee      	or	A, X
    8ae4:	7ed8 09f2 	lod	X, 0x9f2 <.LASF1601+0x7>
    8ae8:	36da 3000 	and	X, #12288
    8aec:	a6ee      	or	A, X
    8aee:	7ad8 09d0 	lod	Y, 0x9d0 <.Lframe0>
    8af2:	7ae8      	swap	Y
    8af4:	f43f      	and	Y, #63
    8af6:	a6e6      	or	A, Y
    8af8:	52d8 0206 	mov	0x206 <_TRIM_MISC>, A

00008afc <.LM7>:
               TRIM_OTD, EE_GET(TRIM_OTD),                   /* trim over temperature detection */
               TRIM_SDAFILT_IO, EE_GET(TRIM_SDAFILT_IO),     /* trim i2c sda filter/delay time */
               TRIM_LCD_LINAA, EE_GET(LINAA_TRIM_LCD_205));  /* trim linaa current */
        IO_SET(PORT_LINAA2,
    8afc:	62d8 0204 	lod	AL, 0x204 <_PORT_LINAA2>
    8b00:	94f8      	and	AL, #-8
    8b02:	7ad8 09d0 	lod	Y, 0x9d0 <.Lframe0>
    8b06:	44c6      	rl	Y, #2
    8b08:	f403      	and	Y, #3
    8b0a:	86e8      	or	AL, YL
    8b0c:	42d8 0204 	mov	0x204 <_PORT_LINAA2>, AL

00008b10 <.LM8>:
               LCD_SEL_LINAA, EE_GET(LINAA_LCD_SEL_205));    /* select adjustment of linaa current */
        IO_SET(PORT_LINAA1,
    8b10:	7ed8 0202 	lod	X, 0x202 <_PORT_LINAA1>
    8b14:	72d8 09d2 	lod	A, 0x9d2 <.LLST8>
    8b18:	6000      	lod	AL, #0
    8b1a:	72e4      	swap	A
    8b1c:	36da fe00 	and	X, #65024
    8b20:	a6ee      	or	A, X
    8b22:	52d8 0202 	mov	0x202 <_PORT_LINAA1>, A

00008b26 <.L2>:
               LINAA_DIV, EE_GET(LINAA_DIV));                /* linaa amplifier common-mode rejection adjustment */
    } else {
        /* load default values */
    }

    IO_SET(PORT_SUPP_CFG,
    8b26:	605f      	lod	AL, #95
    8b28:	42d8 01e4 	mov	0x1e4 <_PORT_SUPP_CFG>, AL

00008b2c <.LM10>:
           UV_VS_FILT_SEL, 1u,                      /* 100-110us filtering for VS under voltage */
           OV_VS_FILT_SEL, 1u,                      /* 100-110us filtering for VS over voltage */
           OVC_FILT_SEL, 0u,                        /* 1-2us filtering for over current */
           OVT_FILT_SEL, 1u);                       /* 100-110us filtering for over temperature */

    IO_SET(PORT_MISC_OUT, SEL_TEMP, 8u);            /* temperature channel selection */
    8b2c:	62d8 01f3 	lod	AL, 0x1f3 <_PORT_MISC_OUT+0x1>
    8b30:	940f      	and	AL, #15
    8b32:	8480      	or	AL, #-128
    8b34:	42d8 01f3 	mov	0x1f3 <_PORT_MISC_OUT+0x1>, AL

00008b38 <.LM11>:

    IO_SET(PORT_MISC2_OUT, ENABLE_OTD, 1u);         /* enable over-temperature detector */
    8b38:	62d8 01f5 	lod	AL, 0x1f5 <_PORT_MISC2_OUT+0x1>
    8b3c:	8402      	or	AL, #2
    8b3e:	42d8 01f5 	mov	0x1f5 <_PORT_MISC2_OUT+0x1>, AL

00008b42 <.LM12>:

    IO_SET(PORT_DRV1_PROT, OC_PM, 1u);              /* switch drivers to tri-state in case of over-current */
    8b42:	62d8 0219 	lod	AL, 0x219 <_PORT_DRV1_PROT+0x1>
    8b46:	8404      	or	AL, #4
    8b48:	42d8 0219 	mov	0x219 <_PORT_DRV1_PROT+0x1>, AL

00008b4c <.LM13>:
}
    8b4c:	5401      	ret

00008b4e <_fw_premain>:

void fw_premain(void)
{
	/* Initialize watch-dogs, both analogue and digital */
//	WDG_disableIwdIt();
    fw_low_level_init();            /* optionally call more low level initialization */
    8b4e:	1791      	call	0x8a72 <_fw_low_level_init>

00008b50 <.LM16>:

    fw_ram_section_init();          /* RAM initialization */
    8b50:	100b      	call	0x8b68 <_fw_ram_section_init>

00008b52 <.LM17>:
#if defined (HAS_PATCH_COLIN)
    patch_colin_Init();
#endif /* HAS_PATCH_COLIN */

#if defined (HAS_MLS_API)
    fw_mls_Init();                  /* MLX LIN Slave initialization */
    8b52:	168a      	call	0x8868 <_fw_mls_Init>

00008b54 <.LM18>:
#endif /* HAS_MLS_API */

#if defined (HAS_STD_LIN_API) || defined (HAS_MLS_DEVICE_ID) || defined (HAS_MLS_LOADER)
    fw_mls_TransportLayerInit();
    8b54:	16bf      	call	0x88d4 <_fw_mls_TransportLayerInit>

00008b56 <.LM19>:
#endif /* HAS_STD_LIN_API || HAS_MLS_DEVICE_ID || defined (HAS_MLS_LOADER) */

#if defined (HAS_MLS_DEVICE_ID)
    fw_lepm_Init();                 /* MLX LIN device ID initialization */
    8b56:	16e9      	call	0x892a <_fw_lepm_Init>

00008b58 <.LBB6>:
    ac_sel = 0u;
#elif FPLL == 28000
    tmp.u = EE_MS_TRIM7_VALUE;
    ac_sel = 0u;
#elif FPLL == 32000
    tmp.u = EE_MS_TRIM8_VALUE;
    8b58:	72d8 0a12 	lod	A, 0xa12 <.LASF1606+0x1>

00008b5c <.LM21>:
    ac_sel = 0u;
#else
    #warning "Clock Speed not valid, use 32MHz"
#endif

    SetSystemSpeed(tmp, ac_sel);
    8b5c:	54ca 0000 	pushw	#0

00008b60 <.LCFI2>:
    8b60:	82db 505e 	callf	0xa0bc <_SetSystemSpeed>

00008b64 <.LBB8>:
        );
}

STATIC INLINE void builtin_mlx16_set_priority(uint8_t level)
{
    __asm__ __volatile__ (
    8b64:	54f7      	mov	UPr, #7

00008b66 <.LBE8>:
    mls_loader_Init();
#endif /* HAS_MLS_LOADER */

    set_Clock_Speed();              /* set clock speed */
    builtin_mlx16_set_priority(7);  /* system mode, the lowest priority: 7 */
}
    8b66:	5403      	ret	#4

00008b68 <_fw_ram_section_init>:
#if !defined(RAM_APPLICATION)
    uint16_t* r;
#endif /* !RAM_APPLICATION */

    /* clear .bss and .dp.bss sections */
    for (w = &_bss_dp_start; w < &_bss_dp_end; ) {
    8b68:	7ada 101a 	lod	Y, #4122
    8b6c:	eeda 101a 	cmp	Y, #4122
    8b70:	1c08      	jnc	0x8b82 <.L2>
    8b72:	7eda 101a 	lod	X, #4122
    8b76:	2ae6      	sub	X, Y
    8b78:	1904      	je	0x8b82 <.L2>
    8b7a:	443e      	lsr	X
    8b7c:	7000      	lod	A, #0
    8b7e:	52d6      	mov	[Y++], A

00008b80 <L0>:
    8b80:	1bfe      	djnz	X, 0x8b7e <.LASF1600+0x14>

00008b82 <.L2>:
        *w++ = 0;
    }

    for (w = &_bss_start; w < &_bss_end; ) {
    8b82:	7ada 10aa 	lod	Y, #4266
    8b86:	eeda 142a 	cmp	Y, #5162
    8b8a:	1c08      	jnc	0x8b9c <.L4>
    8b8c:	7eda 142a 	lod	X, #5162
    8b90:	2ae6      	sub	X, Y
    8b92:	1904      	je	0x8b9c <.L4>
    8b94:	443e      	lsr	X
    8b96:	7000      	lod	A, #0
    8b98:	52d6      	mov	[Y++], A

00008b9a <L0>:
    8b9a:	1bfe      	djnz	X, 0x8b98 <.LASF1136+0x1>

00008b9c <.L4>:

#if !defined(RAM_APPLICATION)   /* skip ROM-to-RAM loading for RAM application */
    /* initialize .data and .dp.data sections */
    r = &_data_load_start;      /* copy data from rom */

    for (w = &_data_dp_start; w < &_data_dp_end; ) {
    8b9c:	7ada 1012 	lod	Y, #4114
    8ba0:	7eda 5b26 	lod	X, #23334

00008ba4 <.L26>:
    8ba4:	eeda 101a 	cmp	Y, #4122
    8ba8:	1c03      	jnc	0x8bb0 <.L6>
    8baa:	0ea7      	lod	C, ML.7
    8bac:	54ce      	movsw	[Y++], [X++]
    8bae:	07fa      	jmp	0x8ba4 <.L26>

00008bb0 <.L6>:
        *w++ = *r++;
    }

    for (w = &_data_start; w < &_data_end; ) {
    8bb0:	7ada 101a 	lod	Y, #4122

00008bb4 <.L25>:
    8bb4:	eeda 10aa 	cmp	Y, #4266
    8bb8:	1c03      	jnc	0x8bc0 <.L8>
    8bba:	0ea7      	lod	C, ML.7
    8bbc:	54ce      	movsw	[Y++], [X++]
    8bbe:	07fa      	jmp	0x8bb4 <.L25>

00008bc0 <.L8>:
    }
#endif /* !RAM_APPLICATION */

#if defined (HAS_MLS_API)
    r = &_mlx4_cst_tables_ram_load_start;
    for (w = &_mlx4_cst_tables_ram_start; w < &_mlx4_cst_tables_ram_end; ) {
    8bc0:	7eda 0e80 	lod	X, #3712
    8bc4:	2eda 0ede 	cmp	X, #3806
    8bc8:	1c07      	jnc	0x8bd8 <.L10>
    8bca:	7ada 5a40 	lod	Y, #23104

00008bce <.L11>:
    8bce:	0ea7      	lod	C, ML.7
    8bd0:	54c6      	movsw	[X++], [Y++]
    8bd2:	2eda 0ede 	cmp	X, #3806
    8bd6:	187b      	jc	0x8bce <.L11>

00008bd8 <.L10>:
        *w++ = *r++;
    }

    r = &_mlx4_flash_table_load_start;
    for (w = &_mlx4_flash_table_start; w < &_mlx4_flash_table_end; ) {
    8bd8:	7eda 0f00 	lod	X, #3840
    8bdc:	2eda 0f88 	cmp	X, #3976
    8be0:	1c07      	jnc	0x8bf0 <.L1>
    8be2:	7ada 5a9e 	lod	Y, #23198

00008be6 <.L13>:
    8be6:	0ea7      	lod	C, ML.7
    8be8:	54c6      	movsw	[X++], [Y++]
    8bea:	2eda 0f88 	cmp	X, #3976
    8bee:	187b      	jc	0x8be6 <.L13>

00008bf0 <.L1>:
        *w++ = *r++;
    }
#endif /* HAS_MLS_API */
}
    8bf0:	5401      	ret

00008bf2 <_fw_start>:
#include "sys_tools.h"
#endif

STATIC INLINE void Sys_SetStack(const uint16_t* const stackptr)
{
    __asm__ __volatile__ (
    8bf2:	72da 142a 	lod	A, #5162
    8bf6:	52ef      	mov	S, A

00008bf8 <.LBB136>:
    return (stack_pointer);
}

STATIC INLINE void SYS_clearCpuStatus (void)
{
    __asm__ __volatile__ (
    8bf8:	7000      	lod	A, #0
    8bfa:	52e3      	mov	M, A

00008bfc <.LBE136>:
	}

}
#endif								 
    /* set priorities to lowest level */
    IO_SET(MLX16, ITC_PRIO0, 0xFFFFu);
    8bfc:	70ff      	lod	A, #-1
    8bfe:	52d8 0088 	mov	0x88 <__mlx4_flash_table_size>, A

00008c02 <.LM5>:
    IO_SET(MLX16, ITC_PRIO1, 0xFFFFu);
    8c02:	0ea7      	lod	C, ML.7
    8c04:	52d8 008a 	mov	0x8a <__mlx4_flash_table_size+0x2>, A

00008c08 <.LM6>:
    IO_SET(MLX16, ITC_PRIO2, 0xFFFFu);
    8c08:	52d8 008c 	mov	0x8c <.LASF1526>, A

00008c0c <.LM7>:
    IO_SET(MLX16, ITC_PRIO3, 0xFFFFu);
    8c0c:	52d8 008e 	mov	0x8e <.LASF1526+0x2>, A

00008c10 <.LM8>:
    IO_SET(MLX16, ITC_PRIO4, 0xFFFFu);
    8c10:	0ea7      	lod	C, ML.7
    8c12:	52d8 0090 	mov	0x90 <__data_size>, A

00008c16 <.LM9>:
    IO_SET(MLX16, ITC_PRIO5, 0xFFFFu);
    8c16:	52d8 0092 	mov	0x92 <__data_size+0x2>, A

00008c1a <.LBB138>:
STATIC INLINE void MotorDriverUVWTSelectSource(DrvCtrlSelect_t drvctrl_u,
                                               DrvCtrlSelect_t drvctrl_v,
                                               DrvCtrlSelect_t drvctrl_w,
                                               DrvCtrlSelect_t drvctrl_t)
{
    IO_SET(PORT_DRV_CTRL,
    8c1a:	72da eeee 	lod	A, #61166
    8c1e:	0ea7      	lod	C, ML.7
    8c20:	52d8 0216 	mov	0x216 <_PORT_DRV_CTRL>, A

00008c24 <.LBE138>:

    /* all phases in tri-state explicitly */
    MotorDriverUVWTSelectSource(DRV_CTRL_TRISTATE, DRV_CTRL_TRISTATE, DRV_CTRL_TRISTATE, DRV_CTRL_TRISTATE);

    fw_premain();           /* Don't make this functions static to be sure its local variable will not apear before the SP assignment */
    8c24:	1794      	call	0x8b4e <_fw_premain>

00008c26 <.LM12>:

    __asm__ ("JMP _main\n\t" ::); /* jump to the main function */
    8c26:	76da 4b18 	jmpf	0x9630 <_main>

00008c2a <.LM13>:
}
    8c2a:	5401      	ret

00008c2c <_ld_AppDiagRequest>:
    {
        transfer->response.respSId = transfer->request.reqSId + 0x40;
    }

    return retVal;
}
    8c2c:	7000      	lod	A, #0

00008c2e <.LVL1>:
    8c2e:	5401      	ret

00008c30 <_lin22_Init>:
 * This function initialize the lin module and it will assign
 * the default frame ids to the different messages.
 */
void lin22_Init(void)
{
    (void)l_sys_init();
    8c30:	12ba      	call	0x91a6 <_l_sys_init>

00008c32 <.LM7>:
    (void)l_ifc_init_sl1();
    8c32:	12e2      	call	0x91f8 <_l_ifc_init_sl1>

00008c34 <.LM8>:

#if 0 //(SL_HAS_SAVE_CONFIGURATION_SERVICE == 1)
    (void)eeprom_ReadLINconfig(lin_config, lin_cfg_len);
    (void)ld_set_configuration(ifcSlave_1, lin_config, lin_cfg_len);
#else
    (void)ml_Disconnect();
    8c34:	82db 11f0 	callf	0x23e0 <_ml_Disconnect>

00008c38 <.LBB281>:
    for (uint8_t index = 0u; index < (lin_cfg_len - 1); index++)
    {
        (void)ml_AssignFrameToMessageID(index, lin_config[1 + index]);
    8c38:	54ca 0092 	pushw	#146

00008c3c <.LCFI0>:
    8c3c:	7000      	lod	A, #0
    8c3e:	82db 1172 	callf	0x22e4 <_ml_AssignFrameToMessageID>
    8c42:	54ca 0011 	pushw	#17

00008c46 <.LCFI1>:
    8c46:	7001      	lod	A, #1
    8c48:	82db 1172 	callf	0x22e4 <_ml_AssignFrameToMessageID>

00008c4c <.LBE281>:
    }
    (void)ml_Connect();
    8c4c:	82db 11ee 	callf	0x23dc <_ml_Connect>

00008c50 <.LM11>:

    ml_ConfiguredNAD = lin_config[0];
    8c50:	6001      	lod	AL, #1
    8c52:	42d8 10a4 	mov	0x10a4 <_ml_ConfiguredNAD>, AL

00008c56 <.LM12>:
#endif /* (SL_HAS_SAVE_CONFIGURATION_SERVICE == 1) */

#if (SL_HAS_UNKNOWN_DIAG_CALLOUT == 1)
    (void)ldt_SubscribeMultipleHandler(plinEventTable->ldt_Request, ld_AppDiagRequest);
    8c56:	7ed8 1002 	lod	X, 0x1002 <_plinEventTable>
    8c5a:	201a      	add	X, #26
    8c5c:	54ca 4616 	pushw	#17942

00008c60 <.LCFI2>:
    8c60:	72f8      	lod	A, [X]
    8c62:	82db 2005 	callf	0x400a <_ldt_SubscribeMultipleHandler>

00008c66 <.LM13>:
#endif /* (SL_HAS_UNKNOWN_DIAG_CALLOUT == 1) */

    /* register a timer for SL_LD_N_AS_TIMEOUT timeout */
    swtimer_register(SWTIMER_LINAS, (SL_LD_N_AS_TIMEOUT / TO_N_AS_TIMEOUT_TICKS), REPETITIVE);
    8c66:	54ca 0001 	pushw	#1

00008c6a <.LCFI3>:
    8c6a:	54ca 0001 	pushw	#1

00008c6e <.LCFI4>:
    8c6e:	7001      	lod	A, #1
    8c70:	82db 4da5 	callf	0x9b4a <_swtimer_register>

00008c74 <.LM14>:
    swtimer_start(SWTIMER_LINAS);
    8c74:	7001      	lod	A, #1
    8c76:	82db 4dbb 	callf	0x9b76 <_swtimer_start>

00008c7a <.LM15>:

    /* register a timer for SL_LD_N_CR_TIMEOUT timeout */
    swtimer_register(SWTIMER_LINCR, (SL_LD_N_CR_TIMEOUT / TO_N_CR_TIMEOUT_TICKS), REPETITIVE);
    8c7a:	54ca 0001 	pushw	#1

00008c7e <.LCFI5>:
    8c7e:	54ca 0001 	pushw	#1

00008c82 <.LCFI6>:
    8c82:	0ea7      	lod	C, ML.7
    8c84:	7002      	lod	A, #2
    8c86:	82db 4da5 	callf	0x9b4a <_swtimer_register>

00008c8a <.LM16>:
    swtimer_start(SWTIMER_LINCR);
    8c8a:	7002      	lod	A, #2
    8c8c:	82db 4dbb 	callf	0x9b76 <_swtimer_start>

00008c90 <.LM17>:

    /* register a timer for COLIN check timeout */
    swtimer_register(SWTIMER_CHECKCOLIN, COLIN_CHECK_TIMEOUT, REPETITIVE);
    8c90:	54ca 0001 	pushw	#1

00008c94 <.LCFI7>:
    8c94:	54ca 0bb8 	pushw	#3000

00008c98 <.LCFI8>:
    8c98:	0ea7      	lod	C, ML.7
    8c9a:	7000      	lod	A, #0
    8c9c:	82db 4da5 	callf	0x9b4a <_swtimer_register>

00008ca0 <.LM18>:
    swtimer_start(SWTIMER_CHECKCOLIN);
    8ca0:	7000      	lod	A, #0
    8ca2:	82db 4dbb 	callf	0x9b76 <_swtimer_start>

00008ca6 <.LM19>:
#if DEBUG_DB_B2 == 1
    adc_RegisterIRQ2(B2_exit);
#endif
#endif

    bLinActive = true;
    8ca6:	6001      	lod	AL, #1
    8ca8:	42d8 118c 	mov	0x118c <_bLinActive>, AL

00008cac <.LM20>:
    bLinTimeoutActive = 0;
    8cac:	0ea7      	lod	C, ML.7
    8cae:	6000      	lod	AL, #0
    8cb0:	42d8 118b 	mov	0x118b <_bLinTimeoutActive>, AL

00008cb4 <.LCFI9>:
}
    8cb4:	5413      	ret	#20

00008cb6 <_lin22_CheckColin>:
    }
}

/** Check the status of the COLIN module and handle accordingly */
void lin22_CheckColin(void)
{
    8cb6:	5801      	inc	S, #2

00008cb8 <.LBB374>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    8cb8:	7ae3      	lod	Y, M

00008cba <.LBB377>:

#include "builtin_mlx16_common.h"

STATIC INLINE void builtin_mlx16_disable_interrupts(void)
{
    __asm__ __volatile__ (
    8cba:	08b2      	clrb	MH.2
    8cbc:	08b1      	clrb	MH.1
    8cbe:	08b0      	clrb	MH.0

00008cc0 <.LBE377>:
    static uint8_t u8ColinErrorState = 0u;
    ml_LinState_t ColinState;

    ENTER_SECTION(ATOMIC_KEEP_MODE);
    ColinState = ml_GetState(ML_CLR_LIN_BUS_ACTIVITY);
    8cc0:	7008      	lod	A, #8
    8cc2:	5a01      	mov	[S-2], Y
    8cc4:	82db 11d3 	callf	0x23a6 <_ml_GetState>

00008cc8 <.LBB380>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    8cc8:	7a01      	lod	Y, [S-2]
    8cca:	5ae3      	mov	M, Y

00008ccc <.LBE374>:
    EXIT_SECTION();

    if (ColinState != ml_stINVALID)
    8ccc:	acff      	cmp	A, #-1
    8cce:	1912      	je	0x8cf4 <.L6>

00008cd0 <.LM39>:
    {
        /* COLIN is responding */
        if (COLIN_LINstatus.event_overflow != 0u)
    8cd0:	62d8 0e2f 	lod	AL, 0xe2f <.LLST13+0x1>

00008cd4 <.LVL23>:
    8cd4:	9408      	and	AL, #8
    8cd6:	1919      	je	0x8d0a <.L5>

00008cd8 <.LBB384>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    8cd8:	7ae3      	lod	Y, M

00008cda <.LBB387>:

#include "builtin_mlx16_common.h"

STATIC INLINE void builtin_mlx16_disable_interrupts(void)
{
    __asm__ __volatile__ (
    8cda:	08b2      	clrb	MH.2
    8cdc:	08b1      	clrb	MH.1
    8cde:	08b0      	clrb	MH.0

00008ce0 <.LBE387>:
        {
            /* command overflow was detected */
            ENTER_SECTION(ATOMIC_KEEP_MODE);
            (void)ml_GetState(ML_CLR_LIN_CMD_OVERFLOW);
    8ce0:	7001      	lod	A, #1
    8ce2:	5a01      	mov	[S-2], Y
    8ce4:	82db 11d3 	callf	0x23a6 <_ml_GetState>

00008ce8 <.LBB390>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    8ce8:	7a01      	lod	Y, [S-2]
    8cea:	5ae3      	mov	M, Y

00008cec <.LBE384>:
            EXIT_SECTION();

            /* do handshake MLX16 <> COLIN */
            ml_SetSLVCMD(0x42u);
    8cec:	7042      	lod	A, #66
    8cee:	82db 1224 	callf	0x2448 <_ml_SetSLVCMD>
    8cf2:	5403      	ret	#4

00008cf4 <.L6>:
        }
    }
    else
    {
        /* COLIN response time-out */
        u8ColinErrorState++;
    8cf4:	62d8 118a 	lod	AL, 0x118a <___u8ColinErrorState_7114>

00008cf8 <.LVL29>:
    8cf8:	8001      	add	AL, #1
    8cfa:	42d8 118a 	mov	0x118a <___u8ColinErrorState_7114>, AL

00008cfe <.LM46>:

        if (u8ColinErrorState >= 4u)
    8cfe:	8c03      	cmp	AL, #3
    8d00:	1a04      	jule	0x8d0a <.L5>

00008d02 <.LBB394>:
    return 1;
}

STATIC INLINE uint16_t mlx16_enter_system_mode_keep_prio(void)
{
    __asm__ __volatile__ (".word OPCODE_CALL_FP_ENTER_SYSTEM_MODE_KEEP_PRIO");
    8d02:	5048      	call	fp2:0x40

00008d04 <.LBE397>:
}

STATIC INLINE NO_RETURN void Sys_ResetCpu (void)
{
    (void) mlx16_enter_system_mode_keep_prio();
    IO_SET(RST_CTRL, SOFT_RESET, 1u);    /* Reset happens immediately after writing SOFT_RESET bit */
    8d04:	6283      	lod	AL, io:0x3 <_RST_CTRL+0x1>
    8d06:	8420      	or	AL, #32
    8d08:	4283      	mov	io:0x3 <_RST_CTRL+0x1>, AL

00008d0a <.L5>:
        {
            /* COLIN has not been responding to often, lets reset the module */
            Sys_ResetCpu();
        }
    }
}
    8d0a:	5403      	ret	#4

00008d0c <_lin22_BackgroundHandler>:
void lin22_BackgroundHandler(void)
{

#if (SL_HAS_SAVE_CONFIGURATION_SERVICE == 1)
    l_s_IfcStatus_t status;
    status.word = l_ifc_read_status_sl1();
    8d0c:	127f      	call	0x920c <_l_ifc_read_status_sl1>

00008d0e <.LM52>:
        /* nothing to be done */
    }
#endif /* (SL_HAS_SAVE_CONFIGURATION_SERVICE == 1) */

    /* Check LIN AS-timeout */
    if (swtimer_isTriggered(SWTIMER_LINAS))
    8d0e:	7001      	lod	A, #1
    8d10:	82db 4dcc 	callf	0x9b98 <_swtimer_isTriggered>
    8d14:	ac00      	cmp	A, #0
    8d16:	1906      	je	0x8d24 <.L13>

00008d18 <.LM53>:
    {
        ldt_Tick(100u / TO_N_AS_TIMEOUT_TICKS, 0u);
    8d18:	54ca 0000 	pushw	#0

00008d1c <.LCFI12>:
    8d1c:	7000      	lod	A, #0
    8d1e:	82db 5156 	callf	0xa2ac <_ldt_Tick>
    8d22:	5c01      	dec	S, #2

00008d24 <.L13>:
    }

    /* Check LIN CR-timeout */
    if (swtimer_isTriggered(SWTIMER_LINCR))
    8d24:	7002      	lod	A, #2
    8d26:	82db 4dcc 	callf	0x9b98 <_swtimer_isTriggered>
    8d2a:	ac00      	cmp	A, #0
    8d2c:	1906      	je	0x8d3a <.L14>

00008d2e <.LM55>:
    {
        ldt_Tick(0u, 100u / TO_N_CR_TIMEOUT_TICKS);
    8d2e:	54ca 0000 	pushw	#0

00008d32 <.LCFI14>:
    8d32:	7000      	lod	A, #0
    8d34:	82db 5156 	callf	0xa2ac <_ldt_Tick>
    8d38:	5c01      	dec	S, #2

00008d3a <.L14>:
    }

    if (swtimer_isTriggered(SWTIMER_CHECKCOLIN))
    8d3a:	7000      	lod	A, #0
    8d3c:	82db 4dcc 	callf	0x9b98 <_swtimer_isTriggered>
    8d40:	ac00      	cmp	A, #0
    8d42:	1901      	je	0x8d46 <.L12>

00008d44 <.LM57>:
    {
        /* check COLIN state */
        lin22_CheckColin();
    8d44:	17b8      	call	0x8cb6 <_lin22_CheckColin>

00008d46 <.L12>:
    }
}
    8d46:	5401      	ret

00008d48 <_ld_serial_number_callout>:
 * This function is called by the lin driver on receipt of a
 * read by id 0x00 request.
 * @param[out]  data  pointer to the data to be filled
 */
void ld_serial_number_callout(l_u8 data[4])
{
    8d48:	7ee2      	lod	X, A

00008d4a <.LM60>:
    data[0] = (l_u8)(EE_CHIP_ID_0); /* LSB */
    8d4a:	7ada 0a30 	lod	Y, #2608
    8d4e:	0ea7      	lod	C, ML.7
    8d50:	54c4      	movsb	[X++], [Y++]

00008d52 <.LM61>:
    data[1] = (l_u8)(EE_CHIP_ID_0 >> 8);
    8d52:	54c4      	movsb	[X++], [Y++]

00008d54 <.LM62>:
    data[2] = (l_u8)(EE_CHIP_ID_1);
    8d54:	7ada 0a32 	lod	Y, #2610
    8d58:	0ea7      	lod	C, ML.7
    8d5a:	54c4      	movsb	[X++], [Y++]

00008d5c <.LM63>:
    data[3] = (l_u8)(EE_CHIP_ID_1 >> 8); /* MSB */
    8d5c:	54c4      	movsb	[X++], [Y++]

00008d5e <.LM64>:
}
    8d5e:	5401      	ret

00008d60 <_fw_lepm_ApplicationStop>:
 * @retval  true   command has been handled successful;
 * @retval  false  command has not been handled successful;
 */
bool fw_lepm_ApplicationStop(void)
{
    adc_Stop();
    8d60:	82db 3b1f 	callf	0x763e <_adc_Stop>

00008d64 <.LM67>:
    pwm_Disable();
    8d64:	82db 4d1c 	callf	0x9a38 <_pwm_Disable>

00008d68 <.LM68>:
    swtimer_deinit();
    8d68:	82db 4d8d 	callf	0x9b1a <_swtimer_deinit>

00008d6c <.LM69>:
    return (true); /* return that the application has stopped */
}
    8d6c:	7001      	lod	A, #1
    8d6e:	5401      	ret

00008d70 <_lin22_GotoSleep>:
 * This function will never return, after the chip went into sleep mode
 * it will wake up again via a power on sequence.
 */
void lin22_GotoSleep(void)
{
    (void)fw_lepm_ApplicationStop(); /* stop the application */
    8d70:	17f7      	call	0x8d60 <_fw_lepm_ApplicationStop>

00008d72 <.LBB399>:
    8d72:	5048      	call	fp2:0x40

00008d74 <.LBB401>:

#include "builtin_mlx16_common.h"

STATIC INLINE void builtin_mlx16_disable_interrupts(void)
{
    __asm__ __volatile__ (
    8d74:	08b2      	clrb	MH.2
    8d76:	08b1      	clrb	MH.1
    8d78:	08b0      	clrb	MH.0

00008d7a <.LBB403>:
    SetRstatFlag();
}

STATIC INLINE void disallowWarmReboot(void)
{
    ResetRstatFlag();
    8d7a:	82db 1508 	callf	0x2a10 <_ResetRstatFlag>

00008d7e <.LM75>:
    bistHeader = C_CHIP_HEADER_INVALID;
    8d7e:	7000      	lod	A, #0
    8d80:	52d8 17f8 	mov	0x17f8 <_bistHeader>, A

00008d84 <.LBB405>:
#endif
	return result;
}
static __attribute__((always_inline)) inline uint16_t IO_AWD__WIN_OPEN_GET (void) {
	register uint16_t result;
	asm volatile (
    8d84:	0f7f      	lod	C, io:0x0f.7

00008d86 <.LBE407>:
}

/** WDG_conditionalAwdRefresh acknowledges the AWD timer if its window is opened */
STATIC INLINE void WDG_conditionalAwdRefresh(void)
{
    if (IO_GET(AWD, WIN_OPEN) != 0u) {
    8d86:	1c01      	jnc	0x8d8a <.L28>

00008d88 <.LM78>:
        IO_SET(AWD, ACK, 1u);
    8d88:	0b76      	setb	io:0x0e.6

00008d8a <.L28>:

    disallowWarmReboot(); /* warm reboot is not allowed any more */

    WDG_conditionalAwdRefresh(); /* refresh the timers if they're used */

    IO_SET(SPI, STOP, 1u); /* stop the SPI despite it's running or not */
    8d8a:	62d8 0132 	lod	AL, 0x132 <_SPI+0xa>
    8d8e:	94fc      	and	AL, #-4
    8d90:	8402      	or	AL, #2
    8d92:	42d8 0132 	mov	0x132 <_SPI+0xa>, AL

00008d96 <.LM80>:

    //    IO_SET(PORT_MISC2_OUT, WU_IO_EN, 0u);           /* disable wake up on IO0 */
    IO_SET(PORT_MISC2_OUT, WU_IO_EN, 1u); /* enable wake up on IO0 */ // 250702-3 Support Sleep by IO0.
    8d96:	62d8 01f5 	lod	AL, 0x1f5 <_PORT_MISC2_OUT+0x1>
    8d9a:	8401      	or	AL, #1
    8d9c:	42d8 01f5 	mov	0x1f5 <_PORT_MISC2_OUT+0x1>, AL

00008da0 <.LM81>:
    ml_ResetDrv();                                                    /* stop the MLX4 */
    8da0:	82db 122f 	callf	0x245e <_ml_ResetDrv>

00008da4 <.L29>:

    /* wait for EEPROM operations */
    while (IO_GET(EEPROM_FLASH, EE_BUSY) != 0u)
    8da4:	72d8 0186 	lod	A, 0x186 <.LASF1348+0x5>
    8da8:	ac00      	cmp	A, #0
    8daa:	1afc      	jsl	0x8da4 <.L29>

00008dac <.L30>:
    {
    }
    /* wait for Flash operations */
    while ((IO_GET(EEPROM_FLASH, FL_STATUS) == FLASH_STATUS_PAGE_PROGRAM) ||
    8dac:	72d8 017c 	lod	A, 0x17c <.LASF1347+0x3>
    8db0:	940f      	and	AL, #15
    8db2:	8c04      	cmp	AL, #4
    8db4:	197b      	je	0x8dac <.L30>

00008db6 <.LM84>:
           (IO_GET(EEPROM_FLASH, FL_STATUS) == FLASH_STATUS_SECTOR_ERASE))
    8db6:	72d8 017c 	lod	A, 0x17c <.LASF1347+0x3>

00008dba <.LM85>:
    /* wait for EEPROM operations */
    while (IO_GET(EEPROM_FLASH, EE_BUSY) != 0u)
    {
    }
    /* wait for Flash operations */
    while ((IO_GET(EEPROM_FLASH, FL_STATUS) == FLASH_STATUS_PAGE_PROGRAM) ||
    8dba:	940f      	and	AL, #15
    8dbc:	8c03      	cmp	AL, #3
    8dbe:	1976      	je	0x8dac <.L30>

00008dc0 <.LM86>:
           (IO_GET(EEPROM_FLASH, FL_STATUS) == FLASH_STATUS_SECTOR_ERASE))
    {
    }

    /* stop MLX16 */
    __asm__("HALT\n\t");
    8dc0:	42c9      	halt

00008dc2 <.LBB409>:
    8dc2:	5048      	call	fp2:0x40

00008dc4 <.LBE411>:
    8dc4:	6283      	lod	AL, io:0x3 <_RST_CTRL+0x1>
    8dc6:	8420      	or	AL, #32
    8dc8:	4283      	mov	io:0x3 <_RST_CTRL+0x1>, AL

00008dca <_ld_read_by_id_callout>:
 * - LD_NEGATIVE_RESPONSE   - the slave node will respond with a negative response;
 * - LD_POSTIVE_RESPONSE    - the slave node will setup a positive response;
 * - LD_NO_RESPONSE         - the slave node will not answer.
 */
l_u8 ld_read_by_id_callout(l_ifc_handle iii, l_u8 id, l_u8 *pci, l_u8 *data)
{
    8dca:	580b      	inc	S, #12

00008dcc <.LCFI16>:
    l_u8 u8Return;
    (void)iii;
    switch (id)
    8dcc:	620f      	lod	AL, [S-16]

00008dce <.LVL45>:
    8dce:	8c2b      	cmp	AL, #43
    8dd0:	1920      	je	0x8e12 <.L39>
    8dd2:	5cf2      	usex	A
    8dd4:	ac2c      	cmp	A, #44
    8dd6:	1929      	je	0x8e2a <.L40>
    8dd8:	ac21      	cmp	A, #33
    8dda:	1901      	je	0x8dde <.LBB413>
    8ddc:	003b      	jmp	0x8e54 <.L43>

00008dde <.LBB413>:
    {
    case 0x21u:
    {
        uint8_t lin_cfg_len = SL_NUMBER_OF_DYNAMIC_MESSAGES + 1u;
        uint8_t lin_config[1 + SL_NUMBER_OF_DYNAMIC_MESSAGES] = SL_NODE_CONFIGURATION_INITIALIZER;
    8dde:	7eef      	lod	X, S
    8de0:	20f4      	add	X, #-12
    8de2:	7ada 5bbe 	lod	Y, #23486
    8de6:	0ea7      	lod	C, ML.7
    8de8:	54c4      	movsb	[X++], [Y++]
    8dea:	54c4      	movsb	[X++], [Y++]
    8dec:	54c4      	movsb	[X++], [Y++]

00008dee <.LM92>:

        /* Verify NAD */
#if (SL_HAS_SAVE_CONFIGURATION_SERVICE == 1)
        (void)eeprom_ReadLINconfig(lin_config, lin_cfg_len);
    8dee:	54ca 0003 	pushw	#3

00008df2 <.LCFI17>:
    8df2:	72ef      	lod	A, S
    8df4:	a0f2      	add	A, #-14
    8df6:	1438      	call	0x8668 <_eeprom_ReadLINconfig>

00008df8 <.LM93>:

        *pci = 8u; /* 7-bytes of data + 1 */
    8df8:	7e13      	lod	X, [S-20]
    8dfa:	6008      	lod	AL, #8
    8dfc:	42f8      	mov	[X], AL

00008dfe <.LBB414>:

        for (uint16_t index = 0u; index < lin_cfg_len && index < 7u; index++)
        {
            data[index] = lin_config[index];
    8dfe:	7e15      	lod	X, [S-22]
    8e00:	620d      	lod	AL, [S-14]
    8e02:	42f8      	mov	[X], AL
    8e04:	620c      	lod	AL, [S-13]
    8e06:	42f9      	mov	[X+1], AL
    8e08:	620b      	lod	AL, [S-12]
    8e0a:	42fa      	mov	[X+2], AL

00008e0c <.LBE414>:
    8e0c:	5c01      	dec	S, #2

00008e0e <.L44>:
        *pci = 5u; /* 4-bytes of data + 1-byte of pci */
        data[0] = (uint8_t)LIBRARIES_VERSION_MAJOR;
        data[1] = (uint8_t)LIBRARIES_VERSION_MINOR;
        data[2] = (uint8_t)LIBRARIES_VERSION_REVISION;
        data[3] = (uint8_t)LIBRARIES_VERSION_CUSTOMER_BUILD;
        u8Return = LD_POSITIVE_RESPONSE;
    8e0e:	7007      	lod	A, #7

00008e10 <.LM96>:
        break;
    8e10:	540d      	ret	#14

00008e12 <.L39>:
 * - LD_NEGATIVE_RESPONSE   - the slave node will respond with a negative response;
 * - LD_POSTIVE_RESPONSE    - the slave node will setup a positive response;
 * - LD_NO_RESPONSE         - the slave node will not answer.
 */
l_u8 ld_read_by_id_callout(l_ifc_handle iii, l_u8 id, l_u8 *pci, l_u8 *data)
{
    8e12:	7e11      	lod	X, [S-18]

00008e14 <.LM98>:
        break;
    }

    case 0x2Bu:
    {
        *pci = 5u; /* 4-bytes of data + 1-byte of pci */
    8e14:	6005      	lod	AL, #5
    8e16:	42f8      	mov	[X], AL

00008e18 <.LM99>:
 * - LD_NEGATIVE_RESPONSE   - the slave node will respond with a negative response;
 * - LD_POSTIVE_RESPONSE    - the slave node will setup a positive response;
 * - LD_NO_RESPONSE         - the slave node will not answer.
 */
l_u8 ld_read_by_id_callout(l_ifc_handle iii, l_u8 id, l_u8 *pci, l_u8 *data)
{
    8e18:	7e13      	lod	X, [S-20]

00008e1a <.LM100>:
    }

    case 0x2Bu:
    {
        *pci = 5u; /* 4-bytes of data + 1-byte of pci */
        data[0] = (uint8_t)LIBRARIES_VERSION_MAJOR;
    8e1a:	6002      	lod	AL, #2
    8e1c:	42f8      	mov	[X], AL

00008e1e <.LM101>:
        data[1] = (uint8_t)LIBRARIES_VERSION_MINOR;
    8e1e:	600b      	lod	AL, #11
    8e20:	42f9      	mov	[X+1], AL

00008e22 <.LM102>:
        data[2] = (uint8_t)LIBRARIES_VERSION_REVISION;
    8e22:	6000      	lod	AL, #0
    8e24:	42fa      	mov	[X+2], AL

00008e26 <.LM103>:
        data[3] = (uint8_t)LIBRARIES_VERSION_CUSTOMER_BUILD;
    8e26:	42fb      	mov	[X+3], AL
    8e28:	07f2      	jmp	0x8e0e <.L44>

00008e2a <.L40>:
        break;
    }

    case 0x2Cu:
    {
        uint32_t version = VERSION_getFwAppVersion();
    8e2a:	82db 50c8 	callf	0xa190 <_VERSION_getFwAppVersion>
    8e2e:	58a0      	mov	[S-4], YA

00008e30 <.LM105>:
        *pci = 5u; /* 4-bytes of data + 1-byte of pci */
    8e30:	7e11      	lod	X, [S-18]
    8e32:	6405      	lod	YL, #5
    8e34:	46f8      	mov	[X], YL

00008e36 <.LM106>:
        data[0] = (uint8_t)(version >> 24);
    8e36:	58e0      	mov	YA, [S-4]
    8e38:	48af      	lsr	YA, #16
    8e3a:	48a7      	lsr	YA, #8

00008e3c <.LVL56>:
    8e3c:	58a2      	mov	[S-8], YA
    8e3e:	7e13      	lod	X, [S-20]
    8e40:	42f8      	mov	[X], AL

00008e42 <.LM107>:
        data[1] = (uint8_t)(version >> 16);
    8e42:	6601      	lod	YL, [S-2]
    8e44:	46f9      	mov	[X+1], YL

00008e46 <.LM108>:
        data[2] = (uint8_t)(version >> 8);
    8e46:	58e0      	mov	YA, [S-4]
    8e48:	48a7      	lsr	YA, #8
    8e4a:	58a2      	mov	[S-8], YA
    8e4c:	42fa      	mov	[X+2], AL

00008e4e <.LM109>:
        data[3] = (uint8_t)(version >> 0);
    8e4e:	6603      	lod	YL, [S-4]
    8e50:	46fb      	mov	[X+3], YL
    8e52:	07dd      	jmp	0x8e0e <.L44>

00008e54 <.L43>:
        u8Return = LD_POSITIVE_RESPONSE;
        break;
    }

    default:
        u8Return = LD_NEGATIVE_RESPONSE;
    8e54:	7002      	lod	A, #2

00008e56 <.LM111>:
        break;
    }

    return (u8Return);
}
    8e56:	540d      	ret	#14

00008e58 <_l_ifc_sleep_entered_callout>:
 *
 * @param[in]  Reason  Reason of entering sleep mode.
 */
void l_ifc_sleep_entered_callout(ml_SleepReason_t Reason)
{
    switch (Reason)
    8e58:	ac01      	cmp	A, #1
    8e5a:	1903      	je	0x8e62 <.L47>
    8e5c:	ac06      	cmp	A, #6
    8e5e:	1904      	je	0x8e68 <.L48>
    8e60:	5401      	ret

00008e62 <.L47>:
    {
    case ml_reasonMaster:
        /* "Go-to-Sleep" frame has been received from Master */
        EVENT_GotoSleep(); // 250415 - To do act after sr
    8e62:	82db 4bb7 	callf	0x976e <_EVENT_GotoSleep>

00008e66 <.LM115>:
        lin22_GotoSleep(); /* switch to sleep mode */
    8e66:	1784      	call	0x8d70 <_lin22_GotoSleep>

00008e68 <.L48>:
        break;
    case ml_reasonTimeOut:
        /* Sleep State entered with a timeout with LIN bus recessive */
        bLinTimeoutActive = 1;
    8e68:	6001      	lod	AL, #1

00008e6a <.LVL63>:
    8e6a:	42d8 118b 	mov	0x118b <_bLinTimeoutActive>, AL

00008e6e <.LM117>:
        EVENT_GotoSleep();
        lin22_GotoSleep(); /* switch to sleep mode */
#endif
        break;
    }
}
    8e6e:	5401      	ret

00008e70 <_l_mls_Init>:
    const l_u8 l_s_ver = ML_VER_DEFAULT;
#endif /* ML_MLX4_VERSION >= 412 */

    /* Start and initialize the LIN Module
     * Note: MLX LIN API shall be initialized first with proper settings and only TL then */
    if (ml_Init(SL_LIN_AUTOBAUDRATE_MODE, SL_LIN_BAUDRATE, l_s_ver, MLX4_FPLL) == ML_SUCCESS) {
    8e70:	54ca 7d00 	pushw	#32000

00008e74 <.LCFI0>:
    8e74:	54ca 0009 	pushw	#9

00008e78 <.LCFI1>:
    8e78:	54ca 4b00 	pushw	#19200

00008e7c <.LCFI2>:
    8e7c:	0ea7      	lod	C, ML.7
    8e7e:	7001      	lod	A, #1
    8e80:	82db 51bb 	callf	0xa376 <_ml_Init>
    8e84:	5c05      	dec	S, #6

00008e86 <.LCFI3>:
    8e86:	ac00      	cmp	A, #0
    8e88:	1d3a      	jne	0x8efe <.L1>

00008e8a <.LBB10>:
 * @return void
 */
static void l_mls_InitEventTable(void)
{
    /* General events processing */
    plinEventTable->mlu_LinSleepMode = l_LinSleepMode;
    8e8a:	7ad8 1002 	lod	Y, 0x1002 <_plinEventTable>
    8e8e:	7ee6      	lod	X, Y
    8e90:	200a      	add	X, #10
    8e92:	72da 4926 	lod	A, #18726
    8e96:	52f8      	mov	[X], A

00008e98 <.LM4>:
    plinEventTable->mlu_AutoAddressingStep = l_AutoAddressingStep;
    8e98:	2002      	add	X, #2
    8e9a:	72da 49a8 	lod	A, #18856
    8e9e:	52f8      	mov	[X], A

00008ea0 <.LM5>:

    /* Non-diagnostic frames are processed always by std. LIN API when it's initialized
     * The std. LIN API uses event from LIN transport layer */
    plinEventTable->ldt_NonDiagMessageReceived = l_MessageReceived;
    8ea0:	2002      	add	X, #2
    8ea2:	72da 4933 	lod	A, #18739
    8ea6:	52f8      	mov	[X], A

00008ea8 <.LM6>:
    plinEventTable->ldt_NonDiagDataRequest = l_DataRequest;
    8ea8:	2004      	add	X, #4
    8eaa:	72da 4952 	lod	A, #18770
    8eae:	52f8      	mov	[X], A

00008eb0 <.LM7>:
    plinEventTable->ldt_NonDiagDataTransmitted = l_DataTransmitted;
    8eb0:	20fe      	add	X, #-2
    8eb2:	72da 498d 	lod	A, #18829
    8eb6:	52f8      	mov	[X], A

00008eb8 <.LM8>:

    /* Subscribe to errors reporting */
    uint8_t* idx = &ld_ErrorDetectedMultipleHandler.eventsCount;
    if (*idx < ld_ErrorDetectedMultipleHandler.eventsMaxLength) {
    8eb8:	62d8 13cf 	lod	AL, 0x13cf <.LLST5>
    8ebc:	5cf2      	usex	A
    8ebe:	7ee2      	lod	X, A
    8ec0:	62d8 13ce 	lod	AL, 0x13ce <_ld_ErrorDetectedMultipleHandler+0x2>
    8ec4:	8ed8 13cf 	cmp	AL, 0x13cf <.LLST5>
    8ec8:	1a0c      	jule	0x8ee2 <.L3>

00008eca <.LM9>:
        ld_ErrorDetectedMultipleHandler.eventHandlerBuffer[*idx] = l_ErrorDetected;
    8eca:	442e      	asl	X
    8ecc:	72d8 13cc 	lod	A, 0x13cc <_ld_ErrorDetectedMultipleHandler>
    8ed0:	22e2      	add	X, A
    8ed2:	72da 496e 	lod	A, #18798
    8ed6:	52f8      	mov	[X], A

00008ed8 <.LM10>:
        *idx = *idx + 1;
    8ed8:	62d8 13cf 	lod	AL, 0x13cf <.LLST5>
    8edc:	8001      	add	AL, #1
    8ede:	42d8 13cf 	mov	0x13cf <.LLST5>, AL

00008ee2 <.L3>:
    }

#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
    /* Diagnostic frames: node configuration / identification */
    (void)ldt_SubscribeMultipleHandler(plinEventTable->ldt_Request, ld_DiagRequest);
    8ee2:	7ee6      	lod	X, Y
    8ee4:	201a      	add	X, #26
    8ee6:	54ca 47bc 	pushw	#18364

00008eea <.LCFI4>:
    8eea:	72f8      	lod	A, [X]
    8eec:	82db 2005 	callf	0x400a <_ldt_SubscribeMultipleHandler>

00008ef0 <.LM12>:
    plinEventTable->ldt_GetLINNAD = ld_GetLINNAD;
    8ef0:	7ed8 1002 	lod	X, 0x1002 <_plinEventTable>
    8ef4:	2014      	add	X, #20
    8ef6:	72da 4793 	lod	A, #18323
    8efa:	52f8      	mov	[X], A
    8efc:	5c01      	dec	S, #2

00008efe <.L1>:
     * Note: MLX LIN API shall be initialized first with proper settings and only TL then */
    if (ml_Init(SL_LIN_AUTOBAUDRATE_MODE, SL_LIN_BAUDRATE, l_s_ver, MLX4_FPLL) == ML_SUCCESS) {
        /* Initialize MLX LIN API event table */
        l_mls_InitEventTable();
    }
}
    8efe:	5401      	ret

00008f00 <_l_sys_irq_disable>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    8f00:	72e3      	lod	A, M

00008f02 <.LBE12>:
l_irqmask l_sys_irq_disable(void)
{
    l_u16 mreg_saved = builtin_mlx16_get_status();

    /* Keep User-bit unchanged */
    builtin_mlx16_set_status((mreg_saved & ~((l_u16)7u << 8)) |
    8f02:	7ee2      	lod	X, A
    8f04:	36da f8ff 	and	X, #63743
    8f08:	26da 0400 	or	X, #1024

00008f0c <.LBB14>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    8f0c:	5ee3      	mov	M, X

00008f0e <.LBE14>:
                             (((l_u16)LINAPI_RESOURCES_BLOCKING_PRIORITY & 7u) << 8));
    return mreg_saved;
}
    8f0e:	5401      	ret

00008f10 <_l_sys_irq_restore>:
    8f10:	52e3      	mov	M, A

00008f12 <.LBE16>:
 * @return void
 */
void l_sys_irq_restore(l_irqmask previous)
{
    builtin_mlx16_set_status(previous);
}
    8f12:	5401      	ret

00008f14 <_ld_DiagInit>:
/** (Re)initialize the configuration/identification layer
 * @return  void
 */
void ld_DiagInit (void)
{
    pendingSlaveResponse = respNoResponse;
    8f14:	7000      	lod	A, #0
    8f16:	52d8 1190 	mov	0x1190 <_pendingSlaveResponse>, A

00008f1a <.LM44>:
    ml_ConfiguredNAD = ml_InitialNAD;
    8f1a:	62d8 5d86 	lod	AL, 0x5d86 <_ml_InitialNAD>
    8f1e:	0ea7      	lod	C, ML.7
    8f20:	42d8 10a4 	mov	0x10a4 <_ml_ConfiguredNAD>, AL

00008f24 <.LM45>:
}
    8f24:	5401      	ret

00008f26 <_ld_GetLINNAD>:
 * @return Current NAD.
 */
l_u8 ld_GetLINNAD (l_u8 NAD)
{
    (void)NAD; /* There is no interest to track other than current NADs on the bus */
    l_u8 retVal = ml_ConfiguredNAD;
    8f26:	66d8 10a4 	lod	YL, 0x10a4 <_ml_ConfiguredNAD>
    8f2a:	5cf6      	usex	Y

00008f2c <.LM51>:
#if SL_EN_ASSIGN_NAD_SERVICE
    /* Assign NAD request */
    if (ML_SLAVE_FRAME_DATA_BUFFER[2] == 0xB0u) {
    8f2c:	62d8 1006 	lod	AL, 0x1006 <_ml_Data+0x2>

00008f30 <.LVL46>:
    8f30:	8cb0      	cmp	AL, #-80
    8f32:	1d03      	jne	0x8f3a <.L29>

00008f34 <.LM52>:
        retVal = ml_InitialNAD;
    8f34:	66d8 5d86 	lod	YL, 0x5d86 <_ml_InitialNAD>
    8f38:	5cf6      	usex	Y

00008f3a <.L29>:
    }
#endif /* SL_EN_ASSIGN_NAD_SERVICE */
    return retVal;
}
    8f3a:	72e6      	lod	A, Y
    8f3c:	5401      	ret

00008f3e <_isSupplierIdValid>:
    l_u16 supplierID;
    l_u16 cur_supplierID;
    ml_Status_t status;

    /* supplierID word could be on odd address, so get LSB, MSB separately */
    supplierID = ((l_u16)data[1] << 8 ) | data[0];
    8f3e:	7ee2      	lod	X, A
    8f40:	62f8      	lod	AL, [X]
    8f42:	6af9      	lod	AH, [X+1]

00008f44 <.LM56>:
    cur_supplierID = (l_u16)ml_ProductID[0]
    8f44:	66d8 5d80 	lod	YL, 0x5d80 <_ml_ProductID>
    8f48:	6ed8 5d81 	lod	YH, 0x5d81 <_ml_ProductID+0x1>

00008f4c <.LM57>:
                     | (((l_u16)ml_ProductID[1]) << 8);

    if (   (supplierID == cur_supplierID)
    8f4c:	aee6      	cmp	A, Y
    8f4e:	1904      	je	0x8f58 <.L32>

00008f50 <.LM58>:
           || (supplierID == 0x7FFFU /* wildcard */)) {
        status = ML_SUCCESS;
    8f50:	aeda 7fff 	cmp	A, #32767
    8f54:	5ca2      	sne	A
    8f56:	5401      	ret

00008f58 <.L32>:
    8f58:	7000      	lod	A, #0

00008f5a <.LM59>:
    } else {
        status = ML_FAILURE;
    }

    return status;
}
    8f5a:	5401      	ret

00008f5c <_isFunctionIdValid>:
    l_u16 functionID;
    l_u16 cur_functionID;
    ml_Status_t status;

    /* functionID word could be on odd address, so get LSB, MSB separately */
    functionID = ((l_u16)data[1] << 8) | data[0];
    8f5c:	7ee2      	lod	X, A
    8f5e:	62f8      	lod	AL, [X]
    8f60:	6af9      	lod	AH, [X+1]

00008f62 <.LM62>:
    cur_functionID = ((l_u16)ml_ProductID[2])
    8f62:	66d8 5d82 	lod	YL, 0x5d82 <.LASF704>
    8f66:	6ed8 5d83 	lod	YH, 0x5d83 <.LASF704+0x1>

00008f6a <.LM63>:
                     | (((l_u16)ml_ProductID[3]) << 8);

    if (   (functionID == cur_functionID)
    8f6a:	aee6      	cmp	A, Y
    8f6c:	1903      	je	0x8f74 <.L35>

00008f6e <.LM64>:
           || (functionID == 0xFFFFU /* wildcard */)) {
        status = ML_SUCCESS;
    8f6e:	acff      	cmp	A, #-1
    8f70:	5ca2      	sne	A
    8f72:	5401      	ret

00008f74 <.L35>:
    8f74:	7000      	lod	A, #0

00008f76 <.LM65>:
    } else {
        status = ML_FAILURE;
    }

    return status;
}
    8f76:	5401      	ret

00008f78 <_ld_DiagRequest>:
 * @return Status:
 * - true  There is data to send;
 * - false There is nothing to send (no response).
 */
bool ld_DiagRequest(LINDiagTransfer_t *transfer)
{
    8f78:	5809      	inc	S, #10

00008f7a <.LCFI4>:
    8f7a:	7ae2      	lod	Y, A

00008f7c <.LM67>:
    pDiagTransfer = transfer;
    8f7c:	52d8 118e 	mov	0x118e <_pDiagTransfer>, A

00008f80 <.LM68>:

    /* A new MRF received,
     * so reset pending response
     */
    pendingSlaveResponse = respNoResponse;
    8f80:	7000      	lod	A, #0

00008f82 <.LVL55>:
    8f82:	52d8 1190 	mov	0x1190 <_pendingSlaveResponse>, A

00008f86 <.LM69>:

    switch (pDiagTransfer->request.reqSId) {
    8f86:	62f0      	lod	AL, [Y]
    8f88:	4205      	mov	[S-6], AL
    8f8a:	6205      	lod	AL, [S-6]
    8f8c:	8cb2      	cmp	AL, #-78
    8f8e:	1d01      	jne	0x8f92 <.LASF1058+0x4>
    8f90:	0061      	jmp	0x9054 <.L38>
    8f92:	5cf2      	usex	A
    8f94:	aeda 00b2 	cmp	A, #178
    8f98:	1e11      	jug	0x8fbc <.L39>
    8f9a:	aeda 00b0 	cmp	A, #176
    8f9e:	1d01      	jne	0x8fa2 <.L37>
    8fa0:	0040      	jmp	0x9022 <.L40>

00008fa2 <.L37>:
 * - false There is nothing to send (no response).
 */
static bool ld_DiagResponse (void)
{
    bool retVal = true;
    SlaveResponse_t thisPendingSlaveResponse = pendingSlaveResponse;
    8fa2:	7ed8 1190 	lod	X, 0x1190 <_pendingSlaveResponse>

00008fa6 <.LM71>:

    /* reset pending response after processing */
    /* speculative next state/response, overwrite if otherwise */
    pendingSlaveResponse = respNoResponse;
    8fa6:	7000      	lod	A, #0
    8fa8:	52d8 1190 	mov	0x1190 <_pendingSlaveResponse>, A

00008fac <.LM72>:

    switch (thisPendingSlaveResponse) {
    8fac:	20ff      	add	X, #-1

00008fae <.LVL58>:
    8fae:	2c06      	cmp	X, #6
    8fb0:	1a01      	jule	0x8fb4 <.LASF1176>
    8fb2:	00d2      	jmp	0x9158 <.L64>
    8fb4:	442e      	asl	X
    8fb6:	22da 5d44 	add	X, #23876
    8fba:	76f8      	jmp	[X]

00008fbc <.L39>:
    /* A new MRF received,
     * so reset pending response
     */
    pendingSlaveResponse = respNoResponse;

    switch (pDiagTransfer->request.reqSId) {
    8fbc:	aeda 00b6 	cmp	A, #182
    8fc0:	1d01      	jne	0x8fc4 <.LASF1548+0x3>
    8fc2:	0086      	jmp	0x90d0 <.L41>
    8fc4:	aeda 00b7 	cmp	A, #183
    8fc8:	1d6c      	jne	0x8fa2 <.L37>

00008fca <.LBB43>:
 * @return: Requested response or respNoResponse.
 */
static SlaveResponse_t assignFrameIdRange (void)
{
    /* wrong PCI */
    if (pDiagTransfer->request.dataLen != 0x05U) { /* if (PCI-1) is not correct .. */
    8fca:	72f2      	lod	A, [Y+2]
    8fcc:	ac05      	cmp	A, #5
    8fce:	1d27      	jne	0x901e <.L48>

00008fd0 <.LM75>:
        return respNoResponse;
    }

    /* invalid start index */
    if (pDiagTransfer->request.data[0] >= SL_NUMBER_OF_DYNAMIC_MESSAGES) {
    8fd0:	62f4      	lod	AL, [Y+4]
    8fd2:	4207      	mov	[S-8], AL
    8fd4:	8c01      	cmp	AL, #1
    8fd6:	1e23      	jug	0x901e <.L48>

00008fd8 <.LBB45>:
    } else {
        l_u8 *pid;
        l_u8 index;
        l_u8 i;

        index = pDiagTransfer->request.data[0] + 3u; /* index of the last frame in the range */
    8fd8:	8003      	add	AL, #3
    8fda:	5cf2      	usex	A
    8fdc:	5205      	mov	[S-6], A

00008fde <.LM77>:
        pid = &pDiagTransfer->request.data[4]; /* PID of the last frame in the range */
    8fde:	e008      	add	Y, #8

00008fe0 <.LVL62>:
    8fe0:	6207      	lod	AL, [S-8]

00008fe2 <.LVL63>:
    8fe2:	80ff      	add	AL, #-1
    8fe4:	5cf2      	usex	A
    8fe6:	5207      	mov	[S-8], A

00008fe8 <.L55>:

        for (i = 0U; i < 4U; i++) {
            if (*pid != 0xFFU) {                                /* if id is NOT 0xFF .. */
    8fe8:	62f0      	lod	AL, [Y]
    8fea:	8cff      	cmp	AL, #-1
    8fec:	1d01      	jne	0x8ff0 <.LM79>
    8fee:	0082      	jmp	0x90f4 <.L49>

00008ff0 <.LM79>:
                if (index >= SL_NUMBER_OF_DYNAMIC_MESSAGES) {   /* if wrong index for valid pid .. */
    8ff0:	7205      	lod	A, [S-6]
    8ff2:	ac01      	cmp	A, #1
    8ff4:	1e14      	jug	0x901e <.L48>

00008ff6 <.LM80>:
                    return respNoResponse;
                } else {                                          /* proper index */
                    (void)ml_Disconnect();
    8ff6:	5a03      	mov	[S-4], Y
    8ff8:	82db 11f0 	callf	0x23e0 <_ml_Disconnect>

00008ffc <.LM81>:
                    if (*pid == 0x00U) {                        /* unassign */
    8ffc:	7a03      	lod	Y, [S-4]
    8ffe:	62f0      	lod	AL, [Y]
    9000:	4201      	mov	[S-2], AL
    9002:	5cf2      	usex	A
    9004:	7ee2      	lod	X, A
    9006:	6201      	lod	AL, [S-2]
    9008:	1901      	je	0x900c <.LM82>
    900a:	007e      	jmp	0x9108 <.L50>

0000900c <.LM82>:
                        if (ml_DisableMessage(index) != ML_SUCCESS) {
    900c:	7205      	lod	A, [S-6]
    900e:	82db 1175 	callf	0x22ea <_ml_DisableMessage>
    9012:	7a03      	lod	Y, [S-4]
    9014:	ac00      	cmp	A, #0
    9016:	1d01      	jne	0x901a <.L54>
    9018:	0065      	jmp	0x90e4 <.L51>

0000901a <.L54>:
                            (void)ml_Connect();
    901a:	82db 11ee 	callf	0x23dc <_ml_Connect>

0000901e <.L48>:
 */
static SlaveResponse_t assignFrameIdRange (void)
{
    /* wrong PCI */
    if (pDiagTransfer->request.dataLen != 0x05U) { /* if (PCI-1) is not correct .. */
        return respNoResponse;
    901e:	7000      	lod	A, #0
    9020:	0016      	jmp	0x904e <.L52>

00009022 <.L40>:
 *
 * @return: Requested response or respNoResponse
 */
static SlaveResponse_t assignNAD (void)
{
    if (pDiagTransfer->request.dataLen != 0x05u) {
    9022:	72f2      	lod	A, [Y+2]
    9024:	ac05      	cmp	A, #5
    9026:	1d7b      	jne	0x901e <.L48>

00009028 <.LM86>:
        return respNoResponse;
    }
    /* else: (PCI-1) is valid, continue processing .. */

    /* Validate SupplierID [3..4] and FunctionID [5..6] */
    if ( (isSupplierIdValid(&pDiagTransfer->request.data[0]) == ML_SUCCESS) &&
    9028:	72e6      	lod	A, Y
    902a:	a004      	add	A, #4
    902c:	5a03      	mov	[S-4], Y
    902e:	1787      	call	0x8f3e <_isSupplierIdValid>

00009030 <.LVL70>:
    9030:	5205      	mov	[S-6], A
    9032:	7a03      	lod	Y, [S-4]
    9034:	ac00      	cmp	A, #0
    9036:	1d73      	jne	0x901e <.L48>

00009038 <.LM87>:
         (isFunctionIdValid(&pDiagTransfer->request.data[2]) == ML_SUCCESS) ) {
    9038:	72e6      	lod	A, Y
    903a:	a006      	add	A, #6
    903c:	178f      	call	0x8f5c <_isFunctionIdValid>

0000903e <.LM88>:
        return respNoResponse;
    }
    /* else: (PCI-1) is valid, continue processing .. */

    /* Validate SupplierID [3..4] and FunctionID [5..6] */
    if ( (isSupplierIdValid(&pDiagTransfer->request.data[0]) == ML_SUCCESS) &&
    903e:	7a03      	lod	Y, [S-4]
    9040:	ac00      	cmp	A, #0
    9042:	1d6d      	jne	0x901e <.L48>

00009044 <.LM89>:
         (isFunctionIdValid(&pDiagTransfer->request.data[2]) == ML_SUCCESS) ) {
        ml_ConfiguredNAD = pDiagTransfer->request.data[4];   /* new NAD */
    9044:	e008      	add	Y, #8
    9046:	62f0      	lod	AL, [Y]
    9048:	42d8 10a4 	mov	0x10a4 <_ml_ConfiguredNAD>, AL

0000904c <.LM90>:
        return respPositiveAssignNAD;
    904c:	7004      	lod	A, #4

0000904e <.L52>:
            break; /* !case 0xB6 */
#endif /* SL_vLIN_2_1_plus || SL_vISO17987_2016 */

#if SL_vLIN_2_1_plus || SL_vISO17987_2016
        case 0xB7: /* Assign Frame ID range */
            pendingSlaveResponse = assignFrameIdRange();
    904e:	52d8 1190 	mov	0x1190 <_pendingSlaveResponse>, A

00009052 <.LM92>:
            break; /* !case 0xB7 */
    9052:	07a7      	jmp	0x8fa2 <.L37>

00009054 <.L38>:
 */
static SlaveResponse_t readByIdentifier (void)
{
    SlaveResponse_t retVal;

    if (pDiagTransfer->request.dataLen != 0x05u) {
    9054:	72f2      	lod	A, [Y+2]
    9056:	ac05      	cmp	A, #5
    9058:	1901      	je	0x905c <.LM94>
    905a:	0034      	jmp	0x90c4 <.L69>

0000905c <.LM94>:
        retVal = respNoResponse;
    } else {
        /* else: (PCI-1) is valid, continue processing .. */

        /* Validate SupplierID [4..5] and FunctionID [6..7] */
        if ( (isSupplierIdValid(&pDiagTransfer->request.data[1]) == ML_SUCCESS) &&
    905c:	72e6      	lod	A, Y
    905e:	a005      	add	A, #5
    9060:	5a03      	mov	[S-4], Y
    9062:	176d      	call	0x8f3e <_isSupplierIdValid>

00009064 <.LVL73>:
    9064:	5205      	mov	[S-6], A
    9066:	7a03      	lod	Y, [S-4]
    9068:	ac00      	cmp	A, #0
    906a:	1d2c      	jne	0x90c4 <.L69>

0000906c <.LM95>:
             (isFunctionIdValid(&pDiagTransfer->request.data[3]) == ML_SUCCESS) ) {
    906c:	72e6      	lod	A, Y
    906e:	a007      	add	A, #7
    9070:	1775      	call	0x8f5c <_isFunctionIdValid>

00009072 <.LM96>:
        retVal = respNoResponse;
    } else {
        /* else: (PCI-1) is valid, continue processing .. */

        /* Validate SupplierID [4..5] and FunctionID [6..7] */
        if ( (isSupplierIdValid(&pDiagTransfer->request.data[1]) == ML_SUCCESS) &&
    9072:	7a03      	lod	Y, [S-4]
    9074:	ac00      	cmp	A, #0
    9076:	1d26      	jne	0x90c4 <.L69>

00009078 <.LM97>:
             (isFunctionIdValid(&pDiagTransfer->request.data[3]) == ML_SUCCESS) ) {

            /* if supplier/function IDs are valid .. */

            switch (pDiagTransfer->request.data[0]) {    /* check IDs ..  */
    9078:	62f4      	lod	AL, [Y+4]
    907a:	4205      	mov	[S-6], AL
    907c:	6205      	lod	AL, [S-6]
    907e:	1924      	je	0x90c8 <.L71>
    9080:	5cf2      	usex	A
    9082:	7ee2      	lod	X, A
    9084:	ac01      	cmp	A, #1
    9086:	1d04      	jne	0x9090 <.L79>

00009088 <.LM98>:
                    retVal = respLinProductID;
                    break;

#if SL_EN_SERIAL_NUMBER_CALLOUT
                case 0x01:                      /* ID: Serial number (optional) */
                    retVal = respSerialNumber;
    9088:	7803      	lod	Y, #3

0000908a <.L44>:
            break;
#endif /* SL_vLIN_2_0 || (SL_vSAE_J2602_2012 && SL_EN_ASSIGN_FRAME_ID_SERVICE) */

#if SL_vLIN_2_x || SL_vISO17987_2016 || (SL_vSAE_J2602_2012 && SL_EN_READ_BY_ID_SERVICE)
        case 0xB2: /* Read by Identifier request */
            pendingSlaveResponse = readByIdentifier();
    908a:	5ad8 1190 	mov	0x1190 <_pendingSlaveResponse>, Y

0000908e <.LM100>:
            break;
    908e:	0789      	jmp	0x8fa2 <.L37>

00009090 <.L79>:
                    break;
#endif /* SL_vISO17987_2016 && SL_EN_NCF_LDF_VERSION */

                default:
#if SL_EN_READ_BY_ID_CALLOUT
                    if ( (pDiagTransfer->request.data[0] > 31u ) && (pDiagTransfer->request.data[0] < 64u) ) {
    9090:	6205      	lod	AL, [S-6]
    9092:	80e0      	add	AL, #-32
    9094:	8c1f      	cmp	AL, #31
    9096:	1e1a      	jug	0x90cc <.L72>

00009098 <.LBB52>:
                        l_u8 pci = 6; /* Default value */
    9098:	6006      	lod	AL, #6
    909a:	4209      	mov	[S-10], AL

0000909c <.LM103>:
                        l_u8 response = ld_read_by_id_callout (dummy,
                                                               pDiagTransfer->request.data[0],
                                                               (l_u8*)&pci,
                                                               pDiagTransfer->response.data);
    909c:	e004      	add	Y, #4

0000909e <.LM104>:

                default:
#if SL_EN_READ_BY_ID_CALLOUT
                    if ( (pDiagTransfer->request.data[0] > 31u ) && (pDiagTransfer->request.data[0] < 64u) ) {
                        l_u8 pci = 6; /* Default value */
                        l_u8 response = ld_read_by_id_callout (dummy,
    909e:	5adf      	push	Y

000090a0 <.LCFI5>:
    90a0:	72ef      	lod	A, S
    90a2:	a0f4      	add	A, #-12
    90a4:	52df      	push	A

000090a6 <.LCFI6>:
    90a6:	5edf      	push	X

000090a8 <.LCFI7>:
    90a8:	72d8 13d0 	lod	A, 0x13d0 <_dummy>
    90ac:	168e      	call	0x8dca <_ld_read_by_id_callout>
    90ae:	7ae2      	lod	Y, A

000090b0 <.LM105>:
                                                               pDiagTransfer->request.data[0],
                                                               (l_u8*)&pci,
                                                               pDiagTransfer->response.data);
                        pDiagTransfer->response.dataLen = (l_u16)pci - 1u; /* Convert PCI to data length */
    90b0:	7ed8 118e 	lod	X, 0x118e <_pDiagTransfer>
    90b4:	620f      	lod	AL, [S-16]

000090b6 <.LVL77>:
    90b6:	5cf2      	usex	A
    90b8:	a0ff      	add	A, #-1
    90ba:	52fa      	mov	[X+2], A

000090bc <.LM106>:
                        pDiagTransfer->response.respSId = RSID(SID_ReadById);
    90bc:	60f2      	lod	AL, #-14
    90be:	42f8      	mov	[X], AL

000090c0 <.LVL78>:
    90c0:	5c05      	dec	S, #6

000090c2 <.LCFI8>:
    90c2:	07e3      	jmp	0x908a <.L44>

000090c4 <.L69>:
{
    SlaveResponse_t retVal;

    if (pDiagTransfer->request.dataLen != 0x05u) {
        /* if (PCI-1) is not valid .. */
        retVal = respNoResponse;
    90c4:	7800      	lod	Y, #0
    90c6:	07e1      	jmp	0x908a <.L44>

000090c8 <.L71>:

            /* if supplier/function IDs are valid .. */

            switch (pDiagTransfer->request.data[0]) {    /* check IDs ..  */
                case 0x00:                      /* ID: LIN Product Identification */
                    retVal = respLinProductID;
    90c8:	7801      	lod	Y, #1
    90ca:	07df      	jmp	0x908a <.L44>

000090cc <.L72>:
                        retVal = (SlaveResponse_t)response;
                        break;
                    }
                    /* else : wrong ID */
#endif /* SL_EN_READ_BY_ID_CALLOUT */
                    retVal = respNegativeResponse;
    90cc:	7802      	lod	Y, #2
    90ce:	07dd      	jmp	0x908a <.L44>

000090d0 <.L41>:
/** Process Save Configuration frame.
 * @return  void
 */
static SlaveResponse_t saveConfiguration (void)
{
    if (pDiagTransfer->request.dataLen != 0u) {
    90d0:	72f2      	lod	A, [Y+2]
    90d2:	1901      	je	0x90d6 <.LM111>
    90d4:	07a4      	jmp	0x901e <.L48>

000090d6 <.LM111>:
        /* if (PCI-1) is not correct .. */
        return respNoResponse;
    }
    /* else: (PCI-1) is correct, continue processing .. */

    s_ifcStatus.mapped.SaveConfig = true;
    90d6:	7eda 13d2 	lod	X, #5074
    90da:	62f8      	lod	AL, [X]
    90dc:	8440      	or	AL, #64
    90de:	42f8      	mov	[X], AL

000090e0 <.LM112>:

    return respPositiveSaveConfig;
    90e0:	7006      	lod	A, #6
    90e2:	07b5      	jmp	0x904e <.L52>

000090e4 <.L51>:
                        }
                        /* else save unassignment to node_configuration */

#if ((SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE) || ((SL_vLIN_2_0 || SL_vSAE_J2602_2012) && \
                        SL_EN_SAVE_CONFIG_FUNC)
                        node_configuration[index] = 0x00U;
    90e4:	7e05      	lod	X, [S-6]
    90e6:	22da 13d8 	add	X, #5080
    90ea:	42f8      	mov	[X], AL

000090ec <.L53>:
                        }
                        /* else: don't store PID */
#endif /* !SL_vSAE_J2602_2012 && SL_EN_EVENT_TRIGGERED_FRAMES */
                    } /* assign */

                    (void)ml_Connect();
    90ec:	5a03      	mov	[S-4], Y
    90ee:	82db 11ee 	callf	0x23dc <_ml_Connect>
    90f2:	7a03      	lod	Y, [S-4]

000090f4 <.L49>:
                } /* proper index */
            } else {   /* id is 0xFF .. */
                       /* .. skip PID from processing */
            }

            --pid;          /*lint !e960 : deviation MISRA 2004:17.4 pointer decrement */
    90f4:	e0ff      	add	Y, #-1

000090f6 <.LM116>:
            --index;        /* get previous index */
    90f6:	6205      	lod	AL, [S-6]
    90f8:	80ff      	add	AL, #-1
    90fa:	5cf2      	usex	A
    90fc:	5205      	mov	[S-6], A

000090fe <.LM117>:
        l_u8 i;

        index = pDiagTransfer->request.data[0] + 3u; /* index of the last frame in the range */
        pid = &pDiagTransfer->request.data[4]; /* PID of the last frame in the range */

        for (i = 0U; i < 4U; i++) {
    90fe:	ae07      	cmp	A, [S-8]
    9100:	1901      	je	0x9104 <.LM118>
    9102:	0772      	jmp	0x8fe8 <.L55>

00009104 <.LM118>:

            --pid;          /*lint !e960 : deviation MISRA 2004:17.4 pointer decrement */
            --index;        /* get previous index */
        } /* for 4 pids */

        return respPositiveAssignFidRange;
    9104:	7005      	lod	A, #5

00009106 <.LVL86>:
    9106:	07a3      	jmp	0x904e <.L52>

00009108 <.L50>:
#if ((SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE) || ((SL_vLIN_2_0 || SL_vSAE_J2602_2012) && \
                        SL_EN_SAVE_CONFIG_FUNC)
                        node_configuration[index] = 0x00U;
#endif /* ((SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE) || ((SL_vLIN_2_0 || SL_vSAE_J2602_2012) && SL_EN_SAVE_CONFIG_FUNC) */
                    } else {                                      /* assign */
                        if (ml_AssignFrameToMessageID(index,*pid) != ML_SUCCESS) {
    9108:	5edf      	push	X

0000910a <.LCFI9>:
    910a:	7207      	lod	A, [S-8]
    910c:	5a05      	mov	[S-6], Y
    910e:	82db 1172 	callf	0x22e4 <_ml_AssignFrameToMessageID>
    9112:	5c01      	dec	S, #2

00009114 <.LCFI10>:
    9114:	7a03      	lod	Y, [S-4]
    9116:	ac00      	cmp	A, #0
    9118:	1901      	je	0x911c <.LM120>
    911a:	077f      	jmp	0x901a <.L54>

0000911c <.LM120>:
                        /* else: assignment was OK, continue processing */

#if ((SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE) || ((SL_vLIN_2_0 || SL_vSAE_J2602_2012) && \
                        SL_EN_SAVE_CONFIG_FUNC)
                        /* save assignment to node_configuration */
                        node_configuration[index] = *pid;
    911c:	7e05      	lod	X, [S-6]
    911e:	22da 13d8 	add	X, #5080
    9122:	0ea7      	lod	C, ML.7
    9124:	54c4      	movsb	[X++], [Y++]

00009126 <.LVL91>:
    9126:	e0ff      	add	Y, #-1
    9128:	07e1      	jmp	0x90ec <.L53>

0000912a <.L57>:
            retVal = false;
            break;

#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_EN_READ_BY_ID_SERVICE
        case respLinProductID:
            pDiagTransfer->response.respSId = RSID(SID_ReadById);
    912a:	7ed8 118e 	lod	X, 0x118e <_pDiagTransfer>
    912e:	60f2      	lod	AL, #-14
    9130:	42f8      	mov	[X], AL

00009132 <.LM122>:
            pDiagTransfer->response.dataLen = 5u; /* Only data bytes length */
    9132:	7005      	lod	A, #5
    9134:	52fa      	mov	[X+2], A

00009136 <.LM123>:
            pDiagTransfer->response.data[0] = ml_ProductID[0];
    9136:	62d8 5d80 	lod	AL, 0x5d80 <_ml_ProductID>
    913a:	42fc      	mov	[X+4], AL

0000913c <.LM124>:
            pDiagTransfer->response.data[1] = ml_ProductID[1];
    913c:	62d8 5d81 	lod	AL, 0x5d81 <_ml_ProductID+0x1>
    9140:	42fd      	mov	[X+5], AL

00009142 <.LM125>:
            pDiagTransfer->response.data[2] = ml_ProductID[2];
    9142:	62d8 5d82 	lod	AL, 0x5d82 <.LASF704>
    9146:	42fe      	mov	[X+6], AL

00009148 <.LM126>:
            pDiagTransfer->response.data[3] = ml_ProductID[3];
    9148:	62d8 5d83 	lod	AL, 0x5d83 <.LASF704+0x1>
    914c:	42ff      	mov	[X+7], AL

0000914e <.LM127>:
            pDiagTransfer->response.data[4] = ml_ProductID[4];
    914e:	2008      	add	X, #8
    9150:	62d8 5d84 	lod	AL, 0x5d84 <.LASF704+0x2>
    9154:	42f8      	mov	[X], AL

00009156 <.L74>:
 * - true  There is data to send;
 * - false There is nothing to send (no response).
 */
static bool ld_DiagResponse (void)
{
    bool retVal = true;
    9156:	7001      	lod	A, #1

00009158 <.L64>:
            break;
    }

    /* Prepare the response */
    return ld_DiagResponse();
}
    9158:	540b      	ret	#12

0000915a <.L60>:
            pDiagTransfer->response.data[4] = ml_ProductID[4];
            break;

#if SL_EN_SERIAL_NUMBER_CALLOUT
        case respSerialNumber:
            pDiagTransfer->response.respSId = RSID(SID_ReadById);
    915a:	7ed8 118e 	lod	X, 0x118e <_pDiagTransfer>
    915e:	60f2      	lod	AL, #-14
    9160:	42f8      	mov	[X], AL

00009162 <.LM131>:
            pDiagTransfer->response.dataLen = 4u; /* Only data bytes length */
    9162:	7004      	lod	A, #4
    9164:	52fa      	mov	[X+2], A

00009166 <.LM132>:
            ld_serial_number_callout(&pDiagTransfer->response.data[0]); /* Insert Serial Number into data bytes 3..6 */
    9166:	72ee      	lod	A, X
    9168:	a004      	add	A, #4
    916a:	15ee      	call	0x8d48 <_ld_serial_number_callout>
    916c:	07f4      	jmp	0x9156 <.L74>

0000916e <.L59>:
            pDiagTransfer->response.data[4] = 0x00u; /* reserved */
            break;
#endif /* SL_vISO17987_2016 && SL_EN_NCF_LDF_VERSION */

        case respNegativeResponse:
            pDiagTransfer->response.respSId = RSID_NegativeResponse;
    916e:	7ed8 118e 	lod	X, 0x118e <_pDiagTransfer>
    9172:	607f      	lod	AL, #127
    9174:	42f8      	mov	[X], AL

00009176 <.LM134>:
            pDiagTransfer->response.dataLen = 2u; /* Only data bytes length */
    9176:	7002      	lod	A, #2
    9178:	52fa      	mov	[X+2], A
    917a:	72da 12b2 	lod	A, #4786
    917e:	52fc      	mov	[X+4], A
    9180:	07ea      	jmp	0x9156 <.L74>

00009182 <.L61>:
            break;
#endif /* SL_vLIN_2_x || SL_vISO17987_2016 || SL_EN_READ_BY_ID_SERVICE */

#if SL_EN_ASSIGN_NAD_SERVICE
        case respPositiveAssignNAD:
            pDiagTransfer->response.respSId = RSID(SID_AssignNad);
    9182:	7ed8 118e 	lod	X, 0x118e <_pDiagTransfer>
    9186:	72da 00f0 	lod	A, #240

0000918a <.L80>:
            break;
#endif /* SL_vLIN_2_1_plus || SL_vISO17987_2016 */

#if (SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE
        case respPositiveSaveConfig:
            pDiagTransfer->response.respSId = RSID(SID_SaveConfiguration);
    918a:	42f8      	mov	[X], AL

0000918c <.LM137>:
            pDiagTransfer->response.dataLen = 0u; /* Only data bytes length */
    918c:	7000      	lod	A, #0
    918e:	52fa      	mov	[X+2], A
    9190:	07e2      	jmp	0x9156 <.L74>

00009192 <.L62>:
            break;
#endif /* SL_vSAE_J2602_2012 */

#if SL_vLIN_2_1_plus || SL_vISO17987_2016
        case respPositiveAssignFidRange:
            pDiagTransfer->response.respSId = RSID(SID_AssignFrameIdRange);
    9192:	7ed8 118e 	lod	X, 0x118e <_pDiagTransfer>
    9196:	72da 00f7 	lod	A, #247
    919a:	07f7      	jmp	0x918a <.L80>

0000919c <.L63>:
            break;
#endif /* SL_vLIN_2_1_plus || SL_vISO17987_2016 */

#if (SL_vLIN_2_1_plus || SL_vISO17987_2016) && SL_EN_SAVE_CONFIG_SERVICE
        case respPositiveSaveConfig:
            pDiagTransfer->response.respSId = RSID(SID_SaveConfiguration);
    919c:	7ed8 118e 	lod	X, 0x118e <_pDiagTransfer>
    91a0:	72da 00f6 	lod	A, #246
    91a4:	07f2      	jmp	0x918a <.L80>

000091a6 <_l_sys_init>:
 * - 1 - fail.
 */
l_bool l_sys_init(void)
{
    return (l_bool)0u;
}
    91a6:	7000      	lod	A, #0
    91a8:	5401      	ret

000091aa <_l_SetFlagsMask>:
 * @param[out]  dest    destination pointer
 * @param[in]   mask    used flags mask
 * @param[in]   size    area size
 */
void l_SetFlagsMask(volatile l_u8 *dest, const l_u8 *mask, const l_u8 size)
{
    91aa:	5805      	inc	S, #6

000091ac <.LCFI0>:
    91ac:	5201      	mov	[S-2], A
    91ae:	620b      	lod	AL, [S-12]

000091b0 <.LVL1>:
    91b0:	5cf2      	usex	A
    91b2:	5203      	mov	[S-4], A

000091b4 <.LBB6>:
    ENTER_STD_LIN_API_ATOMIC_SECTION();
    91b4:	16a5      	call	0x8f00 <_l_sys_irq_disable>
    91b6:	5205      	mov	[S-6], A

000091b8 <.LBB7>:
    for (l_u8 cnt = 0u; cnt < size; cnt++) {
    91b8:	7203      	lod	A, [S-4]

000091ba <.LVL4>:
    91ba:	190a      	je	0x91d0 <.L3>
    91bc:	7e09      	lod	X, [S-10]
    91be:	7a01      	lod	Y, [S-2]

000091c0 <.L4>:
        dest[cnt] |= mask[cnt];
    91c0:	62f0      	lod	AL, [Y]
    91c2:	86de      	or	AL, [X++]
    91c4:	42d6      	mov	[Y++], AL

000091c6 <.LM7>:
 * @param[in]   size    area size
 */
void l_SetFlagsMask(volatile l_u8 *dest, const l_u8 *mask, const l_u8 size)
{
    ENTER_STD_LIN_API_ATOMIC_SECTION();
    for (l_u8 cnt = 0u; cnt < size; cnt++) {
    91c6:	62e8      	lod	AL, YL
    91c8:	8a01      	sub	AL, [S-2]
    91ca:	5cf2      	usex	A
    91cc:	ae03      	cmp	A, [S-4]
    91ce:	1878      	jc	0x91c0 <.L4>

000091d0 <.L3>:
 *
 */

STATIC INLINE void l_sys_irq_restore_pointer (const l_irqmask *p)
{
    l_sys_irq_restore(*p);
    91d0:	7205      	lod	A, [S-6]
    91d2:	169e      	call	0x8f10 <_l_sys_irq_restore>

000091d4 <.LBE6>:
        dest[cnt] |= mask[cnt];
    }
    EXIT_STD_LIN_API_ATOMIC_SECTION();
}
    91d4:	5407      	ret	#8

000091d6 <_l_ifcUpdateOverrun>:
    91d6:	7eda 13d2 	lod	X, #5074
    91da:	66f8      	lod	YL, [X]
    91dc:	62e8      	lod	AL, YL
    91de:	9404      	and	AL, #4
    91e0:	1d0a      	jne	0x91f6 <.L1>

000091e2 <.LM3>:
    91e2:	62d8 1192 	lod	AL, 0x1192 <_s_ifcOverrunFramesCount>
    91e6:	8001      	add	AL, #1
    91e8:	42d8 1192 	mov	0x1192 <_s_ifcOverrunFramesCount>, AL

000091ec <.LM4>:
    91ec:	8c01      	cmp	AL, #1
    91ee:	1a03      	jule	0x91f6 <.L1>

000091f0 <.LM5>:
    91f0:	62e8      	lod	AL, YL
    91f2:	8404      	or	AL, #4
    91f4:	42f8      	mov	[X], AL

000091f6 <.L1>:
    91f6:	5401      	ret

000091f8 <_l_ifc_init_sl1>:
    91f8:	163b      	call	0x8e70 <_l_mls_Init>

000091fa <.LM9>:
    91fa:	6000      	lod	AL, #0
    91fc:	42d8 1192 	mov	0x1192 <_s_ifcOverrunFramesCount>, AL

00009200 <.LM10>:
    9200:	1689      	call	0x8f14 <_ld_DiagInit>

00009202 <.LM11>:
    9202:	82db 11ee 	callf	0x23dc <_ml_Connect>
    9206:	ac00      	cmp	A, #0
    9208:	5ca2      	sne	A

0000920a <.LM12>:
    920a:	5401      	ret

0000920c <_l_ifc_read_status_sl1>:
    920c:	5803      	inc	S, #4

0000920e <.LBB17>:
    920e:	1678      	call	0x8f00 <_l_sys_irq_disable>
    9210:	7ae2      	lod	Y, A

00009212 <.LM15>:
    9212:	7008      	lod	A, #8

00009214 <.LVL5>:
    9214:	5a01      	mov	[S-2], Y
    9216:	82db 11d3 	callf	0x23a6 <_ml_GetState>

0000921a <.LM16>:
    921a:	62d8 1010 	lod	AL, 0x1010 <.LLST29+0x6>
    921e:	9401      	and	AL, #1
    9220:	7a01      	lod	Y, [S-2]
    9222:	8c00      	cmp	AL, #0
    9224:	1905      	je	0x9230 <.L7>

00009226 <.LM17>:
    9226:	7eda 13d2 	lod	X, #5074
    922a:	62f8      	lod	AL, [X]
    922c:	8410      	or	AL, #16
    922e:	42f8      	mov	[X], AL

00009230 <.L7>:
    9230:	72d8 13d2 	lod	A, 0x13d2 <_s_ifcStatus>
    9234:	5203      	mov	[S-4], A

00009236 <.LM19>:
    9236:	6000      	lod	AL, #0

00009238 <.LVL8>:
    9238:	42d8 1192 	mov	0x1192 <_s_ifcOverrunFramesCount>, AL

0000923c <.LM20>:
    923c:	7000      	lod	A, #0
    923e:	0ea7      	lod	C, ML.7
    9240:	52d8 13d2 	mov	0x13d2 <_s_ifcStatus>, A

00009244 <.LBB18>:
    9244:	72e6      	lod	A, Y
    9246:	1664      	call	0x8f10 <_l_sys_irq_restore>

00009248 <.LBE17>:
    9248:	7203      	lod	A, [S-4]
    924a:	5405      	ret	#6

0000924c <_l_LinSleepMode>:
/** LIN Slave driver entered a sleep mode.
 * @param[in]   Reason    Reason of entering sleep mode.
 * @return void
 */
void l_LinSleepMode(ml_SleepReason_t Reason)
{
    924c:	7ee2      	lod	X, A

0000924e <.LM29>:

#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
    if (Reason == ml_reasonMaster) {
    924e:	ac01      	cmp	A, #1
    9250:	1d08      	jne	0x9262 <.L14>

00009252 <.LM30>:
        s_ifcStatus.mapped.GoToSleep = true;
    9252:	7ada 13d2 	lod	Y, #5074

00009256 <.LM31>:
        /*
         * MLX4 FW handles Goto Sleep frame (0x3C, 0x00 ...) automatically
         * and does not report it via l_MessageReceived event.
         * Hence write Protected ID 0x3C explicitly.
         */
        s_ifcStatus.mapped.PID = 0x3C;
    9256:	603c      	lod	AL, #60

00009258 <.LVL14>:
    9258:	42d8 13d3 	mov	0x13d3 <_s_ifcStatus+0x1>, AL

0000925c <.LM32>:
        s_ifcStatus.mapped.SuccessfulTrans = true;
    925c:	62f0      	lod	AL, [Y]
    925e:	840a      	or	AL, #10
    9260:	42f0      	mov	[Y], AL

00009262 <.L14>:
    }
    /* else: other reasons of sleep don't required special care */
#endif /* SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012 */

    l_ifc_sleep_entered_callout(Reason);    /* notify application on the sleep reason */
    9262:	72ee      	lod	A, X
    9264:	05f9      	jmp	0x8e58 <_l_ifc_sleep_entered_callout>

00009266 <_l_MessageReceived>:
 * @note The Signals write and Flags update are done atomically.
 * Thus the Signals / Flags API functions are allowed to be used in other interrupts
 * with higher priority then LIN ISR.
 */
void l_MessageReceived(ml_MessageID_t MessageIndex)
{
    9266:	5801      	inc	S, #2

00009268 <.LCFI1>:
    9268:	7ae2      	lod	Y, A

0000926a <.LM36>:
#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
    /*
     * Successful transfer is set if a frame has been
     * transmitted/received without an error
     */
    s_ifcStatus.mapped.SuccessfulTrans = true;
    926a:	7eda 13d2 	lod	X, #5074
    926e:	62f8      	lod	AL, [X]

00009270 <.LVL17>:
    9270:	8402      	or	AL, #2
    9272:	42f8      	mov	[X], AL

00009274 <.LM37>:
    s_ifcStatus.mapped.PID = ml_GetProtectedID();
    9274:	5a01      	mov	[S-2], Y
    9276:	82db 518c 	callf	0xa318 <_ml_GetProtectedID>
    927a:	42d8 13d3 	mov	0x13d3 <_s_ifcStatus+0x1>, AL

0000927e <.LM38>:
#endif /* SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012 */


        if (MessageIndex < SL_NUMBER_OF_DYNAMIC_MESSAGES) {
    927e:	7a01      	lod	Y, [S-2]
    9280:	ec01      	cmp	Y, #1
    9282:	1e0f      	jug	0x92a2 <.L15>

00009284 <.LBB20>:

        }
#else /*SUPPORT_MULTI_SLAVE*/

		/* Get Frame Handler */
		const l_s_UnconditionalFrame_t *uncondFrame = currentFrame->Frame;
    9284:	44a6      	asl	Y, #2
    9286:	e2da 5d76 	add	Y, #23926

0000928a <.LM40>:
		l_s_FrameHandler_t ProcessFrame = uncondFrame->FrameHandler;
    928a:	7ef0      	lod	X, [Y]
    928c:	7af8      	lod	Y, [X]

0000928e <.LM41>:

		/* Actions on the frame */
		(void)ProcessFrame(sfa_UpdateSignals); /* Use new signals values */
    928e:	7000      	lod	A, #0
    9290:	5a01      	mov	[S-2], Y
    9292:	0001      	jmp	0x9296 <.L18>

00009294 <.L17>:
    9294:	76e6      	jmp	Y

00009296 <.L18>:
    9296:	17fe      	call	0x9294 <.L17>

00009298 <.LM42>:
		(void)ProcessFrame(sfa_SetFlags);   /* Mark corresponding signal's flags as received */
    9298:	7003      	lod	A, #3
    929a:	7a01      	lod	Y, [S-2]
    929c:	0001      	jmp	0x92a0 <.L20>

0000929e <.L19>:
    929e:	76e6      	jmp	Y

000092a0 <.L20>:
    92a0:	17fe      	call	0x929e <.L19>

000092a2 <.L15>:
#endif /* SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012 */
#endif /*SUPPORT_MULTI_SLAVE*/
    } else {
        /* Unexpected frame -> ignore */
    }
}
    92a2:	5403      	ret	#4

000092a4 <_l_DataRequest>:
/** Header of the relevant non-diagnostic slave-to-master frame has been received.
 * @param[in]    MessageIndex    Message index of the current Frame
 * @return  void
 */
void l_DataRequest (ml_MessageID_t MessageIndex)
{
    92a4:	5801      	inc	S, #2

000092a6 <.LCFI2>:
    if (MessageIndex < SL_NUMBER_OF_DYNAMIC_MESSAGES) {
    92a6:	ac01      	cmp	A, #1
    92a8:	1e16      	jug	0x92d6 <.L22>

000092aa <.LBB21>:
        /* Non-diagnostic message */
        /* Get the frame by message index */
        const l_s_Frame_t *currentFrame = (const l_s_Frame_t*)&frameList[MessageIndex];

        /* Unconditional frame */
        if (currentFrame->FrameType == sft_UnconditionalFrame) {
    92aa:	44a2      	asl	A, #2

000092ac <.LVL27>:
    92ac:	7ee2      	lod	X, A
    92ae:	22da 5d74 	add	X, #23924
    92b2:	72f8      	lod	A, [X]
    92b4:	1d10      	jne	0x92d6 <.L22>

000092b6 <.LBB22>:
            /* Get Frame Handler */
            const l_s_UnconditionalFrame_t *uncondFrame = currentFrame->Frame;
            const l_s_FrameHandler_t ProcessFrame = uncondFrame->FrameHandler;
    92b6:	7efa      	lod	X, [X+2]
    92b8:	7af8      	lod	Y, [X]

000092ba <.LM48>:


#else	/*SUPPORT_MULTI_SLAVE*/

        /* Actions on the frame */
        (void)ProcessFrame(sfa_FillBuffer);          /* Fill the data buffer */
    92ba:	7001      	lod	A, #1
    92bc:	5a01      	mov	[S-2], Y
    92be:	0001      	jmp	0x92c2 <.L25>

000092c0 <.L24>:
    92c0:	76e6      	jmp	Y

000092c2 <.L25>:
    92c2:	17fe      	call	0x92c0 <.L24>

000092c4 <.LM49>:
        (void)ProcessFrame(sfa_SetFlags);            /* Consider Signals as sent */
    92c4:	7003      	lod	A, #3
    92c6:	7a01      	lod	Y, [S-2]
    92c8:	0001      	jmp	0x92cc <.L27>

000092ca <.L26>:
    92ca:	76e6      	jmp	Y

000092cc <.L27>:
    92cc:	17fe      	call	0x92ca <.L26>

000092ce <.LM50>:

#if SL_vSAE_J2602_2012
        l_u8 api_info = mlu_SAE_SetStatusApiInfo(MessageIndex); /* call User Application */
        (void)ml_SAE_DataReady(api_info);            /* Notify driver */
#else
        (void)ml_DataReady(ML_END_OF_TX_ENABLED);    /* Notify driver */
    92ce:	7001      	lod	A, #1
    92d0:	82db 1167 	callf	0x22ce <_ml_DataReady>

000092d4 <.LBE22>:
    92d4:	5403      	ret	#4

000092d6 <.L22>:
            }
        }
#endif /* !SL_vSAE_J2602_2012 && SL_EN_EVENT_TRIGGERED_FRAMES */
        /* Unexpected frame type -> ignore */
        else {
            (void)ml_DiscardFrame();
    92d6:	82db 119a 	callf	0x2334 <_ml_DiscardFrame>

000092da <.LBE21>:
    }
    /* Unexpected message index -> ignore */
    else {
        (void)ml_DiscardFrame();
    }
}
    92da:	5403      	ret	#4

000092dc <_l_ErrorDetected>:
            /* There is no J2602 only specific action for other errors */
            break;
    }
#endif /* SL_vSAE_J2602_2012 */

    switch (Error) {
    92dc:	a0fc      	add	A, #-4

000092de <.LVL35>:
    92de:	ac0c      	cmp	A, #12
    92e0:	1e1b      	jug	0x9318 <.L28>
    92e2:	4422      	asl	A
    92e4:	7ee2      	lod	X, A
    92e6:	22da 5d52 	add	X, #23890
    92ea:	76f8      	jmp	[X]

000092ec <.L32>:
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Overvoltage, signal, Fwv_Overvoltage)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Overcurrent, signal, Fwv_Overcurrent)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Overtemperature, signal, Fwv_Overtemperature)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Diag_Forced_Status, signal, Fwv_Diag_Forced_Status)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Position_Sensor_Fault, signal, Fwv_Position_Sensor_Fault)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_CommErr, signal, Fwv_CommErr)
    92ec:	1609      	call	0x8f00 <_l_sys_irq_disable>
    92ee:	7ee2      	lod	X, A

000092f0 <.LVL38>:
    92f0:	62d8 13d6 	lod	AL, 0x13d6 <_l_sl1_flags+0x2>

000092f4 <.LVL39>:
    92f4:	94df      	and	AL, #-33
    92f6:	42d8 13d6 	mov	0x13d6 <_l_sl1_flags+0x2>, AL
    92fa:	72ee      	lod	A, X
    92fc:	1609      	call	0x8f10 <_l_sys_irq_restore>

000092fe <.L33>:
L_SIGNAL(l_bool, Fwv_Overvoltage)
L_SIGNAL(l_bool, Fwv_Overcurrent)
L_SIGNAL(l_bool, Fwv_Overtemperature)
L_SIGNAL(l_bool, Fwv_Diag_Forced_Status)
L_SIGNAL(l_bool, Fwv_Position_Sensor_Fault)
L_SIGNAL(l_bool, Fwv_CommErr)
    92fe:	6001      	lod	AL, #1
    9300:	42d8 11a9 	mov	0x11a9 <.LASF1418>, AL

00009304 <.LBE31>:
             */
            l_flg_clr_response_error();

            l_bool_wr_response_error(true);
#endif /* !SL_vSAE_J2602_2012 */
            s_ifcStatus.mapped.ErrorInResponse = true;
    9304:	7eda 13d2 	lod	X, #5074
    9308:	62f8      	lod	AL, [X]
    930a:	8401      	or	AL, #1
    930c:	42f8      	mov	[X], AL

0000930e <.LM58>:
            s_ifcStatus.mapped.PID = ml_GetProtectedID();
    930e:	82db 518c 	callf	0xa318 <_ml_GetProtectedID>
    9312:	42d8 13d3 	mov	0x13d3 <_s_ifcStatus+0x1>, AL

00009316 <.LM59>:
#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
            l_ifcUpdateOverrun();
    9316:	175f      	call	0x91d6 <_l_ifcUpdateOverrun>

00009318 <.L28>:
    }

#if !SL_vSAE_J2602_2012 && SL_EN_EVENT_TRIGGERED_FRAMES
    isNonUnconditional = snuft_False;
#endif /* !SL_vSAE_J2602_2012 && SL_EN_EVENT_TRIGGERED_FRAMES */
}
    9318:	5401      	ret

0000931a <_l_DataTransmitted>:
#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
    /*
     * Successful transfer is set if a frame has been
     * transmitted/received without an error
     */
    s_ifcStatus.mapped.SuccessfulTrans = true;
    931a:	7eda 13d2 	lod	X, #5074
    931e:	62f8      	lod	AL, [X]

00009320 <.LVL45>:
    9320:	8402      	or	AL, #2
    9322:	42f8      	mov	[X], AL

00009324 <.LM63>:
    s_ifcStatus.mapped.PID = ml_GetProtectedID();
    9324:	82db 518c 	callf	0xa318 <_ml_GetProtectedID>
    9328:	42d8 13d3 	mov	0x13d3 <_s_ifcStatus+0x1>, AL

0000932c <.LM64>:
    l_ifcUpdateOverrun();
    932c:	1754      	call	0x91d6 <_l_ifcUpdateOverrun>

0000932e <.LBB39>:
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Overvoltage, signal, Fwv_Overvoltage)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Overcurrent, signal, Fwv_Overcurrent)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Overtemperature, signal, Fwv_Overtemperature)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Diag_Forced_Status, signal, Fwv_Diag_Forced_Status)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Position_Sensor_Fault, signal, Fwv_Position_Sensor_Fault)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_CommErr, signal, Fwv_CommErr)
    932e:	62d8 13d6 	lod	AL, 0x13d6 <_l_sl1_flags+0x2>

00009332 <.LBE39>:
    /*
     * The response_error flag is set when Response Error signal is copied to
     * frame buffer for transmission in the current frame. If an error occurred
     * during transmission, the flag is cleared in l_ErrorDetected handler.
     */
    if (l_flg_tst_response_error()) {
    9332:	9420      	and	AL, #32
    9334:	190c      	je	0x934e <.L34>

00009336 <.LBB41>:
    9336:	15e4      	call	0x8f00 <_l_sys_irq_disable>
    9338:	7ee2      	lod	X, A

0000933a <.LVL49>:
    933a:	62d8 13d6 	lod	AL, 0x13d6 <_l_sl1_flags+0x2>

0000933e <.LVL50>:
    933e:	94df      	and	AL, #-33
    9340:	42d8 13d6 	mov	0x13d6 <_l_sl1_flags+0x2>, AL
    9344:	72ee      	lod	A, X
    9346:	15e4      	call	0x8f10 <_l_sys_irq_restore>

00009348 <.LBB43>:
L_SIGNAL(l_bool, Fwv_Overvoltage)
L_SIGNAL(l_bool, Fwv_Overcurrent)
L_SIGNAL(l_bool, Fwv_Overtemperature)
L_SIGNAL(l_bool, Fwv_Diag_Forced_Status)
L_SIGNAL(l_bool, Fwv_Position_Sensor_Fault)
L_SIGNAL(l_bool, Fwv_CommErr)
    9348:	6000      	lod	AL, #0
    934a:	42d8 11a9 	mov	0x11a9 <.LASF1418>, AL

0000934e <.L34>:
    }

    /* Notify user application about end of transmission */
    mlu_SAE_DataTransmitted();
#endif /* SL_vSAE_J2602_2012 */
}
    934e:	5401      	ret

00009350 <_l_AutoAddressingStep>:
 * @return  void
 */
__attribute__((weak)) void l_AutoAddressingStep(l_u8 StepNumber)
{
    (void)StepNumber;   /* unused parameter */
}
    9350:	5401      	ret

00009352 <_l_FillBufferSlave>:
/** Fill the data buffer from source
 * @param[in]   src     pointer to source
 * @param[in]   size    area size
 */
void l_FillBufferSlave(l_u8 *src, l_u8 size)
{
    9352:	5805      	inc	S, #6

00009354 <.LCFI3>:
    9354:	5205      	mov	[S-6], A

00009356 <.LBB45>:
    for (l_u8 cnt = 0; cnt < size; cnt++) {
    9356:	6209      	lod	AL, [S-10]

00009358 <.LVL56>:
    9358:	1911      	je	0x937c <.L40>
    935a:	5cf2      	usex	A
    935c:	5203      	mov	[S-4], A
    935e:	7000      	lod	A, #0

00009360 <.L42>:
        ((l_u8*)ML_SLAVE_FRAME_DATA_BUFFER)[cnt] = src[cnt];
    9360:	7e05      	lod	X, [S-6]
    9362:	22e2      	add	X, A
    9364:	7ae2      	lod	Y, A
    9366:	e2da 1004 	add	Y, #4100
    936a:	0ea7      	lod	C, ML.7
    936c:	54cc      	movsb	[Y++], [X++]

0000936e <.LVL58>:
    936e:	a001      	add	A, #1

00009370 <.LM75>:
 * @param[in]   src     pointer to source
 * @param[in]   size    area size
 */
void l_FillBufferSlave(l_u8 *src, l_u8 size)
{
    for (l_u8 cnt = 0; cnt < size; cnt++) {
    9370:	66e0      	lod	YL, AL
    9372:	5cf6      	usex	Y
    9374:	5a01      	mov	[S-2], Y
    9376:	7a03      	lod	Y, [S-4]
    9378:	ee01      	cmp	Y, [S-2]
    937a:	1e72      	jug	0x9360 <.L42>

0000937c <.L40>:
        ((l_u8*)ML_SLAVE_FRAME_DATA_BUFFER)[cnt] = src[cnt];
    }
}
    937c:	5407      	ret	#8

0000937e <_l_sl1_VPC_Fwv_Ctrl_handler>:
static l_s_FrameHandlerStatus_t l_sl1_VPC_Fwv_Ctrl_handler (l_s_FrameAction_t frameAction)
{
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    static const l_sl1_flags_t VPC_Fwv_Ctrl_flags_mask = {{0x1f, 0x0, 0x0, 0x2}};

    switch (frameAction) {
    937e:	ac01      	cmp	A, #1
    9380:	1903      	je	0x9388 <.L3>
    9382:	180b      	jc	0x939a <.L4>
    9384:	ac03      	cmp	A, #3
    9386:	1d28      	jne	0x93d8 <.L12>

00009388 <.L3>:
            break;
        }
        case sfa_FillBuffer:    /* For S2M frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&VPC_Fwv_Ctrl_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
    9388:	54ca 0004 	pushw	#4

0000938c <.LCFI0>:
    938c:	54ca 5d70 	pushw	#23920

00009390 <.LCFI1>:
    9390:	72da 13d4 	lod	A, #5076

00009394 <.LVL1>:
    9394:	170a      	call	0x91aa <_l_SetFlagsMask>

00009396 <.LM4>:
            break;
    9396:	5c03      	dec	S, #4

00009398 <.LCFI2>:
    9398:	001d      	jmp	0x93d4 <.L13>

0000939a <.L4>:

    switch (frameAction) {
        case sfa_UpdateSignals:    /* For M2S frames */
        {
            l_sl1_VPC_Fwv_Ctrl_data_t MLXCOMP_354_WA *VPC_Fwv_Ctrl_data = (l_sl1_VPC_Fwv_Ctrl_data_t*)ML_SLAVE_FRAME_DATA_BUFFER;
            l_signals.Fwv_Target_Mode = VPC_Fwv_Ctrl_data->sig_Fwv_Target_Mode;
    939a:	7eda 1004 	lod	X, #4100
    939e:	62f8      	lod	AL, [X]

000093a0 <.LVL4>:
    93a0:	9407      	and	AL, #7
    93a2:	42d8 1194 	mov	0x1194 <_l_signals>, AL

000093a6 <.LM6>:
            l_signals.Fwv_MoveEnable = VPC_Fwv_Ctrl_data->sig_Fwv_MoveEnable;
    93a6:	62f8      	lod	AL, [X]
    93a8:	44b0      	lsr	AL, #2
    93aa:	4430      	lsr	AL
    93ac:	9401      	and	AL, #1
    93ae:	42d8 1195 	mov	0x1195 <_l_signals+0x1>, AL

000093b2 <.LM7>:
            l_signals.Fwv_Initial = VPC_Fwv_Ctrl_data->sig_Fwv_Initial;
    93b2:	62f8      	lod	AL, [X]
    93b4:	44b0      	lsr	AL, #2
    93b6:	44b0      	lsr	AL, #2
    93b8:	9401      	and	AL, #1
    93ba:	42d8 1196 	mov	0x1196 <_l_signals+0x2>, AL

000093be <.LM8>:
            l_signals.Fwv_ForcedDiag = VPC_Fwv_Ctrl_data->sig_Fwv_ForcedDiag;
    93be:	62f8      	lod	AL, [X]
    93c0:	44b0      	lsr	AL, #2
    93c2:	44b0      	lsr	AL, #2
    93c4:	4430      	lsr	AL
    93c6:	9401      	and	AL, #1
    93c8:	42d8 1197 	mov	0x1197 <_l_signals+0x3>, AL

000093cc <.LM9>:
            l_signals.Fwv_Reserved1 = VPC_Fwv_Ctrl_data->sig_Fwv_Reserved1;
    93cc:	62d8 1005 	lod	AL, 0x1005 <_ml_Data+0x1>
    93d0:	42d8 1198 	mov	0x1198 <_l_signals+0x4>, AL

000093d4 <.L13>:
} l_sl1_VPC_Fwv_Ctrl_data_t;
ASSERT(sizeof(l_sl1_VPC_Fwv_Ctrl_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_VPC_Fwv_Ctrl_handler (l_s_FrameAction_t frameAction)
{
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    93d4:	7000      	lod	A, #0

000093d6 <.LM11>:
        }
        case sfa_FillBuffer:    /* For S2M frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&VPC_Fwv_Ctrl_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
            break;
    93d6:	5401      	ret

000093d8 <.L12>:
        }
        case sfa_CheckFlags:    /* Only for frames associated with an Event-triggered frame */
        default:
            retVal = sfhs_Fail;
    93d8:	7001      	lod	A, #1

000093da <.LM13>:
            break;
    }
    return retVal;
}
    93da:	5401      	ret

000093dc <_l_sl1_VPC_Fwv_Resp_handler>:
    l_u8 unused56  : 8;
} l_sl1_VPC_Fwv_Resp_data_t;
ASSERT(sizeof(l_sl1_VPC_Fwv_Resp_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_VPC_Fwv_Resp_handler (l_s_FrameAction_t frameAction)
{
    93dc:	582f      	inc	S, #48

000093de <.LCFI3>:
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    static const l_sl1_flags_t VPC_Fwv_Resp_flags_mask = {{0xe0, 0xff, 0xff, 0x1}};

    switch (frameAction) {
    93de:	ac01      	cmp	A, #1
    93e0:	190d      	je	0x93fc <.L16>
    93e2:	1803      	jc	0x93ea <.L17>
    93e4:	ac03      	cmp	A, #3
    93e6:	1901      	je	0x93ea <.L17>
    93e8:	00e0      	jmp	0x95aa <.L22>

000093ea <.L17>:
            break;
        }
        case sfa_UpdateSignals:     /* For M2S frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&VPC_Fwv_Resp_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
    93ea:	54ca 0004 	pushw	#4

000093ee <.LCFI4>:
    93ee:	54ca 5d6c 	pushw	#23916

000093f2 <.LCFI5>:
    93f2:	72da 13d4 	lod	A, #5076

000093f6 <.LVL10>:
    93f6:	16d9      	call	0x91aa <_l_SetFlagsMask>

000093f8 <.LM17>:
            break;
    93f8:	5c03      	dec	S, #4

000093fa <.LCFI6>:
    93fa:	00d5      	jmp	0x95a6 <.L23>

000093fc <.L16>:

    switch (frameAction) {
        case sfa_FillBuffer:    /* For S2M frames */
        {
            /* Freeze the volatile Signal values */
            l_u8 sig_Fwv_Actual_Mode = l_signals.Fwv_Actual_Mode;
    93fc:	66d8 1199 	lod	YL, 0x1199 <_l_signals+0x5>

00009400 <.LM19>:
            l_bool sig_Fwv_Position_Fault = l_signals.Fwv_Position_Fault;
    9400:	62d8 119a 	lod	AL, 0x119a <_l_signals+0x6>

00009404 <.LVL14>:
    9404:	4205      	mov	[S-6], AL

00009406 <.LM20>:
            l_bool sig_Fwv_FaultMode = l_signals.Fwv_FaultMode;
    9406:	62d8 119b 	lod	AL, 0x119b <_l_signals+0x7>

0000940a <.LVL16>:
    940a:	4209      	mov	[S-10], AL

0000940c <.LM21>:
            l_bool sig_Fwv_ProtectMode = l_signals.Fwv_ProtectMode;
    940c:	62d8 119c 	lod	AL, 0x119c <_l_signals+0x8>

00009410 <.LVL18>:
    9410:	420b      	mov	[S-12], AL

00009412 <.LM22>:
            l_bool sig_Fwv_InitialSta = l_signals.Fwv_InitialSta;
    9412:	62d8 119d 	lod	AL, 0x119d <_l_signals+0x9>

00009416 <.LVL20>:
    9416:	420d      	mov	[S-14], AL

00009418 <.LM23>:
            l_bool sig_Fwv_Calibration_Fail = l_signals.Fwv_Calibration_Fail;
    9418:	62d8 119e 	lod	AL, 0x119e <_l_signals+0xa>

0000941c <.LVL22>:
    941c:	420f      	mov	[S-16], AL

0000941e <.LM24>:
            l_bool sig_Fwv_MoveEnable_Status = l_signals.Fwv_MoveEnable_Status;
    941e:	62d8 119f 	lod	AL, 0x119f <_l_signals+0xb>

00009422 <.LVL24>:
    9422:	4211      	mov	[S-18], AL

00009424 <.LM25>:
            l_bool sig_Fwv_Motor_Stall = l_signals.Fwv_Motor_Stall;
    9424:	62d8 11a0 	lod	AL, 0x11a0 <_l_signals+0xc>

00009428 <.LVL26>:
    9428:	4213      	mov	[S-20], AL

0000942a <.LM26>:
            l_bool sig_Fwv_Short_Circuit = l_signals.Fwv_Short_Circuit;
    942a:	62d8 11a1 	lod	AL, 0x11a1 <_l_signals+0xd>

0000942e <.LVL28>:
    942e:	4215      	mov	[S-22], AL

00009430 <.LM27>:
            l_bool sig_Fwv_Open_Circuit = l_signals.Fwv_Open_Circuit;
    9430:	62d8 11a2 	lod	AL, 0x11a2 <_l_signals+0xe>

00009434 <.LVL30>:
    9434:	4217      	mov	[S-24], AL

00009436 <.LM28>:
            l_bool sig_Fwv_Undervoltage = l_signals.Fwv_Undervoltage;
    9436:	62d8 11a3 	lod	AL, 0x11a3 <_l_signals+0xf>

0000943a <.LVL32>:
    943a:	4219      	mov	[S-26], AL

0000943c <.LM29>:
            l_bool sig_Fwv_Overvoltage = l_signals.Fwv_Overvoltage;
    943c:	62d8 11a4 	lod	AL, 0x11a4 <_l_signals+0x10>

00009440 <.LVL34>:
    9440:	421b      	mov	[S-28], AL

00009442 <.LM30>:
            l_bool sig_Fwv_Overcurrent = l_signals.Fwv_Overcurrent;
    9442:	62d8 11a5 	lod	AL, 0x11a5 <_l_signals+0x11>

00009446 <.LVL36>:
    9446:	421d      	mov	[S-30], AL

00009448 <.LM31>:
            l_bool sig_Fwv_Overtemperature = l_signals.Fwv_Overtemperature;
    9448:	62d8 11a6 	lod	AL, 0x11a6 <_l_signals+0x12>

0000944c <.LVL38>:
    944c:	421f      	mov	[S-32], AL

0000944e <.LM32>:
            l_bool sig_Fwv_Diag_Forced_Status = l_signals.Fwv_Diag_Forced_Status;
    944e:	62d8 11a7 	lod	AL, 0x11a7 <_l_signals+0x13>

00009452 <.LVL40>:
    9452:	4221      	mov	[S-34], AL

00009454 <.LM33>:
            l_bool sig_Fwv_Position_Sensor_Fault = l_signals.Fwv_Position_Sensor_Fault;
    9454:	62d8 11a8 	lod	AL, 0x11a8 <_l_signals+0x14>

00009458 <.LVL42>:
    9458:	4223      	mov	[S-36], AL

0000945a <.LM34>:
            l_bool sig_Fwv_CommErr = l_signals.Fwv_CommErr;
    945a:	62d8 11a9 	lod	AL, 0x11a9 <.LASF1418>

0000945e <.LVL44>:
    945e:	4225      	mov	[S-38], AL

00009460 <.LM35>:
            l_u16 sig_Fwv_SW_Version = l_signals.Fwv_SW_Version;
    9460:	72d8 11aa 	lod	A, 0x11aa <.LASF1418+0x1>

00009464 <.LVL46>:
    9464:	5207      	mov	[S-8], A

00009466 <.LM36>:
            l_u8 sig_Fwv_Stall_State = l_signals.Fwv_Stall_State;
    9466:	62d8 11ac 	lod	AL, 0x11ac <.LASF1418+0x3>

0000946a <.LVL48>:
    946a:	4227      	mov	[S-40], AL

0000946c <.LM37>:

            l_sl1_VPC_Fwv_Resp_data_t VPC_Fwv_Resp_data = {
    946c:	7ee6      	lod	X, Y
    946e:	3407      	and	X, #7
    9470:	5e01      	mov	[S-2], X
    9472:	7a2f      	lod	Y, [S-48]

00009474 <.LVL50>:
    9474:	f4f0      	and	Y, #-16
    9476:	7e05      	lod	X, [S-6]
    9478:	3401      	and	X, #1
    947a:	72ee      	lod	A, X

0000947c <.LVL51>:
    947c:	44a2      	asl	A, #2
    947e:	4422      	asl	A
    9480:	e601      	or	Y, [S-2]
    9482:	e6e2      	or	Y, A
    9484:	7e09      	lod	X, [S-10]
    9486:	3401      	and	X, #1
    9488:	72ee      	lod	A, X
    948a:	44a2      	asl	A, #2
    948c:	44a2      	asl	A, #2
    948e:	5201      	mov	[S-2], A
    9490:	f4cf      	and	Y, #-49
    9492:	7e0b      	lod	X, [S-12]
    9494:	3401      	and	X, #1
    9496:	72ee      	lod	A, X
    9498:	4862 0020 	mulu	A, A, #32
    949c:	e601      	or	Y, [S-2]
    949e:	e6e2      	or	Y, A
    94a0:	7e0d      	lod	X, [S-14]
    94a2:	3401      	and	X, #1
    94a4:	72ee      	lod	A, X
    94a6:	4862 0040 	mulu	A, A, #64
    94aa:	5201      	mov	[S-2], A
    94ac:	f6da ff3f 	and	Y, #65343
    94b0:	7e0f      	lod	X, [S-16]
    94b2:	3401      	and	X, #1
    94b4:	72ee      	lod	A, X
    94b6:	4862 0080 	mulu	A, A, #128
    94ba:	e601      	or	Y, [S-2]
    94bc:	e6e2      	or	Y, A
    94be:	7e11      	lod	X, [S-18]
    94c0:	3401      	and	X, #1
    94c2:	72ee      	lod	A, X
    94c4:	6800      	lod	AH, #0
    94c6:	72e4      	swap	A
    94c8:	5201      	mov	[S-2], A
    94ca:	f6da fcff 	and	Y, #64767
    94ce:	7e13      	lod	X, [S-20]
    94d0:	3401      	and	X, #1
    94d2:	72ee      	lod	A, X
    94d4:	4862 0200 	mulu	A, A, #512
    94d8:	e601      	or	Y, [S-2]
    94da:	e6e2      	or	Y, A
    94dc:	7e15      	lod	X, [S-22]
    94de:	3401      	and	X, #1
    94e0:	72ee      	lod	A, X
    94e2:	4862 0400 	mulu	A, A, #1024
    94e6:	5201      	mov	[S-2], A
    94e8:	f6da f3ff 	and	Y, #62463
    94ec:	7e17      	lod	X, [S-24]
    94ee:	3401      	and	X, #1
    94f0:	72ee      	lod	A, X
    94f2:	4862 0800 	mulu	A, A, #2048
    94f6:	e601      	or	Y, [S-2]
    94f8:	e6e2      	or	Y, A
    94fa:	7e19      	lod	X, [S-26]
    94fc:	3401      	and	X, #1
    94fe:	72ee      	lod	A, X
    9500:	4862 1000 	mulu	A, A, #4096
    9504:	5201      	mov	[S-2], A
    9506:	f6da cfff 	and	Y, #53247
    950a:	7e1b      	lod	X, [S-28]
    950c:	3401      	and	X, #1
    950e:	72ee      	lod	A, X
    9510:	4862 2000 	mulu	A, A, #8192
    9514:	e601      	or	Y, [S-2]
    9516:	e6e2      	or	Y, A
    9518:	7e1d      	lod	X, [S-30]
    951a:	3401      	and	X, #1
    951c:	72ee      	lod	A, X
    951e:	b403      	and	A, #3
    9520:	44d2      	rr	A, #2
    9522:	5203      	mov	[S-4], A
    9524:	f6da 3fff 	and	Y, #16383
    9528:	621f      	lod	AL, [S-32]
    952a:	b401      	and	A, #1
    952c:	4452      	rr	A
    952e:	7ee2      	lod	X, A
    9530:	7203      	lod	A, [S-4]
    9532:	a6e6      	or	A, Y
    9534:	a6ee      	or	A, X
    9536:	522f      	mov	[S-48], A
    9538:	6621      	lod	YL, [S-34]
    953a:	f401      	and	Y, #1
    953c:	7e2d      	lod	X, [S-46]
    953e:	34fc      	and	X, #-4
    9540:	5e01      	mov	[S-2], X
    9542:	7e23      	lod	X, [S-36]
    9544:	3401      	and	X, #1
    9546:	72ee      	lod	A, X
    9548:	4422      	asl	A
    954a:	7e01      	lod	X, [S-2]
    954c:	26e6      	or	X, Y
    954e:	26e2      	or	X, A
    9550:	6225      	lod	AL, [S-38]
    9552:	b401      	and	A, #1
    9554:	44a2      	asl	A, #2
    9556:	7ae2      	lod	Y, A
    9558:	72ee      	lod	A, X
    955a:	94fb      	and	AL, #-5
    955c:	a6e6      	or	A, Y
    955e:	84f8      	or	AL, #-8
    9560:	422d      	mov	[S-46], AL
    9562:	6207      	lod	AL, [S-8]
    9564:	422c      	mov	[S-45], AL
    9566:	7a07      	lod	Y, [S-8]
    9568:	6400      	lod	YL, #0
    956a:	7ae8      	swap	Y
    956c:	7e2b      	lod	X, [S-44]
    956e:	36da fc00 	and	X, #64512
    9572:	5e03      	mov	[S-4], X
    9574:	7e27      	lod	X, [S-40]
    9576:	3403      	and	X, #3
    9578:	5e07      	mov	[S-8], X

0000957a <.LVL52>:
    957a:	72ee      	lod	A, X
    957c:	6800      	lod	AH, #0
    957e:	72e4      	swap	A
    9580:	7e03      	lod	X, [S-4]
    9582:	26e6      	or	X, Y
    9584:	a6ee      	or	A, X
    9586:	522b      	mov	[S-44], A
    9588:	7eef      	lod	X, S
    958a:	20d5      	add	X, #-43
    958c:	62f8      	lod	AL, [X]
    958e:	84fc      	or	AL, #-4
    9590:	42f8      	mov	[X], AL
    9592:	72da 00ff 	lod	A, #255
    9596:	4229      	mov	[S-42], AL
    9598:	4228      	mov	[S-41], AL

0000959a <.LM38>:
                sig_Fwv_Stall_State,
                0x3f,
                0xff,
                0xff
            };
            l_FillBufferSlave((l_u8*)&VPC_Fwv_Resp_data, (l_u8)sizeof(l_sl1_VPC_Fwv_Resp_data_t));
    959a:	54ca 0008 	pushw	#8

0000959e <.LCFI7>:
    959e:	72ef      	lod	A, S
    95a0:	a0ce      	add	A, #-50
    95a2:	16d7      	call	0x9352 <_l_FillBufferSlave>

000095a4 <.LVL54>:
    95a4:	5c01      	dec	S, #2

000095a6 <.L23>:
} l_sl1_VPC_Fwv_Resp_data_t;
ASSERT(sizeof(l_sl1_VPC_Fwv_Resp_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_VPC_Fwv_Resp_handler (l_s_FrameAction_t frameAction)
{
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    95a6:	7000      	lod	A, #0

000095a8 <.LM40>:
        }
        case sfa_UpdateSignals:     /* For M2S frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&VPC_Fwv_Resp_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
            break;
    95a8:	5431      	ret	#50

000095aa <.L22>:
        }
        case sfa_CheckFlags:    /* Only for frames associated with an Event-triggered frame */
        default:
            retVal = sfhs_Fail;
    95aa:	7001      	lod	A, #1

000095ac <.LM42>:
            break;
    }
    return retVal;
}
    95ac:	5431      	ret	#50

000095ae <_globalVariableInit>:
 * @return 0
 */

void globalVariableInit(void)
{
	g_u16MotorSupplyVoltage = C_VSUP_REF; /**< [10mV] */
    95ae:	72da 04b0 	lod	A, #1200
    95b2:	52d8 13fe 	mov	0x13fe <_g_u16MotorSupplyVoltage>, A

000095b6 <.LM3>:
	g_i16ChipTemperature = 35;			  /**< [C] */
    95b6:	7c23      	lod	X, #35
    95b8:	0ea7      	lod	C, ML.7
    95ba:	5ed8 13e4 	mov	0x13e4 <_g_i16ChipTemperature>, X

000095be <.LM4>:
	g_u16SupplyVoltage = C_VSUP_REF;	  /**< [10mV] */
    95be:	52d8 1406 	mov	0x1406 <_g_u16SupplyVoltage>, A

000095c2 <.LM5>:
	g_u16VBGD = 1185u;					  /**< analog supply voltage [1mV] */
    95c2:	72da 04a1 	lod	A, #1185
    95c6:	0ea7      	lod	C, ML.7
    95c8:	52d8 1402 	mov	0x1402 <_g_u16VBGD>, A

000095cc <.LM6>:
	l_u32MotorSupplyVoltageFilter = 0u;
    95cc:	4cfa 0000 	movs	YA, #0
    95d0:	52d8 140a 	mov	0x140a <_l_u32MotorSupplyVoltageFilter>, A
    95d4:	0ea7      	lod	C, ML.7
    95d6:	5ad8 140c 	mov	0x140c <_l_u32MotorSupplyVoltageFilter+0x2>, Y

000095da <.LM7>:
	l_u32SupplyVoltageFilter = 0u;
    95da:	52d8 13de 	mov	0x13de <_l_u32SupplyVoltageFilter>, A
    95de:	5ad8 13e0 	mov	0x13e0 <_l_u32SupplyVoltageFilter+0x2>, Y

000095e2 <.LM8>:
	l_u32ChipTemperatureFilter = 0u;
    95e2:	0ea7      	lod	C, ML.7
    95e4:	52d8 13f4 	mov	0x13f4 <_l_u32ChipTemperatureFilter>, A
    95e8:	5ad8 13f6 	mov	0x13f6 <_l_u32ChipTemperatureFilter+0x2>, Y

000095ec <.LM9>:
	g_u16IO3 = 0;  /**< [1mV] */
    95ec:	52d8 13f2 	mov	0x13f2 <_g_u16IO3>, A

000095f0 <.LM10>:
	g_u16VDDA = 0; /**< [1mV] */
    95f0:	0ea7      	lod	C, ML.7
    95f2:	52d8 13ee 	mov	0x13ee <_g_u16VDDA>, A

000095f6 <.LM11>:
	g_i16ShuntCurrent = 0u;
    95f6:	52d8 1400 	mov	0x1400 <_g_i16ShuntCurrent>, A

000095fa <.LM12>:
	g_u16PositionSensor = 0;
    95fa:	52d8 13dc 	mov	0x13dc <_g_u16PositionSensor>, A

000095fe <.LM13>:
	u16_Angle_Gap = 0;
    95fe:	0ea7      	lod	C, ML.7
    9600:	52d8 13e8 	mov	0x13e8 <_u16_Angle_Gap>, A

00009604 <.LM14>:
	SetDuty = 0;
    9604:	52d8 13f0 	mov	0x13f0 <_SetDuty>, A

00009608 <.LM15>:
	u16_LIN_Target_Angle = 3;
    9608:	7c03      	lod	X, #3
    960a:	0ea7      	lod	C, ML.7
    960c:	5ed8 13ec 	mov	0x13ec <_u16_LIN_Target_Angle>, X

00009610 <.LM16>:
	u16_CONV_Target_Angle = 0;
    9610:	52d8 13e2 	mov	0x13e2 <_u16_CONV_Target_Angle>, A

00009614 <.LM17>:
	u16_Target_Angle_LCL = 0;
    9614:	52d8 13fa 	mov	0x13fa <_u16_Target_Angle_LCL>, A

00009618 <.LM18>:
	u16_Target_Angle_UCL = 0;
    9618:	0ea7      	lod	C, ML.7
    961a:	52d8 13e6 	mov	0x13e6 <_u16_Target_Angle_UCL>, A

0000961e <.LM19>:
	Angle_Hysteresis = 7U;
    961e:	7c07      	lod	X, #7
    9620:	5ed8 13f8 	mov	0x13f8 <_Angle_Hysteresis>, X

00009624 <.LM20>:
	u16_Duty_Dec_Range = 0;
    9624:	0ea7      	lod	C, ML.7
    9626:	52d8 13da 	mov	0x13da <_u16_Duty_Dec_Range>, A

0000962a <.LM21>:
	u16_IGN_PORT_CNT = 0;
    962a:	52d8 13ea 	mov	0x13ea <_u16_IGN_PORT_CNT>, A

0000962e <.LM22>:
}
    962e:	5401      	ret

00009630 <_main>:

int main(void)
{
    9630:	5801      	inc	S, #2

00009632 <.LBB234>:

/** WDG_disableIwdIt disables the intelligent watchdog timer interrupt */
STATIC INLINE void WDG_disableIwdIt(void)
{
    /* disable IWD interrupt */
    IO_SET(MLX16, IWD_ATT_ITC, 0u);
    9632:	62d8 006c 	lod	AL, 0x6c <__mlx4_cst_tables_ram_size+0xe>
    9636:	94f7      	and	AL, #-9
    9638:	42d8 006c 	mov	0x6c <__mlx4_cst_tables_ram_size+0xe>, AL

0000963c <.LBE234>:
	/* Initialize watch-dogs, both analogue and digital */
	WDG_disableIwdIt();

	/* Initialize globalVariable */
	globalVariableInit();
    963c:	17b8      	call	0x95ae <_globalVariableInit>

0000963e <.LBB236>:
 * Log reset source
 */
static void log_reset_source(void)
{
	uint16_t temp;
	if (IO_GET(PORT_MISC_IN, LOCAL_WU) != 0u)
    963e:	72d8 01e2 	lod	A, 0x1e2 <_PORT_MISC_IN>
    9642:	d440      	and	AH, #64
    9644:	1d05      	jne	0x9650 <.L15>

00009646 <.LM27>:
	{
		/* IO_0 wake up */
	}
	else if (IO_GET(PORT_MISC_IN, LIN_WU) != 0u)
    9646:	72d8 01e2 	lod	A, 0x1e2 <_PORT_MISC_IN>
    964a:	d408      	and	AH, #8
    964c:	1d01      	jne	0x9650 <.L15>

0000964e <.LM28>:
	{
		/* LIN wake up */
	}
	else if (IO_GET(RST_CTRL, AWD_WBOOT) != 0u)
    964e:	7282      	lod	A, io:0x2 <_RST_CTRL>

00009650 <.L15>:
	uint16_t temp;
	if (IO_GET(PORT_MISC_IN, LOCAL_WU) != 0u)
	{
		/* IO_0 wake up */
	}
	else if (IO_GET(PORT_MISC_IN, LIN_WU) != 0u)
    9650:	7020      	lod	A, #32
    9652:	5201      	mov	[S-2], A

00009654 <.L7>:

STATIC INLINE uint8_t softio_get(GpioIo_t IO)
{
    uint8_t pinlevel = 0xFFu;
    if(IO <= MAXIO_INDEX) {
        pinlevel = (uint8_t)(IO_GET(PORT_IO_IN, IO_IN_SYNC) >> (uint16_t)IO) & 0x01u;
    9654:	72d8 01de 	lod	A, 0x1de <_PORT_IO_IN>

00009658 <.LBE238>:
	}
#if LIN_WAKEUP_DISABLE == 1
	for (temp = 32; temp > 0; temp--)
	{

		if (softio_get(0) == 0)
    9658:	9401      	and	AL, #1
    965a:	1d09      	jne	0x966e <.L5>

0000965c <.LM32>:
		{

			u16_IGN_PORT_CNT++;
    965c:	72d8 13ea 	lod	A, 0x13ea <_u16_IGN_PORT_CNT>
    9660:	a001      	add	A, #1
    9662:	52d8 13ea 	mov	0x13ea <_u16_IGN_PORT_CNT>, A

00009666 <.LM33>:
			if (u16_IGN_PORT_CNT >= 16)
    9666:	ac0f      	cmp	A, #15
    9668:	1a02      	jule	0x966e <.L5>

0000966a <.LM34>:
			{
				lin22_GotoSleep();
    966a:	82db 46b8 	callf	0x8d70 <_lin22_GotoSleep>

0000966e <.L5>:
	{

		/* power on reset */
	}
#if LIN_WAKEUP_DISABLE == 1
	for (temp = 32; temp > 0; temp--)
    966e:	7201      	lod	A, [S-2]
    9670:	a0ff      	add	A, #-1

00009672 <.LVL4>:
    9672:	5201      	mov	[S-2], A
    9674:	1d6f      	jne	0x9654 <.L7>

00009676 <.LBE236>:

	/* Log reset source */
	log_reset_source();

	/* Initialize the uart module */
	uartInit();
    9676:	12f2      	call	0x9c5c <_uartInit>

00009678 <.LM37>:

	/* Initialize the timeout timer module */
	swtimer_init();
    9678:	1233      	call	0x9ae0 <_swtimer_init>

0000967a <.LM38>:

	/* Initialize the eeprom handler */
	eeprom_Init();
    967a:	82db 4325 	callf	0x864a <_eeprom_Init>

0000967e <.LM39>:

	/* initialize the pwm module */
	pwm_Init();
    967e:	10fc      	call	0x9878 <_pwm_Init>

00009680 <.LM40>:

	/* Initialize the lin handler */
	lin22_Init();
    9680:	82db 4618 	callf	0x8c30 <_lin22_Init>

00009684 <.LM41>:

	/* Initialize the adc driver */
	adc_Init();
    9684:	82db 3ac9 	callf	0x7592 <_adc_Init>

00009688 <.LM42>:

	adc_Shunt_OffsetCalib();
    9688:	82db 3b40 	callf	0x7680 <_adc_Shunt_OffsetCalib>

0000968c <.LM43>:
	adc_Start(true); /* pwm must be initialized before you can use the do start and wait for loop */
    968c:	7001      	lod	A, #1
    968e:	82db 3af0 	callf	0x75e0 <_adc_Start>

00009692 <.LM44>:

	/* Start application */
	IO_SET(PORT_IO_ENABLE, IO_DISREC, 0x1E); // IO 1~4 -> ADC
    9692:	601e      	lod	AL, #30
    9694:	42d8 023b 	mov	0x23b <_PORT_IO_ENABLE+0x1>, AL

00009698 <.LBB240>:
#if defined(HAS_HW_IO0_HV)
/** Enable high voltage cell of IO 0
 */
STATIC INLINE void gpio_io0HvEnable(void)
{
    IO_SET(PORT_IO_OUT_EN, IO0_LV_ENABLE, 0u);
    9698:	0ea7      	lod	C, ML.7
    969a:	62d8 01e8 	lod	AL, 0x1e8 <_PORT_IO_OUT_EN>
    969e:	947f      	and	AL, #127
    96a0:	42d8 01e8 	mov	0x1e8 <_PORT_IO_OUT_EN>, AL

000096a4 <.LBE240>:
	gpio_io0HvEnable();						 // 250702-1 Support IO0 for High Voltage ,ignition interface.
	/* diag & prot */
	protection_Init();
    96a4:	106a      	call	0x977a <_protection_Init>

000096a6 <.LBB242>:
 * @returns  raw Vsm adc sample.
 */
static INLINE uint16_t adc_GetRawVsm(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_VSM];
    96a6:	72d8 126c 	lod	A, 0x126c <_dBase>

000096aa <.LBE244>:
 * --------------------------------------------- */
static void background_Handler(void);
static void log_reset_source(void);
static void app_Initialize(void)
{
	l_u32MotorSupplyVoltageFilter = adc_GetRawVsm() * 4u;
    96aa:	44a2      	asl	A, #2
    96ac:	4cf2      	usex	YA
    96ae:	52d8 140a 	mov	0x140a <_l_u32MotorSupplyVoltageFilter>, A
    96b2:	5ad8 140c 	mov	0x140c <_l_u32MotorSupplyVoltageFilter+0x2>, Y

000096b6 <.LBB246>:
 * @returns  raw Vs adc sample.
 */
static INLINE uint16_t adc_GetRawVs(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_VS];
    96b6:	72d8 1276 	lod	A, 0x1276 <.LASF2063>

000096ba <.LBE246>:
	l_u32SupplyVoltageFilter = adc_GetRawVs() * 4u;
    96ba:	44a2      	asl	A, #2
    96bc:	4cf2      	usex	YA
    96be:	52d8 13de 	mov	0x13de <_l_u32SupplyVoltageFilter>, A
    96c2:	5ad8 13e0 	mov	0x13e0 <_l_u32SupplyVoltageFilter+0x2>, Y

000096c6 <.LBB248>:
 * @returns  raw temperature adc sample.
 */
static INLINE uint16_t adc_GetRawTemperature(void)
{
    extern volatile uint16_t dBase[];
    return dBase[ADC_SAMPLE_TEMP];
    96c6:	72d8 126e 	lod	A, 0x126e <_dBase+0x2>

000096ca <.LBE248>:
	l_u32ChipTemperatureFilter = adc_GetRawTemperature() * 4u;
    96ca:	44a2      	asl	A, #2
    96cc:	4cf2      	usex	YA
    96ce:	52d8 13f4 	mov	0x13f4 <_l_u32ChipTemperatureFilter>, A
    96d2:	5ad8 13f6 	mov	0x13f6 <_l_u32ChipTemperatureFilter+0x2>, Y

000096d6 <.LM53>:
	swtimer_register((uint16_t)SWTIMER_MOT_CTRL_PERIOD, 1, REPETITIVE); // 100usec
    96d6:	54ca 0001 	pushw	#1

000096da <.LCFI1>:
    96da:	0ea7      	lod	C, ML.7
    96dc:	54ca 0001 	pushw	#1

000096e0 <.LCFI2>:
    96e0:	7005      	lod	A, #5
    96e2:	1233      	call	0x9b4a <_swtimer_register>

000096e4 <.LM54>:
	swtimer_start((uint16_t)SWTIMER_MOT_CTRL_PERIOD);
    96e4:	7005      	lod	A, #5
    96e6:	1247      	call	0x9b76 <_swtimer_start>

000096e8 <.LM55>:
	swtimer_register((uint16_t)SWTIMER_APP_CTRL_PERIOD, 10, REPETITIVE); // 1msec
    96e8:	54ca 0001 	pushw	#1

000096ec <.LCFI3>:
    96ec:	54ca 000a 	pushw	#10

000096f0 <.LCFI4>:
    96f0:	0ea7      	lod	C, ML.7
    96f2:	7006      	lod	A, #6
    96f4:	122a      	call	0x9b4a <_swtimer_register>

000096f6 <.LM56>:
	swtimer_start((uint16_t)SWTIMER_APP_CTRL_PERIOD);
    96f6:	7006      	lod	A, #6
    96f8:	123e      	call	0x9b76 <_swtimer_start>

000096fa <.LM57>:

	AppLinInit();
    96fa:	82db 31a3 	callf	0x6346 <_AppLinInit>

000096fe <.LM58>:
	sensor_init();
    96fe:	82db 3bd1 	callf	0x77a2 <_sensor_init>

00009702 <.LM59>:
	app_mot_init();
    9702:	82db 3e8b 	callf	0x7d16 <_app_mot_init>

00009706 <.LM60>:
	AppValveInit();
    9706:	82db 3358 	callf	0x66b0 <_AppValveInit>

0000970a <.LBB250>:
        );
}

STATIC INLINE void builtin_mlx16_enter_user_mode(void)
{
    __asm__ __volatile__ ("setb MH.3" ::: "M", "memory");
    970a:	0ab3      	setb	MH.3
    970c:	5c07      	dec	S, #8

0000970e <.L12>:
    970e:	0f7f      	lod	C, io:0x0f.7

00009710 <.LBE254>:
}

/** WDG_conditionalAwdRefresh acknowledges the AWD timer if its window is opened */
STATIC INLINE void WDG_conditionalAwdRefresh(void)
{
    if (IO_GET(AWD, WIN_OPEN) != 0u) {
    9710:	1c01      	jnc	0x9714 <.L8>

00009712 <.LM64>:
        IO_SET(AWD, ACK, 1u);
    9712:	0b76      	setb	io:0x0e.6

00009714 <.L8>:
#endif
	/* Application loop */
	while (1u)
	{
		WDG_conditionalAwdRefresh(); /* Restart watchdog */
		AppLinTask();
    9714:	82db 31a9 	callf	0x6352 <_AppLinTask>

00009718 <.LM66>:

		protection_Task();
    9718:	10ac      	call	0x9872 <_protection_Task>

0000971a <.LM67>:
		//     fm_Atan2HelperInterpolationInlined(100,200);

		if (g_bUnderVoltageDetected) /* log UV_VS interrupt detection */
    971a:	62d8 11ae 	lod	AL, 0x11ae <_g_bUnderVoltageDetected>
    971e:	1903      	je	0x9726 <.L9>

00009720 <.LM68>:
		{
			g_bUnderVoltageDetected = false; /* IC self detect*/
    9720:	6000      	lod	AL, #0
    9722:	42d8 11ae 	mov	0x11ae <_g_bUnderVoltageDetected>, AL

00009726 <.L9>:
		}
		if (swtimer_isTriggered((uint16_t)SWTIMER_MOT_CTRL_PERIOD) != 0u) // 500s period
    9726:	7005      	lod	A, #5
    9728:	1237      	call	0x9b98 <_swtimer_isTriggered>
    972a:	ac00      	cmp	A, #0
    972c:	1902      	je	0x9732 <.L10>

0000972e <.LM70>:
#if DEBUG_GPIO_ENABLE == 1
			//		#if DEBUG_MODE == DEBUG_MOT_CTRL_TASK
			softio_set(DEBUG_PIN);
//		#endif
#endif
			motor_ctrl_handler();
    972e:	82db 40fd 	callf	0x81fa <_motor_ctrl_handler>

00009732 <.L10>:
			//		#if DEBUG_MODE == DEBUG_MOT_CTRL_TASK
			softio_clr(DEBUG_PIN);
//		#endif
#endif
		}
		if (swtimer_isTriggered((uint16_t)SWTIMER_APP_CTRL_PERIOD) != 0u) // 1ms period
    9732:	7006      	lod	A, #6
    9734:	1231      	call	0x9b98 <_swtimer_isTriggered>
    9736:	ac00      	cmp	A, #0
    9738:	1905      	je	0x9744 <.L11>

0000973a <.LM72>:
		{
			app_motor_task();
    973a:	82db 3eed 	callf	0x7dda <_app_motor_task>

0000973e <.LM73>:
			AppValveTask();
    973e:	82db 33e9 	callf	0x67d2 <_AppValveTask>

00009742 <.LM74>:
			uartTask();
    9742:	128e      	call	0x9c60 <_uartTask>

00009744 <.L11>:
static void background_Handler(void)
{
	static int16_t i16ChipTemperature = 35;

	/* Calibrate stimer over temperature */
	if (abs(g_i16ChipTemperature - i16ChipTemperature) > 10)
    9744:	72d8 13e4 	lod	A, 0x13e4 <_g_i16ChipTemperature>
    9748:	aad8 10a6 	sub	A, 0x10a6 <___i16ChipTemperature_8372>
    974c:	1d81      	jnn	0x9750 <.L27>
    974e:	5cc2      	neg	A

00009750 <.L27>:
    9750:	ac0a      	cmp	A, #10
    9752:	1b5d      	jsle	0x970e <.L12>

00009754 <.LBB258>:
    9754:	72d8 126e 	lod	A, 0x126e <_dBase+0x2>

00009758 <.LBE258>:
	{
		swtimer_calibrate(adc_GetRawTemperature());
    9758:	11ec      	call	0x9b32 <_swtimer_calibrate>

0000975a <.LM78>:
		i16ChipTemperature = g_i16ChipTemperature;
    975a:	72d8 13e4 	lod	A, 0x13e4 <_g_i16ChipTemperature>
    975e:	52d8 10a6 	mov	0x10a6 <___i16ChipTemperature_8372>, A
    9762:	0ea7      	lod	C, ML.7
    9764:	07d4      	jmp	0x970e <.L12>

00009766 <_EVENT_UnderVoltage>:
 * \image html diode.png
 * \image latex diode.png
 */
void EVENT_UnderVoltage(void)
{
	g_bUnderVoltageDetected = true;
    9766:	6001      	lod	AL, #1
    9768:	42d8 11ae 	mov	0x11ae <_g_bUnderVoltageDetected>, AL

0000976c <.LM81>:
}
    976c:	5401      	ret

0000976e <_EVENT_GotoSleep>:
    976e:	0f7f      	lod	C, io:0x0f.7

00009770 <.LBE262>:
}

/** WDG_conditionalAwdRefresh acknowledges the AWD timer if its window is opened */
STATIC INLINE void WDG_conditionalAwdRefresh(void)
{
    if (IO_GET(AWD, WIN_OPEN) != 0u) {
    9770:	1c01      	jnc	0x9774 <.L30>

00009772 <.LM87>:
        IO_SET(AWD, ACK, 1u);
    9772:	0b76      	setb	io:0x0e.6

00009774 <.L30>:
 */
void EVENT_GotoSleep(void)
{

	WDG_conditionalAwdRefresh(); /* Restart watchdog */
}
    9774:	5401      	ret

00009776 <__CTIMER0_3_INT>:

/** Timer1 INT3 handler for LIN AA frame timeout */
INTERRUPT void _CTIMER0_3_INT(void)
{
	/* nop */
}
    9776:	72cb      	pop	M
    9778:	5401      	ret

0000977a <_protection_Init>:
    977a:	5801      	inc	S, #2

0000977c <.LCFI0>:
    977c:	7800      	lod	Y, #0
    977e:	5ad8 11b4 	mov	0x11b4 <_g_e8ErrorVoltage>, Y

00009782 <.LM3>:
    9782:	5ad8 11b2 	mov	0x11b2 <_g_e8ErrorOverTemperature>, Y

00009786 <.LM4>:
    9786:	0ea7      	lod	C, ML.7
    9788:	5ad8 11b0 	mov	0x11b0 <_g_e8ShortOcc>, Y

0000978c <.LM5>:
    978c:	46d8 11af 	mov	0x11af <_g_e8OverCurrent>, YL

00009790 <.LM6>:
    9790:	5adf      	push	Y

00009792 <.LCFI1>:
    9792:	54ca 04e2 	pushw	#1250

00009796 <.LCFI2>:
    9796:	7003      	lod	A, #3
    9798:	5a05      	mov	[S-6], Y
    979a:	11d7      	call	0x9b4a <_swtimer_register>

0000979c <.LM7>:
    979c:	7a05      	lod	Y, [S-6]
    979e:	5adf      	push	Y

000097a0 <.LCFI3>:
    97a0:	54ca 0064 	pushw	#100

000097a4 <.LCFI4>:
    97a4:	7004      	lod	A, #4
    97a6:	11d1      	call	0x9b4a <_swtimer_register>

000097a8 <.LM8>:
    97a8:	82db 426b 	callf	0x84d6 <_diagnostic_Init>

000097ac <.LM9>:
    97ac:	82db 429b 	callf	0x8536 <_diagnostic_Start>

000097b0 <.LCFI5>:
    97b0:	540b      	ret	#12

000097b2 <_protection_CheckShort>:
 *   Stop
 * \enduml
 */
void protection_CheckShort(void)
{
    if (diagnostic_IsOVCPending())
    97b2:	82db 42e7 	callf	0x85ce <_diagnostic_IsOVCPending>
    97b6:	ac00      	cmp	A, #0
    97b8:	1903      	je	0x97c0 <.L6>

000097ba <.LM22>:
    {

        g_e8OverCurrent = 1;
    97ba:	6001      	lod	AL, #1
    97bc:	42d8 11af 	mov	0x11af <_g_e8OverCurrent>, AL

000097c0 <.L6>:
        if (g_e8OverCurrent == 1)
        {
        }
        //		g_e8OverCurrent = 0;
    }
    if (diagnostic_IsVDSPending())
    97c0:	82db 42ec 	callf	0x85d8 <_diagnostic_IsVDSPending>
    97c4:	ac00      	cmp	A, #0
    97c6:	1903      	je	0x97ce <.L5>

000097c8 <.LM24>:
    {
        g_e8ShortOcc = C_ERR_SHORT_VDS;
    97c8:	7002      	lod	A, #2
    97ca:	52d8 11b0 	mov	0x11b0 <_g_e8ShortOcc>, A

000097ce <.L5>:
        {
        }
        //        g_e8ShortOcc = C_ERR_SHORT_NO;
        /* MISRA C-2012 Rule 15.7 */
    }
}
    97ce:	5401      	ret

000097d0 <_protection_CheckSupplyMotorVoltage>:
 *
 * @param[in]  a_u16SupplyMotorVoltage  VSM voltage [10mV]
 */
void protection_CheckSupplyMotorVoltage(void)
{
    if (diagnostic_IsOVPending())
    97d0:	82db 42de 	callf	0x85bc <_diagnostic_IsOVPending>
    97d4:	ac00      	cmp	A, #0
    97d6:	1904      	je	0x97e0 <.L15>

000097d8 <.LM28>:
    {
        g_e8ErrorVoltage = C_ERR_VOLTAGE_OVER_HW;
    97d8:	7004      	lod	A, #4

000097da <.L23>:
    }
    else if (diagnostic_IsUVPending())
    {

        g_e8ErrorVoltage = C_ERR_VOLTAGE_UNDER_HW;
    97da:	52d8 11b4 	mov	0x11b4 <_g_e8ErrorVoltage>, A
    97de:	5401      	ret

000097e0 <.L15>:
{
    if (diagnostic_IsOVPending())
    {
        g_e8ErrorVoltage = C_ERR_VOLTAGE_OVER_HW;
    }
    else if (diagnostic_IsUVPending())
    97e0:	82db 42d9 	callf	0x85b2 <_diagnostic_IsUVPending>
    97e4:	ac00      	cmp	A, #0
    97e6:	1902      	je	0x97ec <.L17>

000097e8 <.LM31>:
    {

        g_e8ErrorVoltage = C_ERR_VOLTAGE_UNDER_HW;
    97e8:	7002      	lod	A, #2
    97ea:	07f7      	jmp	0x97da <.L23>

000097ec <.L17>:
    }
    else
    {
        if ((g_e8ErrorVoltage == C_ERR_VOLTAGE_OVER_HW) && (get_valve_voltage() < C_APPL_OVOLT))
    97ec:	72d8 11b4 	lod	A, 0x11b4 <_g_e8ErrorVoltage>
    97f0:	ac04      	cmp	A, #4
    97f2:	1d0f      	jne	0x9812 <.L19>

000097f4 <.LM33>:
    97f4:	82db 334f 	callf	0x669e <_get_valve_voltage>
    97f8:	aeda 0707 	cmp	A, #1799
    97fc:	1e0a      	jug	0x9812 <.L19>

000097fe <.LM34>:
        {
            IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 1u); /* clear MEM flag */
    97fe:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    9802:	8408      	or	AL, #8
    9804:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

00009808 <.LM35>:
            IO_SET(PORT_DRV1_PROT, DIS_OV_VS, 0u); /* re-enable hardware protection */
    9808:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    980c:	94f7      	and	AL, #-9
    980e:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

00009812 <.L19>:
        }
        if ((g_e8ErrorVoltage == C_ERR_VOLTAGE_UNDER_HW) && (get_valve_voltage() > C_APPL_UVOLT))
    9812:	72d8 11b4 	lod	A, 0x11b4 <_g_e8ErrorVoltage>
    9816:	ac02      	cmp	A, #2
    9818:	1d0f      	jne	0x9838 <.L14>

0000981a <.LM37>:
    981a:	82db 334f 	callf	0x669e <_get_valve_voltage>
    981e:	aeda 02bc 	cmp	A, #700
    9822:	1a0a      	jule	0x9838 <.L14>

00009824 <.LM38>:
        {
            IO_SET(PORT_DRV1_PROT, DIS_UV_VS, 1u); /* clear MEM flag */
    9824:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    9828:	8420      	or	AL, #32
    982a:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

0000982e <.LM39>:
            IO_SET(PORT_DRV1_PROT, DIS_UV_VS, 0u); /* re-enable hardware protection */
    982e:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    9832:	94df      	and	AL, #-33
    9834:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

00009838 <.L14>:
        }
        //		g_e8ErrorVoltage = C_ERR_VOLTAGE_IN_RANGE;
    }
}
    9838:	5401      	ret

0000983a <_protection_CheckChipTemperature>:
 *
 * @param[in]  a_i16ChipTemperature  chip internal temperature sensor [C]
 */
void protection_CheckChipTemperature(void)
{
    if (diagnostic_IsOVTPending())
    983a:	82db 42e3 	callf	0x85c6 <_diagnostic_IsOVTPending>
    983e:	ac00      	cmp	A, #0
    9840:	1904      	je	0x984a <.L25>

00009842 <.LM43>:
    {

        g_e8ErrorOverTemperature = C_ERR_TEMP_ALARM;
    9842:	7002      	lod	A, #2
    9844:	52d8 11b2 	mov	0x11b2 <_g_e8ErrorOverTemperature>, A
    9848:	5401      	ret

0000984a <.L25>:
        //            swtimer_stop(SWTIMER_PROTECTION_DELAY_OVT);
    }
    else
    {
        if ((g_e8ErrorOverTemperature == C_ERR_TEMP_ALARM) && (get_valve_temperature() < (int16_t)(C_APPL_OTEMP + C_TEMP_CONV_OFFSET)))
    984a:	72d8 11b2 	lod	A, 0x11b2 <_g_e8ErrorOverTemperature>
    984e:	ac02      	cmp	A, #2
    9850:	1d0f      	jne	0x9870 <.L24>

00009852 <.LM45>:
    9852:	82db 3352 	callf	0x66a4 <_get_valve_temperature>
    9856:	aeda 009f 	cmp	A, #159
    985a:	1f0a      	jsg	0x9870 <.L24>

0000985c <.LM46>:
        {
            IO_SET(PORT_DRV1_PROT, DIS_OVT, 1u); /* clear MEM flag */
    985c:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    9860:	8402      	or	AL, #2
    9862:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

00009866 <.LM47>:
            IO_SET(PORT_DRV1_PROT, DIS_OVT, 0u); /* re-enable hardware protection */
    9866:	62d8 0218 	lod	AL, 0x218 <_PORT_DRV1_PROT>
    986a:	94fd      	and	AL, #-3
    986c:	42d8 0218 	mov	0x218 <_PORT_DRV1_PROT>, AL

00009870 <.L24>:
        }
        //	 g_e8ErrorOverTemperature = C_ERR_TEMP_NO;
        /* MISRA C-2012 Rule 15.7 */
    }
}
    9870:	5401      	ret

00009872 <_protection_Task>:

void protection_Task(void)
{
    protection_CheckShort();
    9872:	179f      	call	0x97b2 <_protection_CheckShort>

00009874 <.LM51>:

    protection_CheckSupplyMotorVoltage();
    9874:	17ad      	call	0x97d0 <_protection_CheckSupplyMotorVoltage>

00009876 <.LM52>:
    protection_CheckChipTemperature();
    9876:	07e1      	jmp	0x983a <_protection_CheckChipTemperature>

00009878 <_pwm_Init>:
#if defined (IO_PWM_MASTER1__START_GET)
#define PWM1_MASTER_DISABLE pwm1_master_disable

STATIC INLINE void pwm1_master_disable(void)
{
    IO_HOST(PWM_MASTER1, STOP) = 1u << IO_OFFSET(PWM_MASTER1, STOP);
    9878:	7002      	lod	A, #2
    987a:	52d8 013c 	mov	0x13c <_PWM_MASTER1+0x8>, A

0000987e <.LBB1032>:
#if defined (IO_PWM_SLAVE1__START_GET)
#define PWM1_DISABLE pwm1_disable

STATIC INLINE void pwm1_disable(void)
{
    IO_HOST(PWM_SLAVE1, STOP) = 1u << IO_OFFSET(PWM_SLAVE1, STOP);
    987e:	52d8 0146 	mov	0x146 <.LASF2017+0x3>, A

00009882 <.LBB1034>:
#if defined (IO_PWM_SLAVE2__START_GET)
#define PWM2_DISABLE pwm2_disable

STATIC INLINE void pwm2_disable(void)
{
    IO_HOST(PWM_SLAVE2, STOP) = 1u << IO_OFFSET(PWM_SLAVE2, STOP);
    9882:	0ea7      	lod	C, ML.7
    9884:	52d8 0150 	mov	0x150 <_PWM_SLAVE2+0x8>, A

00009888 <.LBB1036>:
#if defined (IO_PWM_SLAVE3__START_GET)
#define PWM3_DISABLE pwm3_disable

STATIC INLINE void pwm3_disable(void)
{
    IO_HOST(PWM_SLAVE3, STOP) = 1u << IO_OFFSET(PWM_SLAVE3, STOP);
    9888:	52d8 015a 	mov	0x15a <.LASF1648+0x3>, A

0000988c <.LBB1038>:
#if defined (IO_PWM_MASTER2__START_GET)
#define PWM2_MASTER_DISABLE pwm2_master_disable

STATIC INLINE void pwm2_master_disable(void)
{
    IO_HOST(PWM_MASTER2, STOP) = 1u << IO_OFFSET(PWM_MASTER2, STOP);
    988c:	52d8 0164 	mov	0x164 <_PWM_MASTER2+0x8>, A

00009890 <.LBB1040>:
                                    uint16_t CMP_,
                                    PwmMode_t MODE_,
                                    PwmPolarity_t POL_,
                                    uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_MASTER1, PSCLM, ((DIV_)-1) & 0x0Fu,
    9890:	0ea7      	lod	C, ML.7
    9892:	7c08      	lod	X, #8
    9894:	5ed8 013c 	mov	0x13c <_PWM_MASTER1+0x8>, X

00009898 <.LM8>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 0u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_MASTER1, PER, PERIOD_);
    9898:	72da 0640 	lod	A, #1600
    989c:	0ea7      	lod	C, ML.7
    989e:	52d8 013a 	mov	0x13a <_PWM_MASTER1+0x6>, A

000098a2 <.LM9>:
    IO_SET(PWM_MASTER1, CMP, CMP_);
    98a2:	72da 010b 	lod	A, #267
    98a6:	52d8 0134 	mov	0x134 <_PWM_MASTER1>, A

000098aa <.LM10>:
    IO_SET(PWM_MASTER1, LT, LT_);
    98aa:	0ea7      	lod	C, ML.7
    98ac:	7000      	lod	A, #0
    98ae:	52d8 0138 	mov	0x138 <_PWM_MASTER1+0x4>, A

000098b2 <.LM11>:
    IO_SET(PWM_MASTER1, HT, HT_);
    98b2:	52d8 0136 	mov	0x136 <_PWM_MASTER1+0x2>, A

000098b6 <.LBB1042>:
#define PWM1_INIT pwm1_init

STATIC INLINE void pwm1_init(uint8_t DIV_, uint8_t DIVN_, uint16_t LT_, uint16_t HT_,
                             uint16_t CMP_, PwmMode_t MODE_, PwmPolarity_t POL_, uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_SLAVE1, PSCLM, ((DIV_)-1) & 0x0Fu,
    98b6:	0ea7      	lod	C, ML.7
    98b8:	7c0c      	lod	X, #12
    98ba:	5ed8 0146 	mov	0x146 <.LASF2017+0x3>, X

000098be <.LM13>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 1u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_SLAVE1, CMP, CMP_);
    98be:	7ada 0215 	lod	Y, #533
    98c2:	0ea7      	lod	C, ML.7
    98c4:	5ad8 013e 	mov	0x13e <_PWM_SLAVE1>, Y

000098c8 <.LM14>:
    IO_SET(PWM_SLAVE1, LT, LT_);
    98c8:	52d8 0142 	mov	0x142 <.LASF2025+0x2>, A

000098cc <.LM15>:
    IO_SET(PWM_SLAVE1, HT, HT_);
    98cc:	52d8 0140 	mov	0x140 <.LASF2025>, A

000098d0 <.LBB1044>:
#define PWM2_INIT pwm2_init

STATIC INLINE void pwm2_init(uint8_t DIV_, uint8_t DIVN_, uint16_t LT_, uint16_t HT_,
                             uint16_t CMP_, PwmMode_t MODE_, PwmPolarity_t POL_, uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_SLAVE2, PSCLM, ((DIV_)-1) & 0x0Fu,
    98d0:	0ea7      	lod	C, ML.7
    98d2:	5ed8 0150 	mov	0x150 <_PWM_SLAVE2+0x8>, X

000098d6 <.LM17>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 1u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_SLAVE2, CMP, CMP_);
    98d6:	7ada 0320 	lod	Y, #800
    98da:	5ad8 0148 	mov	0x148 <_PWM_SLAVE2>, Y

000098de <.LM18>:
    IO_SET(PWM_SLAVE2, LT, LT_);
    98de:	0ea7      	lod	C, ML.7
    98e0:	52d8 014c 	mov	0x14c <_PWM_SLAVE2+0x4>, A

000098e4 <.LM19>:
    IO_SET(PWM_SLAVE2, HT, HT_);
    98e4:	52d8 014a 	mov	0x14a <_PWM_SLAVE2+0x2>, A

000098e8 <.LBB1046>:
#define PWM3_INIT pwm3_init

STATIC INLINE void pwm3_init(uint8_t DIV_, uint8_t DIVN_, uint16_t LT_, uint16_t HT_,
                             uint16_t CMP_, PwmMode_t MODE_, PwmPolarity_t POL_, uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_SLAVE3, PSCLM, ((DIV_)-1) & 0x0Fu,
    98e8:	5ed8 015a 	mov	0x15a <.LASF1648+0x3>, X

000098ec <.LM21>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 1u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_SLAVE3, CMP, CMP_);
    98ec:	0ea7      	lod	C, ML.7
    98ee:	7eda 042a 	lod	X, #1066
    98f2:	5ed8 0152 	mov	0x152 <_PWM_SLAVE3>, X

000098f6 <.LM22>:
    IO_SET(PWM_SLAVE3, LT, LT_);
    98f6:	52d8 0156 	mov	0x156 <_PWM_SLAVE3+0x4>, A

000098fa <.LM23>:
    IO_SET(PWM_SLAVE3, HT, HT_);
    98fa:	0ea7      	lod	C, ML.7
    98fc:	52d8 0154 	mov	0x154 <_PWM_SLAVE3+0x2>, A

00009900 <.LBB1048>:
                                    uint16_t CMP_,
                                    PwmMode_t MODE_,
                                    PwmPolarity_t POL_,
                                    uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_MASTER2, PSCLM, ((DIV_)-1) & 0x0Fu,
    9900:	7c08      	lod	X, #8
    9902:	5ed8 0164 	mov	0x164 <_PWM_MASTER2+0x8>, X

00009906 <.LM25>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 0u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_MASTER2, PER, PERIOD_);
    9906:	0ea7      	lod	C, ML.7
    9908:	7eda 0640 	lod	X, #1600
    990c:	5ed8 0162 	mov	0x162 <_PWM_MASTER2+0x6>, X

00009910 <.LM26>:
    IO_SET(PWM_MASTER2, CMP, CMP_);
    9910:	7eda 0535 	lod	X, #1333
    9914:	0ea7      	lod	C, ML.7
    9916:	5ed8 015c 	mov	0x15c <_PWM_MASTER2>, X

0000991a <.LM27>:
    IO_SET(PWM_MASTER2, LT, LT_);
    991a:	52d8 0160 	mov	0x160 <_PWM_MASTER2+0x4>, A

0000991e <.LM28>:
    IO_SET(PWM_MASTER2, HT, HT_);
    991e:	52d8 015e 	mov	0x15e <_PWM_MASTER2+0x2>, A

00009922 <.LBB1050>:
#if defined (IO_PWM_MASTER1__START_GET)
#define PWM1_MASTER_ENABLE pwm1_master_enable

STATIC INLINE void pwm1_master_enable(void)
{
    IO_HOST(PWM_MASTER1, START) = 1u << IO_OFFSET(PWM_MASTER1, START);
    9922:	0ea7      	lod	C, ML.7
    9924:	7c01      	lod	X, #1
    9926:	5ed8 013c 	mov	0x13c <_PWM_MASTER1+0x8>, X

0000992a <.LBB1052>:
#if defined (IO_PWM_SLAVE1__START_GET)
#define PWM1_ENABLE pwm1_enable

STATIC INLINE void pwm1_enable(void)
{
    IO_HOST(PWM_SLAVE1, START) = 1u << IO_OFFSET(PWM_SLAVE1, START);
    992a:	5ed8 0146 	mov	0x146 <.LASF2017+0x3>, X

0000992e <.LBB1054>:
#if defined (IO_PWM_SLAVE2__START_GET)
#define PWM2_ENABLE pwm2_enable

STATIC INLINE void pwm2_enable(void)
{
    IO_HOST(PWM_SLAVE2, START) = 1u << IO_OFFSET(PWM_SLAVE2, START);
    992e:	0ea7      	lod	C, ML.7
    9930:	5ed8 0150 	mov	0x150 <_PWM_SLAVE2+0x8>, X

00009934 <.LBB1056>:
#if defined (IO_PWM_SLAVE3__START_GET)
#define PWM3_ENABLE pwm3_enable

STATIC INLINE void pwm3_enable(void)
{
    IO_HOST(PWM_SLAVE3, START) = 1u << IO_OFFSET(PWM_SLAVE3, START);
    9934:	5ed8 015a 	mov	0x15a <.LASF1648+0x3>, X

00009938 <.LBB1058>:
#if defined (IO_PWM_MASTER2__START_GET)
#define PWM2_MASTER_ENABLE pwm2_master_enable

STATIC INLINE void pwm2_master_enable(void)
{
    IO_HOST(PWM_MASTER2, START) = 1u << IO_OFFSET(PWM_MASTER2, START);
    9938:	5ed8 0164 	mov	0x164 <_PWM_MASTER2+0x8>, X

0000993c <.LBB1060>:
    993c:	0ea7      	lod	C, ML.7
    993e:	7eda eeee 	lod	X, #61166
    9942:	5ed8 0216 	mov	0x216 <_PORT_DRV_CTRL>, X

00009946 <.LBE1060>:
                                DRV_CTRL_TRISTATE,  /* W */
                                DRV_CTRL_TRISTATE); /* T */

    /* enable digital part of the driver */
    // drvcfg_Enable(); in motor3ph_pwm_private.h
    IO_SET(PORT_DRV2_PROT, DIS_DRV, 0u);
    9946:	42d8 021a 	mov	0x21a <_PORT_DRV2_PROT>, AL

0000994a <.LM36>:

    IO_SET(PORT_DRV_OUT, ENABLE_DRVSUP, 0x1u); /* enable driver supply */
    994a:	0ea7      	lod	C, ML.7
    994c:	62d8 020e 	lod	AL, 0x20e <_PORT_DRV_OUT>
    9950:	8401      	or	AL, #1
    9952:	42d8 020e 	mov	0x20e <_PORT_DRV_OUT>, AL

00009956 <.LBB1062>:
    }
}

STATIC INLINE void DELAY(const uint16_t loops)
{
    delay_cycles(loops);
    9956:	7050      	lod	A, #80
    9958:	82db 1128 	callf	0x2250 <_delay_cycles>

0000995c <.LBE1062>:

    /* wait some time to have Vddaf to stabilize */
    DELAY_US(10u);

    /* enable the driver */
    IO_SET(PORT_DRV_OUT,
    995c:	72d8 020e 	lod	A, 0x20e <_PORT_DRV_OUT>
    9960:	0ea7      	lod	C, ML.7
    9962:	b6da f001 	and	A, #61441
    9966:	a6da 09c2 	or	A, #2498
    996a:	52d8 020e 	mov	0x20e <_PORT_DRV_OUT>, A

0000996e <.LBB1065>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    996e:	7ee3      	lod	X, M

00009970 <.LBB1068>:
    return 1;
}

STATIC INLINE uint16_t mlx16_di_enter_system_mode(void)
{
    __asm__ __volatile__ (".word OPCODE_CALL_FP_ENTER_SYSTEM_MODE_PRIO_0");
    9970:	5049      	call	fp2:0x48

00009972 <.LBE1068>:
           DRVMOD_OPTION, 0x0u,
           PARALLEL_MODE_DRV, 0x1u); /* enable parallel mode U+V, W+T driver */

    /* configure pwm update sync interrupt - CNT ISR */
    ENTER_SECTION(ATOMIC_SYSTEM_MODE);
    Itc_SetPrio(PWM_MASTER1_END, 3u);
    9972:	62d8 008a 	lod	AL, 0x8a <__mlx4_flash_table_size+0x2>
    9976:	943f      	and	AL, #63
    9978:	42d8 008a 	mov	0x8a <__mlx4_flash_table_size+0x2>, AL

0000997c <.LBB1070>:

#define PWM1_MASTER_CNTI_ENABLE pwm1_master_cnti_enable

STATIC INLINE void pwm1_master_cnti_enable(void)
{
    Itc_Clear(PWM_MASTER1_END);
    997c:	6080      	lod	AL, #-128
    997e:	42d8 0053 	mov	0x53 <.LASF1525+0x6>, AL

00009982 <.LM43>:
    Itc_Enable(PWM_MASTER1_END);
    9982:	0ea7      	lod	C, ML.7
    9984:	62d8 006f 	lod	AL, 0x6f <__mlx4_cst_tables_ram_size+0x11>
    9988:	8480      	or	AL, #-128
    998a:	42d8 006f 	mov	0x6f <__mlx4_cst_tables_ram_size+0x11>, AL

0000998e <.LBB1072>:
#if defined (IO_PWM_SLAVE2__START_GET)
#define PWM2_CMPI_ENABLE pwm2_cmpi_enable

STATIC INLINE void pwm2_cmpi_enable(void)
{
    Itc_Clear(PWM_SLAVE2_CMP);
    998e:	6002      	lod	AL, #2
    9990:	42d8 0054 	mov	0x54 <.Lframe0>, AL

00009994 <.LM45>:
    Itc_Enable(PWM_SLAVE2_CMP);
    9994:	0ea7      	lod	C, ML.7
    9996:	62d8 0070 	lod	AL, 0x70 <__mlx4_cst_tables_ram_size+0x12>
    999a:	8402      	or	AL, #2
    999c:	42d8 0070 	mov	0x70 <__mlx4_cst_tables_ram_size+0x12>, AL

000099a0 <.LBB1074>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    99a0:	5ee3      	mov	M, X

000099a2 <.LBE1065>:
    pwm1_master_cnti_enable();
    pwm2_cmpi_enable(); // pwm2
    EXIT_SECTION();

    u16DutyCycleMax = 0x4000;
}
    99a2:	5401      	ret

000099a4 <_pwm_SetDutyCycle>:
 * @param[in]  u8Channels    The channel(s) to update the duty cycle for.
 * @param[in]  u16DutyCycle  The new pwm duty cycle (u16DutyCycle < u16DutyCycleMax).
 */
extern uint16_t g_u16debug_2, g_u16debug_5;
void pwm_SetDutyCycle(uint8_t dir, uint16_t u16DutyCycle)
{
    99a4:	5801      	inc	S, #2

000099a6 <.LCFI0>:
    99a6:	7e05      	lod	X, [S-6]
    99a8:	7ada 0800 	lod	Y, #2048
    99ac:	2ee6      	cmp	X, Y
    99ae:	1a01      	jule	0x99b2 <.L3>
    99b0:	7ee6      	lod	X, Y

000099b2 <.L3>:

    if (u16DutyCycle > C_PWMOUT_MAX_DUTY)
    {
        u16DutyCycle = C_PWMOUT_MAX_DUTY;
    }
    u16DutyCycle = (C_PWMOUT_MAX_DUTY - u16DutyCycle);
    99b2:	eaee      	sub	Y, X

000099b4 <.LM50>:
     * |     _____________     |
     * |____|             |____|
     */

    /* Change direction */
    switch (dir)
    99b4:	ac01      	cmp	A, #1
    99b6:	190f      	je	0x99d6 <.L5>
    99b8:	ac02      	cmp	A, #2
    99ba:	1912      	je	0x99e0 <.L6>

000099bc <.L4>:
MATHLIB_INLINE_STATIC __inline__ uint16_t mulU16hi_U16byU16(uint16_t multiplicand, uint16_t multiplier)
{
    uint16_t result;
    uint16_t result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    99bc:	72e6      	lod	A, Y
    99be:	4822 63f0 	mulu	YA, A, #25584

000099c2 <.LBE1078>:
        break;
    } /* Change direction */

    u16LT = mulU16hi_U16byU16(u16DutyCycle, PWM_PERIOD << 4);

    u16LTcopy[0] = u16LT; /* U */
    99c2:	5ad8 11b6 	mov	0x11b6 <_u16LTcopy>, Y

000099c6 <.LM53>:
    u16LTcopy[1] = u16LT; /* V */
    99c6:	5ad8 11b8 	mov	0x11b8 <_u16LTcopy+0x2>, Y

000099ca <.LM54>:
    u16LTcopy[2] = u16LT; /* W */
    99ca:	5ad8 11ba 	mov	0x11ba <_u16LTcopy+0x4>, Y

000099ce <.LM55>:
    u16LTcopy[3] = u16LT; /* T */
    99ce:	0ea7      	lod	C, ML.7
    99d0:	5ad8 11bc 	mov	0x11bc <.LLST11+0x1>, Y

000099d4 <.LM56>:
}
    99d4:	5403      	ret	#4

000099d6 <.L5>:
    99d6:	72da dd00 	lod	A, #56576

000099da <.L7>:
    99da:	52d8 0216 	mov	0x216 <_PORT_DRV_CTRL>, A
    99de:	07ee      	jmp	0x99bc <.L4>

000099e0 <.L6>:
    99e0:	72da 33dd 	lod	A, #13277

000099e4 <.LVL21>:
    99e4:	07fa      	jmp	0x99da <.L7>

000099e6 <_pwm_Start>:
 * This function will start the pwm driver and will enable the
 * output of the pwm signals on the driver pins.
 * @param[in]  u16DutyCycle  The new pwm duty cycle (u16DutyCycle < u16DutyCycleMax).
 */
void pwm_Start(uint8_t dir, uint16_t u16DutyCycle)
{
    99e6:	7e03      	lod	X, [S-4]

000099e8 <.LM60>:
			Itc_Enable(OVC);
			Itc_Clear(OVT);
			Itc_Enable(OVT);
			EXIT_SECTION();
#endif
        pwm_SetDutyCycle(dir, u16DutyCycle);
    99e8:	5edf      	push	X

000099ea <.LCFI1>:
    99ea:	17dc      	call	0x99a4 <_pwm_SetDutyCycle>

000099ec <.LM61>:
            MotorDriverUVWTSelectSource(DRV_CTRL_PWM_MASTER1,  /* U - Phase A */
            							DRV_CTRL_PWM_MASTER1,  /* V - Phase A */
										DRV_CTRL_PWM_SLAVE1,   /* W - Phase B */
										DRV_CTRL_PWM_SLAVE1);  /* T - Phase B */
#endif
        IO_SET(PORT_DRV_OUT, ENABLE_DRV, 0xFu); /* enable drivers of phases U,V,W,T */
    99ec:	62d8 020e 	lod	AL, 0x20e <_PORT_DRV_OUT>
    99f0:	843c      	or	AL, #60
    99f2:	42d8 020e 	mov	0x20e <_PORT_DRV_OUT>, AL

000099f6 <.LCFI2>:
    }
}
    99f6:	5403      	ret	#4

000099f8 <_pwm_Stop>:
    99f8:	72da dddd 	lod	A, #56797
    99fc:	52d8 0216 	mov	0x216 <_PORT_DRV_CTRL>, A

00009a00 <.LBE1084>:
                                DRV_CTRL_LOW,  /* V */
                                DRV_CTRL_LOW,  /* W */
                                DRV_CTRL_LOW); /* T */

    /* stop pwm modules output */
    IO_SET(PWM_MASTER1, LT, 0u); /* U */
    9a00:	7000      	lod	A, #0
    9a02:	0ea7      	lod	C, ML.7
    9a04:	52d8 0138 	mov	0x138 <_PWM_MASTER1+0x4>, A

00009a08 <.LM68>:
    IO_SET(PWM_SLAVE1, LT, 0u);  /* V */
    9a08:	52d8 0142 	mov	0x142 <.LASF2025+0x2>, A

00009a0c <.LM69>:
    IO_SET(PWM_SLAVE2, LT, 0u);  /* W */
    9a0c:	52d8 014c 	mov	0x14c <_PWM_SLAVE2+0x4>, A

00009a10 <.LM70>:
    IO_SET(PWM_SLAVE3, LT, 0u);  /* T */
    9a10:	0ea7      	lod	C, ML.7
    9a12:	52d8 0156 	mov	0x156 <_PWM_SLAVE3+0x4>, A

00009a16 <.LM71>:
}
    9a16:	5401      	ret

00009a18 <_pwm_Off>:
    9a18:	72da eeee 	lod	A, #61166
    9a1c:	52d8 0216 	mov	0x216 <_PORT_DRV_CTRL>, A

00009a20 <.LBE1086>:
                                DRV_CTRL_TRISTATE,  /* V */
                                DRV_CTRL_TRISTATE,  /* W */
                                DRV_CTRL_TRISTATE); /* T */

    /* stop pwm modules output */
    IO_SET(PWM_MASTER1, LT, 0u); /* U */
    9a20:	7000      	lod	A, #0
    9a22:	0ea7      	lod	C, ML.7
    9a24:	52d8 0138 	mov	0x138 <_PWM_MASTER1+0x4>, A

00009a28 <.LM75>:
    IO_SET(PWM_SLAVE1, LT, 0u);  /* V */
    9a28:	52d8 0142 	mov	0x142 <.LASF2025+0x2>, A

00009a2c <.LM76>:
    IO_SET(PWM_SLAVE2, LT, 0u);  /* W */
    9a2c:	52d8 014c 	mov	0x14c <_PWM_SLAVE2+0x4>, A

00009a30 <.LM77>:
    IO_SET(PWM_SLAVE3, LT, 0u);  /* T */
    9a30:	0ea7      	lod	C, ML.7
    9a32:	52d8 0156 	mov	0x156 <_PWM_SLAVE3+0x4>, A

00009a36 <.LM78>:
}
    9a36:	5401      	ret

00009a38 <_pwm_Disable>:
    9a38:	72da eeee 	lod	A, #61166
    9a3c:	52d8 0216 	mov	0x216 <_PORT_DRV_CTRL>, A

00009a40 <.LBE1088>:
                                DRV_CTRL_TRISTATE,  /* V */
                                DRV_CTRL_TRISTATE,  /* W */
                                DRV_CTRL_TRISTATE); /* T */

    /* stop pwm modules output */
    IO_SET(PWM_MASTER1, LT, 0u); /* U */
    9a40:	7000      	lod	A, #0
    9a42:	0ea7      	lod	C, ML.7
    9a44:	52d8 0138 	mov	0x138 <_PWM_MASTER1+0x4>, A

00009a48 <.LM82>:
    IO_SET(PWM_SLAVE1, LT, 0u);  /* V */
    9a48:	52d8 0142 	mov	0x142 <.LASF2025+0x2>, A

00009a4c <.LM83>:
    IO_SET(PWM_SLAVE2, LT, 0u);  /* W */
    9a4c:	52d8 014c 	mov	0x14c <_PWM_SLAVE2+0x4>, A

00009a50 <.LM84>:
    IO_SET(PWM_SLAVE3, LT, 0u);  /* T */
    9a50:	0ea7      	lod	C, ML.7
    9a52:	52d8 0156 	mov	0x156 <_PWM_SLAVE3+0x4>, A

00009a56 <.LM85>:

    IO_SET(PORT_DRV_OUT,
    9a56:	62d8 020e 	lod	AL, 0x20e <_PORT_DRV_OUT>
    9a5a:	94c0      	and	AL, #-64
    9a5c:	42d8 020e 	mov	0x20e <_PORT_DRV_OUT>, AL

00009a60 <.LM86>:
           ENABLE_DRV, 0x0u,           /* disable drivers of all phases */
           ENABLE_DRVSUP, 0x0u,        /* disable driver supply */
           ENABLE_DRVMOD_CPCLK, 0x0u); /* disable driver clock */

    IO_SET(PORT_DRV2_PROT, DIS_DRV, 1u); /* disable digital part of the driver */
    9a60:	6001      	lod	AL, #1
    9a62:	42d8 021a 	mov	0x21a <_PORT_DRV2_PROT>, AL

00009a66 <.LBB1090>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    9a66:	7ee3      	lod	X, M

00009a68 <.LBB1093>:
    9a68:	5049      	call	fp2:0x48

00009a6a <.LBE1093>:

    ENTER_SECTION(ATOMIC_SYSTEM_MODE);
    Itc_Disable(DIAG);
    9a6a:	62d8 0071 	lod	AL, 0x71 <__mlx4_cst_tables_ram_size+0x13>
    9a6e:	94f7      	and	AL, #-9
    9a70:	42d8 0071 	mov	0x71 <__mlx4_cst_tables_ram_size+0x13>, AL

00009a74 <.LM90>:
    Itc_Disable(UV_VS);
    9a74:	62d8 006c 	lod	AL, 0x6c <__mlx4_cst_tables_ram_size+0xe>
    9a78:	947f      	and	AL, #127
    9a7a:	42d8 006c 	mov	0x6c <__mlx4_cst_tables_ram_size+0xe>, AL

00009a7e <.LM91>:
    Itc_Disable(OV_VS);
    9a7e:	62d8 0071 	lod	AL, 0x71 <__mlx4_cst_tables_ram_size+0x13>
    9a82:	94fb      	and	AL, #-5
    9a84:	42d8 0071 	mov	0x71 <__mlx4_cst_tables_ram_size+0x13>, AL

00009a88 <.LBB1095>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    9a88:	5ee3      	mov	M, X

00009a8a <.LBE1090>:
    EXIT_SECTION();
}
    9a8a:	5401      	ret

00009a8c <__PWM_MASTER1_END_INT>:
 *
 * This function will handle the end of period interrupt to produce a
 * synchronized PWM LT update.
 */
INTERRUPT void _PWM_MASTER1_END_INT(void)
{
    9a8c:	52df      	push	A

00009a8e <.LCFI3>:
    IO_SET(PWM_MASTER1, LT, u16LTcopy[0]); /* U */
    9a8e:	72d8 11b6 	lod	A, 0x11b6 <_u16LTcopy>
    9a92:	52d8 0138 	mov	0x138 <_PWM_MASTER1+0x4>, A

00009a96 <.LM96>:
    IO_SET(PWM_SLAVE1, LT, u16LTcopy[1]);  /* V */
    9a96:	72d8 11b8 	lod	A, 0x11b8 <_u16LTcopy+0x2>
    9a9a:	0ea7      	lod	C, ML.7
    9a9c:	52d8 0142 	mov	0x142 <.LASF2025+0x2>, A

00009aa0 <.LM97>:
    IO_SET(PWM_SLAVE2, LT, u16LTcopy[2]);  /* W */
    9aa0:	72d8 11ba 	lod	A, 0x11ba <_u16LTcopy+0x4>
    9aa4:	52d8 014c 	mov	0x14c <_PWM_SLAVE2+0x4>, A

00009aa8 <.LM98>:
    IO_SET(PWM_SLAVE3, LT, u16LTcopy[3]);  /* T */
    9aa8:	0ea7      	lod	C, ML.7
    9aaa:	72d8 11bc 	lod	A, 0x11bc <.LLST11+0x1>
    9aae:	52d8 0156 	mov	0x156 <_PWM_SLAVE3+0x4>, A

00009ab2 <.LM99>:

    //    ENTER_SECTION(ATOMIC_SYSTEM_MODE);
    //    Itc_Disable(PWM_MASTER1_END);
    //    EXIT_SECTION();
}
    9ab2:	72cf      	pop	A

00009ab4 <.LCFI4>:
    9ab4:	72cb      	pop	M
    9ab6:	5401      	ret

00009ab8 <__PWM_SLAVE2_CMP_INT>:

INTERRUPT void _PWM_SLAVE2_CMP_INT(void)
{
}
    9ab8:	72cb      	pop	M
    9aba:	5401      	ret

00009abc <__DIAG_INT>:
 *
 * This function will handle the generic motor driver
 * interrupt.
 */
INTERRUPT void _DIAG_INT(void)
{
    9abc:	5edf      	push	X

00009abe <.LCFI5>:
    9abe:	5adf      	push	Y

00009ac0 <.LCFI6>:
    9ac0:	52df      	push	A

00009ac2 <.LCFI7>:
    9ac2:	4c83      	push	D

00009ac4 <.LCFI8>:
    /* remember the diagnostic error, all diagnostic errors need to be
     * cleared before the driver can be started again
     */
    u16LastDiagErr = IO_HOST(PORT_DIAG_IN, OVT_MEM);
    9ac4:	72d8 021e 	lod	A, 0x21e <_PORT_DIAG_IN>

00009ac8 <.LM104>:

    pwm_Stop();
    9ac8:	1797      	call	0x99f8 <_pwm_Stop>

00009aca <.LM105>:

    /* disable the interrupt, otherwise the interrupt will be called continuously */
    Itc_Disable(DIAG);
    9aca:	62d8 0071 	lod	AL, 0x71 <__mlx4_cst_tables_ram_size+0x13>
    9ace:	94f7      	and	AL, #-9
    9ad0:	42d8 0071 	mov	0x71 <__mlx4_cst_tables_ram_size+0x13>, AL

00009ad4 <.LM106>:
}
    9ad4:	4cc3      	pop	D

00009ad6 <.LCFI9>:
    9ad6:	72cf      	pop	A

00009ad8 <.LCFI10>:
    9ad8:	7acf      	pop	Y

00009ada <.LCFI11>:
    9ada:	7ecf      	pop	X

00009adc <.LCFI12>:
    9adc:	72cb      	pop	M
    9ade:	5401      	ret

00009ae0 <_swtimer_init>:
 * Initialize Core Timer and start.
 */
void swtimer_init(void)
{
    /* Init clock error conversion */
    conv_clock_error_init();
    9ae0:	82db 3d27 	callf	0x7a4e <_conv_clock_error_init>

00009ae4 <.LBB198>:
/** STIMER_SET_MODE sets the simple timer's mode
 * @param[in] mode new Simple Timer's mode
 */
STATIC INLINE void STIMER_SET_MODE( STimerClk_t mode )
{
    IO_SET(STIMER, MODE, (uint16_t)mode);
    9ae4:	72b2      	lod	A, io:0x32 <_STIMER+0x2>
    9ae6:	d43f      	and	AH, #63
    9ae8:	c480      	or	AH, #-128
    9aea:	52b2      	mov	io:0x32 <_STIMER+0x2>, A

00009aec <.LBB201>:
/** STIMER_SET_VALUE sets the simple timer's mode
 * @param[in] value is new 14-bit timer value
 */
STATIC INLINE void STIMER_SET_VALUE( uint16_t value )
{
    IO_SET(STIMER, VALUE, value);
    9aec:	72b2      	lod	A, io:0x32 <_STIMER+0x2>
    9aee:	b6da c000 	and	A, #49152
    9af2:	8464      	or	AL, #100
    9af4:	52b2      	mov	io:0x32 <_STIMER+0x2>, A

00009af6 <.LBB203>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    9af6:	7ee3      	lod	X, M

00009af8 <.LBB206>:
    return 1;
}

STATIC INLINE uint16_t mlx16_enter_system_mode_keep_prio(void)
{
    __asm__ __volatile__ (".word OPCODE_CALL_FP_ENTER_SYSTEM_MODE_KEEP_PRIO");
    9af8:	5048      	call	fp2:0x40

00009afa <.LBE206>:
    STIMER_INIT(STIMER_1US_CLOCK, CT_PERIODIC_RATE);

    /* Enable Timer interrupt */
    #ifndef UNITTEST
    ENTER_SECTION(SYSTEM_MODE);
    Itc_Clear(STIMER);
    9afa:	6010      	lod	AL, #16
    9afc:	42d8 0052 	mov	0x52 <.LASF1525+0x5>, AL

00009b00 <.LM8>:
    Itc_Enable(STIMER);
    9b00:	62d8 006e 	lod	AL, 0x6e <__mlx4_cst_tables_ram_size+0x10>
    9b04:	8410      	or	AL, #16
    9b06:	42d8 006e 	mov	0x6e <__mlx4_cst_tables_ram_size+0x10>, AL

00009b0a <.LBB208>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    9b0a:	5ee3      	mov	M, X

00009b0c <.LBE203>:

    EXIT_SECTION();
    #endif

    /* Clear all */
    (void)memset((void *)g_pTimer, 0, sizeof(g_pTimer) / sizeof(uint8_t));
    9b0c:	7eda 140e 	lod	X, #5134
    9b10:	7000      	lod	A, #0
    9b12:	54ee      	mov	Cx, #14
    9b14:	52de      	mov	[X++], A
    9b16:	1ffe      	djnz	Cx, 0x9b14 <.LASF1245>

00009b18 <.LM11>:
}
    9b18:	5401      	ret

00009b1a <_swtimer_deinit>:
/** STIMER_SET_MODE sets the simple timer's mode
 * @param[in] mode new Simple Timer's mode
 */
STATIC INLINE void STIMER_SET_MODE( STimerClk_t mode )
{
    IO_SET(STIMER, MODE, (uint16_t)mode);
    9b1a:	72b2      	lod	A, io:0x32 <_STIMER+0x2>
    9b1c:	d43f      	and	AH, #63
    9b1e:	52b2      	mov	io:0x32 <_STIMER+0x2>, A

00009b20 <.LBB214>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    9b20:	7ee3      	lod	X, M

00009b22 <.LBB217>:
    9b22:	5048      	call	fp2:0x40

00009b24 <.LBE217>:
    STIMER_SET_MODE(STIMER_DISABLE_CLOCK);  /* switch off */

    /* Disable Timer interrupt */
    #ifndef UNITTEST
    ENTER_SECTION(SYSTEM_MODE);
    Itc_Disable(STIMER);
    9b24:	62d8 006e 	lod	AL, 0x6e <__mlx4_cst_tables_ram_size+0x10>
    9b28:	94ef      	and	AL, #-17
    9b2a:	42d8 006e 	mov	0x6e <__mlx4_cst_tables_ram_size+0x10>, AL

00009b2e <.LBB219>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    9b2e:	5ee3      	mov	M, X

00009b30 <.LBE214>:
    EXIT_SECTION();
    #endif
}
    9b30:	5401      	ret

00009b32 <_swtimer_calibrate>:
void swtimer_calibrate(uint16_t u16ADC_Value)
{
    int16_t i16ClockCountCorrection = 0;

    /* Get clock count correction */
    i16ClockCountCorrection = conv_clock_error_speed(u16ADC_Value);
    9b32:	82db 3d3b 	callf	0x7a76 <_conv_clock_error_speed>

00009b36 <.LM21>:

    i16ClockCountCorrection = conv_clock_error_correct_period(CT_PERIODIC_RATE, i16ClockCountCorrection);
    9b36:	52df      	push	A

00009b38 <.LCFI0>:
    9b38:	7064      	lod	A, #100

00009b3a <.LVL13>:
    9b3a:	82db 3d51 	callf	0x7aa2 <_conv_clock_error_correct_period>

00009b3e <.LBB223>:
/** STIMER_SET_VALUE sets the simple timer's mode
 * @param[in] value is new 14-bit timer value
 */
STATIC INLINE void STIMER_SET_VALUE( uint16_t value )
{
    IO_SET(STIMER, VALUE, value);
    9b3e:	7eb2      	lod	X, io:0x32 <_STIMER+0x2>
    9b40:	36da c000 	and	X, #49152
    9b44:	a6ee      	or	A, X

00009b46 <.LVL15>:
    9b46:	52b2      	mov	io:0x32 <_STIMER+0x2>, A

00009b48 <.LBE223>:
    STIMER_SET_VALUE(i16ClockCountCorrection);
}
    9b48:	5403      	ret	#4

00009b4a <_swtimer_register>:
 */
bool swtimer_register(swtimer_id_t a_e8Id, uint16_t a_u15Load, swtimer_mode_t a_eMode)
{
    bool bRetVal = false;

    if ((a_e8Id < SWTIMER_NR_OF) && (a_u15Load < 0x8000))
    9b4a:	ac06      	cmp	A, #6
    9b4c:	1e12      	jug	0x9b72 <.L7>

00009b4e <.LM26>:
 * @param  a_u15Load  a 15-bit load value [0:0x8000] x CT_PERIODIC_RATE us
 * @param  a_eMode  timer mode, single shot or repetitive
 * @return  true  in case of success
 */
bool swtimer_register(swtimer_id_t a_e8Id, uint16_t a_u15Load, swtimer_mode_t a_eMode)
{
    9b4e:	7a03      	lod	Y, [S-4]

00009b50 <.LM27>:
    bool bRetVal = false;

    if ((a_e8Id < SWTIMER_NR_OF) && (a_u15Load < 0x8000))
    9b50:	ec00      	cmp	Y, #0
    9b52:	1a8f      	jsl	0x9b72 <.L7>

00009b54 <.LM28>:
    {
        g_pTimer[a_e8Id].bRepetitive = (a_eMode == REPETITIVE) ? 1u : 0u;
    9b54:	44a2      	asl	A, #2

00009b56 <.LVL17>:
    9b56:	7ee2      	lod	X, A
    9b58:	22da 140e 	add	X, #5134

00009b5c <.LM29>:
 * @param  a_u15Load  a 15-bit load value [0:0x8000] x CT_PERIODIC_RATE us
 * @param  a_eMode  timer mode, single shot or repetitive
 * @return  true  in case of success
 */
bool swtimer_register(swtimer_id_t a_e8Id, uint16_t a_u15Load, swtimer_mode_t a_eMode)
{
    9b5c:	7205      	lod	A, [S-6]

00009b5e <.LM30>:
    bool bRetVal = false;

    if ((a_e8Id < SWTIMER_NR_OF) && (a_u15Load < 0x8000))
    {
        g_pTimer[a_e8Id].bRepetitive = (a_eMode == REPETITIVE) ? 1u : 0u;
    9b5e:	ac01      	cmp	A, #1
    9b60:	5c82      	se	A

00009b62 <.LM31>:
        g_pTimer[a_e8Id].u15Load = a_u15Load;
    9b62:	f6da 7fff 	and	Y, #32767
    9b66:	b401      	and	A, #1
    9b68:	4452      	rr	A
    9b6a:	a6e6      	or	A, Y
    9b6c:	52f8      	mov	[X], A

00009b6e <.LM32>:
        bRetVal = true;
    9b6e:	7001      	lod	A, #1
    9b70:	5401      	ret

00009b72 <.L7>:
 * @param  a_eMode  timer mode, single shot or repetitive
 * @return  true  in case of success
 */
bool swtimer_register(swtimer_id_t a_e8Id, uint16_t a_u15Load, swtimer_mode_t a_eMode)
{
    bool bRetVal = false;
    9b72:	7000      	lod	A, #0

00009b74 <.LM34>:
        g_pTimer[a_e8Id].bRepetitive = (a_eMode == REPETITIVE) ? 1u : 0u;
        g_pTimer[a_e8Id].u15Load = a_u15Load;
        bRetVal = true;
    }
    return bRetVal;
}
    9b74:	5401      	ret

00009b76 <_swtimer_start>:
 * Start a software timer
 * @param[in]  a_e8Id  Timer id
 */
void swtimer_start(swtimer_id_t a_e8Id)
{
    g_pTimer[a_e8Id].u15Current = g_pTimer[a_e8Id].u15Load;
    9b76:	44a2      	asl	A, #2

00009b78 <.LVL22>:
    9b78:	7ee2      	lod	X, A
    9b7a:	22da 140e 	add	X, #5134
    9b7e:	7af8      	lod	Y, [X]
    9b80:	f6da 7fff 	and	Y, #32767
    9b84:	72fa      	lod	A, [X+2]
    9b86:	b6da 8000 	and	A, #32768
    9b8a:	a6e6      	or	A, Y
    9b8c:	52fa      	mov	[X+2], A

00009b8e <.LM37>:
    g_pTimer[a_e8Id].bTriggered = 0u;
    9b8e:	2003      	add	X, #3
    9b90:	62f8      	lod	AL, [X]
    9b92:	947f      	and	AL, #127
    9b94:	42f8      	mov	[X], AL

00009b96 <.LM38>:
}
    9b96:	5401      	ret

00009b98 <_swtimer_isTriggered>:
 * Check if a software timer has expired and clear it by timer id.
 * @param[in]  a_e8Id  Timer id
 * @return  true  if expired
 */
bool swtimer_isTriggered(swtimer_id_t a_e8Id)
{
    9b98:	5801      	inc	S, #2

00009b9a <.LCFI2>:
    bool lb_trigged = false;

    if (g_pTimer[a_e8Id].bTriggered != 0u)
    9b9a:	44a2      	asl	A, #2

00009b9c <.LVL31>:
    9b9c:	5201      	mov	[S-2], A
    9b9e:	7ee2      	lod	X, A
    9ba0:	22da 1411 	add	X, #5137
    9ba4:	66f8      	lod	YL, [X]
    9ba6:	62e8      	lod	AL, YL
    9ba8:	4440      	rl	AL
    9baa:	9401      	and	AL, #1
    9bac:	5cf2      	usex	A
    9bae:	7ee2      	lod	X, A
    9bb0:	62e8      	lod	AL, YL
    9bb2:	1d88      	jnn	0x9bc4 <.L16>

00009bb4 <.LM52>:
    {
        g_pTimer[a_e8Id].bTriggered = 0u;
    9bb4:	7e01      	lod	X, [S-2]
    9bb6:	22da 1411 	add	X, #5137
    9bba:	62e8      	lod	AL, YL
    9bbc:	947f      	and	AL, #127
    9bbe:	42f8      	mov	[X], AL

00009bc0 <.LM53>:
        lb_trigged = true;
    9bc0:	7001      	lod	A, #1
    9bc2:	5403      	ret	#4

00009bc4 <.L16>:
 * @param[in]  a_e8Id  Timer id
 * @return  true  if expired
 */
bool swtimer_isTriggered(swtimer_id_t a_e8Id)
{
    bool lb_trigged = false;
    9bc4:	72ee      	lod	A, X

00009bc6 <.LM55>:
        g_pTimer[a_e8Id].bTriggered = 0u;
        lb_trigged = true;
    }

    return (lb_trigged);
}
    9bc6:	5403      	ret	#4

00009bc8 <_swtimer_enterIrq>:
/* ---------------------------------------------
 * Weak, default function implementation
 * --------------------------------------------- */

WEAK void swtimer_enterIrq(void)
{}
    9bc8:	5401      	ret

00009bca <_swtimer_exitIrq>:
    9bca:	5401      	ret

00009bcc <_swtimer_triggerIrq>:
{}

WEAK void swtimer_triggerIrq(uint16_t id)
{
    (void)id;
}
    9bcc:	5401      	ret

00009bce <__STIMER_INT>:

/**
 * The core timer interrupt service routine.
 */
INTERRUPT void _STIMER_INT(void)
{
    9bce:	5edf      	push	X

00009bd0 <.LCFI3>:
    9bd0:	5adf      	push	Y

00009bd2 <.LCFI4>:
    9bd2:	52df      	push	A

00009bd4 <.LCFI5>:
    9bd4:	4c83      	push	D

00009bd6 <.LCFI6>:
    9bd6:	5807      	inc	S, #8

00009bd8 <.LCFI7>:
    swtimer_enterIrq();
    9bd8:	17f7      	call	0x9bc8 <_swtimer_enterIrq>

00009bda <.LBB225>:

    /* Count-down all the registered SW timers, trigger when 0 is reached */
    for (uint16_t index = 0u; index < (uint16_t)SWTIMER_NR_OF; index++)
    9bda:	7000      	lod	A, #0
    9bdc:	5203      	mov	[S-4], A

00009bde <.L23>:
    {
        uint16_t value = g_pTimer[index].u15Current;
    9bde:	7203      	lod	A, [S-4]
    9be0:	44a2      	asl	A, #2
    9be2:	5205      	mov	[S-6], A
    9be4:	7ee2      	lod	X, A
    9be6:	22da 1410 	add	X, #5136
    9bea:	7ef8      	lod	X, [X]

00009bec <.LM64>:

        if (value != 0u)
    9bec:	7aee      	lod	Y, X
    9bee:	f6da 7fff 	and	Y, #32767

00009bf2 <.LVL39>:
    9bf2:	1927      	je	0x9c42 <.L21>
    9bf4:	7aee      	lod	Y, X

00009bf6 <.LVL40>:
    9bf6:	f6da 7fff 	and	Y, #32767

00009bfa <.LM65>:
        {
            value--;

            if (value == 0u)
    9bfa:	72e6      	lod	A, Y
    9bfc:	a0ff      	add	A, #-1

00009bfe <.LVL42>:
    9bfe:	5207      	mov	[S-8], A
    9c00:	ec01      	cmp	Y, #1
    9c02:	1d13      	jne	0x9c2a <.L22>

00009c04 <.LM66>:
            {
                /* Trigger state */
                g_pTimer[index].bTriggered = 1u;
    9c04:	7e05      	lod	X, [S-6]
    9c06:	22da 140e 	add	X, #5134
    9c0a:	5e05      	mov	[S-6], X
    9c0c:	2003      	add	X, #3
    9c0e:	62f8      	lod	AL, [X]

00009c10 <.LVL43>:
    9c10:	8480      	or	AL, #-128
    9c12:	42f8      	mov	[X], AL

00009c14 <.LM67>:

                /* Callback event */
                swtimer_triggerIrq(index);
    9c14:	7203      	lod	A, [S-4]
    9c16:	17da      	call	0x9bcc <_swtimer_triggerIrq>

00009c18 <.LM68>:

                if (g_pTimer[index].bRepetitive != 0u)
    9c18:	7e05      	lod	X, [S-6]
    9c1a:	62f9      	lod	AL, [X+1]
    9c1c:	4201      	mov	[S-2], AL
    9c1e:	9480      	and	AL, #-128
    9c20:	1904      	je	0x9c2a <.L22>

00009c22 <.LM69>:
                {
                    /* Reload periodic timers */
                    value = g_pTimer[index].u15Load;
    9c22:	72f8      	lod	A, [X]
    9c24:	b6da 7fff 	and	A, #32767
    9c28:	5207      	mov	[S-8], A

00009c2a <.L22>:
                }
            }

            g_pTimer[index].u15Current = value;
    9c2a:	7203      	lod	A, [S-4]
    9c2c:	44a2      	asl	A, #2
    9c2e:	7ae2      	lod	Y, A
    9c30:	e2da 140e 	add	Y, #5134
    9c34:	7207      	lod	A, [S-8]
    9c36:	d47f      	and	AH, #127
    9c38:	7ef2      	lod	X, [Y+2]
    9c3a:	36da 8000 	and	X, #32768
    9c3e:	26e2      	or	X, A
    9c40:	5ef2      	mov	[Y+2], X

00009c42 <.L21>:
INTERRUPT void _STIMER_INT(void)
{
    swtimer_enterIrq();

    /* Count-down all the registered SW timers, trigger when 0 is reached */
    for (uint16_t index = 0u; index < (uint16_t)SWTIMER_NR_OF; index++)
    9c42:	7203      	lod	A, [S-4]
    9c44:	a001      	add	A, #1

00009c46 <.LVL48>:
    9c46:	5203      	mov	[S-4], A
    9c48:	ac07      	cmp	A, #7
    9c4a:	1d49      	jne	0x9bde <.L23>

00009c4c <.LBE225>:

            g_pTimer[index].u15Current = value;
        }
    }

    swtimer_exitIrq();
    9c4c:	17be      	call	0x9bca <_swtimer_exitIrq>

00009c4e <.LM73>:
}
    9c4e:	5c07      	dec	S, #8

00009c50 <.LVL50>:
    9c50:	4cc3      	pop	D

00009c52 <.LCFI8>:
    9c52:	72cf      	pop	A

00009c54 <.LCFI9>:
    9c54:	7acf      	pop	Y

00009c56 <.LCFI10>:
    9c56:	7ecf      	pop	X

00009c58 <.LCFI11>:
    9c58:	72cb      	pop	M
    9c5a:	5401      	ret

00009c5c <_uartInit>:
#include <stdbool.h>
#include <uart_plot.h>

void uartInit(void)
{
	uart_plot_Init();
    9c5c:	101d      	call	0x9c98 <_uart_plot_Init>

00009c5e <.LM3>:
	uart_plot_Start();
    9c5e:	006c      	jmp	0x9d38 <_uart_plot_Start>

00009c60 <_uartTask>:
}

void uartTask(void)
{
	uart_plot_SendFrame();
    9c60:	006e      	jmp	0x9d3e <_uart_plot_SendFrame>

00009c62 <_uart_Start>:



STATIC INLINE void UART_RxEnable(void)
{
    IO_SET(UART, REE, 1u);
    9c62:	72d8 0256 	lod	A, 0x256 <.LASF1352+0x2>
    9c66:	8404      	or	AL, #4
    9c68:	52d8 0256 	mov	0x256 <.LASF1352+0x2>, A

00009c6c <.LBB677>:
/*********************** Function from lm_uart, Mulan2/3 ******************************************/


STATIC INLINE void UART_TxEnable(void)
{
    IO_SET(UART, TRE, 1u);
    9c6c:	72d8 0256 	lod	A, 0x256 <.LASF1352+0x2>
    9c70:	8402      	or	AL, #2
    9c72:	52d8 0256 	mov	0x256 <.LASF1352+0x2>, A

00009c76 <.LBE677>:
STATIC void uart_Start(void)
{
#ifndef HAS_TWO_UARTS
    UART_RxEnable();
    UART_TxEnable();
    IO_SET(PORT_UDMA_CTRL, UDMA_TXSTART, 1, UDMA_EN, 1);  /* Enable & Start UART DMA */
    9c76:	62d8 024c 	lod	AL, 0x24c <_PORT_UDMA_CTRL>
    9c7a:	8403      	or	AL, #3
    9c7c:	42d8 024c 	mov	0x24c <_PORT_UDMA_CTRL>, AL

00009c80 <.LM5>:
#else
    UART0_RxEnable();
    UART0_TxEnable();
    IO_SET(PORT_UDMA0_CTRL, UDMA0_TXSTART, 1, UDMA0_EN, 1);  /* Enable & Start UART DMA */
#endif
}
    9c80:	5401      	ret

00009c82 <_uart_Stop>:



STATIC INLINE void UART_RxDisable(void)
{
    IO_SET(UART, REE, 0u);
    9c82:	72d8 0256 	lod	A, 0x256 <.LASF1352+0x2>
    9c86:	94fb      	and	AL, #-5
    9c88:	52d8 0256 	mov	0x256 <.LASF1352+0x2>, A

00009c8c <.LBB681>:



STATIC INLINE void UART_TxDisable(void)
{
    IO_SET(UART, TRE, 0u);
    9c8c:	72d8 0256 	lod	A, 0x256 <.LASF1352+0x2>
    9c90:	94fd      	and	AL, #-3
    9c92:	52d8 0256 	mov	0x256 <.LASF1352+0x2>, A

00009c96 <.LBE681>:
    UART_TxDisable();
#else
    UART0_RxDisable();
    UART0_TxDisable();
#endif
}
    9c96:	5401      	ret

00009c98 <_uart_plot_Init>:
/**
 * Initialize plot / uart HW resources
 * @retval  true  in case of success
 */
bool uart_plot_Init(void)
{
    9c98:	5803      	inc	S, #4

00009c9a <.LCFI0>:
    bool bRetVal;

    l_uart_plot_txMsg.s.header = C_SERIAL_PLOT_HEADER_BYTE0;  /* header */
    9c9a:	7ada 11da 	lod	Y, #4570
    9c9e:	60aa      	lod	AL, #-86
    9ca0:	42f0      	mov	[Y], AL

00009ca2 <.LM12>:
    g_u16TxAddress[0] = (uint16_t)&l_uart_plot_dummy;
    9ca2:	72da 10a8 	lod	A, #4264
    9ca6:	5112      	mov	dp:0x12 <__lin_ram_flash_size>, A

00009ca8 <.LM13>:
    g_u16TxAddress[1] = (uint16_t)&l_uart_plot_dummy;
    9ca8:	5114      	mov	dp:0x14 <_ROM_BIST>, A

00009caa <.LM14>:
    g_u16TxAddress[2] = (uint16_t)&l_uart_plot_dummy;
    9caa:	5116      	mov	dp:0x16 <_ROM_BIST+0x2>, A

00009cac <.LM15>:
    g_u16TxAddress[3] = (uint16_t)&l_uart_plot_dummy;
    9cac:	5118      	mov	dp:0x18 <_ROM_BIST+0x4>, A

00009cae <.LBB919>:
{
    const UartTx_t bit_byte_order = config->bit_byte_order;
    bool rc = true;

    /* select the pin to be used as UART Tx port */
    rc = gpio_configureOutput(config->tx_pin, GPIO_UART_OUT);
    9cae:	54ca 000f 	pushw	#15

00009cb2 <.LCFI1>:
    9cb2:	7006      	lod	A, #6
    9cb4:	5a03      	mov	[S-4], Y
    9cb6:	1273      	call	0xa19e <_gpio_configureOutput>
    9cb8:	5205      	mov	[S-6], A

00009cba <.LM17>:

#ifndef HAS_TWO_UARTS
    IO_SET(PORT_COMM_CFG1, UART_RX_SEL, config->rx_pin); /* Select rx_pin as UART0 input */
    9cba:	6007      	lod	AL, #7
    9cbc:	42d8 0242 	mov	0x242 <_PORT_COMM_CFG1>, AL

00009cc0 <.LM18>:

#ifdef HAS_TWO_UARTS
    IO_SET(PORT_IO_UART_SEL, IO_UART_SEL, 0x0000);  /* Select UART0 for all IO pins */
#endif

    if (rc) /* output pin config succeeded */
    9cc0:	5c01      	dec	S, #2

00009cc2 <.LCFI2>:
    9cc2:	7a01      	lod	Y, [S-2]
    9cc4:	7203      	lod	A, [S-4]
    9cc6:	1936      	je	0x9d34 <.L4>

00009cc8 <.LBB921>:
}


STATIC INLINE void UART_FrameLength(UartMlsCtrl_t len)
{
    IO_SET(UART, MLS, (uint16_t)len);
    9cc8:	72d8 0256 	lod	A, 0x256 <.LASF1352+0x2>
    9ccc:	d4f8      	and	AH, #-8
    9cce:	c401      	or	AH, #1
    9cd0:	52d8 0256 	mov	0x256 <.LASF1352+0x2>, A

00009cd4 <.LBB924>:
}


STATIC INLINE void UART_TxFormat(UartBscCtrl_t format)
{
    IO_SET(UART, BSC, (uint16_t)format);
    9cd4:	72d8 0256 	lod	A, 0x256 <.LASF1352+0x2>
    9cd8:	d4e7      	and	AH, #-25
    9cda:	c408      	or	AH, #8
    9cdc:	52d8 0256 	mov	0x256 <.LASF1352+0x2>, A

00009ce0 <.LBB926>:

#ifndef HAS_TWO_UARTS

STATIC INLINE void UART_SetBaudrate(uint16_t brrd_reg_value)
{
    IO_SET(UART, BRRD, brrd_reg_value);
    9ce0:	7000      	lod	A, #0
    9ce2:	52d8 024e 	mov	0x24e <_UART>, A

00009ce6 <.LBE926>:
        UART0_SetBaudrate(baudrate_divider - 1);  /* IMPORTANT returned baudrate must be decremented by 1 */
#endif

#ifndef HAS_TWO_UARTS
        /* Configure UART DMA ports */
        IO_SET(PORT_UDMA_RDA, UDMA_RDA, (uint16_t)((void *)&l_au8UartRdBufA[0]));
    9ce6:	0ea7      	lod	C, ML.7
    9ce8:	72da 11d0 	lod	A, #4560
    9cec:	52d8 0244 	mov	0x244 <_PORT_UDMA_RDA>, A

00009cf0 <.LM23>:
        IO_SET(PORT_UDMA_RDB, UDMA_RDB, (uint16_t)((void *)&l_au8UartRdBufB[0]));
    9cf0:	72da 11c6 	lod	A, #4550
    9cf4:	0ea7      	lod	C, ML.7
    9cf6:	52d8 0246 	mov	0x246 <_PORT_UDMA_RDB>, A

00009cfa <.LM24>:
        IO_SET(PORT_UDMA_TX, UDMA_TX, (uint16_t)((void *)l_uart_plot_txMsg.buf));
    9cfa:	5ad8 0248 	mov	0x248 <_PORT_UDMA_TX>, Y

00009cfe <.LM25>:

        /* Length transmit buffer in Bytes (minus 1) */
        IO_SET(PORT_UDMA_SIZE, UDMA_SIZTX, (C_UART_BUF_SZ - 1u), UDMA_SIZRX, (C_UART_BUF_SZ - 1u));
    9cfe:	72da 0909 	lod	A, #2313
    9d02:	0ea7      	lod	C, ML.7
    9d04:	52d8 024a 	mov	0x24a <_PORT_UDMA_SIZE>, A

00009d08 <.LM26>:

        /* Configure UART DMA mode */
        IO_SET(PORT_UDMA_CTRL, UDMA_LSB_FIRST, 1, UDMA_LOWBYTE_FIRST, 1);
    9d08:	62d8 024c 	lod	AL, 0x24c <_PORT_UDMA_CTRL>
    9d0c:	840c      	or	AL, #12
    9d0e:	42d8 024c 	mov	0x24c <_PORT_UDMA_CTRL>, AL

00009d12 <.LBB928>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    9d12:	7ee3      	lod	X, M

00009d14 <.LBB931>:
    9d14:	5048      	call	fp2:0x40

00009d16 <.LBE931>:
#endif

        #ifndef UNITTEST
        ENTER_SECTION(SYSTEM_MODE);
#ifndef HAS_TWO_UARTS
        Itc_Clear(UDFR);
    9d16:	6040      	lod	AL, #64
    9d18:	42d8 0057 	mov	0x57 <.Lframe0+0x3>, AL

00009d1c <.LM30>:
        Itc_Enable(UDFR);
    9d1c:	62d8 0073 	lod	AL, 0x73 <__mlx4_cst_tables_ram_size+0x15>
    9d20:	8440      	or	AL, #64
    9d22:	42d8 0073 	mov	0x73 <__mlx4_cst_tables_ram_size+0x15>, AL

00009d26 <.LM31>:
        Itc_SetPrio(UDFR, PRIO_UDFR_INT);
    9d26:	62d8 0092 	lod	AL, 0x92 <__data_size+0x2>
    9d2a:	94cf      	and	AL, #-49
    9d2c:	8420      	or	AL, #32
    9d2e:	42d8 0092 	mov	0x92 <__data_size+0x2>, AL

00009d32 <.LBB933>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    9d32:	5ee3      	mov	M, X

00009d34 <.L4>:
        .rx_pin = C_UART_RX_PIN_NR
    };
    bRetVal = uart_Init(&uart_tx_config);

    return bRetVal;
}
    9d34:	7203      	lod	A, [S-4]
    9d36:	5405      	ret	#6

00009d38 <_uart_plot_Start>:
 */
bool uart_plot_Start(void)
{
    bool bRetVal = true;

    uart_Start();
    9d38:	1794      	call	0x9c62 <_uart_Start>

00009d3a <.LM47>:

    return bRetVal;
}
    9d3a:	7001      	lod	A, #1
    9d3c:	5401      	ret

00009d3e <_uart_plot_SendFrame>:
 * Transmit a frame of format
 * byte0  byte1..byte8 byte9
 * header data         checksum
 */
void uart_plot_SendFrame(void)
{
    9d3e:	5801      	inc	S, #2

00009d40 <.LCFI3>:
    uint16_t tmp;

    /* Checksum byte is sent at the end of each frame.
     * It should be the least significant byte of the byte sum of all data bytes.
     */
    l_uart_plot_txMsg.s.cs = 0u;
    9d40:	7eda 11e3 	lod	X, #4579
    9d44:	6000      	lod	AL, #0
    9d46:	42f8      	mov	[X], AL

00009d48 <.LM53>:
    tmp = *(uint16_t*)(g_u16TxAddress[0]);
    9d48:	7912      	lod	Y, dp:0x12 <__lin_ram_flash_size>
    9d4a:	7af0      	lod	Y, [Y]

00009d4c <.LM54>:
    l_uart_plot_txMsg.s.data[0] = tmp;
    9d4c:	46d8 11db 	mov	0x11db <.LASF1689>, YL
    9d50:	72e6      	lod	A, Y
    9d52:	6000      	lod	AL, #0
    9d54:	72e4      	swap	A
    9d56:	42d8 11dc 	mov	0x11dc <.LASF1689+0x1>, AL

00009d5a <.LM55>:
    l_uart_plot_txMsg.s.cs += tmp >> 8;
    l_uart_plot_txMsg.s.cs += tmp;
    9d5a:	82e8      	add	AL, YL
    9d5c:	4201      	mov	[S-2], AL
    9d5e:	42f8      	mov	[X], AL

00009d60 <.LM56>:
    tmp = *(uint16_t*)(g_u16TxAddress[1]);
    9d60:	7914      	lod	Y, dp:0x14 <_ROM_BIST>

00009d62 <.LVL20>:
    9d62:	7af0      	lod	Y, [Y]

00009d64 <.LM57>:
    l_uart_plot_txMsg.s.data[1] = tmp;
    9d64:	46d8 11dd 	mov	0x11dd <.LASF1689+0x2>, YL
    9d68:	72e6      	lod	A, Y
    9d6a:	6000      	lod	AL, #0
    9d6c:	72e4      	swap	A
    9d6e:	42d8 11de 	mov	0x11de <.LASF1689+0x3>, AL

00009d72 <.LM58>:
    l_uart_plot_txMsg.s.cs += tmp >> 8;
    l_uart_plot_txMsg.s.cs += tmp;
    9d72:	82e8      	add	AL, YL
    9d74:	8201      	add	AL, [S-2]
    9d76:	4201      	mov	[S-2], AL
    9d78:	42f8      	mov	[X], AL

00009d7a <.LM59>:
    tmp = *(uint16_t*)(g_u16TxAddress[2]);
    9d7a:	7916      	lod	Y, dp:0x16 <_ROM_BIST+0x2>

00009d7c <.LVL22>:
    9d7c:	7af0      	lod	Y, [Y]

00009d7e <.LM60>:
    l_uart_plot_txMsg.s.data[2] = tmp;
    9d7e:	46d8 11df 	mov	0x11df <.LASF1689+0x4>, YL
    9d82:	72e6      	lod	A, Y
    9d84:	6000      	lod	AL, #0
    9d86:	72e4      	swap	A
    9d88:	42d8 11e0 	mov	0x11e0 <.LASF1689+0x5>, AL

00009d8c <.LM61>:
    l_uart_plot_txMsg.s.cs += tmp >> 8;
    l_uart_plot_txMsg.s.cs += tmp;
    9d8c:	82e8      	add	AL, YL
    9d8e:	8201      	add	AL, [S-2]
    9d90:	4201      	mov	[S-2], AL
    9d92:	42f8      	mov	[X], AL

00009d94 <.LM62>:
    tmp = *(uint16_t*)(g_u16TxAddress[3]);
    9d94:	7918      	lod	Y, dp:0x18 <_ROM_BIST+0x4>

00009d96 <.LVL24>:
    9d96:	7af0      	lod	Y, [Y]

00009d98 <.LM63>:
    l_uart_plot_txMsg.s.data[3] = tmp;
    9d98:	46d8 11e1 	mov	0x11e1 <.LASF1689+0x6>, YL
    9d9c:	72e6      	lod	A, Y
    9d9e:	6000      	lod	AL, #0
    9da0:	72e4      	swap	A
    9da2:	42d8 11e2 	mov	0x11e2 <.LASF1689+0x7>, AL

00009da6 <.LM64>:
    l_uart_plot_txMsg.s.cs += tmp >> 8;
    l_uart_plot_txMsg.s.cs += tmp;
    9da6:	82e8      	add	AL, YL
    9da8:	8201      	add	AL, [S-2]
    9daa:	42f8      	mov	[X], AL

00009dac <.LM65>:

#ifndef HAS_TWO_UARTS
    uint8_t udma_ctrl = IO_BYTE_HOST(PORT_UDMA_CTRL, UDMA_TXSTART);
    9dac:	62d8 024c 	lod	AL, 0x24c <_PORT_UDMA_CTRL>

00009db0 <.LM66>:
    udma_ctrl &= ~(1u << IO_OFFSET(PORT_UDMA_CTRL, UDMA_TXSTART));
    9db0:	94fd      	and	AL, #-3

00009db2 <.LM67>:
    IO_BYTE_HOST(PORT_UDMA_CTRL, UDMA_TXSTART) = udma_ctrl;
    9db2:	42d8 024c 	mov	0x24c <_PORT_UDMA_CTRL>, AL

00009db6 <.LM68>:
    udma_ctrl |= (1u << IO_OFFSET(PORT_UDMA_CTRL, UDMA_TXSTART));
    9db6:	8402      	or	AL, #2

00009db8 <.LM69>:
    IO_BYTE_HOST(PORT_UDMA_CTRL, UDMA_TXSTART) = udma_ctrl;
    9db8:	42d8 024c 	mov	0x24c <_PORT_UDMA_CTRL>, AL

00009dbc <.LM70>:
    IO_BYTE_HOST(PORT_UDMA0_CTRL, UDMA0_TXSTART) = udma_ctrl;
    udma_ctrl |= (1u << IO_OFFSET(PORT_UDMA0_CTRL, UDMA0_TXSTART));
    IO_BYTE_HOST(PORT_UDMA0_CTRL, UDMA0_TXSTART) = udma_ctrl;

#endif
}
    9dbc:	5403      	ret	#4

00009dbe <__UDFR_INT>:
#ifndef HAS_TWO_UARTS
INTERRUPT void _UDFR_INT(void)
#else
INTERRUPT void _UDFR0_INT(void)
#endif
{
    9dbe:	5edf      	push	X

00009dc0 <.LCFI4>:
    9dc0:	5adf      	push	Y

00009dc2 <.LCFI5>:
    9dc2:	52df      	push	A

00009dc4 <.LCFI6>:
    9dc4:	4c83      	push	D

00009dc6 <.LCFI7>:
    9dc6:	5807      	inc	S, #8

00009dc8 <.LCFI8>:
    uint8_t * pu8UartRxBuf;

#ifndef HAS_TWO_UARTS
    if (IO_GET(PORT_UDMA_STATUS, UDMA_RD_BUFFER_VALID) == 0u)
    9dc8:	72d8 025a 	lod	A, 0x25a <_PORT_UDMA_STATUS>
    9dcc:	9401      	and	AL, #1
    9dce:	1901      	je	0x9dd2 <.LM73>
    9dd0:	0046      	jmp	0x9e5e <.L13>

00009dd2 <.LM73>:
#else
    if (IO_GET(PORT_UDMA0_STATUS, UDMA0_RD_BUFFER_VALID) == 0u)
#endif
    {
        pu8UartRxBuf = (uint8_t *)&l_au8UartRdBufB;
    9dd2:	7eda 11c6 	lod	X, #4550

00009dd6 <.L23>:
    }
    else
    {
        pu8UartRxBuf = (uint8_t *)&l_au8UartRdBufA;
    9dd6:	62f8      	lod	AL, [X]

00009dd8 <.LM75>:
    }

    if ((pu8UartRxBuf[0] == C_SERIAL_PLOT_HEADER_BYTE0))
    9dd8:	8caa      	cmp	AL, #-86
    9dda:	1901      	je	0x9dde <.LASF1301+0x4>
    9ddc:	0046      	jmp	0x9e6a <.L15>
    9dde:	7aee      	lod	Y, X
    9de0:	e001      	add	Y, #1
    9de2:	2009      	add	X, #9
    9de4:	5e07      	mov	[S-8], X
    9de6:	5a05      	mov	[S-6], Y

00009de8 <.LBB1061>:
    {
        uint8_t checksum = 0u;
    9de8:	7000      	lod	A, #0
    9dea:	5203      	mov	[S-4], A
    9dec:	7c08      	lod	X, #8
    9dee:	5e01      	mov	[S-2], X

00009df0 <.L16>:
        for (uint8_t index = 0u; index < C_UART_PLOT_DATA_LENGTH; index++)
        {
            checksum += pu8UartRxBuf[1u + index];
    9df0:	7e05      	lod	X, [S-6]
    9df2:	62de      	lod	AL, [X++]
    9df4:	5e05      	mov	[S-6], X
    9df6:	8203      	add	AL, [S-4]
    9df8:	5cf2      	usex	A
    9dfa:	5203      	mov	[S-4], A

00009dfc <.LM78>:
    }

    if ((pu8UartRxBuf[0] == C_SERIAL_PLOT_HEADER_BYTE0))
    {
        uint8_t checksum = 0u;
        for (uint8_t index = 0u; index < C_UART_PLOT_DATA_LENGTH; index++)
    9dfc:	7201      	lod	A, [S-2]
    9dfe:	a0ff      	add	A, #-1
    9e00:	5201      	mov	[S-2], A
    9e02:	1d76      	jne	0x9df0 <.L16>

00009e04 <.LBE1062>:
        {
            checksum += pu8UartRxBuf[1u + index];
        }

        if (checksum == pu8UartRxBuf[C_UART_PLOT_CRC_POS])
    9e04:	7e07      	lod	X, [S-8]
    9e06:	62f8      	lod	AL, [X]
    9e08:	5cf2      	usex	A
    9e0a:	ae03      	cmp	A, [S-4]
    9e0c:	1d21      	jne	0x9e50 <.L12>
    9e0e:	7001      	lod	A, #1
    9e10:	5205      	mov	[S-6], A
    9e12:	7c04      	lod	X, #4
    9e14:	5e03      	mov	[S-4], X

00009e16 <.L20>:
        {
            for (uint8_t index = 0u; index < C_UART_PLOT_DATA_LENGTH / 2; index++)
            {
                uint16_t addr = (pu8UartRxBuf[1u + (index * 2u) + 1u] << 8) | pu8UartRxBuf[1u + (index * 2u)];
    9e16:	6af1      	lod	AH, [Y+1]
    9e18:	62f0      	lod	AL, [Y]
    9e1a:	5207      	mov	[S-8], A

00009e1c <.LVL33>:
    9e1c:	7205      	lod	A, [S-6]

00009e1e <.LVL34>:
    9e1e:	4422      	asl	A
    9e20:	7ee2      	lod	X, A

00009e22 <.LM81>:
                if (addr != 0)
    9e22:	7207      	lod	A, [S-8]

00009e24 <.LM82>:
                {
                    l_u16Payload[index] = addr;
    9e24:	22da 11bc 	add	X, #4540

00009e28 <.LM83>:
        if (checksum == pu8UartRxBuf[C_UART_PLOT_CRC_POS])
        {
            for (uint8_t index = 0u; index < C_UART_PLOT_DATA_LENGTH / 2; index++)
            {
                uint16_t addr = (pu8UartRxBuf[1u + (index * 2u) + 1u] << 8) | pu8UartRxBuf[1u + (index * 2u)];
                if (addr != 0)
    9e28:	ac00      	cmp	A, #0
    9e2a:	191c      	je	0x9e64 <.L18>

00009e2c <.L24>:
                {
                    l_u16Payload[index] = addr;
                }
                else
                {
                    l_u16Payload[index] = (uint16_t)&l_uart_plot_dummy;
    9e2c:	52f8      	mov	[X], A

00009e2e <.LVL35>:
    9e2e:	7205      	lod	A, [S-6]
    9e30:	a001      	add	A, #1
    9e32:	5205      	mov	[S-6], A

00009e34 <.LVL36>:
    9e34:	e002      	add	Y, #2

00009e36 <.LBE1064>:
            checksum += pu8UartRxBuf[1u + index];
        }

        if (checksum == pu8UartRxBuf[C_UART_PLOT_CRC_POS])
        {
            for (uint8_t index = 0u; index < C_UART_PLOT_DATA_LENGTH / 2; index++)
    9e36:	7e03      	lod	X, [S-4]
    9e38:	20ff      	add	X, #-1
    9e3a:	5e03      	mov	[S-4], X
    9e3c:	1d6c      	jne	0x9e16 <.L20>

00009e3e <.LBE1063>:
            }

            l_bCommandReady = true;
            if (l_bCommandReady)
            {
                memcpy(g_u16TxAddress, l_u16Payload, C_UART_PLOT_DATA_LENGTH);
    9e3e:	7eda 1012 	lod	X, #4114
    9e42:	7ada 11be 	lod	Y, #4542
    9e46:	0ea7      	lod	C, ML.7
    9e48:	54c6      	movsw	[X++], [Y++]
    9e4a:	54c6      	movsw	[X++], [Y++]
    9e4c:	54c6      	movsw	[X++], [Y++]
    9e4e:	54c6      	movsw	[X++], [Y++]

00009e50 <.L12>:
    {
        /* we lost synchronization, repair */
        uart_Stop();
        uart_Start();
    }
}
    9e50:	5c07      	dec	S, #8
    9e52:	4cc3      	pop	D

00009e54 <.LCFI9>:
    9e54:	72cf      	pop	A

00009e56 <.LCFI10>:
    9e56:	7acf      	pop	Y

00009e58 <.LCFI11>:
    9e58:	7ecf      	pop	X

00009e5a <.LCFI12>:
    9e5a:	72cb      	pop	M
    9e5c:	5401      	ret

00009e5e <.L13>:
    {
        pu8UartRxBuf = (uint8_t *)&l_au8UartRdBufB;
    }
    else
    {
        pu8UartRxBuf = (uint8_t *)&l_au8UartRdBufA;
    9e5e:	7eda 11d0 	lod	X, #4560
    9e62:	07b9      	jmp	0x9dd6 <.L23>

00009e64 <.L18>:
                {
                    l_u16Payload[index] = addr;
                }
                else
                {
                    l_u16Payload[index] = (uint16_t)&l_uart_plot_dummy;
    9e64:	72da 10a8 	lod	A, #4264

00009e68 <.LVL40>:
    9e68:	07e1      	jmp	0x9e2c <.L24>

00009e6a <.L15>:
        }
    }
    else
    {
        /* we lost synchronization, repair */
        uart_Stop();
    9e6a:	170b      	call	0x9c82 <_uart_Stop>

00009e6c <.LM91>:
        uart_Start();
    9e6c:	16fa      	call	0x9c62 <_uart_Start>

00009e6e <.LM92>:
    }
}
    9e6e:	07f0      	jmp	0x9e50 <.L12>

00009e70 <__updateCRC8>:
/**
 * @brief Calculate and update CRC8 on one page
 * @param[in]  config  page data
 */
static void _updateCRC8(page_t * config)
{
    9e70:	5801      	inc	S, #2

00009e72 <.LCFI0>:
    9e72:	7ae2      	lod	Y, A

00009e74 <.LM2>:
    uint16_t u16CRC;

    config->crc8 = (uint16_t)0x00;
    9e74:	6000      	lod	AL, #0

00009e76 <.LVL1>:
    9e76:	42f0      	mov	[Y], AL

00009e78 <.LM3>:

    u16CRC = nvram_CalcCRC((void *)config, sizeof(page_t) / sizeof(uint16_t));
    9e78:	54ca 0004 	pushw	#4

00009e7c <.LCFI1>:
    9e7c:	72e6      	lod	A, Y
    9e7e:	5a03      	mov	[S-4], Y
    9e80:	82db 1511 	callf	0x2a22 <_nvram_CalcCRC>

00009e84 <.LM4>:

    config->crc8 = (uint16_t)(0xFFU - u16CRC);
    9e84:	bcff      	xor	A, #-1

00009e86 <.LVL3>:
    9e86:	7a03      	lod	Y, [S-4]
    9e88:	42f0      	mov	[Y], AL

00009e8a <.LCFI2>:
}
    9e8a:	5405      	ret	#6

00009e8c <_unirom_Init>:
/* ---------------------------------------------
 * Public Functions Implementation
 * --------------------------------------------- */

void unirom_Init(void)
{}
    9e8c:	5401      	ret

00009e8e <_unirom_LoadUserConfig>:

bool unirom_LoadUserConfig(void)
{
    9e8e:	5809      	inc	S, #10

00009e90 <.LCFI3>:
    9e90:	7ada 0840 	lod	Y, #2112
    9e94:	5a03      	mov	[S-4], Y

00009e96 <.LM10>:
    bool retVal = true;
    9e96:	7001      	lod	A, #1
    9e98:	5207      	mov	[S-8], A

00009e9a <.L6>:
}

#ifndef UNITTEST
STATIC INLINE void EEPROM_ClearErrorFlags(void)
{
    IO_SET(EEPROM_FLASH,
    9e9a:	600f      	lod	AL, #15
    9e9c:	42d8 0188 	mov	0x188 <.LASF1348+0x7>, AL

00009ea0 <.LVL6>:
    9ea0:	7a03      	lod	Y, [S-4]
    9ea2:	e2da 09a4 	add	Y, #2468
    9ea6:	5a01      	mov	[S-2], Y

00009ea8 <.LBE92>:
        EEPROM_ClearErrorFlags();

        uint16_t eeprom_address = NV_ADDR_PATTERN + (page * sizeof(page_t) / sizeof(uint8_t));

        /* copy one page from EEPROM to RAM */
        memcpy((void*)&l_ramCopy.page[page], (void*)eeprom_address, sizeof(page_t) / sizeof(uint8_t));
    9ea8:	5a09      	mov	[S-10], Y
    9eaa:	7203      	lod	A, [S-4]
    9eac:	7ee6      	lod	X, Y
    9eae:	7ae2      	lod	Y, A
    9eb0:	54e8      	mov	Cx, #8
    9eb2:	54c4      	movsb	[X++], [Y++]
    9eb4:	1ffe      	djnz	Cx, 0x9eb2 <.LASF37+0x1>

00009eb6 <.LBB94>:
}
#endif /* UNITTEST */

STATIC INLINE bool EEPROM_GetErrorFlags(void)
{
    return (IO_GET(EEPROM_FLASH, EE_DATA_CORRUPTED_1) != 0u) || (IO_GET(EEPROM_FLASH, EE_DATA_CORRUPTED_2) != 0u);
    9eb6:	72d8 0188 	lod	A, 0x188 <.LASF1348+0x7>
    9eba:	9402      	and	AL, #2
    9ebc:	1d0d      	jne	0x9ed8 <.L4>
    9ebe:	72d8 0188 	lod	A, 0x188 <.LASF1348+0x7>

00009ec2 <.LBE94>:

        if (EEPROM_GetErrorFlags())
    9ec2:	9408      	and	AL, #8
    9ec4:	1d09      	jne	0x9ed8 <.L4>

00009ec6 <.LM15>:
        {
            retVal = false;  /* ECC error */
        }
        else
        {
            if (nvram_CalcCRC((void *)&l_ramCopy.page[page], sizeof(page_t) / sizeof(uint16_t)) != 0xFF)
    9ec6:	54ca 0004 	pushw	#4

00009eca <.LCFI4>:
    9eca:	7203      	lod	A, [S-4]
    9ecc:	82db 1511 	callf	0x2a22 <_nvram_CalcCRC>
    9ed0:	5c01      	dec	S, #2

00009ed2 <.LCFI5>:
    9ed2:	aeda 00ff 	cmp	A, #255
    9ed6:	1902      	je	0x9edc <.L5>

00009ed8 <.L4>:
            {
                retVal = false;  /* CRC error */
    9ed8:	7000      	lod	A, #0
    9eda:	5207      	mov	[S-8], A

00009edc <.L5>:

bool unirom_LoadUserConfig(void)
{
    bool retVal = true;

    for (uint8_t page = 0; page < sizeof(user_pattern_t) / sizeof(page_t); page++)
    9edc:	7a03      	lod	Y, [S-4]
    9ede:	e008      	add	Y, #8
    9ee0:	5a03      	mov	[S-4], Y
    9ee2:	eeda 0858 	cmp	Y, #2136
    9ee6:	1d59      	jne	0x9e9a <.L6>

00009ee8 <.LBE90>:
            }
        }
    }

    return retVal;
}
    9ee8:	7207      	lod	A, [S-8]
    9eea:	540b      	ret	#12

00009eec <_unirom_StoreUserConfig>:
    /* store RAM to eeprom */
    return unirom_StoreUserConfig();
}

bool unirom_StoreUserConfig(void)
{
    9eec:	5805      	inc	S, #6

00009eee <.LCFI6>:
    9eee:	72da 0840 	lod	A, #2112
    9ef2:	5203      	mov	[S-4], A

00009ef4 <.L15>:
    9ef4:	7e03      	lod	X, [S-4]
    9ef6:	22da 09a4 	add	X, #2468
    9efa:	5e01      	mov	[S-2], X

00009efc <.LBB131>:
 * @param[in]  address  page data in EEPROM
 * @retval  true  in case of success
 */
static bool _pageVerify(page_t * config, uint16_t * address)
{
    return (memcmp((void *)config, (void *)address, sizeof(page_t) / sizeof(uint8_t)) == 0);
    9efc:	5e05      	mov	[S-6], X
    9efe:	7a03      	lod	Y, [S-4]
    9f00:	7000      	lod	A, #0
    9f02:	54e8      	mov	Cx, #8
    9f04:	6ade      	lod	AH, [X++]
    9f06:	cad6      	sub	AH, [Y++]
    9f08:	1d02      	jne	0x9f0e <.L18>
    9f0a:	1ffc      	djnz	Cx, 0x9f04 <.LBB131+0x8>
    9f0c:	0001      	jmp	0x9f10 <.L19>

00009f0e <.L18>:
    9f0e:	4412      	rrc	A

00009f10 <.L19>:
    for (uint8_t page = 0u; page < sizeof(user_pattern_t) / sizeof(page_t); page++)
    {
        uint16_t eeprom_address = NV_ADDR_PATTERN + (page * sizeof(page_t) / sizeof(uint8_t));

        /* Check if EEPROM and RAM copy are not the same */
        if (!_pageVerify(&l_ramCopy.page[page], (uint16_t *)eeprom_address))
    9f10:	ac00      	cmp	A, #0
    9f12:	190f      	je	0x9f32 <.L13>

00009f14 <.LBB135>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    9f14:	72e3      	lod	A, M
    9f16:	5205      	mov	[S-6], A

00009f18 <.LBB138>:
    return 1;
}

STATIC INLINE uint16_t mlx16_di_enter_system_mode(void)
{
    __asm__ __volatile__ (".word OPCODE_CALL_FP_ENTER_SYSTEM_MODE_PRIO_0");
    9f18:	5049      	call	fp2:0x48

00009f1a <.LBE138>:
        {
            /* write to eeprom page */
            ENTER_SECTION(ATOMIC_SYSTEM_MODE);
            EEPROM_WriteWord64_blocking(eeprom_address, (void *)&l_ramCopy.page[page], EE_WRITE_KEY);
    9f1a:	54ca 0007 	pushw	#7

00009f1e <.LCFI7>:
    9f1e:	7e03      	lod	X, [S-4]
    9f20:	5edf      	push	X

00009f22 <.LCFI8>:
    9f22:	7207      	lod	A, [S-8]

00009f24 <.LVL19>:
    9f24:	111e      	call	0xa162 <_EEPROM_WriteWord64_blocking>

00009f26 <.LBB140>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    9f26:	7209      	lod	A, [S-10]
    9f28:	52e3      	mov	M, A

00009f2a <.LBB144>:
    9f2a:	0f7f      	lod	C, io:0x0f.7

00009f2c <.LBE146>:
}

/** WDG_conditionalAwdRefresh acknowledges the AWD timer if its window is opened */
STATIC INLINE void WDG_conditionalAwdRefresh(void)
{
    if (IO_GET(AWD, WIN_OPEN) != 0u) {
    9f2c:	5c03      	dec	S, #4

00009f2e <.LCFI9>:
    9f2e:	1c01      	jnc	0x9f32 <.L13>

00009f30 <.LM29>:
        IO_SET(AWD, ACK, 1u);
    9f30:	0b76      	setb	io:0x0e.6

00009f32 <.L13>:
    return unirom_StoreUserConfig();
}

bool unirom_StoreUserConfig(void)
{
    for (uint8_t page = 0u; page < sizeof(user_pattern_t) / sizeof(page_t); page++)
    9f32:	7e03      	lod	X, [S-4]
    9f34:	2008      	add	X, #8
    9f36:	5e03      	mov	[S-4], X
    9f38:	2eda 0858 	cmp	X, #2136
    9f3c:	1d5b      	jne	0x9ef4 <.L15>

00009f3e <.LBE131>:
            WDG_conditionalAwdRefresh();  /* Restart watchdog */
        }
    }

    return true;
}
    9f3e:	7001      	lod	A, #1
    9f40:	5407      	ret	#8

00009f42 <_unirom_ResetUserConfig>:

    return retVal;
}

bool unirom_ResetUserConfig(const user_pattern_t * def_config)
{
    9f42:	5801      	inc	S, #2

00009f44 <.LCFI10>:
    /* restore ram copy  */
    memcpy((void*)&l_ramCopy, (void*)def_config, sizeof(user_pattern_t) / sizeof(uint8_t));
    9f44:	7ada 11e4 	lod	Y, #4580
    9f48:	5a01      	mov	[S-2], Y
    9f4a:	7ee2      	lod	X, A
    9f4c:	a018      	add	A, #24

00009f4e <.LVL25>:
    9f4e:	0ea7      	lod	C, ML.7

00009f50 <.L21>:
    9f50:	54cc      	movsb	[Y++], [X++]
    9f52:	2ee2      	cmp	X, A
    9f54:	1d7d      	jne	0x9f50 <.L21>

00009f56 <.LBB148>:

    /* restore CRC8 of all pages */
    for (uint8_t page = 0u; page < sizeof(user_pattern_t) / sizeof(page_t); page++)
    {
        _updateCRC8(&l_ramCopy.page[page]);
    9f56:	72da 11e4 	lod	A, #4580
    9f5a:	178a      	call	0x9e70 <__updateCRC8>
    9f5c:	72da 11ec 	lod	A, #4588
    9f60:	1787      	call	0x9e70 <__updateCRC8>
    9f62:	72da 11f4 	lod	A, #4596
    9f66:	1784      	call	0x9e70 <__updateCRC8>

00009f68 <.LBE148>:
    }

    /* store RAM to eeprom */
    return unirom_StoreUserConfig();
    9f68:	17c1      	call	0x9eec <_unirom_StoreUserConfig>

00009f6a <.LM36>:
}
    9f6a:	5403      	ret	#4

00009f6c <_unirom_StorePage>:

    return true;
}

bool unirom_StorePage(uint8_t page)
{
    9f6c:	5805      	inc	S, #6

00009f6e <.LCFI11>:
    uint16_t eeprom_address = NV_ADDR_PATTERN + (page * sizeof(page_t) / sizeof(uint8_t));
    9f6e:	a2da 0108 	add	A, #264

00009f72 <.LVL32>:
    9f72:	44a2      	asl	A, #2
    9f74:	4422      	asl	A
    9f76:	5205      	mov	[S-6], A

00009f78 <.LM39>:

    /* Check if EEPROM and RAM copy are not the same */
    if (!_pageVerify(&l_ramCopy.page[page], (uint16_t *)eeprom_address))
    9f78:	a2da 09a4 	add	A, #2468

00009f7c <.LVL34>:
    9f7c:	5201      	mov	[S-2], A

00009f7e <.LBB160>:
 * @param[in]  address  page data in EEPROM
 * @retval  true  in case of success
 */
static bool _pageVerify(page_t * config, uint16_t * address)
{
    return (memcmp((void *)config, (void *)address, sizeof(page_t) / sizeof(uint8_t)) == 0);
    9f7e:	5203      	mov	[S-4], A
    9f80:	7a05      	lod	Y, [S-6]
    9f82:	7ee2      	lod	X, A
    9f84:	7000      	lod	A, #0
    9f86:	54e8      	mov	Cx, #8
    9f88:	6ade      	lod	AH, [X++]
    9f8a:	cad6      	sub	AH, [Y++]
    9f8c:	1d02      	jne	0x9f92 <.L28>
    9f8e:	1ffc      	djnz	Cx, 0x9f88 <.LBB160+0xa>
    9f90:	0001      	jmp	0x9f94 <.L29>

00009f92 <.L28>:
    9f92:	4412      	rrc	A

00009f94 <.L29>:
bool unirom_StorePage(uint8_t page)
{
    uint16_t eeprom_address = NV_ADDR_PATTERN + (page * sizeof(page_t) / sizeof(uint8_t));

    /* Check if EEPROM and RAM copy are not the same */
    if (!_pageVerify(&l_ramCopy.page[page], (uint16_t *)eeprom_address))
    9f94:	ac00      	cmp	A, #0
    9f96:	190c      	je	0x9fb0 <.L23>

00009f98 <.LBB162>:

STATIC INLINE uint16_t builtin_mlx16_get_status(void)
{
    uint16_t status;

    __asm__ __volatile__ (
    9f98:	72e3      	lod	A, M
    9f9a:	5203      	mov	[S-4], A

00009f9c <.LBB165>:
    9f9c:	5049      	call	fp2:0x48

00009f9e <.LBE165>:
    {
        /* write to eeprom page */
        ENTER_SECTION(ATOMIC_SYSTEM_MODE);
        EEPROM_WriteWord64_blocking(eeprom_address, (void*)&l_ramCopy.page[page], EE_WRITE_KEY);
    9f9e:	54ca 0007 	pushw	#7

00009fa2 <.LCFI12>:
    9fa2:	7e03      	lod	X, [S-4]
    9fa4:	5edf      	push	X

00009fa6 <.LCFI13>:
    9fa6:	7209      	lod	A, [S-10]

00009fa8 <.LVL38>:
    9fa8:	10dc      	call	0xa162 <_EEPROM_WriteWord64_blocking>

00009faa <.LBB167>:
    return status;
}

STATIC INLINE void builtin_mlx16_set_status(uint16_t status)
{
    __asm__ __volatile__ (
    9faa:	7207      	lod	A, [S-8]
    9fac:	52e3      	mov	M, A

00009fae <.LVL40>:
    9fae:	5c03      	dec	S, #4

00009fb0 <.L23>:
        EXIT_SECTION();
    }

    return true;
}
    9fb0:	7001      	lod	A, #1
    9fb2:	5407      	ret	#8

00009fb4 <_unirom_WritePage>:
    }
    return retVal;
}

bool unirom_WritePage(uint8_t page, uint8_t* data, uint8_t len)
{
    9fb4:	5809      	inc	S, #10

00009fb6 <.LCFI19>:
    9fb6:	660f      	lod	YL, [S-16]
    9fb8:	5cf6      	usex	Y
    9fba:	5a01      	mov	[S-2], Y

00009fbc <.LM63>:
    bool retVal = false;

    if (len <= 7u)
    9fbc:	ec07      	cmp	Y, #7
    9fbe:	1a01      	jule	0x9fc2 <.LM63+0x6>
    9fc0:	0031      	jmp	0xa024 <.L42>
    9fc2:	44a2      	asl	A, #2
    9fc4:	4422      	asl	A

00009fc6 <.LVL56>:
    9fc6:	5209      	mov	[S-10], A

00009fc8 <.LM64>:
    {
        if (memcmp((void *)l_ramCopy.page[page].payload, (void *)data, len) != 0)  /* are the new data different ? */
    9fc8:	a2da 11e5 	add	A, #4581
    9fcc:	5205      	mov	[S-6], A
    9fce:	5207      	mov	[S-8], A

00009fd0 <.LM65>:
    }
    return retVal;
}

bool unirom_WritePage(uint8_t page, uint8_t* data, uint8_t len)
{
    9fd0:	7e0d      	lod	X, [S-14]

00009fd2 <.LM66>:
    bool retVal = false;

    if (len <= 7u)
    {
        if (memcmp((void *)l_ramCopy.page[page].payload, (void *)data, len) != 0)  /* are the new data different ? */
    9fd2:	ec00      	cmp	Y, #0
    9fd4:	1927      	je	0xa024 <.L42>
    9fd6:	7ae2      	lod	Y, A
    9fd8:	7201      	lod	A, [S-2]

00009fda <.L54>:
    9fda:	52df      	push	A
    9fdc:	6ad6      	lod	AH, [Y++]
    9fde:	cade      	sub	AH, [X++]
    9fe0:	1d04      	jne	0x9fea <.L55>
    9fe2:	72cf      	pop	A
    9fe4:	a801      	sub	A, #1
    9fe6:	1d79      	jne	0x9fda <.L54>
    9fe8:	0002      	jmp	0x9fee <.L56>

00009fea <.L55>:
    9fea:	5c01      	dec	S, #2
    9fec:	4412      	rrc	A

00009fee <.L56>:
    9fee:	ac00      	cmp	A, #0
    9ff0:	1919      	je	0xa024 <.L42>

00009ff2 <.LM67>:
        {
            memcpy((void*)&l_ramCopy.page[page].payload[0], (void *)data, len);  /* write the data to the ram copy */
    9ff2:	7e0d      	lod	X, [S-14]
    9ff4:	72ee      	lod	A, X
    9ff6:	a201      	add	A, [S-2]
    9ff8:	7a05      	lod	Y, [S-6]
    9ffa:	0ea7      	lod	C, ML.7

00009ffc <.L57>:
    9ffc:	54cc      	movsb	[Y++], [X++]
    9ffe:	2ee2      	cmp	X, A
    a000:	1d7d      	jne	0x9ffc <.L57>

0000a002 <.LM68>:
            memset((void*)&l_ramCopy.page[page].payload[len], 0, 7u - len);  /* clear non-used data with 0 */
    a002:	7c07      	lod	X, #7
    a004:	2a01      	sub	X, [S-2]
    a006:	7a01      	lod	Y, [S-2]
    a008:	e209      	add	Y, [S-10]
    a00a:	e2da 11e5 	add	Y, #4581
    a00e:	2c00      	cmp	X, #0
    a010:	1903      	je	0xa018 <.L40>
    a012:	6000      	lod	AL, #0
    a014:	42d6      	mov	[Y++], AL

0000a016 <L0>:
    a016:	1bfe      	djnz	X, 0xa014 <.LASF1269+0xb>

0000a018 <.L40>:

            _updateCRC8(&l_ramCopy.page[page]);  /* update CRC8 of that page */
    a018:	7209      	lod	A, [S-10]
    a01a:	a2da 11e4 	add	A, #4580
    a01e:	1728      	call	0x9e70 <__updateCRC8>

0000a020 <.LM70>:

            retVal = true;
    a020:	7001      	lod	A, #1
    a022:	540b      	ret	#12

0000a024 <.L42>:
    return retVal;
}

bool unirom_WritePage(uint8_t page, uint8_t* data, uint8_t len)
{
    bool retVal = false;
    a024:	7000      	lod	A, #0

0000a026 <.LM72>:
            retVal = true;
        }
    }

    return retVal;
}
    a026:	540b      	ret	#12

0000a028 <_unirom_ReadPage>:

bool unirom_ReadPage(uint8_t page, uint8_t* data, uint8_t len)
{
    a028:	5805      	inc	S, #6

0000a02a <.LCFI20>:
    a02a:	660b      	lod	YL, [S-12]
    a02c:	5cf6      	usex	Y

0000a02e <.LM74>:
    bool retVal = false;

    if (len <= 7u)
    a02e:	ec07      	cmp	Y, #7
    a030:	1a02      	jule	0xa036 <.L59>

0000a032 <.L61>:
    return retVal;
}

bool unirom_ReadPage(uint8_t page, uint8_t* data, uint8_t len)
{
    bool retVal = false;
    a032:	7000      	lod	A, #0
    a034:	5407      	ret	#8

0000a036 <.L59>:
    a036:	44a2      	asl	A, #2
    a038:	4422      	asl	A

0000a03a <.LVL64>:
    a03a:	5205      	mov	[S-6], A

0000a03c <.LM76>:

    if (len <= 7u)
    {
        if (nvram_CalcCRC((void*)&l_ramCopy.page[page], sizeof(page_t) / sizeof(uint16_t)) == 0xFF)  /* check crc of the page */
    a03c:	a2da 11e4 	add	A, #4580
    a040:	54ca 0004 	pushw	#4

0000a044 <.LCFI21>:
    a044:	5a05      	mov	[S-6], Y
    a046:	82db 1511 	callf	0x2a22 <_nvram_CalcCRC>
    a04a:	5c01      	dec	S, #2

0000a04c <.LCFI22>:
    a04c:	7a03      	lod	Y, [S-4]
    a04e:	aeda 00ff 	cmp	A, #255
    a052:	1d6f      	jne	0xa032 <.L61>

0000a054 <.LM77>:
        {
            memcpy((void*)data, (void *)l_ramCopy.page[page].payload, len);  /* read from ram copy */
    a054:	7205      	lod	A, [S-6]
    a056:	a2da 11e5 	add	A, #4581
    a05a:	ec00      	cmp	Y, #0
    a05c:	190a      	je	0xa072 <.L62>
    a05e:	7e09      	lod	X, [S-10]
    a060:	5e05      	mov	[S-6], X
    a062:	7ee2      	lod	X, A
    a064:	e2e2      	add	Y, A
    a066:	72e6      	lod	A, Y
    a068:	7a05      	lod	Y, [S-6]
    a06a:	0ea7      	lod	C, ML.7

0000a06c <.L66>:
    a06c:	54cc      	movsb	[Y++], [X++]
    a06e:	2ee2      	cmp	X, A
    a070:	1d7d      	jne	0xa06c <.L66>

0000a072 <.L62>:

            retVal = true;
    a072:	7001      	lod	A, #1

0000a074 <.LM79>:
        }
    }
    return retVal;
}
    a074:	5407      	ret	#8

0000a076 <_CalculateTemperature3pLinearize>:
    a076:	7ed8 09b0 	lod	X, 0x9b0 <.LLST14+0x4>
    a07a:	54e4      	mov	Cx, #4
    a07c:	44fe      	asr	X, #2
    a07e:	1ffe      	djnz	Cx, 0xa07c <.LASF1020+0x4>

0000a080 <.LM3>:
    a080:	7ad8 09b4 	lod	Y, 0x9b4 <.LASF1021>
    a084:	eae2      	sub	Y, A
    a086:	72e6      	lod	A, Y

0000a088 <.LVL2>:
    a088:	7ad8 09b8 	lod	Y, 0x9b8 <.LASF1021+0x4>

0000a08c <.LM4>:
    a08c:	ac00      	cmp	A, #0
    a08e:	1e93      	jsge	0xa0b6 <.L2>

0000a090 <.LBB6>:
    a090:	5cf6      	usex	Y

0000a092 <.L8>:
    a092:	4831      	muls	YA, A, Y

0000a094 <.LBE8>:
    a094:	4cb2 0000 	cmp	YA, #0
    a098:	0000 
    a09a:	1e84      	jsge	0xa0a4 <.L5>
    a09c:	4cc0      	mov	D, YA
    a09e:	4c0a 007f 	addu	D, #127
    a0a2:	4c80      	mov	YA, D

0000a0a4 <.L5>:
    a0a4:	48b6      	asr	YA, #7

0000a0a6 <.LM8>:
    a0a6:	2c00      	cmp	X, #0
    a0a8:	1d04      	jne	0xa0b2 <.L6>

0000a0aa <.LM9>:
    a0aa:	66d8 09b6 	lod	YL, 0x9b6 <.LASF1021+0x2>
    a0ae:	5ce6      	ssex	Y
    a0b0:	7ee6      	lod	X, Y

0000a0b2 <.L6>:
    a0b2:	a2ee      	add	A, X

0000a0b4 <.LM11>:
    a0b4:	5401      	ret

0000a0b6 <.L2>:
    a0b6:	6400      	lod	YL, #0
    a0b8:	7ae8      	swap	Y

0000a0ba <.LVL10>:
    a0ba:	07eb      	jmp	0xa092 <.L8>

0000a0bc <_SetSystemSpeed>:
    a0bc:	5801      	inc	S, #2

0000a0be <.LCFI0>:
    a0be:	7ee2      	lod	X, A

0000a0c0 <.LM2>:
    a0c0:	62d8 0180 	lod	AL, 0x180 <.LASF1347+0x7>

0000a0c4 <.LVL1>:
    a0c4:	8407      	or	AL, #7
    a0c6:	42d8 0180 	mov	0x180 <.LASF1347+0x7>, AL

0000a0ca <.LM3>:
    a0ca:	62d8 0191 	lod	AL, 0x191 <.LASF1554+0x8>
    a0ce:	840f      	or	AL, #15
    a0d0:	42d8 0191 	mov	0x191 <.LASF1554+0x8>, AL

0000a0d4 <.LBB118>:
    a0d4:	7ad8 01cc 	lod	Y, 0x1cc <_TRIM_RCO32M>

0000a0d8 <.LBE118>:
    a0d8:	72ee      	lod	A, X
    a0da:	b6da 03ff 	and	A, #1023

0000a0de <.LM6>:
    a0de:	f6da fc00 	and	Y, #64512
    a0e2:	a6e6      	or	A, Y
    a0e4:	52d8 01cc 	mov	0x1cc <_TRIM_RCO32M>, A

0000a0e8 <.LM7>:
    a0e8:	6205      	lod	AL, [S-6]
    a0ea:	42d8 0200 	mov	0x200 <_PORT_CLOCK_CTRL>, AL

0000a0ee <.LM8>:
    a0ee:	7aee      	lod	Y, X
    a0f0:	7ae8      	swap	Y
    a0f2:	44b6      	lsr	Y, #2
    a0f4:	f403      	and	Y, #3
    a0f6:	e004      	add	Y, #4

0000a0f8 <.LM9>:
    a0f8:	5cf2      	usex	A
    a0fa:	5201      	mov	[S-2], A
    a0fc:	6205      	lod	AL, [S-6]
    a0fe:	1904      	je	0xa108 <.L2>

0000a100 <.LM10>:
    a100:	72ee      	lod	A, X
    a102:	d480      	and	AH, #-128
    a104:	5ca2      	sne	A
    a106:	eae2      	sub	Y, A

0000a108 <.L2>:
    a108:	62d8 0191 	lod	AL, 0x191 <.LASF1554+0x8>
    a10c:	94f0      	and	AL, #-16
    a10e:	86e8      	or	AL, YL
    a110:	42d8 0191 	mov	0x191 <.LASF1554+0x8>, AL

0000a114 <.LM12>:
    a114:	7aee      	lod	Y, X

0000a116 <.LVL6>:
    a116:	7ae8      	swap	Y
    a118:	44b6      	lsr	Y, #2
    a11a:	44b6      	lsr	Y, #2
    a11c:	f403      	and	Y, #3
    a11e:	e001      	add	Y, #1

0000a120 <.LM13>:
    a120:	7201      	lod	A, [S-2]
    a122:	1906      	je	0xa130 <.L3>

0000a124 <.LM14>:
    a124:	36da 4000 	and	X, #16384

0000a128 <.LVL8>:
    a128:	5cae      	sne	X
    a12a:	eaee      	sub	Y, X

0000a12c <.LM15>:
    a12c:	1d01      	jne	0xa130 <.L3>

0000a12e <.LM16>:
    a12e:	7801      	lod	Y, #1

0000a130 <.L3>:
    a130:	62d8 0180 	lod	AL, 0x180 <.LASF1347+0x7>
    a134:	94f8      	and	AL, #-8
    a136:	86e8      	or	AL, YL
    a138:	42d8 0180 	mov	0x180 <.LASF1347+0x7>, AL

0000a13c <.LM18>:
    a13c:	5403      	ret	#4

0000a13e <_EEPROM_BusyChecks>:
    a13e:	72d8 0186 	lod	A, 0x186 <.LASF1348+0x5>
    a142:	d440      	and	AH, #64
    a144:	1906      	je	0xa152 <.L2>

0000a146 <.LM3>:
    a146:	62d8 0186 	lod	AL, 0x186 <.LASF1348+0x5>
    a14a:	8401      	or	AL, #1

0000a14c <.L7>:
    a14c:	42d8 0186 	mov	0x186 <.LASF1348+0x5>, AL

0000a150 <.L1>:
    a150:	5401      	ret

0000a152 <.L2>:
    a152:	72d8 0186 	lod	A, 0x186 <.LASF1348+0x5>
    a156:	d410      	and	AH, #16
    a158:	197b      	je	0xa150 <.L1>

0000a15a <.LM7>:
    a15a:	62d8 0186 	lod	AL, 0x186 <.LASF1348+0x5>
    a15e:	940f      	and	AL, #15
    a160:	07f5      	jmp	0xa14c <.L7>

0000a162 <_EEPROM_WriteWord64_blocking>:
    a162:	5801      	inc	S, #2

0000a164 <.LCFI1>:
    a164:	7ed8 0186 	lod	X, 0x186 <.LASF1348+0x5>

0000a168 <.L24>:
    a168:	2c00      	cmp	X, #0
    a16a:	1e86      	jsge	0xa178 <.L19>

0000a16c <.LM42>:
    a16c:	5201      	mov	[S-2], A
    a16e:	17e7      	call	0xa13e <_EEPROM_BusyChecks>

0000a170 <.LM43>:
    a170:	7ed8 0186 	lod	X, 0x186 <.LASF1348+0x5>
    a174:	7201      	lod	A, [S-2]
    a176:	07f8      	jmp	0xa168 <.L24>

0000a178 <.L19>:
    a178:	7e07      	lod	X, [S-8]

0000a17a <.LM45>:
    a17a:	5edf      	push	X

0000a17c <.LCFI2>:
    a17c:	7e07      	lod	X, [S-8]

0000a17e <.LM47>:
    a17e:	5edf      	push	X

0000a180 <.LCFI3>:
    a180:	82db 1328 	callf	0x2650 <_EEPROM_WriteWord64_non_blocking>

0000a184 <.LM48>:
    a184:	5c03      	dec	S, #4

0000a186 <.L21>:
    a186:	72d8 0186 	lod	A, 0x186 <.LASF1348+0x5>
    a18a:	d420      	and	AH, #32
    a18c:	1d7c      	jne	0xa186 <.L21>

0000a18e <.LM50>:
    a18e:	5403      	ret	#4

0000a190 <_VERSION_getFwAppVersion>:
    a190:	72d8 d7ee 	lod	A, 0xd7ee <__fw_app_version_start+0x2>
    a194:	72e4      	swap	A

0000a196 <.LVL1>:
    a196:	7ad8 d7ec 	lod	Y, 0xd7ec <__fw_app_version_start>
    a19a:	7ae8      	swap	Y

0000a19c <.LM3>:
    a19c:	5401      	ret

0000a19e <_gpio_configureOutput>:
    a19e:	5803      	inc	S, #4

0000a1a0 <.LCFI0>:
    a1a0:	5201      	mov	[S-2], A

0000a1a2 <.LM2>:
    a1a2:	ac03      	cmp	A, #3
    a1a4:	1e1f      	jug	0xa1e4 <.L2>

0000a1a6 <.LM3>:
    a1a6:	7ed8 01ea 	lod	X, 0x1ea <_PORT_IO_CFG0>

0000a1aa <.LM4>:
    a1aa:	780f      	lod	Y, #15
    a1ac:	44a2      	asl	A, #2

0000a1ae <.LVL3>:
    a1ae:	ac00      	cmp	A, #0
    a1b0:	1b03      	jsle	0xa1b8 <.L12>
    a1b2:	42e9      	mov	Cx, AL
    a1b4:	4426      	asl	Y
    a1b6:	1ffe      	djnz	Cx, 0xa1b4 <.LVL3+0x6>

0000a1b8 <.L12>:
    a1b8:	fcff      	xor	Y, #-1
    a1ba:	f6ee      	and	Y, X

0000a1bc <.LM5>:
    a1bc:	7e07      	lod	X, [S-8]

0000a1be <.LM6>:
    a1be:	ac00      	cmp	A, #0
    a1c0:	1b03      	jsle	0xa1c8 <.L14>
    a1c2:	42e9      	mov	Cx, AL
    a1c4:	442e      	asl	X
    a1c6:	1ffe      	djnz	Cx, 0xa1c4 <.LASF1120+0x5>

0000a1c8 <.L14>:
    a1c8:	e6ee      	or	Y, X

0000a1ca <.LM7>:
    a1ca:	5ad8 01ea 	mov	0x1ea <_PORT_IO_CFG0>, Y

0000a1ce <.L11>:
    a1ce:	7ed8 023a 	lod	X, 0x23a <_PORT_IO_ENABLE>
    a1d2:	7201      	lod	A, [S-2]
    a1d4:	ac0f      	cmp	A, #15
    a1d6:	1e21      	jug	0xa21a <.L6>
    a1d8:	44e2      	sfb	A

0000a1da <.L7>:
    a1da:	a6ee      	or	A, X
    a1dc:	52d8 023a 	mov	0x23a <_PORT_IO_ENABLE>, A

0000a1e0 <.LM9>:
    a1e0:	7001      	lod	A, #1
    a1e2:	5405      	ret	#6

0000a1e4 <.L2>:
    a1e4:	7201      	lod	A, [S-2]

0000a1e6 <.LVL7>:
    a1e6:	ac07      	cmp	A, #7
    a1e8:	1e1a      	jug	0xa21e <.L8>

0000a1ea <.LM11>:
    a1ea:	7ed8 023c 	lod	X, 0x23c <_PORT_IO_CFG1>

0000a1ee <.LM12>:
    a1ee:	7ae2      	lod	Y, A
    a1f0:	f403      	and	Y, #3
    a1f2:	72e6      	lod	A, Y
    a1f4:	44a2      	asl	A, #2
    a1f6:	780f      	lod	Y, #15
    a1f8:	ac00      	cmp	A, #0
    a1fa:	1b03      	jsle	0xa202 <.L16>
    a1fc:	42e9      	mov	Cx, AL
    a1fe:	4426      	asl	Y
    a200:	1ffe      	djnz	Cx, 0xa1fe <.LASF1490+0x7>

0000a202 <.L16>:
    a202:	fcff      	xor	Y, #-1
    a204:	f6ee      	and	Y, X

0000a206 <.LM13>:
    a206:	7e07      	lod	X, [S-8]
    a208:	ac00      	cmp	A, #0
    a20a:	1b03      	jsle	0xa212 <.L18>
    a20c:	42e9      	mov	Cx, AL
    a20e:	442e      	asl	X
    a210:	1ffe      	djnz	Cx, 0xa20e <.LASF249+0x4>

0000a212 <.L18>:
    a212:	e6ee      	or	Y, X

0000a214 <.LM14>:
    a214:	5ad8 023c 	mov	0x23c <_PORT_IO_CFG1>, Y
    a218:	07da      	jmp	0xa1ce <.L11>

0000a21a <.L6>:
    a21a:	7000      	lod	A, #0
    a21c:	07de      	jmp	0xa1da <.L7>

0000a21e <.L8>:
    a21e:	7000      	lod	A, #0

0000a220 <.LM17>:
    a220:	5405      	ret	#6

0000a222 <_atan2_helper>:
    a222:	5801      	inc	S, #2

0000a224 <.LCFI0>:
    a224:	7ee6      	lod	X, Y

0000a226 <.LM2>:
    a226:	7ae2      	lod	Y, A
    a228:	7000      	lod	A, #0
    a22a:	4c63      	divu	YA, X
    a22c:	4c63      	divu	YA, X
    a22e:	66e4      	lod	YL, AH
    a230:	6c00      	lod	YH, #0
    a232:	4426      	asl	Y
    a234:	e2da 5d88 	add	Y, #23944
    a238:	7ef2      	lod	X, [Y+2]
    a23a:	2af0      	sub	X, [Y]
    a23c:	5cf2      	usex	A
    a23e:	4873      	muls	A, A, X
    a240:	62e4      	lod	AL, AH
    a242:	6800      	lod	AH, #0
    a244:	a2f0      	add	A, [Y]
    a246:	44b2      	lsr	A, #2

0000a248 <.LM3>:
    a248:	5403      	ret	#4

0000a24a <_atan2_lookup>:
    a24a:	5801      	inc	S, #2

0000a24c <.LCFI1>:
    a24c:	7ee2      	lod	X, A

0000a24e <.LVL3>:
    a24e:	5a01      	mov	[S-2], Y
    a250:	7ae2      	lod	Y, A
    a252:	7201      	lod	A, [S-2]

0000a254 <.LM5>:
    a254:	2ee2      	cmp	X, A
    a256:	1a06      	jule	0xa264 <.L3>

0000a258 <.LBB2>:
    a258:	17e4      	call	0xa222 <_atan2_helper>
    a25a:	7ee2      	lod	X, A

0000a25c <.LM7>:
    a25c:	72da 4000 	lod	A, #16384

0000a260 <.LVL6>:
    a260:	aaee      	sub	A, X

0000a262 <.LBE2>:
    a262:	5403      	ret	#4

0000a264 <.L3>:
    a264:	ac00      	cmp	A, #0
    a266:	1908      	je	0xa278 <.L2>

0000a268 <.LM9>:
    a268:	2ee2      	cmp	X, A
    a26a:	1904      	je	0xa274 <.L6>

0000a26c <.LM10>:
    a26c:	72ee      	lod	A, X
    a26e:	7a01      	lod	Y, [S-2]
    a270:	17d8      	call	0xa222 <_atan2_helper>

0000a272 <.LVL9>:
    a272:	5403      	ret	#4

0000a274 <.L6>:
    a274:	72da 2000 	lod	A, #8192

0000a278 <.L2>:
    a278:	5403      	ret	#4

0000a27a <_atan2I16>:
    a27a:	ac00      	cmp	A, #0
    a27c:	1e8c      	jsge	0xa296 <.L9>
    a27e:	5cc2      	neg	A

0000a280 <.LM18>:
    a280:	7a03      	lod	Y, [S-4]
    a282:	1d85      	jnn	0xa28e <.L10>

0000a284 <.LBB3>:
    a284:	5cc6      	neg	Y
    a286:	17e1      	call	0xa24a <_atan2_lookup>
    a288:	a2da 8000 	add	A, #32768

0000a28c <.LBE3>:
    a28c:	5401      	ret

0000a28e <.L10>:
    a28e:	7a03      	lod	Y, [S-4]
    a290:	17dc      	call	0xa24a <_atan2_lookup>
    a292:	5cc2      	neg	A

0000a294 <.LVL20>:
    a294:	5401      	ret

0000a296 <.L9>:
    a296:	7a03      	lod	Y, [S-4]
    a298:	1d87      	jnn	0xa2a8 <.L12>

0000a29a <.LBB4>:
    a29a:	5cc6      	neg	Y
    a29c:	17d6      	call	0xa24a <_atan2_lookup>

0000a29e <.LVL22>:
    a29e:	7eda 8000 	lod	X, #32768
    a2a2:	2ae2      	sub	X, A

0000a2a4 <.LVL23>:
    a2a4:	72ee      	lod	A, X

0000a2a6 <.LBE4>:
    a2a6:	5401      	ret

0000a2a8 <.L12>:
    a2a8:	7a03      	lod	Y, [S-4]
    a2aa:	07cf      	jmp	0xa24a <_atan2_lookup>

0000a2ac <_ldt_Tick>:
    a2ac:	5809      	inc	S, #10

0000a2ae <.LCFI35>:
    a2ae:	5207      	mov	[S-8], A
    a2b0:	620d      	lod	AL, [S-14]

0000a2b2 <.LVL114>:
    a2b2:	5cf2      	usex	A
    a2b4:	5209      	mov	[S-10], A

0000a2b6 <.LBB60>:
    a2b6:	7ad8 1000 	lod	Y, 0x1000 <_ldtMe>
    a2ba:	7ee6      	lod	X, Y
    a2bc:	200c      	add	X, #12
    a2be:	5e03      	mov	[S-4], X
    a2c0:	62f8      	lod	AL, [X]
    a2c2:	1906      	je	0xa2d0 <.L86>

0000a2c4 <.LM190>:
    a2c4:	6064      	lod	AL, #100
    a2c6:	20fd      	add	X, #-3
    a2c8:	42f8      	mov	[X], AL

0000a2ca <.LM191>:
    a2ca:	6000      	lod	AL, #0
    a2cc:	7e03      	lod	X, [S-4]
    a2ce:	42f8      	mov	[X], AL

0000a2d0 <.L86>:
    a2d0:	7ee6      	lod	X, Y
    a2d2:	2009      	add	X, #9
    a2d4:	62f8      	lod	AL, [X]
    a2d6:	4203      	mov	[S-4], AL
    a2d8:	5cf2      	usex	A
    a2da:	5205      	mov	[S-6], A
    a2dc:	7207      	lod	A, [S-8]
    a2de:	ae05      	cmp	A, [S-6]
    a2e0:	1c17      	jnc	0xa310 <.L87>

0000a2e2 <.LM193>:
    a2e2:	6203      	lod	AL, [S-4]
    a2e4:	8a07      	sub	AL, [S-8]

0000a2e6 <.L98>:
    a2e6:	42f8      	mov	[X], AL

0000a2e8 <.LBB63>:
    a2e8:	7ee6      	lod	X, Y
    a2ea:	200d      	add	X, #13
    a2ec:	e00a      	add	Y, #10
    a2ee:	62f8      	lod	AL, [X]
    a2f0:	1904      	je	0xa2fa <.L89>

0000a2f2 <.LM196>:
    a2f2:	6064      	lod	AL, #100
    a2f4:	42f0      	mov	[Y], AL

0000a2f6 <.LM197>:
    a2f6:	6000      	lod	AL, #0
    a2f8:	42f8      	mov	[X], AL

0000a2fa <.L89>:
    a2fa:	62f0      	lod	AL, [Y]
    a2fc:	4205      	mov	[S-6], AL
    a2fe:	5cf2      	usex	A
    a300:	7ee2      	lod	X, A
    a302:	7209      	lod	A, [S-10]
    a304:	aeee      	cmp	A, X
    a306:	1c06      	jnc	0xa314 <.L90>

0000a308 <.LM199>:
    a308:	6205      	lod	AL, [S-6]
    a30a:	8a0d      	sub	AL, [S-14]

0000a30c <.L99>:
    a30c:	42f0      	mov	[Y], AL

0000a30e <.LBE63>:
    a30e:	540b      	ret	#12

0000a310 <.L87>:
    a310:	6000      	lod	AL, #0
    a312:	07e9      	jmp	0xa2e6 <.L98>

0000a314 <.L90>:
    a314:	6000      	lod	AL, #0
    a316:	07fa      	jmp	0xa30c <.L99>

0000a318 <_ml_GetProtectedID>:
    a318:	62d8 0e47 	lod	AL, 0xe47 <_LinProtectedID>
    a31c:	5cf2      	usex	A

0000a31e <.LM11>:
    a31e:	5401      	ret

0000a320 <_ml_SetFixedBaudRate>:
    a320:	5801      	inc	S, #2

0000a322 <.LCFI1>:
    a322:	7ee2      	lod	X, A

0000a324 <.LM24>:
    a324:	a2da fc18 	add	A, #64536

0000a328 <.LVL18>:
    a328:	aeda 4a38 	cmp	A, #19000
    a32c:	1e22      	jug	0xa372 <.L16>

0000a32e <.LM25>:
    a32e:	7205      	lod	A, [S-6]

0000a330 <.LBB36>:
    a330:	4822 2710 	mulu	YA, A, #10000

0000a334 <.LVL21>:
    a334:	442e      	asl	X

0000a336 <.LBB38>:
    a336:	4c63      	divu	YA, X
    a338:	4c63      	divu	YA, X
    a33a:	7ae2      	lod	Y, A

0000a33c <.LBE38>:
    a33c:	7000      	lod	A, #0

0000a33e <.LVL24>:
    a33e:	5201      	mov	[S-2], A
    a340:	7c0c      	lod	X, #12

0000a342 <.L15>:
    a342:	72e6      	lod	A, Y
    a344:	a2da fc27 	add	A, #64551
    a348:	aeda 03fb 	cmp	A, #1019
    a34c:	1e0c      	jug	0xa366 <.L14>

0000a34e <.LM30>:
    a34e:	a2da 03de 	add	A, #990
    a352:	4cf2      	usex	YA

0000a354 <.LBB40>:
    a354:	7c0a      	lod	X, #10
    a356:	4c63      	divu	YA, X
    a358:	4c63      	divu	YA, X

0000a35a <.LBE40>:
    a35a:	5cf2      	usex	A

0000a35c <.LVL28>:
    a35c:	52df      	push	A

0000a35e <.LCFI2>:
    a35e:	7203      	lod	A, [S-4]
    a360:	82db 11e4 	callf	0x23c8 <_ml_SetBaudRate>

0000a364 <.LCFI3>:
    a364:	5405      	ret	#6

0000a366 <.L14>:
    a366:	4436      	lsr	Y

0000a368 <.LM34>:
    a368:	6201      	lod	AL, [S-2]
    a36a:	8001      	add	AL, #1
    a36c:	5cf2      	usex	A
    a36e:	5201      	mov	[S-2], A

0000a370 <.LVL34>:
    a370:	1be8      	djnz	X, 0xa342 <.L15>

0000a372 <.L16>:
    a372:	7001      	lod	A, #1

0000a374 <.LM36>:
    a374:	5403      	ret	#4

0000a376 <_ml_Init>:
    a376:	5801      	inc	S, #2

0000a378 <.LCFI4>:
    a378:	5201      	mov	[S-2], A
    a37a:	82db 20bb 	callf	0x4176 <_ml_InitLinModule>

0000a37e <.LM39>:
    a37e:	7a01      	lod	Y, [S-2]
    a380:	ac00      	cmp	A, #0
    a382:	1d29      	jne	0xa3d6 <.L18>

0000a384 <.LM40>:
    a384:	7e07      	lod	X, [S-8]

0000a386 <.LM41>:
    a386:	5edf      	push	X

0000a388 <.LCFI5>:
    a388:	52df      	push	A

0000a38a <.LCFI6>:
    a38a:	54ca 0001 	pushw	#1

0000a38e <.LCFI7>:
    a38e:	52df      	push	A

0000a390 <.LCFI8>:
    a390:	7001      	lod	A, #1

0000a392 <.LVL38>:
    a392:	5a09      	mov	[S-10], Y
    a394:	82db 118d 	callf	0x231a <_ml_SetOptions>

0000a398 <.LM42>:
    a398:	5c07      	dec	S, #8

0000a39a <.LCFI9>:
    a39a:	7a01      	lod	Y, [S-2]
    a39c:	ac00      	cmp	A, #0
    a39e:	1d1b      	jne	0xa3d6 <.L18>

0000a3a0 <.LM43>:
    a3a0:	ec01      	cmp	Y, #1
    a3a2:	1d0c      	jne	0xa3bc <.L20>

0000a3a4 <.L26>:
    a3a4:	82db 11ea 	callf	0x23d4 <_ml_SetAutoBaudRateMode>

0000a3a8 <.L21>:
    a3a8:	ac00      	cmp	A, #0
    a3aa:	1d15      	jne	0xa3d6 <.L18>

0000a3ac <.LM46>:
    a3ac:	7205      	lod	A, [S-6]

0000a3ae <.LM47>:
    a3ae:	aeda 3a98 	cmp	A, #15000
    a3b2:	5c80      	sc	A
    a3b4:	4422      	asl	A
    a3b6:	82db 1181 	callf	0x2302 <_ml_SetSlewRate>

0000a3ba <.LVL43>:
    a3ba:	5403      	ret	#4

0000a3bc <.L20>:
    a3bc:	ec02      	cmp	Y, #2
    a3be:	1d02      	jne	0xa3c4 <.L22>

0000a3c0 <.LM49>:
    a3c0:	7001      	lod	A, #1

0000a3c2 <.LVL44>:
    a3c2:	07f0      	jmp	0xa3a4 <.L26>

0000a3c4 <.L22>:
    a3c4:	ec00      	cmp	Y, #0
    a3c6:	1d06      	jne	0xa3d4 <.L24>

0000a3c8 <.LM51>:
    a3c8:	7209      	lod	A, [S-10]

0000a3ca <.LM52>:
    a3ca:	52df      	push	A

0000a3cc <.LCFI10>:
    a3cc:	7207      	lod	A, [S-8]
    a3ce:	17a8      	call	0xa320 <_ml_SetFixedBaudRate>

0000a3d0 <.LVL47>:
    a3d0:	5c01      	dec	S, #2

0000a3d2 <.LCFI11>:
    a3d2:	07ea      	jmp	0xa3a8 <.L21>

0000a3d4 <.L24>:
    a3d4:	7001      	lod	A, #1

0000a3d6 <.L18>:
    a3d6:	5403      	ret	#4
