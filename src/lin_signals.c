/**
 ******************************************************************************
 * @file    lin_signals.c
 * @brief   LDF dependent LIN API
 ******************************************************************************
 * @copyright (C) 2025 Melexis N.V. All rights reserved.
 * @internal
 * Melexis N.V. is supplying this software for use with Melexis N.V.
 * processor based microcontrollers only.
 *
 * This file is application specific and depends on LDF file VPC_Fwv_LDF.ldf
 * Generated by configuration tool lin-nodegen (version 2.2.dev0+g5878c6b.d20210701) for node VPC_Fwv_Slave.
 *
 * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
 * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
 * MELEXIS N.V. SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL,
 * INCIDENTAL, OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 * @endinternal
 *
 * @details The file provides LDF-file specific functionality:
 *              - variables declaration for signals
 *              - flag variables declaration for signals
 *              - flag variables declaration for frames (optional)
 *              - flag variables declaration for signals inside specific frame (optional)
 *              - frames structure describing
 *              - frames handler functions to pack the signals inside frames and to provide signal specific frame action
 *
 * @ingroup lin_api
 *
 */

#include <lin_api.h>
#include <lin_core.h>

#if LIN_MASTER_API == 1
#include <lin_core_ma.h>
#endif /* LIN_MASTER_API */

#if LIN_SLAVE_API == 1
#include <lin_core_sl.h>
#include <lin_cfg_sl.h>
#endif /* LIN_SLAVE_API */

/* Example based on VPC_Fwv_LDF.ldf LDF file */

/*-----------------------------------------------------------------------------
 * Common signals for both Slave & Master APIs
 */

#if (LIN_SLAVE_API == 1) || (LIN_MASTER_API == 1)

/*
 * Signals definition
 */

volatile l_signals_t l_signals = {
    /*
     * Master to Slave
     */
    .Fwv_Target_Mode = 0x00u,
    .Fwv_MoveEnable = false,
    .Fwv_Initial = false,
    .Fwv_ForcedDiag = false,
    .Fwv_Reserved1 = 0x00u,

    /*
     * Slave to Master
     */
    .Fwv_Actual_Mode = 0x00u,
    .Fwv_Position_Fault = false,
    .Fwv_FaultMode = false,
    .Fwv_ProtectMode = false,
    .Fwv_InitialSta = false,
    .Fwv_Calibration_Fail = false,
    .Fwv_MoveEnable_Status = false,
    .Fwv_Motor_Stall = false,
    .Fwv_Short_Circuit = false,
    .Fwv_Open_Circuit = false,
    .Fwv_Undervoltage = false,
    .Fwv_Overvoltage = false,
    .Fwv_Overcurrent = false,
    .Fwv_Overtemperature = false,
    .Fwv_Diag_Forced_Status = false,
    .Fwv_Position_Sensor_Fault = false,
    .Fwv_CommErr = false,
    .Fwv_SW_Version = 0x0000u,
    .Fwv_Stall_State = 0x00u
};

#endif /* LIN_SLAVE_API || LIN_MASTER_API */




/*-----------------------------------------------------------------------------
 * Interface specific part. LIN Slave API
 */

#if LIN_SLAVE_API == 1

/*-----------------------------------------------------------------------------
 * LIN Slave configuration
 */

#if SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012
/* Node Address for/by Diagnostics */
const l_u8 ml_InitialNAD = 0x01U; /* Node Address for Diagnostics */
l_u8 ml_ConfiguredNAD = 0x01U;

/* LIN Product Identification */
const l_u8 ml_ProductID[5] __attribute__((aligned(2))) = {
    0x00U,  /* SupplierID LSB */
    0x00U,  /* SupplierID MSB */
    0x00U,  /* FunctionID LSB */
    0x00U,  /* FunctionID MSB */
    0xffU   /* VariantID */
};
#endif /* SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012 */


#if ((SL_vLIN_2_1_plus || SL_vISO17987_2016) && (SL_HAS_SAVE_CONFIGURATION_SERVICE == 1)) || \
    ((SL_vLIN_2_x || SL_vISO17987_2016 || SL_vSAE_J2602_2012) && (SL_HAS_SAVE_CONFIGURATION_FUNCTIONS == 1))

/* Node configuration, stores PIDs corresponding to indices */
l_u8 node_configuration[SL_NUMBER_OF_DYNAMIC_MESSAGES];
#endif /* ((SL_vLIN_2_1_plus || SL_vISO17987_2016) && (SL_HAS_SAVE_CONFIGURATION_SERVICE == 1)) || \
          ((SL_vLIN_2_x || SL_vSAE_J2602_2012) && (SL_HAS_SAVE_CONFIGURATION_FUNCTIONS == 1)) */

/*-----------------------------------------------------------------------------
 * Flags
 */

volatile l_sl1_flags_t l_sl1_flags;

/*-----------------------------------------------------------------------------
 * Frame structures
 */

/*
 * Bit-field structures define signals layout for every frame
 * Type of the bit-field shall be selected according to
 * the size of the signal:
 *
 *   Type     Signal size
 *              (bits)
 * -------------------------------------------
 *   l_bool          1
 *   l_u8        2.. 8
 *   l_u16       9..16
 *   l_u32      17..32  (used only for gaps)
 *   l_u64      33..64  (used only for gaps)
 */

/*
 * Unconditional frame VPC_Fwv_Resp
 */
typedef struct ATTR_PACKED {
    l_u8 sig_Fwv_Actual_Mode  : 3;
    l_bool sig_Fwv_Position_Fault  : 1;
    l_bool sig_Fwv_FaultMode  : 1;
    l_bool sig_Fwv_ProtectMode  : 1;
    l_bool sig_Fwv_InitialSta  : 1;
    l_bool sig_Fwv_Calibration_Fail  : 1;
    l_bool sig_Fwv_MoveEnable_Status  : 1;
    l_bool sig_Fwv_Motor_Stall  : 1;
    l_bool sig_Fwv_Short_Circuit  : 1;
    l_bool sig_Fwv_Open_Circuit  : 1;
    l_bool sig_Fwv_Undervoltage  : 1;
    l_bool sig_Fwv_Overvoltage  : 1;
    l_bool sig_Fwv_Overcurrent  : 1;
    l_bool sig_Fwv_Overtemperature  : 1;
    l_bool sig_Fwv_Diag_Forced_Status  : 1;
    l_bool sig_Fwv_Position_Sensor_Fault  : 1;
    l_bool sig_Fwv_CommErr  : 1;
    l_u8 unused19  : 5;
    l_u16 sig_Fwv_SW_Version  : 16;
    l_u8 sig_Fwv_Stall_State  : 2;
    l_u8 unused42  : 6;
    l_u8 unused48  : 8;
    l_u8 unused56  : 8;
} l_sl1_VPC_Fwv_Resp_data_t;
ASSERT(sizeof(l_sl1_VPC_Fwv_Resp_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_VPC_Fwv_Resp_handler (l_s_FrameAction_t frameAction)
{
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    static const l_sl1_flags_t VPC_Fwv_Resp_flags_mask = {{0xe0, 0xff, 0xff, 0x1}};

    switch (frameAction) {
        case sfa_FillBuffer:    /* For S2M frames */
        {
            /* Freeze the volatile Signal values */
            l_u8 sig_Fwv_Actual_Mode = l_signals.Fwv_Actual_Mode;
            l_bool sig_Fwv_Position_Fault = l_signals.Fwv_Position_Fault;
            l_bool sig_Fwv_FaultMode = l_signals.Fwv_FaultMode;
            l_bool sig_Fwv_ProtectMode = l_signals.Fwv_ProtectMode;
            l_bool sig_Fwv_InitialSta = l_signals.Fwv_InitialSta;
            l_bool sig_Fwv_Calibration_Fail = l_signals.Fwv_Calibration_Fail;
            l_bool sig_Fwv_MoveEnable_Status = l_signals.Fwv_MoveEnable_Status;
            l_bool sig_Fwv_Motor_Stall = l_signals.Fwv_Motor_Stall;
            l_bool sig_Fwv_Short_Circuit = l_signals.Fwv_Short_Circuit;
            l_bool sig_Fwv_Open_Circuit = l_signals.Fwv_Open_Circuit;
            l_bool sig_Fwv_Undervoltage = l_signals.Fwv_Undervoltage;
            l_bool sig_Fwv_Overvoltage = l_signals.Fwv_Overvoltage;
            l_bool sig_Fwv_Overcurrent = l_signals.Fwv_Overcurrent;
            l_bool sig_Fwv_Overtemperature = l_signals.Fwv_Overtemperature;
            l_bool sig_Fwv_Diag_Forced_Status = l_signals.Fwv_Diag_Forced_Status;
            l_bool sig_Fwv_Position_Sensor_Fault = l_signals.Fwv_Position_Sensor_Fault;
            l_bool sig_Fwv_CommErr = l_signals.Fwv_CommErr;
            l_u16 sig_Fwv_SW_Version = l_signals.Fwv_SW_Version;
            l_u8 sig_Fwv_Stall_State = l_signals.Fwv_Stall_State;

            l_sl1_VPC_Fwv_Resp_data_t VPC_Fwv_Resp_data = {
                sig_Fwv_Actual_Mode,
                sig_Fwv_Position_Fault,
                sig_Fwv_FaultMode,
                sig_Fwv_ProtectMode,
                sig_Fwv_InitialSta,
                sig_Fwv_Calibration_Fail,
                sig_Fwv_MoveEnable_Status,
                sig_Fwv_Motor_Stall,
                sig_Fwv_Short_Circuit,
                sig_Fwv_Open_Circuit,
                sig_Fwv_Undervoltage,
                sig_Fwv_Overvoltage,
                sig_Fwv_Overcurrent,
                sig_Fwv_Overtemperature,
                sig_Fwv_Diag_Forced_Status,
                sig_Fwv_Position_Sensor_Fault,
                sig_Fwv_CommErr,
                0x1f,
                sig_Fwv_SW_Version,
                sig_Fwv_Stall_State,
                0x3f,
                0xff,
                0xff
            };
            l_FillBufferSlave((l_u8*)&VPC_Fwv_Resp_data, (l_u8)sizeof(l_sl1_VPC_Fwv_Resp_data_t));
            break;
        }
        case sfa_UpdateSignals:     /* For M2S frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&VPC_Fwv_Resp_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
            break;
        }
        case sfa_CheckFlags:    /* Only for frames associated with an Event-triggered frame */
        default:
            retVal = sfhs_Fail;
            break;
    }
    return retVal;
}

static const l_s_UnconditionalFrame_t l_sl1_VPC_Fwv_Resp_frame = {l_sl1_VPC_Fwv_Resp_handler};

/*
 * Unconditional frame VPC_Fwv_Ctrl
 */
typedef struct ATTR_PACKED {
    l_u8 sig_Fwv_Target_Mode  : 3;
    l_bool sig_Fwv_MoveEnable  : 1;
    l_bool sig_Fwv_Initial  : 1;
    l_bool sig_Fwv_ForcedDiag  : 1;
    l_u8 unused6  : 2;
    l_u8 sig_Fwv_Reserved1  : 8;
    l_u8 unused16  : 8;
    l_u8 unused24  : 8;
    l_u8 unused32  : 8;
    l_u8 unused40  : 8;
    l_u8 unused48  : 8;
    l_u8 unused56  : 8;
} l_sl1_VPC_Fwv_Ctrl_data_t;
ASSERT(sizeof(l_sl1_VPC_Fwv_Ctrl_data_t) == 8);

static l_s_FrameHandlerStatus_t l_sl1_VPC_Fwv_Ctrl_handler (l_s_FrameAction_t frameAction)
{
    l_s_FrameHandlerStatus_t retVal = sfhs_Success;
    static const l_sl1_flags_t VPC_Fwv_Ctrl_flags_mask = {{0x1f, 0x0, 0x0, 0x2}};

    switch (frameAction) {
        case sfa_UpdateSignals:    /* For M2S frames */
        {
            l_sl1_VPC_Fwv_Ctrl_data_t MLXCOMP_354_WA *VPC_Fwv_Ctrl_data = (l_sl1_VPC_Fwv_Ctrl_data_t*)ML_SLAVE_FRAME_DATA_BUFFER;
            l_signals.Fwv_Target_Mode = VPC_Fwv_Ctrl_data->sig_Fwv_Target_Mode;
            l_signals.Fwv_MoveEnable = VPC_Fwv_Ctrl_data->sig_Fwv_MoveEnable;
            l_signals.Fwv_Initial = VPC_Fwv_Ctrl_data->sig_Fwv_Initial;
            l_signals.Fwv_ForcedDiag = VPC_Fwv_Ctrl_data->sig_Fwv_ForcedDiag;
            l_signals.Fwv_Reserved1 = VPC_Fwv_Ctrl_data->sig_Fwv_Reserved1;
            break;
        }
        case sfa_FillBuffer:    /* For S2M frames */
        case sfa_SetFlags:
        {
            l_SetFlagsMask((volatile l_u8*)&l_sl1_flags, (const l_u8*)&VPC_Fwv_Ctrl_flags_mask, (l_u8)sizeof(l_sl1_flags_t));
            break;
        }
        case sfa_CheckFlags:    /* Only for frames associated with an Event-triggered frame */
        default:
            retVal = sfhs_Fail;
            break;
    }
    return retVal;
}

static const l_s_UnconditionalFrame_t l_sl1_VPC_Fwv_Ctrl_frame = {l_sl1_VPC_Fwv_Ctrl_handler};


/*-----------------------------------------------------------------------------
 * Frame tables
 */
const l_s_Frame_t frameList [SL_NUMBER_OF_DYNAMIC_MESSAGES] = {
    {sft_UnconditionalFrame, (l_s_UnconditionalFrame_t *)&l_sl1_VPC_Fwv_Resp_frame},
    {sft_UnconditionalFrame, (l_s_UnconditionalFrame_t *)&l_sl1_VPC_Fwv_Ctrl_frame}
};

#if SL_vLIN_2_0 || SL_vSAE_J2602_2012
/*
 * LIN 2.0 message identifier list
 */
const l_u16 MID_list[SL_NUMBER_OF_DYNAMIC_MESSAGES] = {
        0x0U,
        0x1U
};
#endif /* SL_vLIN_2_0 || SL_vSAE_J2602_2012 */

#endif /* LIN_SLAVE_API */

/* EOF */
