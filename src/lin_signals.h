/**
 ******************************************************************************
 * @file    lin_signals.h
 * @brief   LDF dependent LIN API
 ******************************************************************************
 * @copyright (C) 2025 Melexis N.V. All rights reserved.
 * @internal
 * Melexis N.V. is supplying this software for use with Melexis N.V.
 * processor based microcontrollers only.
 *
 * This file is application specific and depends on LDF/NCF file VPC_Fwv_LDF.ldf.
 * Generated by configuration tool lin-nodegen (version 2.2.dev0+g5878c6b.d20210701) for node  VPC_Fwv_Slave.
 *
 * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
 * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
 * MELEXIS N.V. SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL,
 * INCIDENTAL, OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 * @endinternal
 *
 * @details The file provides LDF-file specific functionality:
 *              - variables declaration for signals
 *              - flag variables declaration for signals
 *              - flag variables declaration for frames (optional)
 *              - flag variables declaration for signals inside specific frame (optional)
 *              - frames structure describing
 *              - frames handler functions to pack the signals inside frames and to provide signal specific frame action
 *              - schedule tables declaration
 *
 * @ingroup lin_api
 *
 */

/* Multiple inclusion of the file is allowed to know the following configuration
 * definitions from LIN Nodegen */
#ifndef LIN_MASTER_API
#define LIN_MASTER_API  0
#endif

#ifndef LIN_SLAVE_API
#define LIN_SLAVE_API  1
#endif

/* Include the rest of the file only when required general LIN API definition
 * are included first */
#if defined(LIN_API_GENERAL_DEFS)

/* After that, enable the header guard  */
#ifndef LIN_SIGNALS_H
#define LIN_SIGNALS_H


/*-----------------------------------------------------------------------------
 * Common signals for both Slave & Master APIs
 */

#if (LIN_SLAVE_API == 1) || (LIN_MASTER_API == 1)

/*
 * Templates to generate function prototypes
 */

/* Template to generate read/write signal function prototypes */
#define L_SIGNAL(sigType, sigName)                                              \
    /** @name The signal "sigName" interaction */                               \
    /** Reads and returns the current value of the "sigName" signal.
       @return signal value */                                                  \
    static __inline__ sigType sigType ## _rd_ ## sigName(void);                 \
    static __inline__ sigType sigType ## _rd_ ## sigName(void)                  \
    {                                                                           \
        sigType s = l_signals.sigName;                                          \
        return s;                                                               \
    }                                                                           \
                                                                                \
    /** Sets the new value of the "sigName" signal.
       @param[in] v new value
       @return void */                                                          \
    static __inline__ void sigType ## _wr_ ## sigName(sigType v);               \
    static __inline__ void sigType ## _wr_ ## sigName(sigType v)                \
    {                                                                           \
        l_signals.sigName = v;                                                  \
    }                                                                           \
    /**@}*/

/* Template to generate 'l_flg_tst' and 'l_flg_clr' function prototypes */
#define L_FLAGS(bufName, flagName, flagType, baseName)                          \
    /** @name The flagType "baseName" flag interaction */                       \
    /** Returns a C boolean indicating the current state of the flagType "baseName" flag.
       @return [l_bool]:
       - zero - cleared;
       - non-zero - set. */                                                     \
    static __inline__ l_bool l_flg_tst_ ## flagName(void);                      \
    static __inline__ l_bool l_flg_tst_ ## flagName(void)                       \
    {                                                                           \
        l_bool s = bufName.flagName;                                            \
        return s;                                                               \
    }                                                                           \
                                                                                \
    /** Sets the current value of the flag specified by the flagType "baseName" to zero.
       @return void */                                                          \
    static __inline__ void l_flg_clr_ ## flagName(void);                        \
    static __inline__ void l_flg_clr_ ## flagName(void)                         \
    {                                                                           \
        l_irqmask m;                                                            \
        m = l_sys_irq_disable();                                                \
        bufName.flagName = false;                                               \
        l_sys_irq_restore (m);                                                  \
    }                                                                           \
    /**@}*/

/* Template to generate 'l_bytes_rd_sss' and 'l_bytes_wr_sss' function prototypes */
#define L_BYTES(sigName)                                                        \
    /** @name The signal "sigName" interaction */                               \
    /** Reads and returns the current values of the selected bytes in the "sigName" signal.
       @param[in] start  first byte to read from
       @param[in] count  number of bytes to read
       @param[out] data  where data will be written
       @return void */                                                          \
    static __inline__ void l_bytes_rd_ ## sigName (l_u8 start, l_u8 count, l_u8 *const data);   \
    static __inline__ void l_bytes_rd_ ## sigName (l_u8 start, l_u8 count, l_u8 *const data)    \
    {                                                                           \
        l_irqmask m;                                                            \
        l_u8 volatile *src;                                                     \
        l_u8 *dest;                                                             \
                                                                                \
        m = l_sys_irq_disable();                                                \
        src  = &l_signals.sigName[start];                                       \
        dest = data;                                                            \
        while (count-- != 0U) {                                                 \
            *dest++ = *src++;                                                   \
        }                                                                       \
        l_sys_irq_restore (m);                                                  \
    }                                                                           \
                                                                                \
    /** Sets the current value of the "sigName" signal.
       @param[in] start  first byte to write to
       @param[in] count  number of bytes to write
       @param[out] data  where data is read from
       @return void */                                                          \
    static __inline__ void l_bytes_wr_ ## sigName (l_u8 start, l_u8 count, l_u8 const *const data); \
    static __inline__ void l_bytes_wr_ ## sigName (l_u8 start, l_u8 count, l_u8 const *const data)  \
    {                                                                           \
        l_irqmask m;                                                            \
        l_u8 const *src;                                                        \
        l_u8 volatile *dest;                                                    \
                                                                                \
        m = l_sys_irq_disable();                                                \
        src  = data;                                                            \
        dest = &l_signals.sigName[start];                                       \
        while (count-- != 0U) {                                                 \
            *dest++ = *src++;                                                   \
        }                                                                       \
        l_sys_irq_restore (m);                                                  \
    }                                                                           \
    /**@}*/

/*
 * Externals
 */

typedef struct {
    l_u8 Fwv_Target_Mode;
    l_bool Fwv_MoveEnable;
    l_bool Fwv_Initial;
    l_bool Fwv_ForcedDiag;
    l_u8 Fwv_Reserved1;
    l_u8 Fwv_Actual_Mode;
    l_bool Fwv_Position_Fault;
    l_bool Fwv_FaultMode;
    l_bool Fwv_ProtectMode;
    l_bool Fwv_InitialSta;
    l_bool Fwv_Calibration_Fail;
    l_bool Fwv_MoveEnable_Status;
    l_bool Fwv_Motor_Stall;
    l_bool Fwv_Short_Circuit;
    l_bool Fwv_Open_Circuit;
    l_bool Fwv_Undervoltage;
    l_bool Fwv_Overvoltage;
    l_bool Fwv_Overcurrent;
    l_bool Fwv_Overtemperature;
    l_bool Fwv_Diag_Forced_Status;
    l_bool Fwv_Position_Sensor_Fault;
    l_bool Fwv_CommErr;
    l_u16 Fwv_SW_Version;
    l_u8 Fwv_Stall_State;
} l_signals_t;

extern volatile l_signals_t l_signals;

/*
 * Define API functions using templates
 */

L_SIGNAL(l_u8, Fwv_Target_Mode)
L_SIGNAL(l_bool, Fwv_MoveEnable)
L_SIGNAL(l_bool, Fwv_Initial)
L_SIGNAL(l_bool, Fwv_ForcedDiag)
L_SIGNAL(l_u8, Fwv_Reserved1)
L_SIGNAL(l_u8, Fwv_Actual_Mode)
L_SIGNAL(l_bool, Fwv_Position_Fault)
L_SIGNAL(l_bool, Fwv_FaultMode)
L_SIGNAL(l_bool, Fwv_ProtectMode)
L_SIGNAL(l_bool, Fwv_InitialSta)
L_SIGNAL(l_bool, Fwv_Calibration_Fail)
L_SIGNAL(l_bool, Fwv_MoveEnable_Status)
L_SIGNAL(l_bool, Fwv_Motor_Stall)
L_SIGNAL(l_bool, Fwv_Short_Circuit)
L_SIGNAL(l_bool, Fwv_Open_Circuit)
L_SIGNAL(l_bool, Fwv_Undervoltage)
L_SIGNAL(l_bool, Fwv_Overvoltage)
L_SIGNAL(l_bool, Fwv_Overcurrent)
L_SIGNAL(l_bool, Fwv_Overtemperature)
L_SIGNAL(l_bool, Fwv_Diag_Forced_Status)
L_SIGNAL(l_bool, Fwv_Position_Sensor_Fault)
L_SIGNAL(l_bool, Fwv_CommErr)
L_SIGNAL(l_u16, Fwv_SW_Version)
L_SIGNAL(l_u8, Fwv_Stall_State)

#endif /* LIN_SLAVE_API || LIN_MASTER_API */




/*-----------------------------------------------------------------------------
 * Interface specific part. LIN Slave API
 */

#if LIN_SLAVE_API == 1

/** @name LIN Slave baudrate selection [baud] */
#ifndef SL_LIN_BAUDRATE
#define SL_LIN_BAUDRATE                         19200
#endif
/**@}*/

/** @name LIN Slave autobaudrate mode:
 * - 0: Fixed;
 * - 1: Auto on first frame;
 * - 2: Auto on each frame
 */
#ifndef SL_LIN_AUTOBAUDRATE_MODE
#define SL_LIN_AUTOBAUDRATE_MODE                1
#endif
/**@}*/

/** @name Select LIN Slave API standard version */

/** LIN Slave API standard
 * - LIN_1_3
 * - LIN_2_0
 * - LIN_2_1
 * - LIN_2_2
 * - SAE_J2602_2012
 * - ISO_17987_2016
 */
#ifndef SL_API_VERSION
#define SL_API_VERSION                          LIN_2_2
#endif

/** Helper macro for Slave versions */
#define SL_vLIN_1_3 vLIN_1_3(SL)
#define SL_vLIN_2_0 vLIN_2_0(SL)
#define SL_vLIN_2_1 vLIN_2_1(SL)
#define SL_vLIN_2_2 vLIN_2_2(SL)
#define SL_vSAE_J2602_2012 vSAE_J2602_2012(SL)
#define SL_vISO17987_2016 vISO_17987_2016(SL)

#define SL_vLIN_2_x vLIN_2_x(SL)
#define SL_vLIN_2_1_plus vLIN_2_1_plus(SL)
/**@}*/

/** @name Switches for Slave options and services:
 * - 0: disabled
 * - 1: enabled
 */

#if !SL_vSAE_J2602_2012
#ifndef SL_HAS_EVENT_TRIGGERED_FRAMES
#define SL_HAS_EVENT_TRIGGERED_FRAMES           0    /**< Event-triggered frames support */
#endif
#endif /* !SL_vSAE_J2602_2012 */

#if !SL_vLIN_1_3
#if SL_vLIN_2_0 || SL_vSAE_J2602_2012

#ifndef SL_HAS_SAVE_CONFIGURATION_FUNCTIONS
#define SL_HAS_SAVE_CONFIGURATION_FUNCTIONS     0    /**< Save Configuration functions */
#endif

#ifndef SL_HAS_ASSIGN_FRAME_ID_SERVICE
#define SL_HAS_ASSIGN_FRAME_ID_SERVICE          0    /**< Assign FrameId service */
#endif

#endif /* SL_vLIN_2_0 || SL_vSAE_J2602_2012 */

#if SL_vLIN_2_1_plus || SL_vISO17987_2016
#ifndef SL_HAS_SAVE_CONFIGURATION_SERVICE
#define SL_HAS_SAVE_CONFIGURATION_SERVICE       1    /**< Save Configuration service */
#endif
#endif /* SL_vLIN_2_1_plus || SL_vISO17987_2016 */

#ifndef SL_HAS_SERIAL_NUMBER_CALLOUT
#define SL_HAS_SERIAL_NUMBER_CALLOUT            1    /**< Read by Identifier (1) support */
#endif

#ifndef SL_HAS_CONDITIONAL_CHANGE_NAD_SERVICE
#define SL_HAS_CONDITIONAL_CHANGE_NAD_SERVICE   0    /**< Conditional NAD change service */
#endif

#ifndef SL_HAS_ASSIGN_NAD_SERVICE
#define SL_HAS_ASSIGN_NAD_SERVICE               1    /**< Assign NAD service */
#endif

#ifndef SL_HAS_READ_BY_ID_CALLOUT
#define SL_HAS_READ_BY_ID_CALLOUT               1    /**< Read by Identifier (all others) support */
#endif

#ifndef SL_HAS_READ_BY_ID_SERVICE
#define SL_HAS_READ_BY_ID_SERVICE               1    /**< Read by Identifier services */
#endif

#if SL_vISO17987_2016
#ifndef SL_HAS_READ_BY_ID_BIT_TIMING_TEST
#define SL_HAS_READ_BY_ID_BIT_TIMING_TEST       0    /**< Read by Identifier (2) service */
#endif

#ifndef SL_HAS_NCF_LDF_VERSION
#define SL_HAS_NCF_LDF_VERSION                  0    /**< Read by Identifier (3) service */
#endif
#endif /* SL_vISO17987_2016 */

/* TODO: To remove or keep for compatibility */
#ifndef SL_HAS_UNKNOWN_DIAG_CALLOUT
#define SL_HAS_UNKNOWN_DIAG_CALLOUT             1    /**< Diagnostic callout with user-data support */
#endif
#endif /* !SL_vLIN_1_3 */
/**@}*/

/** @name Definitions of N_As and N_Cr timeout values */
#if SL_vLIN_2_1_plus || SL_vISO17987_2016
#define SL_LD_N_AS_TIMEOUT  1000U /* ms */
#define SL_LD_N_CR_TIMEOUT  1000U /* ms */
#endif /* SL_vLIN_2_1_plus || SL_vISO17987_2016 */
/**@}*/

/** @name Number of dynamic messages */
#ifndef SL_NUMBER_OF_DYNAMIC_MESSAGES
#define SL_NUMBER_OF_DYNAMIC_MESSAGES   2U
#endif
/**@}*/

/** @name Initializer for use with static (pre-)configuration
 * Contains configured_NAD + Protected ID for each message index
 */
#define SL_NODE_CONFIGURATION_INITIALIZER { 0x1U /* configured NAD */, 0x92U, 0x11U }
/**@}*/

/** @name Standard response error interaction functions used by LIN Slave API */
#if !SL_vLIN_1_3 && !SL_vSAE_J2602_2012
#define l_flg_clr_response_error()  ( l_flg_clr_s_Fwv_CommErr() )
#define l_flg_tst_response_error()  ( l_flg_tst_s_Fwv_CommErr() )
#define l_bool_wr_response_error(isError)  ( l_bool_wr_Fwv_CommErr(isError) )
#define l_bool_rd_response_error()  ( l_bool_rd_Fwv_CommErr() )
#endif /* !SL_vLIN_1_3 && !SL_vSAE_J2602_2012 */
/**@}*/


/*
 * Externals
 */

typedef struct ATTR_PACKED {
    /* Signals */
    /* byte 1 */
    l_bool s_Fwv_Target_Mode : 1;
    l_bool s_Fwv_MoveEnable : 1;
    l_bool s_Fwv_Initial : 1;
    l_bool s_Fwv_ForcedDiag : 1;
    l_bool s_Fwv_Reserved1 : 1;
    l_bool s_Fwv_Actual_Mode : 1;
    l_bool s_Fwv_Position_Fault : 1;
    l_bool s_Fwv_FaultMode : 1;
    /* byte 2 */
    l_bool s_Fwv_ProtectMode : 1;
    l_bool s_Fwv_InitialSta : 1;
    l_bool s_Fwv_Calibration_Fail : 1;
    l_bool s_Fwv_MoveEnable_Status : 1;
    l_bool s_Fwv_Motor_Stall : 1;
    l_bool s_Fwv_Short_Circuit : 1;
    l_bool s_Fwv_Open_Circuit : 1;
    l_bool s_Fwv_Undervoltage : 1;
    /* byte 3 */
    l_bool s_Fwv_Overvoltage : 1;
    l_bool s_Fwv_Overcurrent : 1;
    l_bool s_Fwv_Overtemperature : 1;
    l_bool s_Fwv_Diag_Forced_Status : 1;
    l_bool s_Fwv_Position_Sensor_Fault : 1;
    l_bool s_Fwv_CommErr : 1;
    l_bool s_Fwv_SW_Version : 1;
    l_bool s_Fwv_Stall_State : 1;
    /* byte 4 */

    /* Frames */
    l_bool f_VPC_Fwv_Resp : 1;
    l_bool f_VPC_Fwv_Ctrl : 1;
    l_bool unused_0 : 1;
    l_bool unused_1 : 1;
    l_bool unused_2 : 1;
    l_bool unused_3 : 1;
    l_bool unused_4 : 1;
    l_bool unused_5 : 1;
} l_sl1_mapped_flags_t;
ASSERT(sizeof(l_sl1_mapped_flags_t) == 4);

typedef union {
    l_u8 bytes[sizeof(l_sl1_mapped_flags_t)];
    l_sl1_mapped_flags_t mapped;
} l_sl1_flags_t;

extern volatile l_sl1_flags_t l_sl1_flags;

/*
 * Interface specific flags
 */

L_FLAGS(l_sl1_flags.mapped, s_Fwv_Target_Mode, signal, Fwv_Target_Mode)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_MoveEnable, signal, Fwv_MoveEnable)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Initial, signal, Fwv_Initial)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_ForcedDiag, signal, Fwv_ForcedDiag)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Reserved1, signal, Fwv_Reserved1)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Actual_Mode, signal, Fwv_Actual_Mode)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Position_Fault, signal, Fwv_Position_Fault)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_FaultMode, signal, Fwv_FaultMode)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_ProtectMode, signal, Fwv_ProtectMode)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_InitialSta, signal, Fwv_InitialSta)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Calibration_Fail, signal, Fwv_Calibration_Fail)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_MoveEnable_Status, signal, Fwv_MoveEnable_Status)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Motor_Stall, signal, Fwv_Motor_Stall)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Short_Circuit, signal, Fwv_Short_Circuit)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Open_Circuit, signal, Fwv_Open_Circuit)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Undervoltage, signal, Fwv_Undervoltage)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Overvoltage, signal, Fwv_Overvoltage)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Overcurrent, signal, Fwv_Overcurrent)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Overtemperature, signal, Fwv_Overtemperature)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Diag_Forced_Status, signal, Fwv_Diag_Forced_Status)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Position_Sensor_Fault, signal, Fwv_Position_Sensor_Fault)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_CommErr, signal, Fwv_CommErr)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_SW_Version, signal, Fwv_SW_Version)
L_FLAGS(l_sl1_flags.mapped, s_Fwv_Stall_State, signal, Fwv_Stall_State)

L_FLAGS(l_sl1_flags.mapped, f_VPC_Fwv_Resp, frame, VPC_Fwv_Resp)
L_FLAGS(l_sl1_flags.mapped, f_VPC_Fwv_Ctrl, frame, VPC_Fwv_Ctrl)

#endif /* LIN_SLAVE_API */

#endif /* LIN_SIGNALS_H */
#endif /* LIN_API_GENERAL_DEFS */
/* EOF */


