/**
 * @file
 * @brief EEPROM definition file
 * @internal
 *
 * @copyright (C) 2020 Melexis N.V.
 * git flash edb9c687
 *
 * Melexis N.V. is supplying this code for use with Melexis N.V. processor based microcontrollers only.
 *
 * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY,
 * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.  MELEXIS N.V. SHALL NOT IN ANY CIRCUMSTANCES,
 * BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * @endinternal
 *
 * @details
 * This file was autogenerated. The information of the source is described below:
 * Tag: 1.90
 * This file was autogenerated. The information of the source is described below:
 * Tag: 1.8
 * Automatic generation by MlxCCT 1.24
 * Template version 2.0.3
 *
 * File sections:
 * 1 General for use macros
 * 2 Auxillary macros
 * 3 EEPROM declarations:
 * 3.1 Hosting variables
 * 3.2 Get macros
 * 3.3 Variables
 * 3.4 Dummy ports
 * 4 Summary
 */

#ifndef EEPROM_PARAMETERS_H
#define EEPROM_PARAMETERS_H

#include <stdint.h>
#include "memory_map.h"

/*****************************************************************************/
/* 1. General macros. */

/** Getter for EE parameter
 *
 * Get an EEPROM bit field.
 * @param FIELD the field to read.
 */

#ifndef EE_GET
#define EE_GET(FIELD) EE_ ## FIELD ## _GET ()
#endif

/** Setter for EE parameter

 * Set one or multiple EEPROM bit fields to some values. The number of fields set
 * has to be one or more, maximum 16.
 *
 * Usage:
 * \li EE_SET(FIELD1, VALUE1) <br>
 * \li EE_SET(FIELD1, VALUE1, FIELD2, VALUE2, ..., FIELD16, VALUE16) <br>
 *
 * where FIELDx, is the field to set, and VALUEx, is the value of the field to set (should be in the valid range).
 *
 * @note In most cases this can only be used for unit testing, as the EEPROM is not always writable and variables
 * are declared to be constant.
 * @param ... Alternating sequence of FIELDx and VALUEx pairs, see above example
 */
#ifndef EE_SET
#define EE_SET(...) \
    CCT_EE_SET (__VA_ARGS__, \
        DUMMY2,  0U, DUMMY3,  0U, DUMMY4,  0U, DUMMY5,  0U,  DUMMY6, 0U, \
        DUMMY7,  0U, DUMMY8,  0U, DUMMY9,  0U, DUMMY10, 0U, DUMMY11, 0U, \
        DUMMY12, 0U, DUMMY13, 0U, DUMMY14, 0U, DUMMY15, 0U, DUMMY16, 0U, \
        DUMMY17, 0U)
#endif

/*****************************************************************************/
/* 2. Auxillary (helper) macros. */
/* These macros are subject to change without notice! */

/* TODO: Optimize to always setb/clrb. */

#define CCT_EE_SET(\
        F1,  V1,  F2,  V2,  F3,  V3,  F4,  V4,  F5,  V5,  F6,  V6,  \
        F7,  V7,  F8,  V8,  F9,  V9,  F10, V10, F11, V11, F12, V12, \
        F13, V13, F14, V14, F15, V15, F16, V16, F17, V17, \
        ...) \
    if (EE_BIT_ACCESSIBLE (\
                           F1,  F2,  F3,  F4,  F5,  F6,  F7,  F8,  \
                           F9, F10, F11, F12, F13, F14, F15, F16)) \
    { \
        if (EE_BIT_ACCESSIBLE (F1)) { \
            if (V1) EE_HOST (F1) |=  EE_MASK (F1); \
            else    EE_HOST (F1) &= ~EE_MASK (F1); \
        } \
        if (!EE_DUMMY (F2) && EE_BIT_ACCESSIBLE (F2)) { \
            if (V2) EE_HOST (F2) |=  EE_MASK (F2); \
            else    EE_HOST (F2) &= ~EE_MASK (F2); \
        } \
        if (!EE_DUMMY (F3) && EE_BIT_ACCESSIBLE (F3)) { \
            if (V3) EE_HOST (F3) |=  EE_MASK (F3); \
            else    EE_HOST (F3) &= ~EE_MASK (F3); \
        } \
        if (!EE_DUMMY (F4) && EE_BIT_ACCESSIBLE (F4)) { \
            if (V4) EE_HOST (F4) |=  EE_MASK (F4); \
            else    EE_HOST (F4) &= ~EE_MASK (F4); \
        } \
        if (!EE_DUMMY (F5) && EE_BIT_ACCESSIBLE (F5)) { \
            if (V5) EE_HOST (F5) |=  EE_MASK (F5); \
            else    EE_HOST (F5) &= ~EE_MASK (F5); \
        } \
        if (!EE_DUMMY (F6) && EE_BIT_ACCESSIBLE (F6)) { \
            if (V6) EE_HOST (F6) |=  EE_MASK (F6); \
            else    EE_HOST (F6) &= ~EE_MASK (F6); \
        } \
        if (!EE_DUMMY (F7) && EE_BIT_ACCESSIBLE (F7)) { \
            if (V7) EE_HOST (F7) |=  EE_MASK (F7); \
            else    EE_HOST (F7) &= ~EE_MASK (F7); \
        } \
        if (!EE_DUMMY (F8) && EE_BIT_ACCESSIBLE (F8)) { \
            if (V8) EE_HOST (F8) |=  EE_MASK (F8); \
            else    EE_HOST (F8) &= ~EE_MASK (F8); \
        } \
        if (!EE_DUMMY (F9) && EE_BIT_ACCESSIBLE (F9)) { \
            if (V9) EE_HOST (F9) |=  EE_MASK (F9); \
            else    EE_HOST (F9) &= ~EE_MASK (F9); \
        } \
        if (!EE_DUMMY (F10) && EE_BIT_ACCESSIBLE (F10)) { \
            if (V10) EE_HOST (F10) |=  EE_MASK (F10); \
            else    EE_HOST (F10) &= ~EE_MASK (F10); \
        } \
        if (!EE_DUMMY (F11) && EE_BIT_ACCESSIBLE (F11)) { \
            if (V11) EE_HOST (F11) |=  EE_MASK (F11); \
            else    EE_HOST (F11) &= ~EE_MASK (F11); \
        } \
        if (!EE_DUMMY (F12) && EE_BIT_ACCESSIBLE (F12)) { \
            if (V12) EE_HOST (F12) |=  EE_MASK (F12); \
            else    EE_HOST (F12) &= ~EE_MASK (F12); \
        } \
        if (!EE_DUMMY (F13) && EE_BIT_ACCESSIBLE (F13)) { \
            if (V13) EE_HOST (F13) |=  EE_MASK (F13); \
            else    EE_HOST (F13) &= ~EE_MASK (F13); \
        } \
        if (!EE_DUMMY (F14) && EE_BIT_ACCESSIBLE (F14)) { \
            if (V14) EE_HOST (F14) |=  EE_MASK (F14); \
            else    EE_HOST (F14) &= ~EE_MASK (F14); \
        } \
        if (!EE_DUMMY (F15) && EE_BIT_ACCESSIBLE (F15)) { \
            if (V15) EE_HOST (F15) |=  EE_MASK (F15); \
            else    EE_HOST (F15) &= ~EE_MASK (F15); \
        } \
        if (!EE_DUMMY (F16) && EE_BIT_ACCESSIBLE (F16)) { \
            if (V16) EE_HOST (F16) |=  EE_MASK (F16); \
            else    EE_HOST (F16) &= ~EE_MASK (F16); \
        } \
    } \
    else if ((EE_HOST_UNUSED (F1) | EE_MASK (\
                    F1, F2, F3, F4, F5, F6, F7, F8, \
                    F9, F10, F11, F12, F13, F14, F15, F16)) == 0xFFFFU) {\
        EE_HOST (F1) = \
          ((V1 ) << EE_OFFSET (F1 )) | ((V2 ) << EE_OFFSET (F2 ))\
        | ((V3 ) << EE_OFFSET (F3 )) | ((V4 ) << EE_OFFSET (F4 ))\
        | ((V5 ) << EE_OFFSET (F5 )) | ((V6 ) << EE_OFFSET (F6 ))\
        | ((V7 ) << EE_OFFSET (F7 )) | ((V8 ) << EE_OFFSET (F8 ))\
        | ((V9 ) << EE_OFFSET (F9 )) | ((V10) << EE_OFFSET (F10))\
        | ((V11) << EE_OFFSET (F11)) | ((V12) << EE_OFFSET (F12))\
        | ((V13) << EE_OFFSET (F13)) | ((V14) << EE_OFFSET (F14))\
        | ((V15) << EE_OFFSET (F15)) | ((V16) << EE_OFFSET (F16))\
            ; \
    } \
    else { \
        EE_HOST (F1) = (EE_HOST (F1) \
            & ~EE_MASK (\
                    F1, F2, F3, F4, F5, F6, F7, F8,   \
                    F9, F10, F11, F12, F13, F14, F15, F16)) \
        | ((V1 ) << EE_OFFSET (F1 )) | ((V2 ) << EE_OFFSET (F2 ))\
        | ((V3 ) << EE_OFFSET (F3 )) | ((V4 ) << EE_OFFSET (F4 ))\
        | ((V5 ) << EE_OFFSET (F5 )) | ((V6 ) << EE_OFFSET (F6 ))\
        | ((V7 ) << EE_OFFSET (F7 )) | ((V8 ) << EE_OFFSET (F8 ))\
        | ((V9 ) << EE_OFFSET (F9 )) | ((V10) << EE_OFFSET (F10))\
        | ((V11) << EE_OFFSET (F11)) | ((V12) << EE_OFFSET (F12))\
        | ((V13) << EE_OFFSET (F13)) | ((V14) << EE_OFFSET (F14))\
        | ((V15) << EE_OFFSET (F15)) | ((V16) << EE_OFFSET (F16))\
            ; \
    } \
    EE_ASSERT_WRITABLES (\
            F1, F2, F3, F4, F5, F6, F7, F8, \
            F9, F10, F11, F12, F13, F14, F15, F16); \
    EE_ASSERT_SAME_HOST (\
            F1, F2, F3, F4, F5, F6, F7, F8, \
            F9, F10, F11, F12, F13, F14, F15, F16); \
    EE_ASSERT_ARGS_FIT  (\
            F1, F2, F3, F4, F5, F6, F7, F8, \
            F9, F10, F11, F12, F13, F14, F15, F16, F17);

/** Return a dereferenced pointer to the address where a given field resides.
 *
 * @param FIELD Field to retrieve the information for
 */
#define EE_HOST(FIELD)  CCT_EE_HOST2 (EE_ ## FIELD)
#define CCT_EE_HOST2(F)   CCT_EE_HOST3 (F)
#define CCT_EE_HOST3(...) CCT_EE_HOST4 (__VA_ARGS__)
#define CCT_EE_HOST4(H, A, BA, M, O, W, B, U) (H)

/** Return the word address where the given field resides.
 *
 * @param FIELD Field to retrieve the information for
 */
#define EE_ADDRESS(FIELD)  CCT_EE_ADDRESS2 (EE_ ## FIELD)
#define CCT_EE_ADDRESS2(F)   CCT_EE_ADDRESS3 (F)
#define CCT_EE_ADDRESS3(...) CCT_EE_ADDRESS4 (__VA_ARGS__)
#define CCT_EE_ADDRESS4(H, A, BA, M, O, W, B, U) (A)

/** Return the byte address where the given field resides.
 *
 * @param FIELD Field to retrieve the information for
 */
#define EE_BYTE_ADDRESS(FIELD)  CCT_EE_BYTE_ADDRESS2 (EE_ ## FIELD)
#define CCT_EE_BYTE_ADDRESS2(F)   CCT_EE_BYTE_ADDRESS3 (F)
#define CCT_EE_BYTE_ADDRESS3(...) CCT_EE_BYTE_ADDRESS4 (__VA_ARGS__)
#define CCT_EE_BYTE_ADDRESS4(H, A, BA, M, O, W, B, U) (BA)

/** Get a mask of all unused host bits for giveb field field.
 *
 * @param FIELD Field to retrieve the information for
 */
#define EE_HOST_UNUSED(FIELD)  CCT_EE_HOST_UNUSED2 (EE_ ## FIELD)
#define CCT_EE_HOST_UNUSED2(F)   CCT_EE_HOST_UNUSED3 (F)
#define CCT_EE_HOST_UNUSED3(...) CCT_EE_HOST_UNUSED4 (__VA_ARGS__)
#define CCT_EE_HOST_UNUSED4(H, A, BA, M, O, W, B, U) (U)

/** Get the bit offset from where the given field begins in its host.
 *
 * @param FIELD Field to retrieve the information for
 */

#define EE_OFFSET(FIELD)  CCT_EE_OFFSET2 (EE_ ## FIELD)
#define CCT_EE_OFFSET2(F)   CCT_EE_OFFSET3 (F)
#define CCT_EE_OFFSET3(...) CCT_EE_OFFSET4 (__VA_ARGS__)
#define CCT_EE_OFFSET4(H, A, BA, M, O, W, B, U) (O)

/** Checks whether the given field is dummy one i.e. it is a MlxCCT private.
 *
 * @param FIELD Field to retrieve the information for
 */
#define EE_DUMMY(FIELD)  CCT_EE_DUMMY2 (EE_ ## FIELD)
#define CCT_EE_DUMMY2(F)   CCT_EE_DUMMY3 (F)
#define CCT_EE_DUMMY3(...) CCT_EE_DUMMY4 (__VA_ARGS__)
#define CCT_EE_DUMMY4(H, A, BA, M, O, W, B, U) (B == 2U)

/** Checks whether the given fields can be bit accessed (setb, clrb, ...).
 *
 * @param FIELD Field to retrieve the information for
 * @param ... Sequence of FIELDx to include in the query
 */
#define EE_BIT_ACCESSIBLE(FIELD, ...) \
    CCT_EE_BIT_ACCESSIBLE2 (FIELD, __VA_ARGS__, \
  DUMMY2,  DUMMY3,  DUMMY4,  DUMMY5,  DUMMY6,  DUMMY7,  DUMMY8,  DUMMY9, \
  DUMMY10, DUMMY11, DUMMY12, DUMMY13, DUMMY14, DUMMY15, DUMMY16)
#define CCT_EE_BIT_ACCESSIBLE2(F1, F2, F3, F4, F5, F6, F7, F8,  \
                            F9, F10, F11, F12, F13, F14, F15, F16, ...) \
    (  CCT_EE_BIT_ACCESSIBLE3 (EE_##F1 ) && CCT_EE_BIT_ACCESSIBLE3 (EE_##F2 )\
    && CCT_EE_BIT_ACCESSIBLE3 (EE_##F3 ) && CCT_EE_BIT_ACCESSIBLE3 (EE_##F4 )\
    && CCT_EE_BIT_ACCESSIBLE3 (EE_##F5 ) && CCT_EE_BIT_ACCESSIBLE3 (EE_##F6 )\
    && CCT_EE_BIT_ACCESSIBLE3 (EE_##F7 ) && CCT_EE_BIT_ACCESSIBLE3 (EE_##F8 )\
    && CCT_EE_BIT_ACCESSIBLE3 (EE_##F9 ) && CCT_EE_BIT_ACCESSIBLE3 (EE_##F10)\
    && CCT_EE_BIT_ACCESSIBLE3 (EE_##F11) && CCT_EE_BIT_ACCESSIBLE3 (EE_##F12)\
    && CCT_EE_BIT_ACCESSIBLE3 (EE_##F13) && CCT_EE_BIT_ACCESSIBLE3 (EE_##F14)\
    && CCT_EE_BIT_ACCESSIBLE3 (EE_##F15) && CCT_EE_BIT_ACCESSIBLE3 (EE_##F16))
#define CCT_EE_BIT_ACCESSIBLE3(...) CCT_EE_BIT_ACCESSIBLE4 (__VA_ARGS__)
#define CCT_EE_BIT_ACCESSIBLE4(H, A, BA, M, O, W, B, U) (B)

/** Get a compound mask for all the given fields.
 *
 * @param FIELD Field to retrieve the information for
 * @param ... Sequence of FIELDx to include in the query
 */
#define EE_MASK(FIELD, ...) \
    CCT_EE_MASK2 (FIELD, __VA_ARGS__, \
  DUMMY2,  DUMMY3,  DUMMY4,  DUMMY5,  DUMMY6,  DUMMY7,  DUMMY8,  DUMMY9, \
  DUMMY10, DUMMY11, DUMMY12, DUMMY13, DUMMY14, DUMMY15, DUMMY16)
#define CCT_EE_MASK2(F1, F2, F3, F4, F5, F6, F7, F8, \
                  F9, F10, F11, F12, F13, F14, F15, F16, ...) \
    ( CCT_EE_MASK3 (EE_ ## F1 ) | CCT_EE_MASK3 (EE_ ## F2 ) \
    | CCT_EE_MASK3 (EE_ ## F3 ) | CCT_EE_MASK3 (EE_ ## F4 ) \
    | CCT_EE_MASK3 (EE_ ## F5 ) | CCT_EE_MASK3 (EE_ ## F6 ) \
    | CCT_EE_MASK3 (EE_ ## F7 ) | CCT_EE_MASK3 (EE_ ## F8 ) \
    | CCT_EE_MASK3 (EE_ ## F9 ) | CCT_EE_MASK3 (EE_ ## F10) \
    | CCT_EE_MASK3 (EE_ ## F11) | CCT_EE_MASK3 (EE_ ## F12) \
    | CCT_EE_MASK3 (EE_ ## F13) | CCT_EE_MASK3 (EE_ ## F14) \
    | CCT_EE_MASK3 (EE_ ## F15) | CCT_EE_MASK3 (EE_ ## F16))
#define CCT_EE_MASK3(...) CCT_EE_MASK4 (__VA_ARGS__)
#define CCT_EE_MASK4(H, A, BA, M, O, W, B, U) (M)

/** Type of somewhat expressive, compile-time check.
 *
 * @param MSG Error message
 * @param EXPR Expression to assert
 */
#define EE_STATIC_ASSERT(MSG, EXPR) { enum { MSG = 1/(!!(EXPR)) }; }

/** Compile time assert that the given fields can be written.
 *
 * @param FIELD Field to retrieve the information for
 * @param ... Sequence of FIELDx to include in the query
 */
#define EE_ASSERT_WRITABLES(FIELD, ...) \
    CCT_EE_WRITABLES2 (FIELD, __VA_ARGS__, \
  DUMMY2,  DUMMY3,  DUMMY4,  DUMMY5,  DUMMY6,  DUMMY7,  DUMMY8,  DUMMY9, \
  DUMMY10, DUMMY11, DUMMY12, DUMMY13, DUMMY14, DUMMY15, DUMMY16)
#define CCT_EE_WRITABLES2(F1, F2, F3, F4, F5, F6, F7, F8, \
                       F9, F10, F11, F12, F13, F14, F15, F16, ...) \
    CCT_EE_WRITABLES3 (F1 , EE_##F1 ) CCT_EE_WRITABLES3 (F2 , EE_##F2 ) \
    CCT_EE_WRITABLES3 (F3 , EE_##F3 ) CCT_EE_WRITABLES3 (F4 , EE_##F4 ) \
    CCT_EE_WRITABLES3 (F5 , EE_##F5 ) CCT_EE_WRITABLES3 (F6 , EE_##F6 ) \
    CCT_EE_WRITABLES3 (F7 , EE_##F7 ) CCT_EE_WRITABLES3 (F8 , EE_##F8 ) \
    CCT_EE_WRITABLES3 (F9 , EE_##F9 ) CCT_EE_WRITABLES3 (F10, EE_##F10) \
    CCT_EE_WRITABLES3 (F11, EE_##F11) CCT_EE_WRITABLES3 (F12, EE_##F12) \
    CCT_EE_WRITABLES3 (F13, EE_##F13) CCT_EE_WRITABLES3 (F14, EE_##F14) \
    CCT_EE_WRITABLES3 (F15, EE_##F15) CCT_EE_WRITABLES3 (F16, EE_##F16)
#define CCT_EE_WRITABLES3(...) CCT_EE_WRITABLES4 (__VA_ARGS__)
#define CCT_EE_WRITABLES4(F, H, A, BA, M, O, W, B, U) \
    EE_STATIC_ASSERT (F ## _IS_WRITABLE, W)

/** Compile time assert that the given fields share the same host.
 *
 * @param FIELD Field to retrieve the information for
 * @param ... Sequence of FIELDx to include in the query
 */
#define EE_ASSERT_SAME_HOST(FIELD, ...) \
    CCT_EE_SAME_HOST2 (FIELD, __VA_ARGS__, \
  DUMMY2,  DUMMY3,  DUMMY4,  DUMMY5,  DUMMY6,  DUMMY7,  DUMMY8,  DUMMY9, \
  DUMMY10, DUMMY11, DUMMY12, DUMMY13, DUMMY14, DUMMY15, DUMMY16)
#define CCT_EE_SAME_HOST2(F1, F2, F3, F4, F5, F6, F7, F8, \
                       F9, F10, F11, F12, F13, F14, F15, F16, ...) \
    EE_STATIC_ASSERT (FIELDS_SHARE_SAME_ADDRESS, \
       (EE_DUMMY (F2 ) || EE_ADDRESS (F1) == EE_ADDRESS (F2 )) \
    && (EE_DUMMY (F3 ) || EE_ADDRESS (F1) == EE_ADDRESS (F3 )) \
    && (EE_DUMMY (F4 ) || EE_ADDRESS (F1) == EE_ADDRESS (F4 )) \
    && (EE_DUMMY (F5 ) || EE_ADDRESS (F1) == EE_ADDRESS (F5 )) \
    && (EE_DUMMY (F6 ) || EE_ADDRESS (F1) == EE_ADDRESS (F6 )) \
    && (EE_DUMMY (F7 ) || EE_ADDRESS (F1) == EE_ADDRESS (F7 )) \
    && (EE_DUMMY (F8 ) || EE_ADDRESS (F1) == EE_ADDRESS (F8 )) \
    && (EE_DUMMY (F9 ) || EE_ADDRESS (F1) == EE_ADDRESS (F9 )) \
    && (EE_DUMMY (F10) || EE_ADDRESS (F1) == EE_ADDRESS (F10)) \
    && (EE_DUMMY (F11) || EE_ADDRESS (F1) == EE_ADDRESS (F11)) \
    && (EE_DUMMY (F12) || EE_ADDRESS (F1) == EE_ADDRESS (F12)) \
    && (EE_DUMMY (F13) || EE_ADDRESS (F1) == EE_ADDRESS (F13)) \
    && (EE_DUMMY (F14) || EE_ADDRESS (F1) == EE_ADDRESS (F14)) \
    && (EE_DUMMY (F15) || EE_ADDRESS (F1) == EE_ADDRESS (F15)) \
    && (EE_DUMMY (F16) || EE_ADDRESS (F1) == EE_ADDRESS (F16)))

/** Assert whether these arguments fits in the EE_ macros.
 *
 * @param FIELD Field to retrieve the information for
 * @param ... Sequence of FIELDx to include in the query
 */
#define EE_ASSERT_ARGS_FIT(FIELD, ...) \
    CCT_EE_ASSERT_ARGS_FIT2 (FIELD, __VA_ARGS__, \
  DUMMY2,  DUMMY3,  DUMMY4,  DUMMY5,  DUMMY6,  DUMMY7,  DUMMY8,  DUMMY9, \
  DUMMY10, DUMMY11, DUMMY12, DUMMY13, DUMMY14, DUMMY15, DUMMY16, DUMMY17)
#define CCT_EE_ASSERT_ARGS_FIT2(F1, F2, F3, F4, F5, F6, F7, F8, \
                    F9, F10, F11, F12, F13, F14, F15, F16, F17, ...) \
    CCT_EE_ASSERT_ARGS_FIT3 (EE_ ## F17)
#define CCT_EE_ASSERT_ARGS_FIT3(...) CCT_EE_ASSERT_ARGS_FIT4 (__VA_ARGS__)
#define CCT_EE_ASSERT_ARGS_FIT4(H, A, BA, M, O, W, B, U) \
    EE_STATIC_ASSERT (ARGUMENTS_FIT_IN_MACRO, B == 2U)

/*****************************************************************************/
/* 3. EEPROM declarations. */

/*****************************************************************************/
/* 3.1 Hosting variables. */

extern uint16_t ee0x800 __attribute__((ep, addr(MEM_EEPROM_START + 0x0000u)));
extern uint16_t ee0x802 __attribute__((ep, addr(MEM_EEPROM_START + 0x0002u)));
extern uint16_t ee0x804 __attribute__((ep, addr(MEM_EEPROM_START + 0x0004u)));
extern uint16_t ee0x806 __attribute__((ep, addr(MEM_EEPROM_START + 0x0006u)));
extern uint16_t ee0x808 __attribute__((ep, addr(MEM_EEPROM_START + 0x0008u)));
extern uint16_t ee0x80a __attribute__((ep, addr(MEM_EEPROM_START + 0x000au)));
extern uint16_t ee0x80c __attribute__((ep, addr(MEM_EEPROM_START + 0x000cu)));
extern uint16_t ee0x80e __attribute__((ep, addr(MEM_EEPROM_START + 0x000eu)));
extern uint16_t ee0x810 __attribute__((ep, addr(MEM_EEPROM_START + 0x0010u)));
extern uint16_t ee0x812 __attribute__((ep, addr(MEM_EEPROM_START + 0x0012u)));
extern uint16_t ee0x814 __attribute__((ep, addr(MEM_EEPROM_START + 0x0014u)));
extern uint16_t ee0x816 __attribute__((ep, addr(MEM_EEPROM_START + 0x0016u)));
extern uint16_t ee0x818 __attribute__((ep, addr(MEM_EEPROM_START + 0x0018u)));
extern uint16_t ee0x81a __attribute__((ep, addr(MEM_EEPROM_START + 0x001au)));
extern uint16_t ee0x81c __attribute__((ep, addr(MEM_EEPROM_START + 0x001cu)));
extern uint16_t ee0x81e __attribute__((ep, addr(MEM_EEPROM_START + 0x001eu)));
extern uint16_t ee0x820 __attribute__((ep, addr(MEM_EEPROM_START + 0x0020u)));
extern uint16_t ee0x822 __attribute__((ep, addr(MEM_EEPROM_START + 0x0022u)));
extern uint16_t ee0x824 __attribute__((ep, addr(MEM_EEPROM_START + 0x0024u)));
extern uint16_t ee0x826 __attribute__((ep, addr(MEM_EEPROM_START + 0x0026u)));
extern uint16_t ee0x828 __attribute__((ep, addr(MEM_EEPROM_START + 0x0028u)));
extern uint16_t ee0x82a __attribute__((ep, addr(MEM_EEPROM_START + 0x002au)));
extern uint16_t ee0x82c __attribute__((ep, addr(MEM_EEPROM_START + 0x002cu)));
extern uint16_t ee0x82e __attribute__((ep, addr(MEM_EEPROM_START + 0x002eu)));
extern uint16_t ee0x830 __attribute__((ep, addr(MEM_EEPROM_START + 0x0030u)));
extern uint16_t ee0x832 __attribute__((ep, addr(MEM_EEPROM_START + 0x0032u)));
extern uint16_t ee0x834 __attribute__((ep, addr(MEM_EEPROM_START + 0x0034u)));
extern uint16_t ee0x836 __attribute__((ep, addr(MEM_EEPROM_START + 0x0036u)));
extern uint16_t ee0x838 __attribute__((ep, addr(MEM_EEPROM_START + 0x0038u)));
extern uint16_t ee0x83a __attribute__((ep, addr(MEM_EEPROM_START + 0x003au)));
extern uint16_t ee0x83c __attribute__((ep, addr(MEM_EEPROM_START + 0x003cu)));
extern uint16_t ee0x83e __attribute__((ep, addr(MEM_EEPROM_START + 0x003eu)));
extern uint16_t ee0x9b0 __attribute__((addr(MEM_EEPROM_START + 0x01b0u)));
extern uint16_t ee0x9b2 __attribute__((addr(MEM_EEPROM_START + 0x01b2u)));
extern uint16_t ee0x9b4 __attribute__((addr(MEM_EEPROM_START + 0x01b4u)));
extern uint16_t ee0x9b6 __attribute__((addr(MEM_EEPROM_START + 0x01b6u)));
extern uint16_t ee0x9b8 __attribute__((addr(MEM_EEPROM_START + 0x01b8u)));
extern uint16_t ee0x9ba __attribute__((addr(MEM_EEPROM_START + 0x01bau)));
extern uint16_t ee0x9bc __attribute__((addr(MEM_EEPROM_START + 0x01bcu)));
extern uint16_t ee0x9be __attribute__((addr(MEM_EEPROM_START + 0x01beu)));
extern uint16_t ee0x9c0 __attribute__((addr(MEM_EEPROM_START + 0x01c0u)));
extern uint16_t ee0x9c2 __attribute__((addr(MEM_EEPROM_START + 0x01c2u)));
extern uint16_t ee0x9c4 __attribute__((addr(MEM_EEPROM_START + 0x01c4u)));
extern uint16_t ee0x9c6 __attribute__((addr(MEM_EEPROM_START + 0x01c6u)));
extern uint16_t ee0x9c8 __attribute__((addr(MEM_EEPROM_START + 0x01c8u)));
extern uint16_t ee0x9ca __attribute__((addr(MEM_EEPROM_START + 0x01cau)));
extern uint16_t ee0x9cc __attribute__((addr(MEM_EEPROM_START + 0x01ccu)));
extern uint16_t ee0x9ce __attribute__((addr(MEM_EEPROM_START + 0x01ceu)));
extern uint16_t ee0x9d0 __attribute__((addr(MEM_EEPROM_START + 0x01d0u)));
extern uint16_t ee0x9d2 __attribute__((addr(MEM_EEPROM_START + 0x01d2u)));
extern uint16_t ee0x9d4 __attribute__((addr(MEM_EEPROM_START + 0x01d4u)));
extern uint16_t ee0x9d6 __attribute__((addr(MEM_EEPROM_START + 0x01d6u)));
extern uint16_t ee0x9d8 __attribute__((addr(MEM_EEPROM_START + 0x01d8u)));
extern uint16_t ee0x9da __attribute__((addr(MEM_EEPROM_START + 0x01dau)));
extern uint16_t ee0x9dc __attribute__((addr(MEM_EEPROM_START + 0x01dcu)));
extern uint16_t ee0x9de __attribute__((addr(MEM_EEPROM_START + 0x01deu)));
extern uint16_t ee0x9e0 __attribute__((addr(MEM_EEPROM_START + 0x01e0u)));
extern uint16_t ee0x9e2 __attribute__((addr(MEM_EEPROM_START + 0x01e2u)));
extern uint16_t ee0x9e4 __attribute__((addr(MEM_EEPROM_START + 0x01e4u)));
extern uint16_t ee0x9e6 __attribute__((addr(MEM_EEPROM_START + 0x01e6u)));
extern uint16_t ee0x9e8 __attribute__((addr(MEM_EEPROM_START + 0x01e8u)));
extern uint16_t ee0x9ea __attribute__((addr(MEM_EEPROM_START + 0x01eau)));
extern uint16_t ee0x9ec __attribute__((addr(MEM_EEPROM_START + 0x01ecu)));
extern uint16_t ee0x9ee __attribute__((addr(MEM_EEPROM_START + 0x01eeu)));
extern uint16_t ee0x9f0 __attribute__((addr(MEM_EEPROM_START + 0x01f0u)));
extern uint16_t ee0x9f2 __attribute__((addr(MEM_EEPROM_START + 0x01f2u)));
extern uint16_t ee0x9f4 __attribute__((addr(MEM_EEPROM_START + 0x01f4u)));
extern uint16_t ee0x9f6 __attribute__((addr(MEM_EEPROM_START + 0x01f6u)));
extern uint16_t ee0x9f8 __attribute__((addr(MEM_EEPROM_START + 0x01f8u)));
extern uint16_t ee0x9fa __attribute__((addr(MEM_EEPROM_START + 0x01fau)));
extern uint16_t ee0x9fc __attribute__((addr(MEM_EEPROM_START + 0x01fcu)));
extern uint16_t ee0x9fe __attribute__((addr(MEM_EEPROM_START + 0x01feu)));
extern uint16_t ee0xa00 __attribute__((addr(MEM_EEPROM_START + 0x0200u)));
extern uint16_t ee0xa02 __attribute__((addr(MEM_EEPROM_START + 0x0202u)));
extern uint16_t ee0xa04 __attribute__((addr(MEM_EEPROM_START + 0x0204u)));
extern uint16_t ee0xa06 __attribute__((addr(MEM_EEPROM_START + 0x0206u)));
extern uint16_t ee0xa08 __attribute__((addr(MEM_EEPROM_START + 0x0208u)));
extern uint16_t ee0xa0a __attribute__((addr(MEM_EEPROM_START + 0x020au)));
extern uint16_t ee0xa0c __attribute__((addr(MEM_EEPROM_START + 0x020cu)));
extern uint16_t ee0xa0e __attribute__((addr(MEM_EEPROM_START + 0x020eu)));
extern uint16_t ee0xa10 __attribute__((addr(MEM_EEPROM_START + 0x0210u)));
extern uint16_t ee0xa12 __attribute__((addr(MEM_EEPROM_START + 0x0212u)));
extern uint16_t ee0xa14 __attribute__((addr(MEM_EEPROM_START + 0x0214u)));
extern uint16_t ee0xa16 __attribute__((addr(MEM_EEPROM_START + 0x0216u)));
extern uint16_t ee0xa18 __attribute__((addr(MEM_EEPROM_START + 0x0218u)));
extern uint16_t ee0xa1a __attribute__((addr(MEM_EEPROM_START + 0x021au)));
extern uint16_t ee0xa1c __attribute__((addr(MEM_EEPROM_START + 0x021cu)));
extern uint16_t ee0xa1e __attribute__((addr(MEM_EEPROM_START + 0x021eu)));
extern uint16_t ee0xa20 __attribute__((addr(MEM_EEPROM_START + 0x0220u)));
extern uint16_t ee0xa22 __attribute__((addr(MEM_EEPROM_START + 0x0222u)));
extern uint16_t ee0xa24 __attribute__((addr(MEM_EEPROM_START + 0x0224u)));
extern uint16_t ee0xa26 __attribute__((addr(MEM_EEPROM_START + 0x0226u)));
extern uint16_t ee0xa28 __attribute__((addr(MEM_EEPROM_START + 0x0228u)));
extern uint16_t ee0xa2a __attribute__((addr(MEM_EEPROM_START + 0x022au)));
extern uint16_t ee0xa2c __attribute__((addr(MEM_EEPROM_START + 0x022cu)));
extern uint16_t ee0xa2e __attribute__((addr(MEM_EEPROM_START + 0x022eu)));
extern uint16_t ee0xa30 __attribute__((addr(MEM_EEPROM_START + 0x0230u)));
extern uint16_t ee0xa32 __attribute__((addr(MEM_EEPROM_START + 0x0232u)));
extern uint16_t ee0xa34 __attribute__((addr(MEM_EEPROM_START + 0x0234u)));
extern uint16_t ee0xa36 __attribute__((addr(MEM_EEPROM_START + 0x0236u)));
extern uint16_t ee0xa38 __attribute__((addr(MEM_EEPROM_START + 0x0238u)));
extern uint16_t ee0xa3a __attribute__((addr(MEM_EEPROM_START + 0x023au)));
extern uint16_t ee0xa3c __attribute__((addr(MEM_EEPROM_START + 0x023cu)));
extern uint16_t ee0xa3e __attribute__((addr(MEM_EEPROM_START + 0x023eu)));

/*****************************************************************************/
/* 3.2 Get macros. */

/** PATCH_LEN : High byte : PATCH Length */
#define EE_PATCH_LEN_GET() \
    (uint8_t)((ee0x800 & 0xff00u) >> 8U)
/** PATCH_CRC : Low byte : Calculated CRC over patch addresses */
#define EE_PATCH_CRC_GET() \
    (uint8_t)((ee0x800 & 0x00ffu) >> 0U)
/** PATCH_ID : ID of the patch */
#define EE_PATCH_ID_GET() \
    (uint16_t)((ee0x802 & 0xffffu) >> 0U)
/** PATCH0_ADR : DEBUG_ADR0 (patch addr) + enable (LSB, ports DEBUG_ADR , DEBUG_DATA, DEBUG_CTRL  only written when LSB=1) (DEBUG_CTRL0=0x0410 fixed) */
#define EE_PATCH0_ADR_GET() \
    (uint16_t)((ee0x804 & 0xffffu) >> 0U)
/** PATCH0_DATA : DEBUG_DATA0 (replacement instr) */
#define EE_PATCH0_DATA_GET() \
    (uint16_t)((ee0x806 & 0xffffu) >> 0U)
/** PATCH1_ADR : DEBUG_ADR1 (patch addr) + enable (LSB, ports DEBUG_ADR , DEBUG_DATA, DEBUG_CTRL  only written when LSB=1) (DEBUG_CTRL0=0x0410 fixed) */
#define EE_PATCH1_ADR_GET() \
    (uint16_t)((ee0x808 & 0xffffu) >> 0U)
/** PATCH1_DATA : DEBUG_DATA1 (replacement instr) */
#define EE_PATCH1_DATA_GET() \
    (uint16_t)((ee0x80a & 0xffffu) >> 0U)
/** PATCH2_ADR : DEBUG_ADR2 (patch addr) + enable (LSB, ports DEBUG_ADR , DEBUG_DATA, DEBUG_CTRL  only written when LSB=1) (DEBUG_CTRL0=0x0410 fixed) */
#define EE_PATCH2_ADR_GET() \
    (uint16_t)((ee0x80c & 0xffffu) >> 0U)
/** PATCH2_DATA : DEBUG_DATA2 (replacement instr) */
#define EE_PATCH2_DATA_GET() \
    (uint16_t)((ee0x80e & 0xffffu) >> 0U)
/** PATCH_CODE00 : patch code in EEPROM */
#define EE_PATCH_CODE00_GET() \
    (uint16_t)((ee0x810 & 0xffffu) >> 0U)
/** PATCH_CODE01 : patch code in EEPROM */
#define EE_PATCH_CODE01_GET() \
    (uint16_t)((ee0x812 & 0xffffu) >> 0U)
/** PATCH_CODE02 : patch code in EEPROM */
#define EE_PATCH_CODE02_GET() \
    (uint16_t)((ee0x814 & 0xffffu) >> 0U)
/** PATCH_CODE03 : patch code in EEPROM */
#define EE_PATCH_CODE03_GET() \
    (uint16_t)((ee0x816 & 0xffffu) >> 0U)
/** PATCH_CODE04 : patch code in EEPROM */
#define EE_PATCH_CODE04_GET() \
    (uint16_t)((ee0x818 & 0xffffu) >> 0U)
/** PATCH_CODE05 : patch code in EEPROM */
#define EE_PATCH_CODE05_GET() \
    (uint16_t)((ee0x81a & 0xffffu) >> 0U)
/** PATCH_CODE06 : patch code in EEPROM */
#define EE_PATCH_CODE06_GET() \
    (uint16_t)((ee0x81c & 0xffffu) >> 0U)
/** PATCH_CODE07 : patch code in EEPROM */
#define EE_PATCH_CODE07_GET() \
    (uint16_t)((ee0x81e & 0xffffu) >> 0U)
/** PATCH_CODE08 : patch code in EEPROM */
#define EE_PATCH_CODE08_GET() \
    (uint16_t)((ee0x820 & 0xffffu) >> 0U)
/** PATCH_CODE09 : patch code in EEPROM */
#define EE_PATCH_CODE09_GET() \
    (uint16_t)((ee0x822 & 0xffffu) >> 0U)
/** PATCH_CODE10 : patch code in EEPROM */
#define EE_PATCH_CODE10_GET() \
    (uint16_t)((ee0x824 & 0xffffu) >> 0U)
/** PATCH_CODE11 : patch code in EEPROM */
#define EE_PATCH_CODE11_GET() \
    (uint16_t)((ee0x826 & 0xffffu) >> 0U)
/** PATCH_CODE12 : patch code in EEPROM */
#define EE_PATCH_CODE12_GET() \
    (uint16_t)((ee0x828 & 0xffffu) >> 0U)
/** PATCH_CODE13 : patch code in EEPROM */
#define EE_PATCH_CODE13_GET() \
    (uint16_t)((ee0x82a & 0xffffu) >> 0U)
/** PATCH_CODE14 : patch code in EEPROM */
#define EE_PATCH_CODE14_GET() \
    (uint16_t)((ee0x82c & 0xffffu) >> 0U)
/** PATCH_CODE15 : patch code in EEPROM */
#define EE_PATCH_CODE15_GET() \
    (uint16_t)((ee0x82e & 0xffffu) >> 0U)
/** PATCH_CODE16 : patch code in EEPROM */
#define EE_PATCH_CODE16_GET() \
    (uint16_t)((ee0x830 & 0xffffu) >> 0U)
/** PATCH_CODE17 : patch code in EEPROM */
#define EE_PATCH_CODE17_GET() \
    (uint16_t)((ee0x832 & 0xffffu) >> 0U)
/** PATCH_CODE18 : patch code in EEPROM */
#define EE_PATCH_CODE18_GET() \
    (uint16_t)((ee0x834 & 0xffffu) >> 0U)
/** PATCH_CODE19 : patch code in EEPROM */
#define EE_PATCH_CODE19_GET() \
    (uint16_t)((ee0x836 & 0xffffu) >> 0U)
/** PATCH_CODE20 : patch code in EEPROM */
#define EE_PATCH_CODE20_GET() \
    (uint16_t)((ee0x838 & 0xffffu) >> 0U)
/** PATCH_CODE21 : patch code in EEPROM */
#define EE_PATCH_CODE21_GET() \
    (uint16_t)((ee0x83a & 0xffffu) >> 0U)
/** PATCH_CODE22 : patch code in EEPROM */
#define EE_PATCH_CODE22_GET() \
    (uint16_t)((ee0x83c & 0xffffu) >> 0U)
/** PATCH_CODE23 : patch code in EEPROM */
#define EE_PATCH_CODE23_GET() \
    (uint16_t)((ee0x83e & 0xffffu) >> 0U)
/** APP_TRIM0 : {TempMid[7:0], CalibCRC_EE[7:0]} */
#define EE_APP_TRIM0_GET() \
    (uint16_t)((ee0x9b0 & 0xffffu) >> 0U)
/** TEMPMID : Middle Temperature used in production (mostly probing1 = 35degC) (copy at 09B6) */
#define EE_TEMPMID_GET() \
    (int8_t)((ee0x9b0 & 0xff00u) >> 8U)
/** CALIBCRC : 8bit EEPROM calibration area CRC ( sum with carry ) */
#define EE_CALIBCRC_GET() \
    (uint8_t)((ee0x9b0 & 0x00ffu) >> 0U)
/** APP_TRIM1 : reserved[15:0] */
#define EE_APP_TRIM1_GET() \
    (uint16_t)((ee0x9b2 & 0xffffu) >> 0U)
/** APP_TRIM2 : OTempCal_EE[15:0] */
#define EE_APP_TRIM2_GET() \
    (uint16_t)((ee0x9b4 & 0xffffu) >> 0U)
/** OTEMPCAL : Temperature Sensor Offset , 16bit unsigned */
#define EE_OTEMPCAL_GET() \
    (uint16_t)((ee0x9b4 & 0xffffu) >> 0U)
/** APP_TRIM3 : {CALIB_VERSION[7:0], TempMid[7:0]} */
#define EE_APP_TRIM3_GET() \
    (uint16_t)((ee0x9b6 & 0xffffu) >> 0U)
/** CALIB_VERSION : Calibration data version */
#define EE_CALIB_VERSION_GET() \
    (uint8_t)((ee0x9b6 & 0xff00u) >> 8U)
/** TEMPMID_CP : Middle Temperature used in production (mostly probing1 = 35degC) (copy at 09B1) */
#define EE_TEMPMID_CP_GET() \
    (int8_t)((ee0x9b6 & 0x00ffu) >> 0U)
/** APP_TRIM4 : {GainTempHighCal_EE[7:0], GainTempLowCal_EE[7:0]} */
#define EE_APP_TRIM4_GET() \
    (uint16_t)((ee0x9b8 & 0xffffu) >> 0U)
/** GAINTEMPHIGHCAL : Temp sensor calibration, Gain for High Temp range */
#define EE_GAINTEMPHIGHCAL_GET() \
    (uint8_t)((ee0x9b8 & 0xff00u) >> 8U)
/** GAINTEMPLOWCAL : Temp sensor calibration, Gain for Low Temp range */
#define EE_GAINTEMPLOWCAL_GET() \
    (uint8_t)((ee0x9b8 & 0x00ffu) >> 0U)
/** APP_TRIM5 : {reserved[2:0],LINAA_DIV_EXT[4:0], OADCCal_EE[7:0]} */
#define EE_APP_TRIM5_GET() \
    (uint16_t)((ee0x9ba & 0xffffu) >> 0U)
/** LINAA_DIV_EXT : extended 5bit LINAA_DIV control for CMR adjustment */
#define EE_LINAA_DIV_EXT_GET() \
    (uint8_t)((ee0x9ba & 0x1f00u) >> 8U)
/** OADCCAL : ADC reference (2.5V) offset [8bit signed] */
#define EE_OADCCAL_GET() \
    (int8_t)((ee0x9ba & 0x00ffu) >> 0U)
/** APP_TRIM6 : {GainADCHighCal_EE[7:0], GainADCLowCal_EE[7:0]} */
#define EE_APP_TRIM6_GET() \
    (uint16_t)((ee0x9bc & 0xffffu) >> 0U)
/** GAINADCHIGHCAL : ADC reference (2.5V) gain for high temp range  [8bit signed] */
#define EE_GAINADCHIGHCAL_GET() \
    (int8_t)((ee0x9bc & 0xff00u) >> 8U)
/** GAINADCLOWCAL : ADC reference (2.5V) gain for low temp range  [8bit signed] */
#define EE_GAINADCLOWCAL_GET() \
    (int8_t)((ee0x9bc & 0x00ffu) >> 0U)
/** APP_TRIM7 : {SClock24HighCal _EE[7:0], SClock24LowCal _EE[7:0]} */
#define EE_APP_TRIM7_GET() \
    (uint16_t)((ee0x9be & 0xffffu) >> 0U)
/** SCLOCK24HIGHCAL : CPU clock (24MHz)  Gain for High Temp range [8bit signed] */
#define EE_SCLOCK24HIGHCAL_GET() \
    (int8_t)((ee0x9be & 0xff00u) >> 8U)
/** SCLOCK24LOWCAL : CPU clock (24MHz)  Gain for Low Temp range [8bit signed] */
#define EE_SCLOCK24LOWCAL_GET() \
    (int8_t)((ee0x9be & 0x00ffu) >> 0U)
/** APP_TRIM8 : {SClock28LowCal _EE[7:0], OClock24Cal _EE[7:0]} */
#define EE_APP_TRIM8_GET() \
    (uint16_t)((ee0x9c0 & 0xffffu) >> 0U)
/** SCLOCK28LOWCAL : CPU clock (28MHz)  Gain for Low Temp range [8bit signed] */
#define EE_SCLOCK28LOWCAL_GET() \
    (int8_t)((ee0x9c0 & 0xff00u) >> 8U)
/** OCLOCK24CAL : CPU clock (24MHz)  Offset [8bit signed] */
#define EE_OCLOCK24CAL_GET() \
    (int8_t)((ee0x9c0 & 0x00ffu) >> 0U)
/** APP_TRIM9 : {OClock28Cal _EE[7:0], SClock28HighCal _EE[7:0]} */
#define EE_APP_TRIM9_GET() \
    (uint16_t)((ee0x9c2 & 0xffffu) >> 0U)
/** OCLOCK28CAL : CPU clock (28MHz)  Offset [8bit signed] */
#define EE_OCLOCK28CAL_GET() \
    (int8_t)((ee0x9c2 & 0xff00u) >> 8U)
/** SCLOCK28HIGHCAL : CPU clock (28MHz)  Gain for High Temp range [8bit signed] */
#define EE_SCLOCK28HIGHCAL_GET() \
    (int8_t)((ee0x9c2 & 0x00ffu) >> 0U)
/** APP_TRIM10 : {SClock32HighCal _EE[7:0], SClock32LowCal _EE[7:0]} */
#define EE_APP_TRIM10_GET() \
    (uint16_t)((ee0x9c4 & 0xffffu) >> 0U)
/** SCLOCK32HIGHCAL : CPU clock (30MHz)  Gain for High Temp range [8bit signed] */
#define EE_SCLOCK32HIGHCAL_GET() \
    (int8_t)((ee0x9c4 & 0xff00u) >> 8U)
/** SCLOCK32LOWCAL : CPU clock (30MHz)  Gain for Low Temp range [8bit signed] */
#define EE_SCLOCK32LOWCAL_GET() \
    (int8_t)((ee0x9c4 & 0x00ffu) >> 0U)
/** APP_TRIM11 : {O10kHzCal_EE[7:0], OClock32Cal _EE[7:0]} */
#define EE_APP_TRIM11_GET() \
    (uint16_t)((ee0x9c6 & 0xffffu) >> 0U)
/** O10KHZCAL : Wake up Clock Offset [8bit signed] */
#define EE_O10KHZCAL_GET() \
    (int8_t)((ee0x9c6 & 0xff00u) >> 8U)
/** OCLOCK32CAL : CPU clock (30MHz)  Offset [8bit signed] */
#define EE_OCLOCK32CAL_GET() \
    (int8_t)((ee0x9c6 & 0x00ffu) >> 0U)
/** APP_TRIM12 : Rshunt from the LIN autoconfig block */
#define EE_APP_TRIM12_GET() \
    (uint16_t)((ee0x9c8 & 0xffffu) >> 0U)
/** LINAA_INT_SHUNT : Rshunt from the LIN autoconfig block */
#define EE_LINAA_INT_SHUNT_GET() \
    (uint16_t)((ee0x9c8 & 0xffffu) >> 0U)
/** APP_TRIM13 : reserved[15:0] */
#define EE_APP_TRIM13_GET() \
    (uint16_t)((ee0x9ca & 0xffffu) >> 0U)
/** APP_TRIM14 : LINAA_SDMCM_EE[15:0] */
#define EE_APP_TRIM14_GET() \
    (uint16_t)((ee0x9cc & 0xffffu) >> 0U)
/** LINAA_SDMCM : LINAA - differential current measurement sensitivity to common mode voltage step */
#define EE_LINAA_SDMCM_GET() \
    (int16_t)((ee0x9cc & 0xffffu) >> 0U)
/** APP_TRIM15 : LINAA_GainDMCal_EE [15:0] */
#define EE_APP_TRIM15_GET() \
    (uint16_t)((ee0x9ce & 0xffffu) >> 0U)
/** LINAA_GAINDMCAL : LINAA - differential current measurement sensitivity to  current */
#define EE_LINAA_GAINDMCAL_GET() \
    (int16_t)((ee0x9ce & 0xffffu) >> 0U)
/** APP_TRIM16 : {IAA_Trim205mA[7:0], IAA_Trim045mA[7:0]} */
#define EE_APP_TRIM16_GET() \
    (uint16_t)((ee0x9d0 & 0xffffu) >> 0U)
/** LINAA_LCD_SEL_205 : IAA_Trim205mA[7:6]: current selection for low side diagnosis current source for 205mA */
#define EE_LINAA_LCD_SEL_205_GET() \
    (uint8_t)((ee0x9d0 & 0xc000u) >> 14U)
/** LINAA_TRIM_LCD_205 : IAA_Trim205mA[5:0]:  trimming for low side diagnosis current source for 205mA, copy to PORT_TR_MISC[5:0] */
#define EE_LINAA_TRIM_LCD_205_GET() \
    (uint8_t)((ee0x9d0 & 0x3f00u) >> 8U)
/** LINAA_LCD_SEL_112 : IAA_Trim045mA[7:6]: current selection for low side diagnosis current source for 0.45mA */
#define EE_LINAA_LCD_SEL_112_GET() \
    (uint8_t)((ee0x9d0 & 0x00c0u) >> 6U)
/** LINAA_TRIM_LCD_112 : IAA_Trim045mA[5:0]:  trimming for low side diagnosis current source for 0.45mA, copy to PORT_TR_MISC[5:0] */
#define EE_LINAA_TRIM_LCD_112_GET() \
    (uint8_t)((ee0x9d0 & 0x003fu) >> 0U)
/** LINAA_LCD_SEL_045 : IAA_Trim045mA[7:6]: current selection for low side diagnosis current source for 0.45mA */
#define EE_LINAA_LCD_SEL_045_GET() \
    (uint8_t)((ee0x9d0 & 0x00c0u) >> 6U)
/** LINAA_TRIM_LCD_045 : IAA_Trim045mA[5:0]:  trimming for low side diagnosis current source for 0.45mA, copy to PORT_TR_MISC[5:0] */
#define EE_LINAA_TRIM_LCD_045_GET() \
    (int8_t)((ee0x9d0 & 0x003fu) >> 0U)
/** APP_TRIM17 : {LIN_AA_DIV[3:0], LINN_AA_GAIN[3:0], IAA_Trim240mA[7:0]} */
#define EE_APP_TRIM17_GET() \
    (uint16_t)((ee0x9d2 & 0xffffu) >> 0U)
/** LINAA_DIV : Common mode suppression adjustements bits, copy to PORT_LINAA1 */
#define EE_LINAA_DIV_GET() \
    (uint8_t)((ee0x9d2 & 0xf000u) >> 12U)
/** LINAA_GAIN : Gain control bits of the variable gain amp, , copy to PORT_LINAA1 */
#define EE_LINAA_GAIN_GET() \
    (uint8_t)((ee0x9d2 & 0x0f00u) >> 8U)
/** LINAA_LCD_SEL_240 : IAA_Trim240mA[7:6]: current selection for low side diagnosis current source for 2.4mA */
#define EE_LINAA_LCD_SEL_240_GET() \
    (uint8_t)((ee0x9d2 & 0x00c0u) >> 6U)
/** LINAA_TRIM_LCD_240 : IAA_Trim240mA[5:0]:  trimming for low side diagnosis current source for 2.4mA, copy to PORT_TR_MISC[5:0] */
#define EE_LINAA_TRIM_LCD_240_GET() \
    (uint8_t)((ee0x9d2 & 0x003fu) >> 0U)
/** APP_TRIM18 : application specific calibration information */
#define EE_APP_TRIM18_GET() \
    (uint16_t)((ee0x9d4 & 0xffffu) >> 0U)
/** O_HVI : Offset of High-voltage input HVI/21 at mid temp */
#define EE_O_HVI_GET() \
    (int8_t)((ee0x9d4 & 0xff00u) >> 8U)
/** GAIN_VSMF : Gain of filtered VSM at mid temp */
#define EE_GAIN_VSMF_GET() \
    (uint8_t)((ee0x9d4 & 0x00ffu) >> 0U)
/** APP_TRIM19 : application specific calibration information */
#define EE_APP_TRIM19_GET() \
    (uint16_t)((ee0x9d6 & 0xffffu) >> 0U)
/** O_LVI : Offset of Low-voltage input LVI/1.36 at mid temp */
#define EE_O_LVI_GET() \
    (int8_t)((ee0x9d6 & 0xff00u) >> 8U)
/** GAIN_LVI : Gain of Low-voltage input LVI/1.36 at mid temp */
#define EE_GAIN_LVI_GET() \
    (uint8_t)((ee0x9d6 & 0x00ffu) >> 0U)
/** APP_TRIM20 : application specific calibration information */
#define EE_APP_TRIM20_GET() \
    (uint16_t)((ee0x9d8 & 0xffffu) >> 0U)
/** O_VSMF : Offset of filtered VSM */
#define EE_O_VSMF_GET() \
    (int8_t)((ee0x9d8 & 0xff00u) >> 8U)
/** GAIN_HVI : Gain of High-voltage input HVI/21 at mid temp */
#define EE_GAIN_HVI_GET() \
    (uint8_t)((ee0x9d8 & 0x00ffu) >> 0U)
/** APP_TRIM21 : application specific calibration information */
#define EE_APP_TRIM21_GET() \
    (uint16_t)((ee0x9da & 0xffffu) >> 0U)
/** GAINHI_LVI : Gain-change of LVI voltage over high-temperature range */
#define EE_GAINHI_LVI_GET() \
    (int8_t)((ee0x9da & 0xff00u) >> 8U)
/** GAINLO_LVI : Gain-change of LVI voltage over low-temperature range */
#define EE_GAINLO_LVI_GET() \
    (int8_t)((ee0x9da & 0x00ffu) >> 0U)
/** APP_TRIM22 : application specific calibration information */
#define EE_APP_TRIM22_GET() \
    (uint16_t)((ee0x9dc & 0xffffu) >> 0U)
/** O_CURR : Offset of motor current at mid temp */
#define EE_O_CURR_GET() \
    (int8_t)((ee0x9dc & 0xff00u) >> 8U)
/** GAIN_CURR : Gain of motor current at mid temp */
#define EE_GAIN_CURR_GET() \
    (uint8_t)((ee0x9dc & 0x00ffu) >> 0U)
/** APP_TRIM23 : application specific calibration information */
#define EE_APP_TRIM23_GET() \
    (uint16_t)((ee0x9de & 0xffffu) >> 0U)
/** APP_TRIM24 : application specific calibration information */
#define EE_APP_TRIM24_GET() \
    (uint16_t)((ee0x9e0 & 0xffffu) >> 0U)
/** GAINHI_CURR : Gain-change of motor current over high-temperature range */
#define EE_GAINHI_CURR_GET() \
    (int8_t)((ee0x9e0 & 0xff00u) >> 8U)
/** GAINLO_CURR : Gain-change of motor current over low-temperature range */
#define EE_GAINLO_CURR_GET() \
    (int8_t)((ee0x9e0 & 0x00ffu) >> 0U)
/** APP_TRIM25 : application specific calibration information */
#define EE_APP_TRIM25_GET() \
    (uint16_t)((ee0x9e2 & 0xffffu) >> 0U)
/** GAINHI_VSMF : Gain-change of filtered VSM over high-temperature range */
#define EE_GAINHI_VSMF_GET() \
    (int8_t)((ee0x9e2 & 0xff00u) >> 8U)
/** GAINLO_VSMF : Gain-change of filtered VSM over low-temperature range */
#define EE_GAINLO_VSMF_GET() \
    (int8_t)((ee0x9e2 & 0x00ffu) >> 0U)
/** APP_TRIM26 : application specific calibration information */
#define EE_APP_TRIM26_GET() \
    (uint16_t)((ee0x9e4 & 0xffffu) >> 0U)
/** APP_TRIM27 : application specific calibration information */
#define EE_APP_TRIM27_GET() \
    (uint16_t)((ee0x9e6 & 0xffffu) >> 0U)
/** MTEMPLOW : Raw ADC measurement of the temperature sensor at low test temperature */
#define EE_MTEMPLOW_GET() \
    (uint16_t)((ee0x9e6 & 0xffffu) >> 0U)
/** APP_TRIM28 : application specific calibration information */
#define EE_APP_TRIM28_GET() \
    (uint16_t)((ee0x9e8 & 0xffffu) >> 0U)
/** MTEMPHIGH : Raw ADC measurement of the temperature sensor at high test temperature */
#define EE_MTEMPHIGH_GET() \
    (uint16_t)((ee0x9e8 & 0xffffu) >> 0U)
/** APP_TRIM29 : application specific calibration information */
#define EE_APP_TRIM29_GET() \
    (uint16_t)((ee0x9ea & 0xffffu) >> 0U)
/** TC_CHARGEPUMPCLOCK82 : Temperature coefficient for 82MHz charge pump clock trimming */
#define EE_TC_CHARGEPUMPCLOCK82_GET() \
    (uint8_t)((ee0x9ea & 0xff00u) >> 8U)
/** TC_CHARGEPUMPCLOCK60 : Temperature coefficient for 60MHz charge pump clock trimming */
#define EE_TC_CHARGEPUMPCLOCK60_GET() \
    (uint8_t)((ee0x9ea & 0x00ffu) >> 0U)
/** APP_TRIM30 : application specific calibration information */
#define EE_APP_TRIM30_GET() \
    (uint16_t)((ee0x9ec & 0xffffu) >> 0U)
/** TRIM_CPCLK : Trim setting charge pump clock 82MHz (default) */
#define EE_TRIM_CPCLK_GET() \
    (uint16_t)((ee0x9ec & 0x0ffcu) >> 2U)
/** TRIM_DRVSUP : Trim setting driver supply (default) */
#define EE_TRIM_DRVSUP_GET() \
    (uint8_t)((ee0x9ec & 0x0003u) >> 0U)
/** APP_TRIM31 : application specific calibration information */
#define EE_APP_TRIM31_GET() \
    (uint16_t)((ee0x9ee & 0xffffu) >> 0U)
/** TRIM_CSA_GAIN : Trim setting current sense amplifier gain */
#define EE_TRIM_CSA_GAIN_GET() \
    (uint8_t)((ee0x9ee & 0x01f0u) >> 4U)
/** TRIM_SLWRT : Trim setting pre-driver current */
#define EE_TRIM_SLWRT_GET() \
    (uint8_t)((ee0x9ee & 0x000fu) >> 0U)
/** APP_TRIM32 : application specific calibration information */
#define EE_APP_TRIM32_GET() \
    (uint16_t)((ee0x9f0 & 0xffffu) >> 0U)
/** TRIM_CSA_CL_LOW : Trim setting over-current detection low */
#define EE_TRIM_CSA_CL_LOW_GET() \
    (uint8_t)((ee0x9f0 & 0xff00u) >> 8U)
/** TRIM_CSA_CL_HIGH : Trim setting over-current detection high */
#define EE_TRIM_CSA_CL_HIGH_GET() \
    (uint8_t)((ee0x9f0 & 0x00ffu) >> 0U)
/** APP_TRIM33 : application specific calibration information */
#define EE_APP_TRIM33_GET() \
    (uint16_t)((ee0x9f2 & 0xffffu) >> 0U)
/** TRIM_SDAFILT_IO : Trim setting I2C SDA filter */
#define EE_TRIM_SDAFILT_IO_GET() \
    (uint8_t)((ee0x9f2 & 0x3000u) >> 12U)
/** TRIM_OTD : Trim setting over-temperature detection */
#define EE_TRIM_OTD_GET() \
    (uint8_t)((ee0x9f2 & 0x0fc0u) >> 6U)
/** APP_TRIM34 : application specific calibration information */
#define EE_APP_TRIM34_GET() \
    (uint16_t)((ee0x9f4 & 0xffffu) >> 0U)
/** TRIM_CPCLK_ALT : Trim setting charge pump clock 60MHz */
#define EE_TRIM_CPCLK_ALT_GET() \
    (uint16_t)((ee0x9f4 & 0x0ffcu) >> 2U)
/** TRIM_DRVSUP_COPY : Trim setting driver supply (copy of 9EC) */
#define EE_TRIM_DRVSUP_COPY_GET() \
    (uint8_t)((ee0x9f4 & 0x0003u) >> 0U)
/** APP_TRIM35 : application specific calibration information */
#define EE_APP_TRIM35_GET() \
    (uint16_t)((ee0x9f6 & 0xffffu) >> 0U)
/** APP_TRIM36 : speed7 reserved for additional speed settings */
#define EE_APP_TRIM36_GET() \
    (uint16_t)((ee0x9f8 & 0xffffu) >> 0U)
/** SPEED7 : speed7 reserved for additional speed settings */
#define EE_SPEED7_GET() \
    (uint16_t)((ee0x9f8 & 0xffffu) >> 0U)
/** APP_TRIM37 : speed6 reserved for additional speed settings */
#define EE_APP_TRIM37_GET() \
    (uint16_t)((ee0x9fa & 0xffffu) >> 0U)
/** SPEED6 : speed6 reserved for additional speed settings */
#define EE_SPEED6_GET() \
    (uint16_t)((ee0x9fa & 0xffffu) >> 0U)
/** APP_TRIM38 : speed5 reserved for additional speed settings */
#define EE_APP_TRIM38_GET() \
    (uint16_t)((ee0x9fc & 0xffffu) >> 0U)
/** SPEED5 : speed5 reserved for additional speed settings */
#define EE_SPEED5_GET() \
    (uint16_t)((ee0x9fc & 0xffffu) >> 0U)
/** APP_TRIM39 : speed4 setting for 32MHz/16MHz with 2 flash wait states */
#define EE_APP_TRIM39_GET() \
    (uint16_t)((ee0x9fe & 0xffffu) >> 0U)
/** SPEED4 : speed4 setting for 32MHz/16MHz with 2 flash wait states */
#define EE_SPEED4_GET() \
    (uint16_t)((ee0x9fe & 0xffffu) >> 0U)
/** MELEXIS_TRIM_CRC : Melexis Trimming - CRC location */
#define EE_MELEXIS_TRIM_CRC_GET() \
    (uint16_t)((ee0xa00 & 0xffffu) >> 0U)
/** ROM_CONFIGURATION : ROM_CONFIGURATION byte used by ROM code, function is project specific */
#define EE_ROM_CONFIGURATION_GET() \
    (uint8_t)((ee0xa00 & 0xff00u) >> 8U)
/** CRC_CS : CRC checksum of config sector */
#define EE_CRC_CS_GET() \
    (uint8_t)((ee0xa00 & 0x00ffu) >> 0U)
/** MS_TRIM0 : trim_bg_bias (bandgap, bias) */
#define EE_MS_TRIM0_GET() \
    (uint16_t)((ee0xa02 & 0xffffu) >> 0U)
/** LOCK_MS_TRIM0 : lock bit of trim port */
#define EE_LOCK_MS_TRIM0_GET() \
    (uint8_t)((ee0xa02 & 0x8000u) >> 15U)
/** MS_TR_BIAS : trim bias source */
#define EE_MS_TR_BIAS_GET() \
    (uint8_t)((ee0xa02 & 0x3f00u) >> 8U)
/** MS_TR_BGD : trim digital bandgap */
#define EE_MS_TR_BGD_GET() \
    (uint8_t)((ee0xa02 & 0x00f0u) >> 4U)
/** MS_TR_BGA : trim analog bandgap */
#define EE_MS_TR_BGA_GET() \
    (uint8_t)((ee0xa02 & 0x000fu) >> 0U)
/** MS_TRIM1 : trim_vdd (vddd, vdda) */
#define EE_MS_TRIM1_GET() \
    (uint16_t)((ee0xa04 & 0xffffu) >> 0U)
/** LOCK_MS_TRIM1 : lock bit of trim port */
#define EE_LOCK_MS_TRIM1_GET() \
    (uint8_t)((ee0xa04 & 0x8000u) >> 15U)
/** MS_TR_SUP : 8 trim support bits, ECADC: CORR_x_y */
#define EE_MS_TR_SUP_GET() \
    (uint8_t)((ee0xa04 & 0x3fc0u) >> 6U)
/** MS_TR_VDDD : digital supply trimming */
#define EE_MS_TR_VDDD_GET() \
    (uint8_t)((ee0xa04 & 0x0038u) >> 3U)
/** MS_TR_VDDA : analog supply trimming */
#define EE_MS_TR_VDDA_GET() \
    (uint8_t)((ee0xa04 & 0x0007u) >> 0U)
/** MS_TRIM2 : trim_rco1m_lin (1MHz RCO, LIN) */
#define EE_MS_TRIM2_GET() \
    (uint16_t)((ee0xa06 & 0xffffu) >> 0U)
/** LOCK_MS_TRIM2 : lock bit of trim port */
#define EE_LOCK_MS_TRIM2_GET() \
    (uint8_t)((ee0xa06 & 0x8000u) >> 15U)
/** MS_TR_LIN_SLVTERM : LIN slave termination trimming */
#define EE_MS_TR_LIN_SLVTERM_GET() \
    (uint8_t)((ee0xa06 & 0x3800u) >> 11U)
/** MS_TR_LIN_SLEWRATE : LIN slewrate trimming */
#define EE_MS_TR_LIN_SLEWRATE_GET() \
    (uint8_t)((ee0xa06 & 0x0700u) >> 8U)
/** MS_TR_RCO1M : RCO 1MHz trimming */
#define EE_MS_TR_RCO1M_GET() \
    (uint8_t)((ee0xa06 & 0x00ffu) >> 0U)
/** MS_TRIM3 : SAR ADC: adc_sar_tr_adcref1 ((ADC refs 1+2); ECADC: Calibration factor CORR[15:0] */
#define EE_MS_TRIM3_GET() \
    (uint16_t)((ee0xa08 & 0xffffu) >> 0U)
/** TR_ADCREF2 : Option SAR ADC: reference trimming for xxx V */
#define EE_TR_ADCREF2_GET() \
    (uint8_t)((ee0xa08 & 0x3f80u) >> 7U)
/** TR_ADCREF1 : Option SAR ADC:  reference trimming for xxx V, */
#define EE_TR_ADCREF1_GET() \
    (uint8_t)((ee0xa08 & 0x007fu) >> 0U)
/** CORR_15_0 : Option ECADC: Calibration bits CORR[15:0] */
#define EE_CORR_15_0_GET() \
    (uint16_t)((ee0xa08 & 0xffffu) >> 0U)
/** MS_TRIM4 : SAR ADC: adc_sar_tr_adcref3 (ADC ref 3); ECADC: Calibration factor CORR[31:16] */
#define EE_MS_TRIM4_GET() \
    (uint16_t)((ee0xa0a & 0xffffu) >> 0U)
/** TR_ADCREF3 : Option SAR ADC: reference trimming for xxx V */
#define EE_TR_ADCREF3_GET() \
    (uint8_t)((ee0xa0a & 0x007fu) >> 0U)
/** CORR_31_16 : Option ECADC: Calibration bits CORR[31:16] */
#define EE_CORR_31_16_GET() \
    (uint16_t)((ee0xa0a & 0xffffu) >> 0U)
/** MS_TRIM5 : SAR ADC: trim_vdd_ext (second regulator vddio) ; ECADC: Calibration factor CORR[46:32] */
#define EE_MS_TRIM5_GET() \
    (uint16_t)((ee0xa0c & 0xffffu) >> 0U)
/** LOCK_MS_TRIM5 : Option SAR ADC - lock bit of trim port, not used for ECADC */
#define EE_LOCK_MS_TRIM5_GET() \
    (uint8_t)((ee0xa0c & 0x8000u) >> 15U)
/** MS_TR_VDDIO : Option SAR ADC - trimming for second regulator 5V */
#define EE_MS_TR_VDDIO_GET() \
    (uint8_t)((ee0xa0c & 0x0007u) >> 0U)
/** CORR_46_32 : Option ECADC: Calibration bits CORR[46:32] */
#define EE_CORR_46_32_GET() \
    (uint16_t)((ee0xa0c & 0x7fffu) >> 0U)
/** MS_TRIM6 : speed1 setting for 24/12 MHz */
#define EE_MS_TRIM6_GET() \
    (uint16_t)((ee0xa0e & 0xffffu) >> 0U)
/** EE_AC_SL_WAIT_OPTION_SPEED1 : SPEED1 - RCO trimming, 24/12MHz, ac_sl option for ee wait states */
#define EE_EE_AC_SL_WAIT_OPTION_SPEED1_GET() \
    (uint8_t)((ee0xa0e & 0x8000u) >> 15U)
/** FL_AC_SL_WAIT_OPTION_SPEED1 : ac_sl option for flash wait states */
#define EE_FL_AC_SL_WAIT_OPTION_SPEED1_GET() \
    (uint8_t)((ee0xa0e & 0x4000u) >> 14U)
/** FL_WAIT_STATES_P_SPEED1 : encoded flash wait states, (values {0,1,2,3} map to FL_WAIT_STATES=FL_AC_ SL_OPTION? {1,2,3,4} : {1,1,2,3} ) */
#define EE_FL_WAIT_STATES_P_SPEED1_GET() \
    (uint8_t)((ee0xa0e & 0x3000u) >> 12U)
/** EE_WAIT_STATES_P_SPEED1 : encoded ee wait states, (values {0,1,2,3} map to EE_WAIT_STATES=EE_AC_ SL_OPTION? {4,5,6,7} : {3,4,5,6} ) */
#define EE_EE_WAIT_STATES_P_SPEED1_GET() \
    (uint8_t)((ee0xa0e & 0x0c00u) >> 10U)
/** TR_RCO32M_IN_SPEED1 : RC oscillator trim code */
#define EE_TR_RCO32M_IN_SPEED1_GET() \
    (uint16_t)((ee0xa0e & 0x03ffu) >> 0U)
/** MS_TRIM7 : speed2 setting for 28/14 MHz */
#define EE_MS_TRIM7_GET() \
    (uint16_t)((ee0xa10 & 0xffffu) >> 0U)
/** EE_AC_SL_WAIT_OPTION_SPEED2 : SPEED2 - RCO trimming, 28/14MHz */
#define EE_EE_AC_SL_WAIT_OPTION_SPEED2_GET() \
    (uint8_t)((ee0xa10 & 0x8000u) >> 15U)
/** FL_AC_SL_WAIT_OPTION_SPEED2 :  */
#define EE_FL_AC_SL_WAIT_OPTION_SPEED2_GET() \
    (uint8_t)((ee0xa10 & 0x4000u) >> 14U)
/** FL_WAIT_STATES_P_SPEED2 :  */
#define EE_FL_WAIT_STATES_P_SPEED2_GET() \
    (uint8_t)((ee0xa10 & 0x3000u) >> 12U)
/** EE_WAIT_STATES_P_SPEED2 :  */
#define EE_EE_WAIT_STATES_P_SPEED2_GET() \
    (uint8_t)((ee0xa10 & 0x0c00u) >> 10U)
/** TR_RCO32M_IN_SPEED2 :  */
#define EE_TR_RCO32M_IN_SPEED2_GET() \
    (uint16_t)((ee0xa10 & 0x03ffu) >> 0U)
/** MS_TRIM8 : speed3 setting for 32/16 MHz */
#define EE_MS_TRIM8_GET() \
    (uint16_t)((ee0xa12 & 0xffffu) >> 0U)
/** EE_AC_SL_WAIT_OPTION_SPEED3 : SPEED3 - RCO trimming, 32/16MHz */
#define EE_EE_AC_SL_WAIT_OPTION_SPEED3_GET() \
    (uint8_t)((ee0xa12 & 0x8000u) >> 15U)
/** FL_AC_SL_WAIT_OPTION_SPEED3 :  */
#define EE_FL_AC_SL_WAIT_OPTION_SPEED3_GET() \
    (uint8_t)((ee0xa12 & 0x4000u) >> 14U)
/** FL_WAIT_STATES_P_SPEED3 :  */
#define EE_FL_WAIT_STATES_P_SPEED3_GET() \
    (uint8_t)((ee0xa12 & 0x3000u) >> 12U)
/** EE_WAIT_STATES_P_SPEED3 :  */
#define EE_EE_WAIT_STATES_P_SPEED3_GET() \
    (uint8_t)((ee0xa12 & 0x0c00u) >> 10U)
/** TR_RCO32M_IN_SPEED3 :  */
#define EE_TR_RCO32M_IN_SPEED3_GET() \
    (uint16_t)((ee0xa12 & 0x03ffu) >> 0U)
/** NV_TRIM0 : R2_EE */
#define EE_NV_TRIM0_GET() \
    (uint16_t)((ee0xa14 & 0xffffu) >> 0U)
/** R2_EE : R2_EE */
#define EE_R2_EE_GET() \
    (uint16_t)((ee0xa14 & 0xffffu) >> 0U)
/** TSENSE : Sense time settings */
#define EE_TSENSE_GET() \
    (uint8_t)((ee0xa14 & 0x7000u) >> 12U)
/** TRDY : Ready signal delay settings */
#define EE_TRDY_GET() \
    (uint8_t)((ee0xa14 & 0x0c00u) >> 10U)
/** TPRE : Precharge delay settings */
#define EE_TPRE_GET() \
    (uint8_t)((ee0xa14 & 0x0300u) >> 8U)
/** EN_VMG : VMG voltage to memory gates */
#define EE_EN_VMG_GET() \
    (uint8_t)((ee0xa14 & 0x0080u) >> 7U)
/** EN_VMG_CT : enable VMGM margin voltage at CSA */
#define EE_EN_VMG_CT_GET() \
    (uint8_t)((ee0xa14 & 0x0040u) >> 6U)
/** EN_VMG_TT : enable VMGM margin voltage at MSA */
#define EE_EN_VMG_TT_GET() \
    (uint8_t)((ee0xa14 & 0x0020u) >> 5U)
/** SW_VMGM_EE : VMG margin voltage (VMGM) */
#define EE_SW_VMGM_EE_GET() \
    (uint8_t)((ee0xa14 & 0x001fu) >> 0U)
/** NV_TRIM1 : R1_EE */
#define EE_NV_TRIM1_GET() \
    (uint16_t)((ee0xa16 & 0xffffu) >> 0U)
/** R1_EE : R1_EE */
#define EE_R1_EE_GET() \
    (uint16_t)((ee0xa16 & 0xffffu) >> 0U)
/** REG_1_RES : register, reserve */
#define EE_REG_1_RES_GET() \
    (uint8_t)((ee0xa16 & 0x8000u) >> 15U)
/** CP_CLK_DIV : CP clock divider */
#define EE_CP_CLK_DIV_GET() \
    (uint8_t)((ee0xa16 & 0x6000u) >> 13U)
/** EE_CP_SC_FL : disable second CP chain */
#define EE_EE_CP_SC_FL_GET() \
    (uint8_t)((ee0xa16 & 0x1000u) >> 12U)
/** SEL_ODD : select odd cells in CS / MA */
#define EE_SEL_ODD_GET() \
    (uint8_t)((ee0xa16 & 0x0800u) >> 11U)
/** SEL_EVEN : select even cells in CS / MA */
#define EE_SEL_EVEN_GET() \
    (uint8_t)((ee0xa16 & 0x0400u) >> 10U)
/** SEL_CS : select CS */
#define EE_SEL_CS_GET() \
    (uint8_t)((ee0xa16 & 0x0200u) >> 9U)
/** SEL_MA : select MA */
#define EE_SEL_MA_GET() \
    (uint8_t)((ee0xa16 & 0x0100u) >> 8U)
/** TR_PCP1_W_EE : EEPROM program voltage */
#define EE_TR_PCP1_W_EE_GET() \
    (uint8_t)((ee0xa16 & 0x00f0u) >> 4U)
/** TR_PCP1_E_EE : EEPROM erase voltage */
#define EE_TR_PCP1_E_EE_GET() \
    (uint8_t)((ee0xa16 & 0x000fu) >> 0U)
/** NV_TRIM2 : R3_FL */
#define EE_NV_TRIM2_GET() \
    (uint16_t)((ee0xa18 & 0xffffu) >> 0U)
/** R3_FL : R3_FL */
#define EE_R3_FL_GET() \
    (uint16_t)((ee0xa18 & 0xffffu) >> 0U)
/** SW_VCTAT : Flash 32k : SW_VCTAT[1:0], set VCTAT voltage */
#define EE_SW_VCTAT_GET() \
    (uint8_t)((ee0xa18 & 0xc000u) >> 14U)
/** VCTAT_EN : Flash 32k : VCTAT_EN  - activate VCTAT voltage; */
#define EE_VCTAT_EN_GET() \
    (uint8_t)((ee0xa18 & 0x2000u) >> 13U)
/** EN_IREF1_BL : Flash 32k : EN_IREF1_BL  -  Enable pmos reference current (BL); */
#define EE_EN_IREF1_BL_GET() \
    (uint8_t)((ee0xa18 & 0x1000u) >> 12U)
/** EN_IREF1_BLR : Flash 32k : EN_IREF1_BLR  -  Enable pmos reference current (BLR); */
#define EE_EN_IREF1_BLR_GET() \
    (uint8_t)((ee0xa18 & 0x0800u) >> 11U)
/** VPTAT_EN : Flash 32k: VPTAT_EN  -  Enable VPTAT voltage; */
#define EE_VPTAT_EN_GET() \
    (uint8_t)((ee0xa18 & 0x0400u) >> 10U)
/** YD : Flash 32k: Enable dummy bitline 1:0 */
#define EE_YD_GET() \
    (uint8_t)((ee0xa18 & 0x0300u) >> 8U)
/** BLRES_ENA_1 : Flash 32k : BLRES_ENA[1]  -  Enable bitline reset; */
#define EE_BLRES_ENA_1_GET() \
    (uint8_t)((ee0xa18 & 0x0080u) >> 7U)
/** TSEN : Flash 32K : TSEN - Sense time; */
#define EE_TSEN_GET() \
    (uint8_t)((ee0xa18 & 0x0070u) >> 4U)
/** BLRES_ENA_0 : Flash 32k : BLRES_ENA[0] - Enable bitline reset; */
#define EE_BLRES_ENA_0_GET() \
    (uint8_t)((ee0xa18 & 0x0008u) >> 3U)
/** TPRECH : Flash 32k : TPRECH - Pre-charge time; */
#define EE_TPRECH_GET() \
    (uint8_t)((ee0xa18 & 0x0007u) >> 0U)
/** SW_VCTAT_64 : Flash 64k : SW_VCTAT[3:0], set VCTAT voltage */
#define EE_SW_VCTAT_64_GET() \
    (uint8_t)((ee0xa18 & 0xf000u) >> 12U)
/** EN_IREF_BL_64 : Flash 64k : EN_IREF_BL  -  Enable pmos reference current (BL); */
#define EE_EN_IREF_BL_64_GET() \
    (uint8_t)((ee0xa18 & 0x0800u) >> 11U)
/** EN_IREF_BLR_64 : Flash 64k : EN_IREF_BLR  -  Enable pmos reference current (BLR); */
#define EE_EN_IREF_BLR_64_GET() \
    (uint8_t)((ee0xa18 & 0x0400u) >> 10U)
/** YD_64 : Flash 64k: Enable dummy bitline 1:0 */
#define EE_YD_64_GET() \
    (uint8_t)((ee0xa18 & 0x0300u) >> 8U)
/** TSEN_64 : Flash 64k : TSEN - Sense time */
#define EE_TSEN_64_GET() \
    (uint8_t)((ee0xa18 & 0x00e0u) >> 5U)
/** TPRECH_64 : Flash 64k : TPRECH - Pre-charge time; */
#define EE_TPRECH_64_GET() \
    (uint8_t)((ee0xa18 & 0x001cu) >> 2U)
/** TINIT_64 : Flash 64k : TINIT - Init read timing */
#define EE_TINIT_64_GET() \
    (uint8_t)((ee0xa18 & 0x0003u) >> 0U)
/** NV_TRIM3 : R2_FL */
#define EE_NV_TRIM3_GET() \
    (uint16_t)((ee0xa1a & 0xffffu) >> 0U)
/** R2_FL : R2_FL */
#define EE_R2_FL_GET() \
    (uint16_t)((ee0xa1a & 0xffffu) >> 0U)
/** T_MEAS : Flash 32k: T_MEAS[3:0]; Flash 64k: T_MEAS[4:1] - measurement test modes */
#define EE_T_MEAS_GET() \
    (uint8_t)((ee0xa1a & 0xf000u) >> 12U)
/** SW_IREF_X2 : Flash 32k: double IREF for margin mode; Flash 64k: T_MEAS[0] */
#define EE_SW_IREF_X2_GET() \
    (uint8_t)((ee0xa1a & 0x0800u) >> 11U)
/** SW_IREF : set IREF for margin mode */
#define EE_SW_IREF_GET() \
    (uint8_t)((ee0xa1a & 0x07e0u) >> 5U)
/** SW_VMG : VMG voltage Flash and EEPROM */
#define EE_SW_VMG_GET() \
    (uint8_t)((ee0xa1a & 0x001fu) >> 0U)
/** NV_TRIM4 : R1_FL */
#define EE_NV_TRIM4_GET() \
    (uint16_t)((ee0xa1c & 0xffffu) >> 0U)
/** R1_FL : R1_FL */
#define EE_R1_FL_GET() \
    (uint16_t)((ee0xa1c & 0xffffu) >> 0U)
/** DIS_ALL_MG : disable all MG */
#define EE_DIS_ALL_MG_GET() \
    (uint8_t)((ee0xa1c & 0x8000u) >> 15U)
/** WNV_MODE : write modes */
#define EE_WNV_MODE_GET() \
    (uint8_t)((ee0xa1c & 0x7000u) >> 12U)
/** CP_DIS_SG : disable SG CP */
#define EE_CP_DIS_SG_GET() \
    (uint8_t)((ee0xa1c & 0x0800u) >> 11U)
/** CP_SC_FL : disable second CP chain */
#define EE_CP_SC_FL_GET() \
    (uint8_t)((ee0xa1c & 0x0400u) >> 10U)
/** ERA_MODE : erase modes */
#define EE_ERA_MODE_GET() \
    (uint8_t)((ee0xa1c & 0x0300u) >> 8U)
/** TR_PCP1_W_FL : Flash program voltage */
#define EE_TR_PCP1_W_FL_GET() \
    (uint8_t)((ee0xa1c & 0x00f0u) >> 4U)
/** TR_PCP1_E_FL : Flash Erase voltage */
#define EE_TR_PCP1_E_FL_GET() \
    (uint8_t)((ee0xa1c & 0x000fu) >> 0U)
/** NV_TRIM5 : EEPROM read timing port */
#define EE_NV_TRIM5_GET() \
    (uint16_t)((ee0xa1e & 0xffffu) >> 0U)
/** EE_LOCK_RD : lock this port */
#define EE_EE_LOCK_RD_GET() \
    (uint8_t)((ee0xa1e & 0x8000u) >> 15U)
/** EE_WAIT_STATES
 * (EE_WAIT_STATES +1) is the number of clock pulses to have a stable read data
 * Ready delay = (EE_WAIT_STATES + 2) * MCU_CLK
 */
#define EE_EE_WAIT_STATES_GET() \
    (uint8_t)((ee0xa1e & 0x0f00u) >> 8U)
/** EE_HALT_BEHAVIOR : Define the EEPROM behavior when application is halted */
#define EE_EE_HALT_BEHAVIOR_GET() \
    (uint8_t)((ee0xa1e & 0x0003u) >> 0U)
/** NV_TRIM6 : EEPROM program cycle port */
#define EE_NV_TRIM6_GET() \
    (uint16_t)((ee0xa20 & 0xffffu) >> 0U)
/** EE_PROGRAM_CYCLE_LOCK : lock this port */
#define EE_EE_PROGRAM_CYCLE_LOCK_GET() \
    (uint8_t)((ee0xa20 & 0x8000u) >> 15U)
/** EE_PROGRAM_CYCLE
 * This field defined the number of program cycles needed for writing a word in the EEPROM
 * Number of program cycles = EE_PROGRAM_CYCLE + 1
 */
#define EE_EE_PROGRAM_CYCLE_GET() \
    (uint8_t)((ee0xa20 & 0x001fu) >> 0U)
/** NV_TRIM7 : EEPROM erase timing */
#define EE_NV_TRIM7_GET() \
    (uint16_t)((ee0xa22 & 0xffffu) >> 0U)
/** EE_LOCK_ER : lock this port */
#define EE_EE_LOCK_ER_GET() \
    (uint8_t)((ee0xa22 & 0x8000u) >> 15U)
/** EE_ER_TIME : Erase time = (EE_ER_TIME + 1) * 100us */
#define EE_EE_ER_TIME_GET() \
    (uint8_t)((ee0xa22 & 0x003fu) >> 0U)
/** NV_TRIM8 : EEPROM write timing */
#define EE_NV_TRIM8_GET() \
    (uint16_t)((ee0xa24 & 0xffffu) >> 0U)
/** EE_LOCK_WR : lock this port */
#define EE_EE_LOCK_WR_GET() \
    (uint8_t)((ee0xa24 & 0x8000u) >> 15U)
/** EE_WR_TIME : Write time = (EE_WR_TIME + 1) * 10us */
#define EE_EE_WR_TIME_GET() \
    (uint8_t)((ee0xa24 & 0x7f00u) >> 8U)
/** EE_PRE_WR_TIME : Pre-Write time = (EE_PRE_WR_TIME + 1) * 10us */
#define EE_EE_PRE_WR_TIME_GET() \
    (uint8_t)((ee0xa24 & 0x007fu) >> 0U)
/** NV_TRIM9 : Flash read configuration word */
#define EE_NV_TRIM9_GET() \
    (uint16_t)((ee0xa26 & 0xffffu) >> 0U)
/** FL_LOCK_RDY : lock this port */
#define EE_FL_LOCK_RDY_GET() \
    (uint8_t)((ee0xa26 & 0x8000u) >> 15U)
/** FL_HALT_BEHAVIOR : Define the flash behavior when application is halted */
#define EE_FL_HALT_BEHAVIOR_GET() \
    (uint8_t)((ee0xa26 & 0x3000u) >> 12U)
/** FL_DED_RETRY : number of re-try in case of Double Error Detect (DED) */
#define EE_FL_DED_RETRY_GET() \
    (uint8_t)((ee0xa26 & 0x0700u) >> 8U)
/** FL_PREDICTION_BEHAVIOR : Define the behavior of the flash prediction */
#define EE_FL_PREDICTION_BEHAVIOR_GET() \
    (uint8_t)((ee0xa26 & 0x00c0u) >> 6U)
/** FL_BYPASS_QUEUE : Define if Queue is used */
#define EE_FL_BYPASS_QUEUE_GET() \
    (uint8_t)((ee0xa26 & 0x0010u) >> 4U)
/** FL_WAIT_STATES : Number of clock pulses between the read access start and the wishbone READY rising edge. */
#define EE_FL_WAIT_STATES_GET() \
    (uint8_t)((ee0xa26 & 0x0007u) >> 0U)
/** NV_TRIM10 : Flash erase/write timing */
#define EE_NV_TRIM10_GET() \
    (uint16_t)((ee0xa28 & 0xffffu) >> 0U)
/** FL_LOCK_ER_WR : lock this port */
#define EE_FL_LOCK_ER_WR_GET() \
    (uint8_t)((ee0xa28 & 0x8000u) >> 15U)
/** FL_WR_TIME : Write time = (FL_WR_TIME + 1) * 100us */
#define EE_FL_WR_TIME_GET() \
    (uint8_t)((ee0xa28 & 0x7f00u) >> 8U)
/** FL_ER_TIME : Erase time = (FL_ER_TIME + 1) * 100us */
#define EE_FL_ER_TIME_GET() \
    (uint8_t)((ee0xa28 & 0x00ffu) >> 0U)
/** NV_TRIM11 : Timing Port2 */
#define EE_NV_TRIM11_GET() \
    (uint16_t)((ee0xa2a & 0xffffu) >> 0U)
/** LOCK_T_1US : lock this port */
#define EE_LOCK_T_1US_GET() \
    (uint8_t)((ee0xa2a & 0x8000u) >> 15U)
/** R3_FL_FLASH_15_13 : R3_FL[15:13] = VCTAT enable for flash (starting from Flash 1.4) */
#define EE_R3_FL_FLASH_15_13_GET() \
    (uint8_t)((ee0xa2a & 0x0e00u) >> 9U)
/** T_1US : control the 1us time in the flash shell */
#define EE_T_1US_GET() \
    (uint8_t)((ee0xa2a & 0x001fu) >> 0U)
/** NV_TRIM12 : Timing Port1 */
#define EE_NV_TRIM12_GET() \
    (uint16_t)((ee0xa2c & 0xffffu) >> 0U)
/** LOCK_T : lock this port */
#define EE_LOCK_T_GET() \
    (uint8_t)((ee0xa2c & 0x8000u) >> 15U)
/** T_50US : control the 50us time in the flash shell */
#define EE_T_50US_GET() \
    (uint8_t)((ee0xa2c & 0x7c00u) >> 10U)
/** T_10US : control the 10us time in the flash shell */
#define EE_T_10US_GET() \
    (uint8_t)((ee0xa2c & 0x03e0u) >> 5U)
/** T_50NS : control the 50ns time in the flash shell */
#define EE_T_50NS_GET() \
    (uint8_t)((ee0xa2c & 0x001cu) >> 2U)
/** T_10NS : control the 10ns time in the flash shell */
#define EE_T_10NS_GET() \
    (uint8_t)((ee0xa2c & 0x0001u) >> 0U)
/** NV_TRIM13 : NV memory, open */
#define EE_NV_TRIM13_GET() \
    (uint16_t)((ee0xa2e & 0xffffu) >> 0U)
/** CHIPID0 : Chip ID0 readable by application - copy of MLX TestChipId0 */
#define EE_CHIPID0_GET() \
    (uint16_t)((ee0xa30 & 0xffffu) >> 0U)
/** APP_D_YPOS_ID : Copy of TEST_CHIP_ID0 */
#define EE_APP_D_YPOS_ID_GET() \
    (uint8_t)((ee0xa30 & 0xff00u) >> 8U)
/** APP_D_XPOS_ID : Copy of TEST_CHIP_ID0 */
#define EE_APP_D_XPOS_ID_GET() \
    (uint8_t)((ee0xa30 & 0x00ffu) >> 0U)
/** CHIPID1 : Chip ID1 readable by application - copy of MLX TestChipId1 */
#define EE_CHIPID1_GET() \
    (uint16_t)((ee0xa32 & 0xffffu) >> 0U)
/** APP_D_LOT_ID_H : Copy of TEST_CHIP_ID1 */
#define EE_APP_D_LOT_ID_H_GET() \
    (uint16_t)((ee0xa32 & 0xffe0u) >> 5U)
/** APP_D_WFR_ID : Copy of TEST_CHIP_ID1 */
#define EE_APP_D_WFR_ID_GET() \
    (uint8_t)((ee0xa32 & 0x001fu) >> 0U)
/** CHIPID2 : Copy of TEST_CHIP_ID2 */
#define EE_CHIPID2_GET() \
    (uint16_t)((ee0xa34 & 0xffffu) >> 0U)
/** APP_D_CORDAT6_ID : Chip ID2 readable by application - copy of MLX TestChipId2 */
#define EE_APP_D_CORDAT6_ID_GET() \
    (uint8_t)((ee0xa34 & 0xfc00u) >> 10U)
/** APP_D_FAB_ID : Copy of TEST_CHIP_ID2 */
#define EE_APP_D_FAB_ID_GET() \
    (uint8_t)((ee0xa34 & 0x03c0u) >> 6U)
/** APP_D_LOT_ID_L : Copy of TEST_CHIP_ID2 */
#define EE_APP_D_LOT_ID_L_GET() \
    (uint8_t)((ee0xa34 & 0x003fu) >> 0U)
/** PROJECT_ID : Copy of Hardware Project ID (high byte: project identifier, low byte: version) */
#define EE_PROJECT_ID_GET() \
    (uint16_t)((ee0xa36 & 0xffffu) >> 0U)
/** CHIPID3 : Copy of TEST_CHIP_ID3 */
#define EE_CHIPID3_GET() \
    (uint16_t)((ee0xa36 & 0xffffu) >> 0U)
/** APP_PROJECT_ID : Unique PROJECT_ID for software use */
#define EE_APP_PROJECT_ID_GET() \
    (uint16_t)((ee0xa36 & 0xffffu) >> 0U)
/** TESTCHIPID0 : MLX TestChipID0 created by test program */
#define EE_TESTCHIPID0_GET() \
    (uint16_t)((ee0xa38 & 0xffffu) >> 0U)
/** MLX_ID0 : Melexis IC test identification data */
#define EE_MLX_ID0_GET() \
    (uint16_t)((ee0xa38 & 0xffffu) >> 0U)
/** D_CHIP_ID : Melexis IC test identification data D_CHIP ID[20:0] */
#define EE_D_CHIP_ID_GET() \
    (uint16_t)((ee0xa38 & 0x1fffffu) >> 0U)
/** D_YPOS_ID : Y position */
#define EE_D_YPOS_ID_GET() \
    (uint8_t)((ee0xa38 & 0xff00u) >> 8U)
/** D_XPOS_ID : X position */
#define EE_D_XPOS_ID_GET() \
    (uint8_t)((ee0xa38 & 0x00ffu) >> 0U)
/** TESTCHIPID1 : MLX TestChipId1 created by test program */
#define EE_TESTCHIPID1_GET() \
    (uint16_t)((ee0xa3a & 0xffffu) >> 0U)
/** MLX_ID1 : Melexis IC test identification data */
#define EE_MLX_ID1_GET() \
    (uint16_t)((ee0xa3a & 0xffffu) >> 0U)
/** D_LOT_ID : Lot Number */
#define EE_D_LOT_ID_GET() \
    (uint16_t)((ee0xa3a & 0x3fffe0u) >> 5U)
/** D_LOT_ID_LSB11 : Lot Number [10:0] */
#define EE_D_LOT_ID_LSB11_GET() \
    (uint16_t)((ee0xa3a & 0xffe0u) >> 5U)
/** D_WFR_ID : Wafer number */
#define EE_D_WFR_ID_GET() \
    (uint8_t)((ee0xa3a & 0x001fu) >> 0U)
/** TESTCHIPID2 : MLX TestChipId2 created by test program */
#define EE_TESTCHIPID2_GET() \
    (uint16_t)((ee0xa3c & 0xffffu) >> 0U)
/** MLX_ID2 : Melexis IC test identification data */
#define EE_MLX_ID2_GET() \
    (uint16_t)((ee0xa3c & 0xffffu) >> 0U)
/** D_CORDAT_ID : Melexis IC test identification data */
#define EE_D_CORDAT_ID_GET() \
    (uint8_t)((ee0xa3c & 0xfc00u) >> 10U)
/** D_FAB_ID : FAB id number */
#define EE_D_FAB_ID_GET() \
    (uint8_t)((ee0xa3c & 0x03c0u) >> 6U)
/** D_LOT_ID_MSB6 : Lot Number [16:11] */
#define EE_D_LOT_ID_MSB6_GET() \
    (uint8_t)((ee0xa3c & 0x003fu) >> 0U)
/** TESTCHIPID3 : Hardware Project ID (high byte: project identifier, low byte: version) */
#define EE_TESTCHIPID3_GET() \
    (uint16_t)((ee0xa3e & 0xffffu) >> 0U)
/** TEST_PROJECT_ID : Hardware Project ID (high byte: project identifier, low byte: version) */
#define EE_TEST_PROJECT_ID_GET() \
    (uint16_t)((ee0xa3e & 0xffffu) >> 0U)

/*****************************************************************************/
/* 3.3 Fields. */

/**
 * Description of the records from left to right:
 * EE, underscore, field name.
 * Hosting variable.
 * Absolute word address of the field. Also location of the host variable.
 * Absolute byte address of the field.
 * Bit mask, showing the meaningful bits of the field inside the host.
 * Offset, shows the location of the first significant bit of the mask.
 * Boolean true (1U) or false (0U), showing whether the field is writable.
 * Triboolean, showing whether the field is bit accessible i.e. the assembler
 *    operation setb, clrb and mov c can be used for it. The value 2U is
 *    reserved for MlxCCT's private dummy fields.
 * Bit mask, showing which bits of the host variable are not occupied.
 */

/** PATCH_LEN - High byte : PATCH Length */
#define EE_PATCH_LEN \
    ee0x800, (MEM_EEPROM_START + 0x0000u), (MEM_EEPROM_START + 0x0000u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** PATCH_CRC - Low byte : Calculated CRC over patch addresses */
#define EE_PATCH_CRC \
    ee0x800, (MEM_EEPROM_START + 0x0000u), (MEM_EEPROM_START + 0x0000u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** PATCH_ID - ID of the patch */
#define EE_PATCH_ID \
    ee0x802, (MEM_EEPROM_START + 0x0002u), (MEM_EEPROM_START + 0x0002u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH0_ADR - DEBUG_ADR0 (patch addr) + enable (LSB, ports DEBUG_ADR , DEBUG_DATA, DEBUG_CTRL  only written when LSB=1) (DEBUG_CTRL0=0x0410 fixed) */
#define EE_PATCH0_ADR \
    ee0x804, (MEM_EEPROM_START + 0x0004u), (MEM_EEPROM_START + 0x0004u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH0_DATA - DEBUG_DATA0 (replacement instr) */
#define EE_PATCH0_DATA \
    ee0x806, (MEM_EEPROM_START + 0x0006u), (MEM_EEPROM_START + 0x0006u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH1_ADR - DEBUG_ADR1 (patch addr) + enable (LSB, ports DEBUG_ADR , DEBUG_DATA, DEBUG_CTRL  only written when LSB=1) (DEBUG_CTRL0=0x0410 fixed) */
#define EE_PATCH1_ADR \
    ee0x808, (MEM_EEPROM_START + 0x0008u), (MEM_EEPROM_START + 0x0008u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH1_DATA - DEBUG_DATA1 (replacement instr) */
#define EE_PATCH1_DATA \
    ee0x80a, (MEM_EEPROM_START + 0x000au), (MEM_EEPROM_START + 0x000au), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH2_ADR - DEBUG_ADR2 (patch addr) + enable (LSB, ports DEBUG_ADR , DEBUG_DATA, DEBUG_CTRL  only written when LSB=1) (DEBUG_CTRL0=0x0410 fixed) */
#define EE_PATCH2_ADR \
    ee0x80c, (MEM_EEPROM_START + 0x000cu), (MEM_EEPROM_START + 0x000cu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH2_DATA - DEBUG_DATA2 (replacement instr) */
#define EE_PATCH2_DATA \
    ee0x80e, (MEM_EEPROM_START + 0x000eu), (MEM_EEPROM_START + 0x000eu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE00 - patch code in EEPROM */
#define EE_PATCH_CODE00 \
    ee0x810, (MEM_EEPROM_START + 0x0010u), (MEM_EEPROM_START + 0x0010u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE01 - patch code in EEPROM */
#define EE_PATCH_CODE01 \
    ee0x812, (MEM_EEPROM_START + 0x0012u), (MEM_EEPROM_START + 0x0012u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE02 - patch code in EEPROM */
#define EE_PATCH_CODE02 \
    ee0x814, (MEM_EEPROM_START + 0x0014u), (MEM_EEPROM_START + 0x0014u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE03 - patch code in EEPROM */
#define EE_PATCH_CODE03 \
    ee0x816, (MEM_EEPROM_START + 0x0016u), (MEM_EEPROM_START + 0x0016u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE04 - patch code in EEPROM */
#define EE_PATCH_CODE04 \
    ee0x818, (MEM_EEPROM_START + 0x0018u), (MEM_EEPROM_START + 0x0018u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE05 - patch code in EEPROM */
#define EE_PATCH_CODE05 \
    ee0x81a, (MEM_EEPROM_START + 0x001au), (MEM_EEPROM_START + 0x001au), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE06 - patch code in EEPROM */
#define EE_PATCH_CODE06 \
    ee0x81c, (MEM_EEPROM_START + 0x001cu), (MEM_EEPROM_START + 0x001cu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE07 - patch code in EEPROM */
#define EE_PATCH_CODE07 \
    ee0x81e, (MEM_EEPROM_START + 0x001eu), (MEM_EEPROM_START + 0x001eu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE08 - patch code in EEPROM */
#define EE_PATCH_CODE08 \
    ee0x820, (MEM_EEPROM_START + 0x0020u), (MEM_EEPROM_START + 0x0020u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE09 - patch code in EEPROM */
#define EE_PATCH_CODE09 \
    ee0x822, (MEM_EEPROM_START + 0x0022u), (MEM_EEPROM_START + 0x0022u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE10 - patch code in EEPROM */
#define EE_PATCH_CODE10 \
    ee0x824, (MEM_EEPROM_START + 0x0024u), (MEM_EEPROM_START + 0x0024u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE11 - patch code in EEPROM */
#define EE_PATCH_CODE11 \
    ee0x826, (MEM_EEPROM_START + 0x0026u), (MEM_EEPROM_START + 0x0026u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE12 - patch code in EEPROM */
#define EE_PATCH_CODE12 \
    ee0x828, (MEM_EEPROM_START + 0x0028u), (MEM_EEPROM_START + 0x0028u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE13 - patch code in EEPROM */
#define EE_PATCH_CODE13 \
    ee0x82a, (MEM_EEPROM_START + 0x002au), (MEM_EEPROM_START + 0x002au), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE14 - patch code in EEPROM */
#define EE_PATCH_CODE14 \
    ee0x82c, (MEM_EEPROM_START + 0x002cu), (MEM_EEPROM_START + 0x002cu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE15 - patch code in EEPROM */
#define EE_PATCH_CODE15 \
    ee0x82e, (MEM_EEPROM_START + 0x002eu), (MEM_EEPROM_START + 0x002eu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE16 - patch code in EEPROM */
#define EE_PATCH_CODE16 \
    ee0x830, (MEM_EEPROM_START + 0x0030u), (MEM_EEPROM_START + 0x0030u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE17 - patch code in EEPROM */
#define EE_PATCH_CODE17 \
    ee0x832, (MEM_EEPROM_START + 0x0032u), (MEM_EEPROM_START + 0x0032u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE18 - patch code in EEPROM */
#define EE_PATCH_CODE18 \
    ee0x834, (MEM_EEPROM_START + 0x0034u), (MEM_EEPROM_START + 0x0034u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE19 - patch code in EEPROM */
#define EE_PATCH_CODE19 \
    ee0x836, (MEM_EEPROM_START + 0x0036u), (MEM_EEPROM_START + 0x0036u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE20 - patch code in EEPROM */
#define EE_PATCH_CODE20 \
    ee0x838, (MEM_EEPROM_START + 0x0038u), (MEM_EEPROM_START + 0x0038u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE21 - patch code in EEPROM */
#define EE_PATCH_CODE21 \
    ee0x83a, (MEM_EEPROM_START + 0x003au), (MEM_EEPROM_START + 0x003au), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE22 - patch code in EEPROM */
#define EE_PATCH_CODE22 \
    ee0x83c, (MEM_EEPROM_START + 0x003cu), (MEM_EEPROM_START + 0x003cu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** PATCH_CODE23 - patch code in EEPROM */
#define EE_PATCH_CODE23 \
    ee0x83e, (MEM_EEPROM_START + 0x003eu), (MEM_EEPROM_START + 0x003eu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM0 - {TempMid[7:0], CalibCRC_EE[7:0]} */
#define EE_APP_TRIM0 \
    ee0x9b0, (MEM_EEPROM_START + 0x01b0u), (MEM_EEPROM_START + 0x01b0u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** TEMPMID - Middle Temperature used in production (mostly probing1 = 35degC) (copy at 09B6) */
#define EE_TEMPMID \
    ee0x9b0, (MEM_EEPROM_START + 0x01b0u), (MEM_EEPROM_START + 0x01b0u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** CALIBCRC - 8bit EEPROM calibration area CRC ( sum with carry ) */
#define EE_CALIBCRC \
    ee0x9b0, (MEM_EEPROM_START + 0x01b0u), (MEM_EEPROM_START + 0x01b0u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM1 - reserved[15:0] */
#define EE_APP_TRIM1 \
    ee0x9b2, (MEM_EEPROM_START + 0x01b2u), (MEM_EEPROM_START + 0x01b2u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM2 - OTempCal_EE[15:0] */
#define EE_APP_TRIM2 \
    ee0x9b4, (MEM_EEPROM_START + 0x01b4u), (MEM_EEPROM_START + 0x01b4u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** OTEMPCAL - Temperature Sensor Offset , 16bit unsigned */
#define EE_OTEMPCAL \
    ee0x9b4, (MEM_EEPROM_START + 0x01b4u), (MEM_EEPROM_START + 0x01b4u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM3 - {CALIB_VERSION[7:0], TempMid[7:0]} */
#define EE_APP_TRIM3 \
    ee0x9b6, (MEM_EEPROM_START + 0x01b6u), (MEM_EEPROM_START + 0x01b6u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** CALIB_VERSION - Calibration data version */
#define EE_CALIB_VERSION \
    ee0x9b6, (MEM_EEPROM_START + 0x01b6u), (MEM_EEPROM_START + 0x01b6u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** TEMPMID_CP - Middle Temperature used in production (mostly probing1 = 35degC) (copy at 09B1) */
#define EE_TEMPMID_CP \
    ee0x9b6, (MEM_EEPROM_START + 0x01b6u), (MEM_EEPROM_START + 0x01b6u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM4 - {GainTempHighCal_EE[7:0], GainTempLowCal_EE[7:0]} */
#define EE_APP_TRIM4 \
    ee0x9b8, (MEM_EEPROM_START + 0x01b8u), (MEM_EEPROM_START + 0x01b8u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** GAINTEMPHIGHCAL - Temp sensor calibration, Gain for High Temp range */
#define EE_GAINTEMPHIGHCAL \
    ee0x9b8, (MEM_EEPROM_START + 0x01b8u), (MEM_EEPROM_START + 0x01b8u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** GAINTEMPLOWCAL - Temp sensor calibration, Gain for Low Temp range */
#define EE_GAINTEMPLOWCAL \
    ee0x9b8, (MEM_EEPROM_START + 0x01b8u), (MEM_EEPROM_START + 0x01b8u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM5 - {reserved[2:0],LINAA_DIV_EXT[4:0], OADCCal_EE[7:0]} */
#define EE_APP_TRIM5 \
    ee0x9ba, (MEM_EEPROM_START + 0x01bau), (MEM_EEPROM_START + 0x01bau), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LINAA_DIV_EXT - extended 5bit LINAA_DIV control for CMR adjustment */
#define EE_LINAA_DIV_EXT \
    ee0x9ba, (MEM_EEPROM_START + 0x01bau), (MEM_EEPROM_START + 0x01bau), 0x1f00u,  8U, 1U, 0U, 0x0000u
/** OADCCAL - ADC reference (2.5V) offset [8bit signed] */
#define EE_OADCCAL \
    ee0x9ba, (MEM_EEPROM_START + 0x01bau), (MEM_EEPROM_START + 0x01bau), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM6 - {GainADCHighCal_EE[7:0], GainADCLowCal_EE[7:0]} */
#define EE_APP_TRIM6 \
    ee0x9bc, (MEM_EEPROM_START + 0x01bcu), (MEM_EEPROM_START + 0x01bcu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** GAINADCHIGHCAL - ADC reference (2.5V) gain for high temp range  [8bit signed] */
#define EE_GAINADCHIGHCAL \
    ee0x9bc, (MEM_EEPROM_START + 0x01bcu), (MEM_EEPROM_START + 0x01bcu), 0xff00u,  8U, 1U, 0U, 0x0000u
/** GAINADCLOWCAL - ADC reference (2.5V) gain for low temp range  [8bit signed] */
#define EE_GAINADCLOWCAL \
    ee0x9bc, (MEM_EEPROM_START + 0x01bcu), (MEM_EEPROM_START + 0x01bcu), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM7 - {SClock24HighCal _EE[7:0], SClock24LowCal _EE[7:0]} */
#define EE_APP_TRIM7 \
    ee0x9be, (MEM_EEPROM_START + 0x01beu), (MEM_EEPROM_START + 0x01beu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** SCLOCK24HIGHCAL - CPU clock (24MHz)  Gain for High Temp range [8bit signed] */
#define EE_SCLOCK24HIGHCAL \
    ee0x9be, (MEM_EEPROM_START + 0x01beu), (MEM_EEPROM_START + 0x01beu), 0xff00u,  8U, 1U, 0U, 0x0000u
/** SCLOCK24LOWCAL - CPU clock (24MHz)  Gain for Low Temp range [8bit signed] */
#define EE_SCLOCK24LOWCAL \
    ee0x9be, (MEM_EEPROM_START + 0x01beu), (MEM_EEPROM_START + 0x01beu), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM8 - {SClock28LowCal _EE[7:0], OClock24Cal _EE[7:0]} */
#define EE_APP_TRIM8 \
    ee0x9c0, (MEM_EEPROM_START + 0x01c0u), (MEM_EEPROM_START + 0x01c0u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** SCLOCK28LOWCAL - CPU clock (28MHz)  Gain for Low Temp range [8bit signed] */
#define EE_SCLOCK28LOWCAL \
    ee0x9c0, (MEM_EEPROM_START + 0x01c0u), (MEM_EEPROM_START + 0x01c0u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** OCLOCK24CAL - CPU clock (24MHz)  Offset [8bit signed] */
#define EE_OCLOCK24CAL \
    ee0x9c0, (MEM_EEPROM_START + 0x01c0u), (MEM_EEPROM_START + 0x01c0u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM9 - {OClock28Cal _EE[7:0], SClock28HighCal _EE[7:0]} */
#define EE_APP_TRIM9 \
    ee0x9c2, (MEM_EEPROM_START + 0x01c2u), (MEM_EEPROM_START + 0x01c2u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** OCLOCK28CAL - CPU clock (28MHz)  Offset [8bit signed] */
#define EE_OCLOCK28CAL \
    ee0x9c2, (MEM_EEPROM_START + 0x01c2u), (MEM_EEPROM_START + 0x01c2u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** SCLOCK28HIGHCAL - CPU clock (28MHz)  Gain for High Temp range [8bit signed] */
#define EE_SCLOCK28HIGHCAL \
    ee0x9c2, (MEM_EEPROM_START + 0x01c2u), (MEM_EEPROM_START + 0x01c2u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM10 - {SClock32HighCal _EE[7:0], SClock32LowCal _EE[7:0]} */
#define EE_APP_TRIM10 \
    ee0x9c4, (MEM_EEPROM_START + 0x01c4u), (MEM_EEPROM_START + 0x01c4u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** SCLOCK32HIGHCAL - CPU clock (30MHz)  Gain for High Temp range [8bit signed] */
#define EE_SCLOCK32HIGHCAL \
    ee0x9c4, (MEM_EEPROM_START + 0x01c4u), (MEM_EEPROM_START + 0x01c4u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** SCLOCK32LOWCAL - CPU clock (30MHz)  Gain for Low Temp range [8bit signed] */
#define EE_SCLOCK32LOWCAL \
    ee0x9c4, (MEM_EEPROM_START + 0x01c4u), (MEM_EEPROM_START + 0x01c4u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM11 - {O10kHzCal_EE[7:0], OClock32Cal _EE[7:0]} */
#define EE_APP_TRIM11 \
    ee0x9c6, (MEM_EEPROM_START + 0x01c6u), (MEM_EEPROM_START + 0x01c6u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** O10KHZCAL - Wake up Clock Offset [8bit signed] */
#define EE_O10KHZCAL \
    ee0x9c6, (MEM_EEPROM_START + 0x01c6u), (MEM_EEPROM_START + 0x01c6u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** OCLOCK32CAL - CPU clock (30MHz)  Offset [8bit signed] */
#define EE_OCLOCK32CAL \
    ee0x9c6, (MEM_EEPROM_START + 0x01c6u), (MEM_EEPROM_START + 0x01c6u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM12 - Rshunt from the LIN autoconfig block */
#define EE_APP_TRIM12 \
    ee0x9c8, (MEM_EEPROM_START + 0x01c8u), (MEM_EEPROM_START + 0x01c8u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LINAA_INT_SHUNT - Rshunt from the LIN autoconfig block */
#define EE_LINAA_INT_SHUNT \
    ee0x9c8, (MEM_EEPROM_START + 0x01c8u), (MEM_EEPROM_START + 0x01c8u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM13 - reserved[15:0] */
#define EE_APP_TRIM13 \
    ee0x9ca, (MEM_EEPROM_START + 0x01cau), (MEM_EEPROM_START + 0x01cau), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM14 - LINAA_SDMCM_EE[15:0] */
#define EE_APP_TRIM14 \
    ee0x9cc, (MEM_EEPROM_START + 0x01ccu), (MEM_EEPROM_START + 0x01ccu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LINAA_SDMCM - LINAA - differential current measurement sensitivity to common mode voltage step */
#define EE_LINAA_SDMCM \
    ee0x9cc, (MEM_EEPROM_START + 0x01ccu), (MEM_EEPROM_START + 0x01ccu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM15 - LINAA_GainDMCal_EE [15:0] */
#define EE_APP_TRIM15 \
    ee0x9ce, (MEM_EEPROM_START + 0x01ceu), (MEM_EEPROM_START + 0x01ceu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LINAA_GAINDMCAL - LINAA - differential current measurement sensitivity to  current */
#define EE_LINAA_GAINDMCAL \
    ee0x9ce, (MEM_EEPROM_START + 0x01ceu), (MEM_EEPROM_START + 0x01ceu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM16 - {IAA_Trim205mA[7:0], IAA_Trim045mA[7:0]} */
#define EE_APP_TRIM16 \
    ee0x9d0, (MEM_EEPROM_START + 0x01d0u), (MEM_EEPROM_START + 0x01d0u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LINAA_LCD_SEL_205 - IAA_Trim205mA[7:6]: current selection for low side diagnosis current source for 205mA */
#define EE_LINAA_LCD_SEL_205 \
    ee0x9d0, (MEM_EEPROM_START + 0x01d0u), (MEM_EEPROM_START + 0x01d0u), 0xc000u, 14U, 1U, 0U, 0x0000u
/** LINAA_TRIM_LCD_205 - IAA_Trim205mA[5:0]:  trimming for low side diagnosis current source for 205mA, copy to PORT_TR_MISC[5:0] */
#define EE_LINAA_TRIM_LCD_205 \
    ee0x9d0, (MEM_EEPROM_START + 0x01d0u), (MEM_EEPROM_START + 0x01d0u), 0x3f00u,  8U, 1U, 0U, 0x0000u
/** LINAA_LCD_SEL_112 - IAA_Trim045mA[7:6]: current selection for low side diagnosis current source for 0.45mA */
#define EE_LINAA_LCD_SEL_112 \
    ee0x9d0, (MEM_EEPROM_START + 0x01d0u), (MEM_EEPROM_START + 0x01d0u), 0x00c0u,  6U, 1U, 0U, 0x0000u
/** LINAA_TRIM_LCD_112 - IAA_Trim045mA[5:0]:  trimming for low side diagnosis current source for 0.45mA, copy to PORT_TR_MISC[5:0] */
#define EE_LINAA_TRIM_LCD_112 \
    ee0x9d0, (MEM_EEPROM_START + 0x01d0u), (MEM_EEPROM_START + 0x01d0u), 0x003fu,  0U, 1U, 0U, 0x0000u
/** LINAA_LCD_SEL_045 - IAA_Trim045mA[7:6]: current selection for low side diagnosis current source for 0.45mA */
#define EE_LINAA_LCD_SEL_045 \
    ee0x9d0, (MEM_EEPROM_START + 0x01d0u), (MEM_EEPROM_START + 0x01d0u), 0x00c0u,  6U, 1U, 0U, 0x0000u
/** LINAA_TRIM_LCD_045 - IAA_Trim045mA[5:0]:  trimming for low side diagnosis current source for 0.45mA, copy to PORT_TR_MISC[5:0] */
#define EE_LINAA_TRIM_LCD_045 \
    ee0x9d0, (MEM_EEPROM_START + 0x01d0u), (MEM_EEPROM_START + 0x01d0u), 0x003fu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM17 - {LIN_AA_DIV[3:0], LINN_AA_GAIN[3:0], IAA_Trim240mA[7:0]} */
#define EE_APP_TRIM17 \
    ee0x9d2, (MEM_EEPROM_START + 0x01d2u), (MEM_EEPROM_START + 0x01d2u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LINAA_DIV - Common mode suppression adjustements bits, copy to PORT_LINAA1 */
#define EE_LINAA_DIV \
    ee0x9d2, (MEM_EEPROM_START + 0x01d2u), (MEM_EEPROM_START + 0x01d2u), 0xf000u, 12U, 1U, 0U, 0x0000u
/** LINAA_GAIN - Gain control bits of the variable gain amp, , copy to PORT_LINAA1 */
#define EE_LINAA_GAIN \
    ee0x9d2, (MEM_EEPROM_START + 0x01d2u), (MEM_EEPROM_START + 0x01d2u), 0x0f00u,  8U, 1U, 0U, 0x0000u
/** LINAA_LCD_SEL_240 - IAA_Trim240mA[7:6]: current selection for low side diagnosis current source for 2.4mA */
#define EE_LINAA_LCD_SEL_240 \
    ee0x9d2, (MEM_EEPROM_START + 0x01d2u), (MEM_EEPROM_START + 0x01d2u), 0x00c0u,  6U, 1U, 0U, 0x0000u
/** LINAA_TRIM_LCD_240 - IAA_Trim240mA[5:0]:  trimming for low side diagnosis current source for 2.4mA, copy to PORT_TR_MISC[5:0] */
#define EE_LINAA_TRIM_LCD_240 \
    ee0x9d2, (MEM_EEPROM_START + 0x01d2u), (MEM_EEPROM_START + 0x01d2u), 0x003fu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM18 - application specific calibration information */
#define EE_APP_TRIM18 \
    ee0x9d4, (MEM_EEPROM_START + 0x01d4u), (MEM_EEPROM_START + 0x01d4u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** O_HVI - Offset of High-voltage input HVI/21 at mid temp */
#define EE_O_HVI \
    ee0x9d4, (MEM_EEPROM_START + 0x01d4u), (MEM_EEPROM_START + 0x01d4u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** GAIN_VSMF - Gain of filtered VSM at mid temp */
#define EE_GAIN_VSMF \
    ee0x9d4, (MEM_EEPROM_START + 0x01d4u), (MEM_EEPROM_START + 0x01d4u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM19 - application specific calibration information */
#define EE_APP_TRIM19 \
    ee0x9d6, (MEM_EEPROM_START + 0x01d6u), (MEM_EEPROM_START + 0x01d6u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** O_LVI - Offset of Low-voltage input LVI/1.36 at mid temp */
#define EE_O_LVI \
    ee0x9d6, (MEM_EEPROM_START + 0x01d6u), (MEM_EEPROM_START + 0x01d6u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** GAIN_LVI - Gain of Low-voltage input LVI/1.36 at mid temp */
#define EE_GAIN_LVI \
    ee0x9d6, (MEM_EEPROM_START + 0x01d6u), (MEM_EEPROM_START + 0x01d6u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM20 - application specific calibration information */
#define EE_APP_TRIM20 \
    ee0x9d8, (MEM_EEPROM_START + 0x01d8u), (MEM_EEPROM_START + 0x01d8u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** O_VSMF - Offset of filtered VSM */
#define EE_O_VSMF \
    ee0x9d8, (MEM_EEPROM_START + 0x01d8u), (MEM_EEPROM_START + 0x01d8u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** GAIN_HVI - Gain of High-voltage input HVI/21 at mid temp */
#define EE_GAIN_HVI \
    ee0x9d8, (MEM_EEPROM_START + 0x01d8u), (MEM_EEPROM_START + 0x01d8u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM21 - application specific calibration information */
#define EE_APP_TRIM21 \
    ee0x9da, (MEM_EEPROM_START + 0x01dau), (MEM_EEPROM_START + 0x01dau), 0xffffu,  0U, 1U, 0U, 0x0000u
/** GAINHI_LVI - Gain-change of LVI voltage over high-temperature range */
#define EE_GAINHI_LVI \
    ee0x9da, (MEM_EEPROM_START + 0x01dau), (MEM_EEPROM_START + 0x01dau), 0xff00u,  8U, 1U, 0U, 0x0000u
/** GAINLO_LVI - Gain-change of LVI voltage over low-temperature range */
#define EE_GAINLO_LVI \
    ee0x9da, (MEM_EEPROM_START + 0x01dau), (MEM_EEPROM_START + 0x01dau), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM22 - application specific calibration information */
#define EE_APP_TRIM22 \
    ee0x9dc, (MEM_EEPROM_START + 0x01dcu), (MEM_EEPROM_START + 0x01dcu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** O_CURR - Offset of motor current at mid temp */
#define EE_O_CURR \
    ee0x9dc, (MEM_EEPROM_START + 0x01dcu), (MEM_EEPROM_START + 0x01dcu), 0xff00u,  8U, 1U, 0U, 0x0000u
/** GAIN_CURR - Gain of motor current at mid temp */
#define EE_GAIN_CURR \
    ee0x9dc, (MEM_EEPROM_START + 0x01dcu), (MEM_EEPROM_START + 0x01dcu), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM23 - application specific calibration information */
#define EE_APP_TRIM23 \
    ee0x9de, (MEM_EEPROM_START + 0x01deu), (MEM_EEPROM_START + 0x01deu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM24 - application specific calibration information */
#define EE_APP_TRIM24 \
    ee0x9e0, (MEM_EEPROM_START + 0x01e0u), (MEM_EEPROM_START + 0x01e0u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** GAINHI_CURR - Gain-change of motor current over high-temperature range */
#define EE_GAINHI_CURR \
    ee0x9e0, (MEM_EEPROM_START + 0x01e0u), (MEM_EEPROM_START + 0x01e0u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** GAINLO_CURR - Gain-change of motor current over low-temperature range */
#define EE_GAINLO_CURR \
    ee0x9e0, (MEM_EEPROM_START + 0x01e0u), (MEM_EEPROM_START + 0x01e0u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM25 - application specific calibration information */
#define EE_APP_TRIM25 \
    ee0x9e2, (MEM_EEPROM_START + 0x01e2u), (MEM_EEPROM_START + 0x01e2u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** GAINHI_VSMF - Gain-change of filtered VSM over high-temperature range */
#define EE_GAINHI_VSMF \
    ee0x9e2, (MEM_EEPROM_START + 0x01e2u), (MEM_EEPROM_START + 0x01e2u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** GAINLO_VSMF - Gain-change of filtered VSM over low-temperature range */
#define EE_GAINLO_VSMF \
    ee0x9e2, (MEM_EEPROM_START + 0x01e2u), (MEM_EEPROM_START + 0x01e2u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM26 - application specific calibration information */
#define EE_APP_TRIM26 \
    ee0x9e4, (MEM_EEPROM_START + 0x01e4u), (MEM_EEPROM_START + 0x01e4u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM27 - application specific calibration information */
#define EE_APP_TRIM27 \
    ee0x9e6, (MEM_EEPROM_START + 0x01e6u), (MEM_EEPROM_START + 0x01e6u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** MTEMPLOW - Raw ADC measurement of the temperature sensor at low test temperature */
#define EE_MTEMPLOW \
    ee0x9e6, (MEM_EEPROM_START + 0x01e6u), (MEM_EEPROM_START + 0x01e6u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM28 - application specific calibration information */
#define EE_APP_TRIM28 \
    ee0x9e8, (MEM_EEPROM_START + 0x01e8u), (MEM_EEPROM_START + 0x01e8u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** MTEMPHIGH - Raw ADC measurement of the temperature sensor at high test temperature */
#define EE_MTEMPHIGH \
    ee0x9e8, (MEM_EEPROM_START + 0x01e8u), (MEM_EEPROM_START + 0x01e8u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM29 - application specific calibration information */
#define EE_APP_TRIM29 \
    ee0x9ea, (MEM_EEPROM_START + 0x01eau), (MEM_EEPROM_START + 0x01eau), 0xffffu,  0U, 1U, 0U, 0x0000u
/** TC_CHARGEPUMPCLOCK82 - Temperature coefficient for 82MHz charge pump clock trimming */
#define EE_TC_CHARGEPUMPCLOCK82 \
    ee0x9ea, (MEM_EEPROM_START + 0x01eau), (MEM_EEPROM_START + 0x01eau), 0xff00u,  8U, 1U, 0U, 0x0000u
/** TC_CHARGEPUMPCLOCK60 - Temperature coefficient for 60MHz charge pump clock trimming */
#define EE_TC_CHARGEPUMPCLOCK60 \
    ee0x9ea, (MEM_EEPROM_START + 0x01eau), (MEM_EEPROM_START + 0x01eau), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM30 - application specific calibration information */
#define EE_APP_TRIM30 \
    ee0x9ec, (MEM_EEPROM_START + 0x01ecu), (MEM_EEPROM_START + 0x01ecu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** TRIM_CPCLK - Trim setting charge pump clock 82MHz (default) */
#define EE_TRIM_CPCLK \
    ee0x9ec, (MEM_EEPROM_START + 0x01ecu), (MEM_EEPROM_START + 0x01ecu), 0x0ffcu,  2U, 1U, 0U, 0x0000u
/** TRIM_DRVSUP - Trim setting driver supply (default) */
#define EE_TRIM_DRVSUP \
    ee0x9ec, (MEM_EEPROM_START + 0x01ecu), (MEM_EEPROM_START + 0x01ecu), 0x0003u,  0U, 1U, 0U, 0x0000u
/** APP_TRIM31 - application specific calibration information */
#define EE_APP_TRIM31 \
    ee0x9ee, (MEM_EEPROM_START + 0x01eeu), (MEM_EEPROM_START + 0x01eeu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** TRIM_CSA_GAIN - Trim setting current sense amplifier gain */
#define EE_TRIM_CSA_GAIN \
    ee0x9ee, (MEM_EEPROM_START + 0x01eeu), (MEM_EEPROM_START + 0x01eeu), 0x01f0u,  4U, 1U, 0U, 0x0000u
/** TRIM_SLWRT - Trim setting pre-driver current */
#define EE_TRIM_SLWRT \
    ee0x9ee, (MEM_EEPROM_START + 0x01eeu), (MEM_EEPROM_START + 0x01eeu), 0x000fu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM32 - application specific calibration information */
#define EE_APP_TRIM32 \
    ee0x9f0, (MEM_EEPROM_START + 0x01f0u), (MEM_EEPROM_START + 0x01f0u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** TRIM_CSA_CL_LOW - Trim setting over-current detection low */
#define EE_TRIM_CSA_CL_LOW \
    ee0x9f0, (MEM_EEPROM_START + 0x01f0u), (MEM_EEPROM_START + 0x01f0u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** TRIM_CSA_CL_HIGH - Trim setting over-current detection high */
#define EE_TRIM_CSA_CL_HIGH \
    ee0x9f0, (MEM_EEPROM_START + 0x01f0u), (MEM_EEPROM_START + 0x01f0u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM33 - application specific calibration information */
#define EE_APP_TRIM33 \
    ee0x9f2, (MEM_EEPROM_START + 0x01f2u), (MEM_EEPROM_START + 0x01f2u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** TRIM_SDAFILT_IO - Trim setting I2C SDA filter */
#define EE_TRIM_SDAFILT_IO \
    ee0x9f2, (MEM_EEPROM_START + 0x01f2u), (MEM_EEPROM_START + 0x01f2u), 0x3000u, 12U, 1U, 0U, 0x0000u
/** TRIM_OTD - Trim setting over-temperature detection */
#define EE_TRIM_OTD \
    ee0x9f2, (MEM_EEPROM_START + 0x01f2u), (MEM_EEPROM_START + 0x01f2u), 0x0fc0u,  6U, 1U, 0U, 0x0000u
/** APP_TRIM34 - application specific calibration information */
#define EE_APP_TRIM34 \
    ee0x9f4, (MEM_EEPROM_START + 0x01f4u), (MEM_EEPROM_START + 0x01f4u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** TRIM_CPCLK_ALT - Trim setting charge pump clock 60MHz */
#define EE_TRIM_CPCLK_ALT \
    ee0x9f4, (MEM_EEPROM_START + 0x01f4u), (MEM_EEPROM_START + 0x01f4u), 0x0ffcu,  2U, 1U, 0U, 0x0000u
/** TRIM_DRVSUP_COPY - Trim setting driver supply (copy of 9EC) */
#define EE_TRIM_DRVSUP_COPY \
    ee0x9f4, (MEM_EEPROM_START + 0x01f4u), (MEM_EEPROM_START + 0x01f4u), 0x0003u,  0U, 1U, 0U, 0x0000u
/** APP_TRIM35 - application specific calibration information */
#define EE_APP_TRIM35 \
    ee0x9f6, (MEM_EEPROM_START + 0x01f6u), (MEM_EEPROM_START + 0x01f6u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM36 - speed7 reserved for additional speed settings */
#define EE_APP_TRIM36 \
    ee0x9f8, (MEM_EEPROM_START + 0x01f8u), (MEM_EEPROM_START + 0x01f8u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** SPEED7 - speed7 reserved for additional speed settings */
#define EE_SPEED7 \
    ee0x9f8, (MEM_EEPROM_START + 0x01f8u), (MEM_EEPROM_START + 0x01f8u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM37 - speed6 reserved for additional speed settings */
#define EE_APP_TRIM37 \
    ee0x9fa, (MEM_EEPROM_START + 0x01fau), (MEM_EEPROM_START + 0x01fau), 0xffffu,  0U, 1U, 0U, 0x0000u
/** SPEED6 - speed6 reserved for additional speed settings */
#define EE_SPEED6 \
    ee0x9fa, (MEM_EEPROM_START + 0x01fau), (MEM_EEPROM_START + 0x01fau), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM38 - speed5 reserved for additional speed settings */
#define EE_APP_TRIM38 \
    ee0x9fc, (MEM_EEPROM_START + 0x01fcu), (MEM_EEPROM_START + 0x01fcu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** SPEED5 - speed5 reserved for additional speed settings */
#define EE_SPEED5 \
    ee0x9fc, (MEM_EEPROM_START + 0x01fcu), (MEM_EEPROM_START + 0x01fcu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_TRIM39 - speed4 setting for 32MHz/16MHz with 2 flash wait states */
#define EE_APP_TRIM39 \
    ee0x9fe, (MEM_EEPROM_START + 0x01feu), (MEM_EEPROM_START + 0x01feu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** SPEED4 - speed4 setting for 32MHz/16MHz with 2 flash wait states */
#define EE_SPEED4 \
    ee0x9fe, (MEM_EEPROM_START + 0x01feu), (MEM_EEPROM_START + 0x01feu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** MELEXIS_TRIM_CRC - Melexis Trimming - CRC location */
#define EE_MELEXIS_TRIM_CRC \
    ee0xa00, (MEM_EEPROM_START + 0x0200u), (MEM_EEPROM_START + 0x0200u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** ROM_CONFIGURATION - ROM_CONFIGURATION byte used by ROM code, function is project specific */
#define EE_ROM_CONFIGURATION \
    ee0xa00, (MEM_EEPROM_START + 0x0200u), (MEM_EEPROM_START + 0x0200u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** CRC_CS - CRC checksum of config sector */
#define EE_CRC_CS \
    ee0xa00, (MEM_EEPROM_START + 0x0200u), (MEM_EEPROM_START + 0x0200u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** MS_TRIM0 - trim_bg_bias (bandgap, bias) */
#define EE_MS_TRIM0 \
    ee0xa02, (MEM_EEPROM_START + 0x0202u), (MEM_EEPROM_START + 0x0202u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LOCK_MS_TRIM0 - lock bit of trim port */
#define EE_LOCK_MS_TRIM0 \
    ee0xa02, (MEM_EEPROM_START + 0x0202u), (MEM_EEPROM_START + 0x0202u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** MS_TR_BIAS - trim bias source */
#define EE_MS_TR_BIAS \
    ee0xa02, (MEM_EEPROM_START + 0x0202u), (MEM_EEPROM_START + 0x0202u), 0x3f00u,  8U, 1U, 0U, 0x0000u
/** MS_TR_BGD - trim digital bandgap */
#define EE_MS_TR_BGD \
    ee0xa02, (MEM_EEPROM_START + 0x0202u), (MEM_EEPROM_START + 0x0202u), 0x00f0u,  4U, 1U, 0U, 0x0000u
/** MS_TR_BGA - trim analog bandgap */
#define EE_MS_TR_BGA \
    ee0xa02, (MEM_EEPROM_START + 0x0202u), (MEM_EEPROM_START + 0x0202u), 0x000fu,  0U, 1U, 0U, 0x0000u
/** MS_TRIM1 - trim_vdd (vddd, vdda) */
#define EE_MS_TRIM1 \
    ee0xa04, (MEM_EEPROM_START + 0x0204u), (MEM_EEPROM_START + 0x0204u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LOCK_MS_TRIM1 - lock bit of trim port */
#define EE_LOCK_MS_TRIM1 \
    ee0xa04, (MEM_EEPROM_START + 0x0204u), (MEM_EEPROM_START + 0x0204u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** MS_TR_SUP - 8 trim support bits, ECADC: CORR_x_y */
#define EE_MS_TR_SUP \
    ee0xa04, (MEM_EEPROM_START + 0x0204u), (MEM_EEPROM_START + 0x0204u), 0x3fc0u,  6U, 1U, 0U, 0x0000u
/** MS_TR_VDDD - digital supply trimming */
#define EE_MS_TR_VDDD \
    ee0xa04, (MEM_EEPROM_START + 0x0204u), (MEM_EEPROM_START + 0x0204u), 0x0038u,  3U, 1U, 0U, 0x0000u
/** MS_TR_VDDA - analog supply trimming */
#define EE_MS_TR_VDDA \
    ee0xa04, (MEM_EEPROM_START + 0x0204u), (MEM_EEPROM_START + 0x0204u), 0x0007u,  0U, 1U, 0U, 0x0000u
/** MS_TRIM2 - trim_rco1m_lin (1MHz RCO, LIN) */
#define EE_MS_TRIM2 \
    ee0xa06, (MEM_EEPROM_START + 0x0206u), (MEM_EEPROM_START + 0x0206u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LOCK_MS_TRIM2 - lock bit of trim port */
#define EE_LOCK_MS_TRIM2 \
    ee0xa06, (MEM_EEPROM_START + 0x0206u), (MEM_EEPROM_START + 0x0206u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** MS_TR_LIN_SLVTERM - LIN slave termination trimming */
#define EE_MS_TR_LIN_SLVTERM \
    ee0xa06, (MEM_EEPROM_START + 0x0206u), (MEM_EEPROM_START + 0x0206u), 0x3800u, 11U, 1U, 0U, 0x0000u
/** MS_TR_LIN_SLEWRATE - LIN slewrate trimming */
#define EE_MS_TR_LIN_SLEWRATE \
    ee0xa06, (MEM_EEPROM_START + 0x0206u), (MEM_EEPROM_START + 0x0206u), 0x0700u,  8U, 1U, 0U, 0x0000u
/** MS_TR_RCO1M - RCO 1MHz trimming */
#define EE_MS_TR_RCO1M \
    ee0xa06, (MEM_EEPROM_START + 0x0206u), (MEM_EEPROM_START + 0x0206u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** MS_TRIM3 - SAR ADC: adc_sar_tr_adcref1 ((ADC refs 1+2); ECADC: Calibration factor CORR[15:0] */
#define EE_MS_TRIM3 \
    ee0xa08, (MEM_EEPROM_START + 0x0208u), (MEM_EEPROM_START + 0x0208u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** TR_ADCREF2 - Option SAR ADC: reference trimming for xxx V */
#define EE_TR_ADCREF2 \
    ee0xa08, (MEM_EEPROM_START + 0x0208u), (MEM_EEPROM_START + 0x0208u), 0x3f80u,  7U, 1U, 0U, 0x0000u
/** TR_ADCREF1 - Option SAR ADC:  reference trimming for xxx V, */
#define EE_TR_ADCREF1 \
    ee0xa08, (MEM_EEPROM_START + 0x0208u), (MEM_EEPROM_START + 0x0208u), 0x007fu,  0U, 1U, 0U, 0x0000u
/** CORR_15_0 - Option ECADC: Calibration bits CORR[15:0] */
#define EE_CORR_15_0 \
    ee0xa08, (MEM_EEPROM_START + 0x0208u), (MEM_EEPROM_START + 0x0208u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** MS_TRIM4 - SAR ADC: adc_sar_tr_adcref3 (ADC ref 3); ECADC: Calibration factor CORR[31:16] */
#define EE_MS_TRIM4 \
    ee0xa0a, (MEM_EEPROM_START + 0x020au), (MEM_EEPROM_START + 0x020au), 0xffffu,  0U, 1U, 0U, 0x0000u
/** TR_ADCREF3 - Option SAR ADC: reference trimming for xxx V */
#define EE_TR_ADCREF3 \
    ee0xa0a, (MEM_EEPROM_START + 0x020au), (MEM_EEPROM_START + 0x020au), 0x007fu,  0U, 1U, 0U, 0x0000u
/** CORR_31_16 - Option ECADC: Calibration bits CORR[31:16] */
#define EE_CORR_31_16 \
    ee0xa0a, (MEM_EEPROM_START + 0x020au), (MEM_EEPROM_START + 0x020au), 0xffffu,  0U, 1U, 0U, 0x0000u
/** MS_TRIM5 - SAR ADC: trim_vdd_ext (second regulator vddio) ; ECADC: Calibration factor CORR[46:32] */
#define EE_MS_TRIM5 \
    ee0xa0c, (MEM_EEPROM_START + 0x020cu), (MEM_EEPROM_START + 0x020cu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LOCK_MS_TRIM5 - Option SAR ADC - lock bit of trim port, not used for ECADC */
#define EE_LOCK_MS_TRIM5 \
    ee0xa0c, (MEM_EEPROM_START + 0x020cu), (MEM_EEPROM_START + 0x020cu), 0x8000u, 15U, 1U, 0U, 0x0000u
/** MS_TR_VDDIO - Option SAR ADC - trimming for second regulator 5V */
#define EE_MS_TR_VDDIO \
    ee0xa0c, (MEM_EEPROM_START + 0x020cu), (MEM_EEPROM_START + 0x020cu), 0x0007u,  0U, 1U, 0U, 0x0000u
/** CORR_46_32 - Option ECADC: Calibration bits CORR[46:32] */
#define EE_CORR_46_32 \
    ee0xa0c, (MEM_EEPROM_START + 0x020cu), (MEM_EEPROM_START + 0x020cu), 0x7fffu,  0U, 1U, 0U, 0x0000u
/** MS_TRIM6 - speed1 setting for 24/12 MHz */
#define EE_MS_TRIM6 \
    ee0xa0e, (MEM_EEPROM_START + 0x020eu), (MEM_EEPROM_START + 0x020eu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** EE_AC_SL_WAIT_OPTION_SPEED1 - SPEED1 - RCO trimming, 24/12MHz, ac_sl option for ee wait states */
#define EE_EE_AC_SL_WAIT_OPTION_SPEED1 \
    ee0xa0e, (MEM_EEPROM_START + 0x020eu), (MEM_EEPROM_START + 0x020eu), 0x8000u, 15U, 1U, 0U, 0x0000u
/** FL_AC_SL_WAIT_OPTION_SPEED1 - ac_sl option for flash wait states */
#define EE_FL_AC_SL_WAIT_OPTION_SPEED1 \
    ee0xa0e, (MEM_EEPROM_START + 0x020eu), (MEM_EEPROM_START + 0x020eu), 0x4000u, 14U, 1U, 0U, 0x0000u
/** FL_WAIT_STATES_P_SPEED1 - encoded flash wait states, (values {0,1,2,3} map to FL_WAIT_STATES=FL_AC_ SL_OPTION? {1,2,3,4} : {1,1,2,3} ) */
#define EE_FL_WAIT_STATES_P_SPEED1 \
    ee0xa0e, (MEM_EEPROM_START + 0x020eu), (MEM_EEPROM_START + 0x020eu), 0x3000u, 12U, 1U, 0U, 0x0000u
/** EE_WAIT_STATES_P_SPEED1 - encoded ee wait states, (values {0,1,2,3} map to EE_WAIT_STATES=EE_AC_ SL_OPTION? {4,5,6,7} : {3,4,5,6} ) */
#define EE_EE_WAIT_STATES_P_SPEED1 \
    ee0xa0e, (MEM_EEPROM_START + 0x020eu), (MEM_EEPROM_START + 0x020eu), 0x0c00u, 10U, 1U, 0U, 0x0000u
/** TR_RCO32M_IN_SPEED1 - RC oscillator trim code */
#define EE_TR_RCO32M_IN_SPEED1 \
    ee0xa0e, (MEM_EEPROM_START + 0x020eu), (MEM_EEPROM_START + 0x020eu), 0x03ffu,  0U, 1U, 0U, 0x0000u
/** MS_TRIM7 - speed2 setting for 28/14 MHz */
#define EE_MS_TRIM7 \
    ee0xa10, (MEM_EEPROM_START + 0x0210u), (MEM_EEPROM_START + 0x0210u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** EE_AC_SL_WAIT_OPTION_SPEED2 - SPEED2 - RCO trimming, 28/14MHz */
#define EE_EE_AC_SL_WAIT_OPTION_SPEED2 \
    ee0xa10, (MEM_EEPROM_START + 0x0210u), (MEM_EEPROM_START + 0x0210u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** FL_AC_SL_WAIT_OPTION_SPEED2 -  */
#define EE_FL_AC_SL_WAIT_OPTION_SPEED2 \
    ee0xa10, (MEM_EEPROM_START + 0x0210u), (MEM_EEPROM_START + 0x0210u), 0x4000u, 14U, 1U, 0U, 0x0000u
/** FL_WAIT_STATES_P_SPEED2 -  */
#define EE_FL_WAIT_STATES_P_SPEED2 \
    ee0xa10, (MEM_EEPROM_START + 0x0210u), (MEM_EEPROM_START + 0x0210u), 0x3000u, 12U, 1U, 0U, 0x0000u
/** EE_WAIT_STATES_P_SPEED2 -  */
#define EE_EE_WAIT_STATES_P_SPEED2 \
    ee0xa10, (MEM_EEPROM_START + 0x0210u), (MEM_EEPROM_START + 0x0210u), 0x0c00u, 10U, 1U, 0U, 0x0000u
/** TR_RCO32M_IN_SPEED2 -  */
#define EE_TR_RCO32M_IN_SPEED2 \
    ee0xa10, (MEM_EEPROM_START + 0x0210u), (MEM_EEPROM_START + 0x0210u), 0x03ffu,  0U, 1U, 0U, 0x0000u
/** MS_TRIM8 - speed3 setting for 32/16 MHz */
#define EE_MS_TRIM8 \
    ee0xa12, (MEM_EEPROM_START + 0x0212u), (MEM_EEPROM_START + 0x0212u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** EE_AC_SL_WAIT_OPTION_SPEED3 - SPEED3 - RCO trimming, 32/16MHz */
#define EE_EE_AC_SL_WAIT_OPTION_SPEED3 \
    ee0xa12, (MEM_EEPROM_START + 0x0212u), (MEM_EEPROM_START + 0x0212u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** FL_AC_SL_WAIT_OPTION_SPEED3 -  */
#define EE_FL_AC_SL_WAIT_OPTION_SPEED3 \
    ee0xa12, (MEM_EEPROM_START + 0x0212u), (MEM_EEPROM_START + 0x0212u), 0x4000u, 14U, 1U, 0U, 0x0000u
/** FL_WAIT_STATES_P_SPEED3 -  */
#define EE_FL_WAIT_STATES_P_SPEED3 \
    ee0xa12, (MEM_EEPROM_START + 0x0212u), (MEM_EEPROM_START + 0x0212u), 0x3000u, 12U, 1U, 0U, 0x0000u
/** EE_WAIT_STATES_P_SPEED3 -  */
#define EE_EE_WAIT_STATES_P_SPEED3 \
    ee0xa12, (MEM_EEPROM_START + 0x0212u), (MEM_EEPROM_START + 0x0212u), 0x0c00u, 10U, 1U, 0U, 0x0000u
/** TR_RCO32M_IN_SPEED3 -  */
#define EE_TR_RCO32M_IN_SPEED3 \
    ee0xa12, (MEM_EEPROM_START + 0x0212u), (MEM_EEPROM_START + 0x0212u), 0x03ffu,  0U, 1U, 0U, 0x0000u
/** NV_TRIM0 - R2_EE */
#define EE_NV_TRIM0 \
    ee0xa14, (MEM_EEPROM_START + 0x0214u), (MEM_EEPROM_START + 0x0214u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** R2_EE - R2_EE */
#define EE_R2_EE \
    ee0xa14, (MEM_EEPROM_START + 0x0214u), (MEM_EEPROM_START + 0x0214u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** TSENSE - Sense time settings */
#define EE_TSENSE \
    ee0xa14, (MEM_EEPROM_START + 0x0214u), (MEM_EEPROM_START + 0x0214u), 0x7000u, 12U, 1U, 0U, 0x0000u
/** TRDY - Ready signal delay settings */
#define EE_TRDY \
    ee0xa14, (MEM_EEPROM_START + 0x0214u), (MEM_EEPROM_START + 0x0214u), 0x0c00u, 10U, 1U, 0U, 0x0000u
/** TPRE - Precharge delay settings */
#define EE_TPRE \
    ee0xa14, (MEM_EEPROM_START + 0x0214u), (MEM_EEPROM_START + 0x0214u), 0x0300u,  8U, 1U, 0U, 0x0000u
/** EN_VMG - VMG voltage to memory gates */
#define EE_EN_VMG \
    ee0xa14, (MEM_EEPROM_START + 0x0214u), (MEM_EEPROM_START + 0x0214u), 0x0080u,  7U, 1U, 0U, 0x0000u
/** EN_VMG_CT - enable VMGM margin voltage at CSA */
#define EE_EN_VMG_CT \
    ee0xa14, (MEM_EEPROM_START + 0x0214u), (MEM_EEPROM_START + 0x0214u), 0x0040u,  6U, 1U, 0U, 0x0000u
/** EN_VMG_TT - enable VMGM margin voltage at MSA */
#define EE_EN_VMG_TT \
    ee0xa14, (MEM_EEPROM_START + 0x0214u), (MEM_EEPROM_START + 0x0214u), 0x0020u,  5U, 1U, 0U, 0x0000u
/** SW_VMGM_EE - VMG margin voltage (VMGM) */
#define EE_SW_VMGM_EE \
    ee0xa14, (MEM_EEPROM_START + 0x0214u), (MEM_EEPROM_START + 0x0214u), 0x001fu,  0U, 1U, 0U, 0x0000u
/** NV_TRIM1 - R1_EE */
#define EE_NV_TRIM1 \
    ee0xa16, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** R1_EE - R1_EE */
#define EE_R1_EE \
    ee0xa16, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** REG_1_RES - register, reserve */
#define EE_REG_1_RES \
    ee0xa16, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** CP_CLK_DIV - CP clock divider */
#define EE_CP_CLK_DIV \
    ee0xa16, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0x6000u, 13U, 1U, 0U, 0x0000u
/** EE_CP_SC_FL - disable second CP chain */
#define EE_EE_CP_SC_FL \
    ee0xa16, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0x1000u, 12U, 1U, 0U, 0x0000u
/** SEL_ODD - select odd cells in CS / MA */
#define EE_SEL_ODD \
    ee0xa16, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0x0800u, 11U, 1U, 0U, 0x0000u
/** SEL_EVEN - select even cells in CS / MA */
#define EE_SEL_EVEN \
    ee0xa16, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0x0400u, 10U, 1U, 0U, 0x0000u
/** SEL_CS - select CS */
#define EE_SEL_CS \
    ee0xa16, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0x0200u,  9U, 1U, 0U, 0x0000u
/** SEL_MA - select MA */
#define EE_SEL_MA \
    ee0xa16, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0x0100u,  8U, 1U, 0U, 0x0000u
/** TR_PCP1_W_EE - EEPROM program voltage */
#define EE_TR_PCP1_W_EE \
    ee0xa16, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0x00f0u,  4U, 1U, 0U, 0x0000u
/** TR_PCP1_E_EE - EEPROM erase voltage */
#define EE_TR_PCP1_E_EE \
    ee0xa16, (MEM_EEPROM_START + 0x0216u), (MEM_EEPROM_START + 0x0216u), 0x000fu,  0U, 1U, 0U, 0x0000u
/** NV_TRIM2 - R3_FL */
#define EE_NV_TRIM2 \
    ee0xa18, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** R3_FL - R3_FL */
#define EE_R3_FL \
    ee0xa18, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** SW_VCTAT - Flash 32k : SW_VCTAT[1:0], set VCTAT voltage */
#define EE_SW_VCTAT \
    ee0xa18, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0xc000u, 14U, 1U, 0U, 0x0000u
/** VCTAT_EN - Flash 32k : VCTAT_EN  - activate VCTAT voltage; */
#define EE_VCTAT_EN \
    ee0xa18, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x2000u, 13U, 1U, 0U, 0x0000u
/** EN_IREF1_BL - Flash 32k : EN_IREF1_BL  -  Enable pmos reference current (BL); */
#define EE_EN_IREF1_BL \
    ee0xa18, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x1000u, 12U, 1U, 0U, 0x0000u
/** EN_IREF1_BLR - Flash 32k : EN_IREF1_BLR  -  Enable pmos reference current (BLR); */
#define EE_EN_IREF1_BLR \
    ee0xa18, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0800u, 11U, 1U, 0U, 0x0000u
/** VPTAT_EN - Flash 32k: VPTAT_EN  -  Enable VPTAT voltage; */
#define EE_VPTAT_EN \
    ee0xa18, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0400u, 10U, 1U, 0U, 0x0000u
/** YD - Flash 32k: Enable dummy bitline 1:0 */
#define EE_YD \
    ee0xa18, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0300u,  8U, 1U, 0U, 0x0000u
/** BLRES_ENA_1 - Flash 32k : BLRES_ENA[1]  -  Enable bitline reset; */
#define EE_BLRES_ENA_1 \
    ee0xa18, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0080u,  7U, 1U, 0U, 0x0000u
/** TSEN - Flash 32K : TSEN - Sense time; */
#define EE_TSEN \
    ee0xa18, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0070u,  4U, 1U, 0U, 0x0000u
/** BLRES_ENA_0 - Flash 32k : BLRES_ENA[0] - Enable bitline reset; */
#define EE_BLRES_ENA_0 \
    ee0xa18, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0008u,  3U, 1U, 0U, 0x0000u
/** TPRECH - Flash 32k : TPRECH - Pre-charge time; */
#define EE_TPRECH \
    ee0xa18, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0007u,  0U, 1U, 0U, 0x0000u
/** SW_VCTAT_64 - Flash 64k : SW_VCTAT[3:0], set VCTAT voltage */
#define EE_SW_VCTAT_64 \
    ee0xa18, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0xf000u, 12U, 1U, 0U, 0x0000u
/** EN_IREF_BL_64 - Flash 64k : EN_IREF_BL  -  Enable pmos reference current (BL); */
#define EE_EN_IREF_BL_64 \
    ee0xa18, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0800u, 11U, 1U, 0U, 0x0000u
/** EN_IREF_BLR_64 - Flash 64k : EN_IREF_BLR  -  Enable pmos reference current (BLR); */
#define EE_EN_IREF_BLR_64 \
    ee0xa18, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0400u, 10U, 1U, 0U, 0x0000u
/** YD_64 - Flash 64k: Enable dummy bitline 1:0 */
#define EE_YD_64 \
    ee0xa18, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0300u,  8U, 1U, 0U, 0x0000u
/** TSEN_64 - Flash 64k : TSEN - Sense time */
#define EE_TSEN_64 \
    ee0xa18, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x00e0u,  5U, 1U, 0U, 0x0000u
/** TPRECH_64 - Flash 64k : TPRECH - Pre-charge time; */
#define EE_TPRECH_64 \
    ee0xa18, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x001cu,  2U, 1U, 0U, 0x0000u
/** TINIT_64 - Flash 64k : TINIT - Init read timing */
#define EE_TINIT_64 \
    ee0xa18, (MEM_EEPROM_START + 0x0218u), (MEM_EEPROM_START + 0x0218u), 0x0003u,  0U, 1U, 0U, 0x0000u
/** NV_TRIM3 - R2_FL */
#define EE_NV_TRIM3 \
    ee0xa1a, (MEM_EEPROM_START + 0x021au), (MEM_EEPROM_START + 0x021au), 0xffffu,  0U, 1U, 0U, 0x0000u
/** R2_FL - R2_FL */
#define EE_R2_FL \
    ee0xa1a, (MEM_EEPROM_START + 0x021au), (MEM_EEPROM_START + 0x021au), 0xffffu,  0U, 1U, 0U, 0x0000u
/** T_MEAS - Flash 32k: T_MEAS[3:0]; Flash 64k: T_MEAS[4:1] - measurement test modes */
#define EE_T_MEAS \
    ee0xa1a, (MEM_EEPROM_START + 0x021au), (MEM_EEPROM_START + 0x021au), 0xf000u, 12U, 1U, 0U, 0x0000u
/** SW_IREF_X2 - Flash 32k: double IREF for margin mode; Flash 64k: T_MEAS[0] */
#define EE_SW_IREF_X2 \
    ee0xa1a, (MEM_EEPROM_START + 0x021au), (MEM_EEPROM_START + 0x021au), 0x0800u, 11U, 1U, 0U, 0x0000u
/** SW_IREF - set IREF for margin mode */
#define EE_SW_IREF \
    ee0xa1a, (MEM_EEPROM_START + 0x021au), (MEM_EEPROM_START + 0x021au), 0x07e0u,  5U, 1U, 0U, 0x0000u
/** SW_VMG - VMG voltage Flash and EEPROM */
#define EE_SW_VMG \
    ee0xa1a, (MEM_EEPROM_START + 0x021au), (MEM_EEPROM_START + 0x021au), 0x001fu,  0U, 1U, 0U, 0x0000u
/** NV_TRIM4 - R1_FL */
#define EE_NV_TRIM4 \
    ee0xa1c, (MEM_EEPROM_START + 0x021cu), (MEM_EEPROM_START + 0x021cu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** R1_FL - R1_FL */
#define EE_R1_FL \
    ee0xa1c, (MEM_EEPROM_START + 0x021cu), (MEM_EEPROM_START + 0x021cu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** DIS_ALL_MG - disable all MG */
#define EE_DIS_ALL_MG \
    ee0xa1c, (MEM_EEPROM_START + 0x021cu), (MEM_EEPROM_START + 0x021cu), 0x8000u, 15U, 1U, 0U, 0x0000u
/** WNV_MODE - write modes */
#define EE_WNV_MODE \
    ee0xa1c, (MEM_EEPROM_START + 0x021cu), (MEM_EEPROM_START + 0x021cu), 0x7000u, 12U, 1U, 0U, 0x0000u
/** CP_DIS_SG - disable SG CP */
#define EE_CP_DIS_SG \
    ee0xa1c, (MEM_EEPROM_START + 0x021cu), (MEM_EEPROM_START + 0x021cu), 0x0800u, 11U, 1U, 0U, 0x0000u
/** CP_SC_FL - disable second CP chain */
#define EE_CP_SC_FL \
    ee0xa1c, (MEM_EEPROM_START + 0x021cu), (MEM_EEPROM_START + 0x021cu), 0x0400u, 10U, 1U, 0U, 0x0000u
/** ERA_MODE - erase modes */
#define EE_ERA_MODE \
    ee0xa1c, (MEM_EEPROM_START + 0x021cu), (MEM_EEPROM_START + 0x021cu), 0x0300u,  8U, 1U, 0U, 0x0000u
/** TR_PCP1_W_FL - Flash program voltage */
#define EE_TR_PCP1_W_FL \
    ee0xa1c, (MEM_EEPROM_START + 0x021cu), (MEM_EEPROM_START + 0x021cu), 0x00f0u,  4U, 1U, 0U, 0x0000u
/** TR_PCP1_E_FL - Flash Erase voltage */
#define EE_TR_PCP1_E_FL \
    ee0xa1c, (MEM_EEPROM_START + 0x021cu), (MEM_EEPROM_START + 0x021cu), 0x000fu,  0U, 1U, 0U, 0x0000u
/** NV_TRIM5 - EEPROM read timing port */
#define EE_NV_TRIM5 \
    ee0xa1e, (MEM_EEPROM_START + 0x021eu), (MEM_EEPROM_START + 0x021eu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** EE_LOCK_RD - lock this port */
#define EE_EE_LOCK_RD \
    ee0xa1e, (MEM_EEPROM_START + 0x021eu), (MEM_EEPROM_START + 0x021eu), 0x8000u, 15U, 1U, 0U, 0x0000u
/** EE_WAIT_STATES
 * (EE_WAIT_STATES +1) is the number of clock pulses to have a stable read data
 * Ready delay = (EE_WAIT_STATES + 2) * MCU_CLK
 */
#define EE_EE_WAIT_STATES \
    ee0xa1e, (MEM_EEPROM_START + 0x021eu), (MEM_EEPROM_START + 0x021eu), 0x0f00u,  8U, 1U, 0U, 0x0000u
/** EE_HALT_BEHAVIOR - Define the EEPROM behavior when application is halted */
#define EE_EE_HALT_BEHAVIOR \
    ee0xa1e, (MEM_EEPROM_START + 0x021eu), (MEM_EEPROM_START + 0x021eu), 0x0003u,  0U, 1U, 0U, 0x0000u
/** NV_TRIM6 - EEPROM program cycle port */
#define EE_NV_TRIM6 \
    ee0xa20, (MEM_EEPROM_START + 0x0220u), (MEM_EEPROM_START + 0x0220u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** EE_PROGRAM_CYCLE_LOCK - lock this port */
#define EE_EE_PROGRAM_CYCLE_LOCK \
    ee0xa20, (MEM_EEPROM_START + 0x0220u), (MEM_EEPROM_START + 0x0220u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** EE_PROGRAM_CYCLE
 * This field defined the number of program cycles needed for writing a word in the EEPROM
 * Number of program cycles = EE_PROGRAM_CYCLE + 1
 */
#define EE_EE_PROGRAM_CYCLE \
    ee0xa20, (MEM_EEPROM_START + 0x0220u), (MEM_EEPROM_START + 0x0220u), 0x001fu,  0U, 1U, 0U, 0x0000u
/** NV_TRIM7 - EEPROM erase timing */
#define EE_NV_TRIM7 \
    ee0xa22, (MEM_EEPROM_START + 0x0222u), (MEM_EEPROM_START + 0x0222u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** EE_LOCK_ER - lock this port */
#define EE_EE_LOCK_ER \
    ee0xa22, (MEM_EEPROM_START + 0x0222u), (MEM_EEPROM_START + 0x0222u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** EE_ER_TIME - Erase time = (EE_ER_TIME + 1) * 100us */
#define EE_EE_ER_TIME \
    ee0xa22, (MEM_EEPROM_START + 0x0222u), (MEM_EEPROM_START + 0x0222u), 0x003fu,  0U, 1U, 0U, 0x0000u
/** NV_TRIM8 - EEPROM write timing */
#define EE_NV_TRIM8 \
    ee0xa24, (MEM_EEPROM_START + 0x0224u), (MEM_EEPROM_START + 0x0224u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** EE_LOCK_WR - lock this port */
#define EE_EE_LOCK_WR \
    ee0xa24, (MEM_EEPROM_START + 0x0224u), (MEM_EEPROM_START + 0x0224u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** EE_WR_TIME - Write time = (EE_WR_TIME + 1) * 10us */
#define EE_EE_WR_TIME \
    ee0xa24, (MEM_EEPROM_START + 0x0224u), (MEM_EEPROM_START + 0x0224u), 0x7f00u,  8U, 1U, 0U, 0x0000u
/** EE_PRE_WR_TIME - Pre-Write time = (EE_PRE_WR_TIME + 1) * 10us */
#define EE_EE_PRE_WR_TIME \
    ee0xa24, (MEM_EEPROM_START + 0x0224u), (MEM_EEPROM_START + 0x0224u), 0x007fu,  0U, 1U, 0U, 0x0000u
/** NV_TRIM9 - Flash read configuration word */
#define EE_NV_TRIM9 \
    ee0xa26, (MEM_EEPROM_START + 0x0226u), (MEM_EEPROM_START + 0x0226u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** FL_LOCK_RDY - lock this port */
#define EE_FL_LOCK_RDY \
    ee0xa26, (MEM_EEPROM_START + 0x0226u), (MEM_EEPROM_START + 0x0226u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** FL_HALT_BEHAVIOR - Define the flash behavior when application is halted */
#define EE_FL_HALT_BEHAVIOR \
    ee0xa26, (MEM_EEPROM_START + 0x0226u), (MEM_EEPROM_START + 0x0226u), 0x3000u, 12U, 1U, 0U, 0x0000u
/** FL_DED_RETRY - number of re-try in case of Double Error Detect (DED) */
#define EE_FL_DED_RETRY \
    ee0xa26, (MEM_EEPROM_START + 0x0226u), (MEM_EEPROM_START + 0x0226u), 0x0700u,  8U, 1U, 0U, 0x0000u
/** FL_PREDICTION_BEHAVIOR - Define the behavior of the flash prediction */
#define EE_FL_PREDICTION_BEHAVIOR \
    ee0xa26, (MEM_EEPROM_START + 0x0226u), (MEM_EEPROM_START + 0x0226u), 0x00c0u,  6U, 1U, 0U, 0x0000u
/** FL_BYPASS_QUEUE - Define if Queue is used */
#define EE_FL_BYPASS_QUEUE \
    ee0xa26, (MEM_EEPROM_START + 0x0226u), (MEM_EEPROM_START + 0x0226u), 0x0010u,  4U, 1U, 0U, 0x0000u
/** FL_WAIT_STATES - Number of clock pulses between the read access start and the wishbone READY rising edge. */
#define EE_FL_WAIT_STATES \
    ee0xa26, (MEM_EEPROM_START + 0x0226u), (MEM_EEPROM_START + 0x0226u), 0x0007u,  0U, 1U, 0U, 0x0000u
/** NV_TRIM10 - Flash erase/write timing */
#define EE_NV_TRIM10 \
    ee0xa28, (MEM_EEPROM_START + 0x0228u), (MEM_EEPROM_START + 0x0228u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** FL_LOCK_ER_WR - lock this port */
#define EE_FL_LOCK_ER_WR \
    ee0xa28, (MEM_EEPROM_START + 0x0228u), (MEM_EEPROM_START + 0x0228u), 0x8000u, 15U, 1U, 0U, 0x0000u
/** FL_WR_TIME - Write time = (FL_WR_TIME + 1) * 100us */
#define EE_FL_WR_TIME \
    ee0xa28, (MEM_EEPROM_START + 0x0228u), (MEM_EEPROM_START + 0x0228u), 0x7f00u,  8U, 1U, 0U, 0x0000u
/** FL_ER_TIME - Erase time = (FL_ER_TIME + 1) * 100us */
#define EE_FL_ER_TIME \
    ee0xa28, (MEM_EEPROM_START + 0x0228u), (MEM_EEPROM_START + 0x0228u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** NV_TRIM11 - Timing Port2 */
#define EE_NV_TRIM11 \
    ee0xa2a, (MEM_EEPROM_START + 0x022au), (MEM_EEPROM_START + 0x022au), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LOCK_T_1US - lock this port */
#define EE_LOCK_T_1US \
    ee0xa2a, (MEM_EEPROM_START + 0x022au), (MEM_EEPROM_START + 0x022au), 0x8000u, 15U, 1U, 0U, 0x0000u
/** R3_FL_FLASH_15_13 - R3_FL[15:13] = VCTAT enable for flash (starting from Flash 1.4) */
#define EE_R3_FL_FLASH_15_13 \
    ee0xa2a, (MEM_EEPROM_START + 0x022au), (MEM_EEPROM_START + 0x022au), 0x0e00u,  9U, 1U, 0U, 0x0000u
/** T_1US - control the 1us time in the flash shell */
#define EE_T_1US \
    ee0xa2a, (MEM_EEPROM_START + 0x022au), (MEM_EEPROM_START + 0x022au), 0x001fu,  0U, 1U, 0U, 0x0000u
/** NV_TRIM12 - Timing Port1 */
#define EE_NV_TRIM12 \
    ee0xa2c, (MEM_EEPROM_START + 0x022cu), (MEM_EEPROM_START + 0x022cu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** LOCK_T - lock this port */
#define EE_LOCK_T \
    ee0xa2c, (MEM_EEPROM_START + 0x022cu), (MEM_EEPROM_START + 0x022cu), 0x8000u, 15U, 1U, 0U, 0x0000u
/** T_50US - control the 50us time in the flash shell */
#define EE_T_50US \
    ee0xa2c, (MEM_EEPROM_START + 0x022cu), (MEM_EEPROM_START + 0x022cu), 0x7c00u, 10U, 1U, 0U, 0x0000u
/** T_10US - control the 10us time in the flash shell */
#define EE_T_10US \
    ee0xa2c, (MEM_EEPROM_START + 0x022cu), (MEM_EEPROM_START + 0x022cu), 0x03e0u,  5U, 1U, 0U, 0x0000u
/** T_50NS - control the 50ns time in the flash shell */
#define EE_T_50NS \
    ee0xa2c, (MEM_EEPROM_START + 0x022cu), (MEM_EEPROM_START + 0x022cu), 0x001cu,  2U, 1U, 0U, 0x0000u
/** T_10NS - control the 10ns time in the flash shell */
#define EE_T_10NS \
    ee0xa2c, (MEM_EEPROM_START + 0x022cu), (MEM_EEPROM_START + 0x022cu), 0x0001u,  0U, 1U, 0U, 0x0000u
/** NV_TRIM13 - NV memory, open */
#define EE_NV_TRIM13 \
    ee0xa2e, (MEM_EEPROM_START + 0x022eu), (MEM_EEPROM_START + 0x022eu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** CHIPID0 - Chip ID0 readable by application - copy of MLX TestChipId0 */
#define EE_CHIPID0 \
    ee0xa30, (MEM_EEPROM_START + 0x0230u), (MEM_EEPROM_START + 0x0230u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_D_YPOS_ID - Copy of TEST_CHIP_ID0 */
#define EE_APP_D_YPOS_ID \
    ee0xa30, (MEM_EEPROM_START + 0x0230u), (MEM_EEPROM_START + 0x0230u), 0xff00u,  8U, 1U, 0U, 0x0000u
/** APP_D_XPOS_ID - Copy of TEST_CHIP_ID0 */
#define EE_APP_D_XPOS_ID \
    ee0xa30, (MEM_EEPROM_START + 0x0230u), (MEM_EEPROM_START + 0x0230u), 0x00ffu,  0U, 1U, 0U, 0x0000u
/** CHIPID1 - Chip ID1 readable by application - copy of MLX TestChipId1 */
#define EE_CHIPID1 \
    ee0xa32, (MEM_EEPROM_START + 0x0232u), (MEM_EEPROM_START + 0x0232u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_D_LOT_ID_H - Copy of TEST_CHIP_ID1 */
#define EE_APP_D_LOT_ID_H \
    ee0xa32, (MEM_EEPROM_START + 0x0232u), (MEM_EEPROM_START + 0x0232u), 0xffe0u,  5U, 1U, 0U, 0x0000u
/** APP_D_WFR_ID - Copy of TEST_CHIP_ID1 */
#define EE_APP_D_WFR_ID \
    ee0xa32, (MEM_EEPROM_START + 0x0232u), (MEM_EEPROM_START + 0x0232u), 0x001fu,  0U, 1U, 0U, 0x0000u
/** CHIPID2 - Copy of TEST_CHIP_ID2 */
#define EE_CHIPID2 \
    ee0xa34, (MEM_EEPROM_START + 0x0234u), (MEM_EEPROM_START + 0x0234u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_D_CORDAT6_ID - Chip ID2 readable by application - copy of MLX TestChipId2 */
#define EE_APP_D_CORDAT6_ID \
    ee0xa34, (MEM_EEPROM_START + 0x0234u), (MEM_EEPROM_START + 0x0234u), 0xfc00u, 10U, 1U, 0U, 0x0000u
/** APP_D_FAB_ID - Copy of TEST_CHIP_ID2 */
#define EE_APP_D_FAB_ID \
    ee0xa34, (MEM_EEPROM_START + 0x0234u), (MEM_EEPROM_START + 0x0234u), 0x03c0u,  6U, 1U, 0U, 0x0000u
/** APP_D_LOT_ID_L - Copy of TEST_CHIP_ID2 */
#define EE_APP_D_LOT_ID_L \
    ee0xa34, (MEM_EEPROM_START + 0x0234u), (MEM_EEPROM_START + 0x0234u), 0x003fu,  0U, 1U, 0U, 0x0000u
/** PROJECT_ID - Copy of Hardware Project ID (high byte: project identifier, low byte: version) */
#define EE_PROJECT_ID \
    ee0xa36, (MEM_EEPROM_START + 0x0236u), (MEM_EEPROM_START + 0x0236u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** CHIPID3 - Copy of TEST_CHIP_ID3 */
#define EE_CHIPID3 \
    ee0xa36, (MEM_EEPROM_START + 0x0236u), (MEM_EEPROM_START + 0x0236u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** APP_PROJECT_ID - Unique PROJECT_ID for software use */
#define EE_APP_PROJECT_ID \
    ee0xa36, (MEM_EEPROM_START + 0x0236u), (MEM_EEPROM_START + 0x0236u), 0xffffu,  0U, 1U, 0U, 0x0000u
/** TESTCHIPID0 - MLX TestChipID0 created by test program */
#define EE_TESTCHIPID0 \
    ee0xa38, (MEM_EEPROM_START + 0x0238u), (MEM_EEPROM_START + 0x0238u), 0xffffu,  0U, 1U, 0U, -0x1f0000u
/** MLX_ID0 - Melexis IC test identification data */
#define EE_MLX_ID0 \
    ee0xa38, (MEM_EEPROM_START + 0x0238u), (MEM_EEPROM_START + 0x0238u), 0xffffu,  0U, 1U, 0U, -0x1f0000u
/** D_CHIP_ID - Melexis IC test identification data D_CHIP ID[20:0] */
#define EE_D_CHIP_ID \
    ee0xa38, (MEM_EEPROM_START + 0x0238u), (MEM_EEPROM_START + 0x0238u), 0x1fffffu,  0U, 1U, 0U, -0x1f0000u
/** D_YPOS_ID - Y position */
#define EE_D_YPOS_ID \
    ee0xa38, (MEM_EEPROM_START + 0x0238u), (MEM_EEPROM_START + 0x0238u), 0xff00u,  8U, 1U, 0U, -0x1f0000u
/** D_XPOS_ID - X position */
#define EE_D_XPOS_ID \
    ee0xa38, (MEM_EEPROM_START + 0x0238u), (MEM_EEPROM_START + 0x0238u), 0x00ffu,  0U, 1U, 0U, -0x1f0000u
/** TESTCHIPID1 - MLX TestChipId1 created by test program */
#define EE_TESTCHIPID1 \
    ee0xa3a, (MEM_EEPROM_START + 0x023au), (MEM_EEPROM_START + 0x023au), 0xffffu,  0U, 1U, 0U, -0x3f0000u
/** MLX_ID1 - Melexis IC test identification data */
#define EE_MLX_ID1 \
    ee0xa3a, (MEM_EEPROM_START + 0x023au), (MEM_EEPROM_START + 0x023au), 0xffffu,  0U, 1U, 0U, -0x3f0000u
/** D_LOT_ID - Lot Number */
#define EE_D_LOT_ID \
    ee0xa3a, (MEM_EEPROM_START + 0x023au), (MEM_EEPROM_START + 0x023au), 0x3fffe0u,  5U, 1U, 0U, -0x3f0000u
/** D_LOT_ID_LSB11 - Lot Number [10:0] */
#define EE_D_LOT_ID_LSB11 \
    ee0xa3a, (MEM_EEPROM_START + 0x023au), (MEM_EEPROM_START + 0x023au), 0xffe0u,  5U, 1U, 0U, -0x3f0000u
/** D_WFR_ID - Wafer number */
#define EE_D_WFR_ID \
    ee0xa3a, (MEM_EEPROM_START + 0x023au), (MEM_EEPROM_START + 0x023au), 0x001fu,  0U, 1U, 0U, -0x3f0000u
/** TESTCHIPID2 - MLX TestChipId2 created by test program */
#define EE_TESTCHIPID2 \
    ee0xa3c, (MEM_EEPROM_START + 0x023cu), (MEM_EEPROM_START + 0x023cu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** MLX_ID2 - Melexis IC test identification data */
#define EE_MLX_ID2 \
    ee0xa3c, (MEM_EEPROM_START + 0x023cu), (MEM_EEPROM_START + 0x023cu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** D_CORDAT_ID - Melexis IC test identification data */
#define EE_D_CORDAT_ID \
    ee0xa3c, (MEM_EEPROM_START + 0x023cu), (MEM_EEPROM_START + 0x023cu), 0xfc00u, 10U, 1U, 0U, 0x0000u
/** D_FAB_ID - FAB id number */
#define EE_D_FAB_ID \
    ee0xa3c, (MEM_EEPROM_START + 0x023cu), (MEM_EEPROM_START + 0x023cu), 0x03c0u,  6U, 1U, 0U, 0x0000u
/** D_LOT_ID_MSB6 - Lot Number [16:11] */
#define EE_D_LOT_ID_MSB6 \
    ee0xa3c, (MEM_EEPROM_START + 0x023cu), (MEM_EEPROM_START + 0x023cu), 0x003fu,  0U, 1U, 0U, 0x0000u
/** TESTCHIPID3 - Hardware Project ID (high byte: project identifier, low byte: version) */
#define EE_TESTCHIPID3 \
    ee0xa3e, (MEM_EEPROM_START + 0x023eu), (MEM_EEPROM_START + 0x023eu), 0xffffu,  0U, 1U, 0U, 0x0000u
/** TEST_PROJECT_ID - Hardware Project ID (high byte: project identifier, low byte: version) */
#define EE_TEST_PROJECT_ID \
    ee0xa3e, (MEM_EEPROM_START + 0x023eu), (MEM_EEPROM_START + 0x023eu), 0xffffu,  0U, 1U, 0U, 0x0000u

/*****************************************************************************/
/* 3.4 Dummy fields. */

/* MlxCCT private. */

#define EE_ \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY2  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY3  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY4  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY5  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY6  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY7  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY8  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY9  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY10  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY11  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY12  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY13  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY14  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY15  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY16  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U
#define EE_DUMMY17  \
    (*(uint16_t*)0U), 0xFFFFU, 0xFFFFU, 0x0000U,  0U, 1U, 2U, 0x0000U

/*****************************************************************************/
/* 4. Summary. */

/* Report of values which might be of interest. */

/*
 * Range: 0x0800u to 0x0a3eu
 * Variables: 104
 * Fields: 306
 * Occupation: 36.48% (209.3 bytes)
 */

#endif /* EEPROM_PARAMETERS_H */

/* EOF */
